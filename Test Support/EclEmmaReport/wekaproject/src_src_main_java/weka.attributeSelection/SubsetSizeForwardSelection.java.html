<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>SubsetSizeForwardSelection.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.attributeSelection</a> &gt; <span class="el_source">SubsetSizeForwardSelection.java</span></div><h1>SubsetSizeForwardSelection.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    SubsetSizeForwardSelection.java
 *    Copyright (C) 2007 Martin Guetlein
 *
 */
package weka.attributeSelection;

import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.Utils;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.BitSet;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;


/**
 &lt;!-- globalinfo-start --&gt;
 * SubsetSizeForwardSelection:&lt;br/&gt;
 * &lt;br/&gt;
 * Extension of LinearForwardSelection. The search performs an interior cross-validation (seed and number of folds can be specified). A LinearForwardSelection is performed on each foldto determine the optimal subset-size (using the given SubsetSizeEvaluator). Finally, a LinearForwardSelection up to the optimal subset-size is performed on the whole data.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Martin Guetlein (2006). Large Scale Attribute Selection Using Wrappers. Freiburg, Germany.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -I
 *  Perform initial ranking to select the
 *  top-ranked attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -K &amp;lt;num&amp;gt;
 *  Number of top-ranked attributes that are 
 *  taken into account by the search.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T &amp;lt;0 = fixed-set | 1 = fixed-width&amp;gt;
 *  Type of Linear Forward Selection (default = 0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Size of lookup cache for evaluated subsets.
 *  Expressed as a multiple of the number of
 *  attributes in the data set. (default = 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;subset evaluator&amp;gt;
 *  Subset-evaluator used for subset-size determination.-- -M&lt;/pre&gt;
 * 
 * &lt;pre&gt; -F &amp;lt;num&amp;gt;
 *  Number of cross validation folds
 *  for subset size determination (default = 5).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;num&amp;gt;
 *  Seed for cross validation
 *  subset size determination. (default = 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -Z
 *  verbose on/off&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to evaluator weka.attributeSelection.ClassifierSubsetEval:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -B &amp;lt;classifier&amp;gt;
 *  class name of the classifier to use for accuracy estimation.
 *  Place any classifier options LAST on the command line
 *  following a &quot;--&quot;. eg.:
 *   -B weka.classifiers.bayes.NaiveBayes ... -- -K
 *  (default: weka.classifiers.rules.ZeroR)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T
 *  Use the training data to estimate accuracy.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H &amp;lt;filename&amp;gt;
 *  Name of the hold out/test set to 
 *  estimate accuracy on.&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to scheme weka.classifiers.rules.ZeroR:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Martin Guetlein (martin.guetlein@gmail.com)
 * @version $Revision: 5605 $
 */
<span class="fc" id="L117">public class SubsetSizeForwardSelection extends ASSearch</span>
  implements OptionHandler {
  /** search directions */
  protected static final int TYPE_FIXED_SET = 0;
  protected static final int TYPE_FIXED_WIDTH = 1;
<span class="fc" id="L122">  public static final Tag[] TAGS_TYPE = {</span>
<span class="fc" id="L123">    new Tag(TYPE_FIXED_SET, &quot;Fixed-set&quot;),</span>
<span class="fc" id="L124">    new Tag(TYPE_FIXED_WIDTH, &quot;Fixed-width&quot;),</span>
  };

  // member variables
  /** perform initial ranking to select top-ranked attributes */
  protected boolean m_performRanking;

  /**
   * number of top-ranked attributes that are taken into account for the
   * search
   */
  protected int m_numUsedAttributes;

  /** 0 == fixed-set, 1 == fixed-width */
  protected int m_linearSelectionType;

  /** the subset evaluator to use for subset size determination */
  private ASEvaluation m_setSizeEval;

  /**
   * Number of cross validation folds for subset size determination (default =
   * 5).
   */
  protected int m_numFolds;

  /** Seed for cross validation subset size determination. (default = 1) */
  protected int m_seed;

  /** number of attributes in the data */
  protected int m_numAttribs;

  /** total number of subsets evaluated during a search */
  protected int m_totalEvals;

  /** for debugging */
  protected boolean m_verbose;

  /** holds the merit of the best subset found */
  protected double m_bestMerit;

  /** holds the maximum size of the lookup cache for evaluated subsets */
  protected int m_cacheSize;

  /**
   * Constructor
   */
<span class="nc" id="L170">  public SubsetSizeForwardSelection() {</span>
<span class="nc" id="L171">    resetOptions();</span>
<span class="nc" id="L172">  }</span>

  /**
   * Returns a string describing this search method
   *
   * @return a description of the search method suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L181">    return &quot;SubsetSizeForwardSelection:\n\n&quot; +</span>
      &quot;Extension of LinearForwardSelection. The search performs an interior &quot; +
      &quot;cross-validation (seed and number of folds can be specified). A &quot; +
      &quot;LinearForwardSelection is performed on each foldto determine the optimal &quot; +
      &quot;subset-size (using the given SubsetSizeEvaluator). Finally, a &quot; +
      &quot;LinearForwardSelection up to the optimal subset-size is performed on &quot; +
      &quot;the whole data.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L189">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation        result;
    TechnicalInformation        additional;
    
<span class="nc" id="L203">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L204">    result.setValue(Field.AUTHOR, &quot;Martin Guetlein and Eibe Frank and Mark Hall&quot;);</span>
<span class="nc" id="L205">    result.setValue(Field.YEAR, &quot;2009&quot;);</span>
<span class="nc" id="L206">    result.setValue(Field.TITLE, &quot;Large Scale Attribute Selection Using Wrappers&quot;);</span>
<span class="nc" id="L207">    result.setValue(Field.BOOKTITLE, &quot;Proc IEEE Symposium on Computational Intelligence and Data Mining&quot;);</span>
<span class="nc" id="L208">    result.setValue(Field.PAGES, &quot;332-339&quot;);</span>
<span class="nc" id="L209">    result.setValue(Field.PUBLISHER, &quot;IEEE&quot;);</span>
    
<span class="nc" id="L211">    additional = result.add(Type.MASTERSTHESIS);</span>
<span class="nc" id="L212">    additional.setValue(Field.AUTHOR, &quot;Martin Guetlein&quot;);</span>
<span class="nc" id="L213">    additional.setValue(Field.YEAR, &quot;2006&quot;);</span>
<span class="nc" id="L214">    additional.setValue(Field.TITLE, &quot;Large Scale Attribute Selection Using Wrappers&quot;);</span>
<span class="nc" id="L215">    additional.setValue(Field.SCHOOL, &quot;Albert-Ludwigs-Universitaet&quot;);</span>
<span class="nc" id="L216">    additional.setValue(Field.ADDRESS, &quot;Freiburg, Germany&quot;);</span>
    
<span class="nc" id="L218">    return result;</span>
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   *
   */
  public Enumeration listOptions() {
<span class="nc" id="L228">    Vector newVector = new Vector(9);</span>

<span class="nc" id="L230">    newVector.addElement(new Option(&quot;\tPerform initial ranking to select the&quot; +</span>
<span class="nc" id="L231">                                    &quot;\n\ttop-ranked attributes.&quot;, &quot;I&quot;, 0, &quot;-I&quot;));</span>
<span class="nc" id="L232">    newVector.addElement(new Option(</span>
<span class="nc" id="L233">                                    &quot;\tNumber of top-ranked attributes that are &quot; +</span>
<span class="nc" id="L234">                                    &quot;\n\ttaken into account by the search.&quot;, &quot;K&quot;, 1, &quot;-K &lt;num&gt;&quot;));</span>
<span class="nc" id="L235">    newVector.addElement(new Option(</span>
<span class="nc" id="L236">                                    &quot;\tType of Linear Forward Selection (default = 0).&quot;, &quot;T&quot;, 1,</span>
<span class="nc" id="L237">                                    &quot;-T &lt;0 = fixed-set | 1 = fixed-width&gt;&quot;));</span>
<span class="nc" id="L238">    newVector.addElement(new Option(</span>
<span class="nc" id="L239">                                    &quot;\tSize of lookup cache for evaluated subsets.&quot; +</span>
                                    &quot;\n\tExpressed as a multiple of the number of&quot; +
<span class="nc" id="L241">                                    &quot;\n\tattributes in the data set. (default = 1)&quot;, &quot;S&quot;, 1, &quot;-S &lt;num&gt;&quot;));</span>
<span class="nc" id="L242">    newVector.addElement(new Option(</span>
<span class="nc" id="L243">                                    &quot;\tSubset-evaluator used for subset-size determination.&quot; + &quot;-- -M&quot;,</span>
<span class="nc" id="L244">                                    &quot;E&quot;, 1, &quot;-E &lt;subset evaluator&gt;&quot;));</span>
<span class="nc" id="L245">    newVector.addElement(new Option(&quot;\tNumber of cross validation folds&quot; +</span>
<span class="nc" id="L246">                                    &quot;\n\tfor subset size determination (default = 5).&quot;, &quot;F&quot;, 1, &quot;-F &lt;num&gt;&quot;));</span>
<span class="nc" id="L247">    newVector.addElement(new Option(&quot;\tSeed for cross validation&quot; +</span>
<span class="nc" id="L248">                                    &quot;\n\tsubset size determination. (default = 1)&quot;, &quot;R&quot;, 1, &quot;-R &lt;num&gt;&quot;));</span>
<span class="nc" id="L249">    newVector.addElement(new Option(&quot;\tverbose on/off&quot;, &quot;Z&quot;, 0, &quot;-Z&quot;));</span>

<span class="nc bnc" id="L251" title="All 4 branches missed.">    if ((m_setSizeEval != null) &amp;&amp; (m_setSizeEval instanceof OptionHandler)) {</span>
<span class="nc" id="L252">      newVector.addElement(new Option(&quot;&quot;, &quot;&quot;, 0,</span>
<span class="nc" id="L253">                                      &quot;\nOptions specific to &quot; + &quot;evaluator &quot; +</span>
<span class="nc" id="L254">                                      m_setSizeEval.getClass().getName() + &quot;:&quot;));</span>

<span class="nc" id="L256">      Enumeration enu = ((OptionHandler) m_setSizeEval).listOptions();</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">      while (enu.hasMoreElements()) {</span>
<span class="nc" id="L259">        newVector.addElement(enu.nextElement());</span>
      }
    }

<span class="nc" id="L263">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options.
   *
   * Valid options are:
   * &lt;p&gt;
   *
   * -I &lt;br&gt;
   * Perform initial ranking to select top-ranked attributes.
   * &lt;p&gt;
   *
   * -K &lt;num&gt; &lt;br&gt;
   * Number of top-ranked attributes that are taken into account.
   * &lt;p&gt;
   *
   * -T &lt;0 = fixed-set | 1 = fixed-width&gt; &lt;br&gt;
   * Typ of Linear Forward Selection (default = 0).
   * &lt;p&gt;
   *
   * -S &lt;num&gt; &lt;br&gt;
   * Size of lookup cache for evaluated subsets. Expressed as a multiple of
   * the number of attributes in the data set. (default = 1).
   * &lt;p&gt;
   *
   * -E &lt;string&gt; &lt;br&gt;
   * class name of subset evaluator to use for subset size determination
   * (default = null, same subset evaluator as for ranking and final forward
   * selection is used). Place any evaluator options LAST on the command line
   * following a &quot;--&quot;. eg. -A weka.attributeSelection.ClassifierSubsetEval ... --
   * -M
   *
   * &lt;/pre&gt;
   *
   * -F &lt;num&gt; &lt;br&gt;
   * Number of cross validation folds for subset size determination (default =
   * 5).
   * &lt;p&gt;
   *
   * -R &lt;num&gt; &lt;br&gt;
   * Seed for cross validation subset size determination. (default = 1)
   * &lt;p&gt;
   *
   * -Z &lt;br&gt;
   * verbose on/off.
   * &lt;p&gt;
   *
   * @param options
   *            the list of options as an array of strings
   * @exception Exception
   *                if an option is not supported
   *
   */
  public void setOptions(String[] options) throws Exception {
    String optionString;
<span class="nc" id="L319">    resetOptions();</span>

<span class="nc" id="L321">    setPerformRanking(Utils.getFlag('I', options));</span>

<span class="nc" id="L323">    optionString = Utils.getOption('K', options);</span>

<span class="nc bnc" id="L325" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L326">      setNumUsedAttributes(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L329">    optionString = Utils.getOption('T', options);</span>

<span class="nc bnc" id="L331" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L332">      setType(new SelectedTag(Integer.parseInt(optionString), TAGS_TYPE));</span>
    } else {
<span class="nc" id="L334">      setType(new SelectedTag(TYPE_FIXED_SET, TAGS_TYPE));</span>
    }

<span class="nc" id="L337">    optionString = Utils.getOption('S', options);</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L340">      setLookupCacheSize(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L343">    optionString = Utils.getOption('E', options);</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">    if (optionString.length() == 0) {</span>
<span class="nc" id="L346">      System.out.println(</span>
<span class="nc" id="L347">                         &quot;No subset size evaluator given, using evaluator that is used for final search.&quot;);</span>
<span class="nc" id="L348">      m_setSizeEval = null;</span>
    } else {
<span class="nc" id="L350">      setSubsetSizeEvaluator(ASEvaluation.forName(optionString,</span>
<span class="nc" id="L351">                                                  Utils.partitionOptions(options)));</span>
    }

<span class="nc" id="L354">    optionString = Utils.getOption('F', options);</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L357">      setNumSubsetSizeCVFolds(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L360">    optionString = Utils.getOption('R', options);</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L363">      setSeed(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L366">    m_verbose = Utils.getFlag('Z', options);</span>
<span class="nc" id="L367">  }</span>

  /**
   * Set the maximum size of the evaluated subset cache (hashtable). This is
   * expressed as a multiplier for the number of attributes in the data set.
   * (default = 1).
   *
   * @param size
   *            the maximum size of the hashtable
   */
  public void setLookupCacheSize(int size) {
<span class="nc bnc" id="L378" title="All 2 branches missed.">    if (size &gt;= 0) {</span>
<span class="nc" id="L379">      m_cacheSize = size;</span>
    }
<span class="nc" id="L381">  }</span>

  /**
   * Return the maximum size of the evaluated subset cache (expressed as a
   * multiplier for the number of attributes in a data set.
   *
   * @return the maximum size of the hashtable.
   */
  public int getLookupCacheSize() {
<span class="nc" id="L390">    return m_cacheSize;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String lookupCacheSizeTipText() {
<span class="nc" id="L400">    return &quot;Set the maximum size of the lookup cache of evaluated subsets. This is &quot; +</span>
      &quot;expressed as a multiplier of the number of attributes in the data set. &quot; +
      &quot;(default = 1).&quot;;
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String performRankingTipText() {
<span class="nc" id="L412">    return &quot;Perform initial ranking to select top-ranked attributes.&quot;;</span>
  }

  /**
   * Perform initial ranking to select top-ranked attributes.
   *
   * @param b
   *            true if initial ranking should be performed
   */
  public void setPerformRanking(boolean b) {
<span class="nc" id="L422">    m_performRanking = b;</span>
<span class="nc" id="L423">  }</span>

  /**
   * Get boolean if initial ranking should be performed to select the
   * top-ranked attributes
   *
   * @return true if initial ranking should be performed
   */
  public boolean getPerformRanking() {
<span class="nc" id="L432">    return m_performRanking;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String numUsedAttributesTipText() {
<span class="nc" id="L442">    return &quot;Set the amount of top-ranked attributes that are taken into account by the search process.&quot;;</span>
  }

  /**
   * Set the number of top-ranked attributes that taken into account by the
   * search process.
   *
   * @param k
   *            the number of attributes
   * @exception Exception
   *                if k is less than 2
   */
  public void setNumUsedAttributes(int k) throws Exception {
<span class="nc bnc" id="L455" title="All 2 branches missed.">    if (k &lt; 2) {</span>
<span class="nc" id="L456">      throw new Exception(&quot;Value of -K must be &gt;= 2.&quot;);</span>
    }

<span class="nc" id="L459">    m_numUsedAttributes = k;</span>
<span class="nc" id="L460">  }</span>

  /**
   * Get the number of top-ranked attributes that taken into account by the
   * search process.
   *
   * @return the number of top-ranked attributes that taken into account
   */
  public int getNumUsedAttributes() {
<span class="nc" id="L469">    return m_numUsedAttributes;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String typeTipText() {
<span class="nc" id="L479">    return &quot;Set the type of the search.&quot;;</span>
  }

  /**
   * Set the type
   *
   * @param t
   *            the Linear Forward Selection type
   */
  public void setType(SelectedTag t) {
<span class="nc bnc" id="L489" title="All 2 branches missed.">    if (t.getTags() == TAGS_TYPE) {</span>
<span class="nc" id="L490">      m_linearSelectionType = t.getSelectedTag().getID();</span>
    }
<span class="nc" id="L492">  }</span>

  /**
   * Get the type
   *
   * @return the Linear Forward Selection type
   */
  public SelectedTag getType() {
<span class="nc" id="L500">    return new SelectedTag(m_linearSelectionType, TAGS_TYPE);</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String subsetSizeEvaluatorTipText() {
<span class="nc" id="L510">    return &quot;Subset evaluator to use for subset size determination.&quot;;</span>
  }

  /**
   * Set the subset evaluator to use for subset size determination.
   *
   * @param eval
   *            the subset evaluator to use for subset size determination.
   */
  public void setSubsetSizeEvaluator(ASEvaluation eval)
    throws Exception {
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (!(eval instanceof SubsetEvaluator)) {</span>
<span class="nc" id="L522">      throw new Exception(eval.getClass().getName() +</span>
<span class="nc" id="L523">                          &quot; is no subset evaluator.&quot;);</span>
    }

<span class="nc" id="L526">    m_setSizeEval = eval;</span>
<span class="nc" id="L527">  }</span>

  /**
   * Get the subset evaluator used for subset size determination.
   *
   * @return the evaluator used for subset size determination.
   */
  public ASEvaluation getSubsetSizeEvaluator() {
<span class="nc" id="L535">    return m_setSizeEval;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String numSubsetSizeCVFoldsTipText() {
<span class="nc" id="L545">    return &quot;Number of cross validation folds for subset size determination&quot;;</span>
  }

  /**
   * Set the number of cross validation folds for subset size determination
   * (default = 5).
   *
   * @param f
   *            number of folds
   */
  public void setNumSubsetSizeCVFolds(int f) {
<span class="nc" id="L556">    m_numFolds = f;</span>
<span class="nc" id="L557">  }</span>

  /**
   * Get the number of cross validation folds for subset size determination
   * (default = 5).
   *
   * @return number of folds
   */
  public int getNumSubsetSizeCVFolds() {
<span class="nc" id="L566">    return m_numFolds;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String seedTipText() {
<span class="nc" id="L576">    return &quot;Seed for cross validation subset size determination. (default = 1)&quot;;</span>
  }

  /**
   * Seed for cross validation subset size determination. (default = 1)
   *
   * @param s
   *            seed
   */
  public void setSeed(int s) {
<span class="nc" id="L586">    m_seed = s;</span>
<span class="nc" id="L587">  }</span>

  /**
   * Seed for cross validation subset size determination. (default = 1)
   *
   * @return seed
   */
  public int getSeed() {
<span class="nc" id="L595">    return m_seed;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String verboseTipText() {
<span class="nc" id="L605">    return &quot;Turn on verbose output for monitoring the search's progress.&quot;;</span>
  }

  /**
   * Set whether verbose output should be generated.
   *
   * @param d
   *            true if output is to be verbose.
   */
  public void setVerbose(boolean b) {
<span class="nc" id="L615">    m_verbose = b;</span>
<span class="nc" id="L616">  }</span>

  /**
   * Get whether output is to be verbose
   *
   * @return true if output will be verbose
   */
  public boolean getVerbose() {
<span class="nc" id="L624">    return m_verbose;</span>
  }

  /**
   * Gets the current settings of LinearForwardSelection.
   *
   * @return an array of strings suitable for passing to setOptions()
   */
  public String[] getOptions() {
<span class="nc" id="L633">    String[] evaluatorOptions = new String[0];</span>

<span class="nc bnc" id="L635" title="All 4 branches missed.">    if ((m_setSizeEval != null) &amp;&amp; (m_setSizeEval instanceof OptionHandler)) {</span>
<span class="nc" id="L636">      evaluatorOptions = ((OptionHandler) m_setSizeEval).getOptions();</span>
    }

<span class="nc" id="L639">    String[] options = new String[15 + evaluatorOptions.length];</span>
<span class="nc" id="L640">    int current = 0;</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">    if (m_performRanking) {</span>
<span class="nc" id="L643">      options[current++] = &quot;-I&quot;;</span>
    }

<span class="nc" id="L646">    options[current++] = &quot;-K&quot;;</span>
<span class="nc" id="L647">    options[current++] = &quot;&quot; + m_numUsedAttributes;</span>
<span class="nc" id="L648">    options[current++] = &quot;-T&quot;;</span>
<span class="nc" id="L649">    options[current++] = &quot;&quot; + m_linearSelectionType;</span>

<span class="nc" id="L651">    options[current++] = &quot;-F&quot;;</span>
<span class="nc" id="L652">    options[current++] = &quot;&quot; + m_numFolds;</span>
<span class="nc" id="L653">    options[current++] = &quot;-S&quot;;</span>
<span class="nc" id="L654">    options[current++] = &quot;&quot; + m_seed;</span>

<span class="nc" id="L656">    options[current++] = &quot;-Z&quot;;</span>
<span class="nc" id="L657">    options[current++] = &quot;&quot; + m_verbose;</span>

<span class="nc bnc" id="L659" title="All 2 branches missed.">    if (m_setSizeEval != null) {</span>
<span class="nc" id="L660">      options[current++] = &quot;-E&quot;;</span>
<span class="nc" id="L661">      options[current++] = m_setSizeEval.getClass().getName();</span>
    }

<span class="nc" id="L664">    options[current++] = &quot;--&quot;;</span>
<span class="nc" id="L665">    System.arraycopy(evaluatorOptions, 0, options, current,</span>
<span class="nc" id="L666">                     evaluatorOptions.length);</span>
<span class="nc" id="L667">    current += evaluatorOptions.length;</span>

<span class="nc bnc" id="L669" title="All 2 branches missed.">    while (current &lt; options.length) {</span>
<span class="nc" id="L670">      options[current++] = &quot;&quot;;</span>
    }

<span class="nc" id="L673">    return options;</span>
  }

  /**
   * returns a description of the search as a String
   *
   * @return a description of the search
   */
  public String toString() {
<span class="nc" id="L682">    StringBuffer LFSString = new StringBuffer();</span>

<span class="nc" id="L684">    LFSString.append(&quot;\tSubset Size Forward Selection.\n&quot;);</span>

<span class="nc" id="L686">    LFSString.append(&quot;\tLinear Forward Selection Type: &quot;);</span>

<span class="nc bnc" id="L688" title="All 2 branches missed.">    if (m_linearSelectionType == TYPE_FIXED_SET) {</span>
<span class="nc" id="L689">      LFSString.append(&quot;fixed-set\n&quot;);</span>
    } else {
<span class="nc" id="L691">      LFSString.append(&quot;fixed-width\n&quot;);</span>
    }

<span class="nc" id="L694">    LFSString.append(&quot;\tNumber of top-ranked attributes that are used: &quot; +</span>
<span class="nc" id="L695">                     m_numUsedAttributes + &quot;\n&quot;);</span>

<span class="nc" id="L697">    LFSString.append(</span>
<span class="nc" id="L698">                     &quot;\tNumber of cross validation folds for subset size determination: &quot; +</span>
<span class="nc" id="L699">                     m_numFolds + &quot;\n&quot;);</span>
<span class="nc" id="L700">    LFSString.append(&quot;\tSeed for cross validation subset size determination: &quot; +</span>
<span class="nc" id="L701">                     m_seed + &quot;\n&quot;);</span>

<span class="nc" id="L703">    LFSString.append(&quot;\tTotal number of subsets evaluated: &quot; + m_totalEvals +</span>
<span class="nc" id="L704">                     &quot;\n&quot;);</span>
<span class="nc" id="L705">    LFSString.append(&quot;\tMerit of best subset found: &quot; +</span>
<span class="nc" id="L706">                     Utils.doubleToString(Math.abs(m_bestMerit), 8, 3) + &quot;\n&quot;);</span>

<span class="nc" id="L708">    return LFSString.toString();</span>
  }

  /**
   * Searches the attribute subset space by subset size forward selection
   *
   * @param ASEvaluator
   *            the attribute evaluator to guide the search
   * @param data
   *            the training instances.
   * @return an array (not necessarily ordered) of selected attribute indexes
   * @exception Exception
   *                if the search can't be completed
   */
  public int[] search(ASEvaluation ASEval, Instances data)
    throws Exception {
<span class="nc" id="L724">    m_totalEvals = 0;</span>

<span class="nc bnc" id="L726" title="All 2 branches missed.">    if (!(ASEval instanceof SubsetEvaluator)) {</span>
<span class="nc" id="L727">      throw new Exception(ASEval.getClass().getName() + &quot; is not a &quot; +</span>
<span class="nc" id="L728">                          &quot;Subset evaluator!&quot;);</span>
    }

<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (m_setSizeEval == null) {</span>
<span class="nc" id="L732">      m_setSizeEval = ASEval;</span>
    }

<span class="nc" id="L735">    m_numAttribs = data.numAttributes();</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (m_numUsedAttributes &gt; m_numAttribs) {</span>
<span class="nc" id="L738">      System.out.println(</span>
<span class="nc" id="L739">                         &quot;Decreasing number of top-ranked attributes to total number of attributes: &quot; +</span>
<span class="nc" id="L740">                         data.numAttributes());</span>
<span class="nc" id="L741">      m_numUsedAttributes = m_numAttribs;</span>
    }

<span class="nc" id="L744">    Instances[] trainData = new Instances[m_numFolds];</span>
<span class="nc" id="L745">    Instances[] testData = new Instances[m_numFolds];</span>
<span class="nc" id="L746">    LFSMethods[] searchResults = new LFSMethods[m_numFolds];</span>

<span class="nc" id="L748">    Random random = new Random(m_seed);</span>
<span class="nc" id="L749">    Instances dataCopy = new Instances(data);</span>
<span class="nc" id="L750">    dataCopy.randomize(random);</span>

<span class="nc bnc" id="L752" title="All 2 branches missed.">    if (dataCopy.classAttribute().isNominal()) {</span>
<span class="nc" id="L753">      dataCopy.stratify(m_numFolds);</span>
    }

<span class="nc bnc" id="L756" title="All 2 branches missed.">    for (int f = 0; f &lt; m_numFolds; f++) {</span>
<span class="nc" id="L757">      trainData[f] = dataCopy.trainCV(m_numFolds, f, random);</span>
<span class="nc" id="L758">      testData[f] = dataCopy.testCV(m_numFolds, f);</span>
    }

<span class="nc" id="L761">    LFSMethods LSF = new LFSMethods();</span>

    int[] ranking;

<span class="nc bnc" id="L765" title="All 2 branches missed.">    if (m_performRanking) {</span>
<span class="nc" id="L766">      ASEval.buildEvaluator(data);</span>
<span class="nc" id="L767">      ranking = LSF.rankAttributes(data, (SubsetEvaluator) ASEval, m_verbose);</span>
    } else {
<span class="nc" id="L769">      ranking = new int[m_numAttribs];</span>

<span class="nc bnc" id="L771" title="All 2 branches missed.">      for (int i = 0; i &lt; ranking.length; i++) {</span>
<span class="nc" id="L772">        ranking[i] = i;</span>
      }
    }

<span class="nc" id="L776">    int maxSubsetSize = 0;</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">    for (int f = 0; f &lt; m_numFolds; f++) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">      if (m_verbose) {</span>
<span class="nc" id="L780">        System.out.println(&quot;perform search on internal fold: &quot; + (f + 1) + &quot;/&quot; +</span>
<span class="nc" id="L781">                           m_numFolds);</span>
      }

<span class="nc" id="L784">      m_setSizeEval.buildEvaluator(trainData[f]);</span>
<span class="nc" id="L785">      searchResults[f] = new LFSMethods();</span>
<span class="nc" id="L786">      searchResults[f].forwardSearch(m_cacheSize, new BitSet(m_numAttribs),</span>
<span class="nc" id="L787">                                     ranking, m_numUsedAttributes,</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                                     m_linearSelectionType == TYPE_FIXED_WIDTH, 1, -1, trainData[f],</span>
<span class="nc" id="L789">                                     (SubsetEvaluator)m_setSizeEval, m_verbose);</span>

<span class="nc" id="L791">      maxSubsetSize = Math.max(maxSubsetSize,</span>
<span class="nc" id="L792">                               searchResults[f].getBestGroup().cardinality());</span>
    }

<span class="nc bnc" id="L795" title="All 2 branches missed.">    if (m_verbose) {</span>
<span class="nc" id="L796">      System.out.println(</span>
<span class="nc" id="L797">                         &quot;continue searches on internal folds to maxSubsetSize (&quot; +</span>
<span class="nc" id="L798">                         maxSubsetSize + &quot;)&quot;);</span>
    }

<span class="nc bnc" id="L801" title="All 2 branches missed.">    for (int f = 0; f &lt; m_numFolds; f++) {</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">      if (m_verbose) {</span>
<span class="nc" id="L803">        System.out.print(&quot;perform search on internal fold: &quot; + (f + 1) + &quot;/&quot; +</span>
<span class="nc" id="L804">                         m_numFolds + &quot; with starting set &quot;);</span>
<span class="nc" id="L805">        LFSMethods.printGroup(searchResults[f].getBestGroup(),</span>
<span class="nc" id="L806">                              trainData[f].numAttributes());</span>
      }

<span class="nc bnc" id="L809" title="All 2 branches missed.">      if (searchResults[f].getBestGroup().cardinality() &lt; maxSubsetSize) {</span>
<span class="nc" id="L810">        m_setSizeEval.buildEvaluator(trainData[f]);</span>
<span class="nc" id="L811">        searchResults[f].forwardSearch(m_cacheSize,</span>
<span class="nc" id="L812">                                       searchResults[f].getBestGroup(), ranking, m_numUsedAttributes,</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">                                       m_linearSelectionType == TYPE_FIXED_WIDTH, 1, maxSubsetSize,</span>
<span class="nc" id="L814">                                       trainData[f], (SubsetEvaluator)m_setSizeEval, m_verbose);</span>
      }
    }

<span class="nc" id="L818">    double[][] testMerit = new double[m_numFolds][maxSubsetSize + 1];</span>

<span class="nc bnc" id="L820" title="All 2 branches missed.">    for (int f = 0; f &lt; m_numFolds; f++) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">      for (int s = 1; s &lt;= maxSubsetSize; s++) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (HoldOutSubsetEvaluator.class.isInstance(m_setSizeEval)) {</span>
<span class="nc" id="L823">          m_setSizeEval.buildEvaluator(trainData[f]);</span>
<span class="nc" id="L824">          testMerit[f][s] = ((HoldOutSubsetEvaluator) m_setSizeEval).evaluateSubset(searchResults[f].getBestGroupOfSize(</span>
<span class="nc" id="L825">                                                                                                                        s), testData[f]);</span>
        } else {
<span class="nc" id="L827">          m_setSizeEval.buildEvaluator(testData[f]);</span>
<span class="nc" id="L828">          testMerit[f][s] = ((SubsetEvaluator)m_setSizeEval).evaluateSubset(searchResults[f].getBestGroupOfSize(</span>
<span class="nc" id="L829">                                                                                             s));</span>
        }
      }
    }

<span class="nc" id="L834">    double[] avgTestMerit = new double[maxSubsetSize + 1];</span>
<span class="nc" id="L835">    int finalSubsetSize = -1;</span>

<span class="nc bnc" id="L837" title="All 2 branches missed.">    for (int s = 1; s &lt;= maxSubsetSize; s++) {</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">      for (int f = 0; f &lt; m_numFolds; f++) {</span>
<span class="nc" id="L839">        avgTestMerit[s] = ((avgTestMerit[s] * f) + testMerit[f][s]) / (double) (f +</span>
<span class="nc" id="L840">                                                                                1);</span>
      }

<span class="nc bnc" id="L843" title="All 2 branches missed.">      if ((finalSubsetSize == -1) ||</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">          (avgTestMerit[s] &gt; avgTestMerit[finalSubsetSize])) {</span>
<span class="nc" id="L845">        finalSubsetSize = s;</span>
      }

<span class="nc bnc" id="L848" title="All 2 branches missed.">      if (m_verbose) {</span>
<span class="nc" id="L849">        System.out.println(&quot;average merit for subset-size &quot; + s + &quot;: &quot; +</span>
<span class="nc" id="L850">                           avgTestMerit[s]);</span>
      }
    }

<span class="nc bnc" id="L854" title="All 2 branches missed.">    if (m_verbose) {</span>
<span class="nc" id="L855">      System.out.println(&quot;performing final forward selection to subset-size: &quot; +</span>
<span class="nc" id="L856">                         finalSubsetSize);</span>
    }

<span class="nc" id="L859">    ASEval.buildEvaluator(data);</span>
<span class="nc" id="L860">    LSF.forwardSearch(m_cacheSize, new BitSet(m_numAttribs), ranking,</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">                      m_numUsedAttributes, m_linearSelectionType == TYPE_FIXED_WIDTH, 1,</span>
<span class="nc" id="L862">                      finalSubsetSize, data, (SubsetEvaluator) ASEval, m_verbose);</span>

<span class="nc" id="L864">    m_totalEvals = LSF.getNumEvalsTotal();</span>
<span class="nc" id="L865">    m_bestMerit = LSF.getBestMerit();</span>

<span class="nc" id="L867">    return attributeList(LSF.getBestGroup());</span>
  }

  /**
   * Reset options to default values
   */
  protected void resetOptions() {
<span class="nc" id="L874">    m_performRanking = true;</span>
<span class="nc" id="L875">    m_numUsedAttributes = 50;</span>
<span class="nc" id="L876">    m_linearSelectionType = TYPE_FIXED_SET;</span>
<span class="nc" id="L877">    m_setSizeEval = new ClassifierSubsetEval();</span>
<span class="nc" id="L878">    m_numFolds = 5;</span>
<span class="nc" id="L879">    m_seed = 1;</span>
<span class="nc" id="L880">    m_totalEvals = 0;</span>
<span class="nc" id="L881">    m_cacheSize = 1;</span>
<span class="nc" id="L882">    m_verbose = false;</span>
<span class="nc" id="L883">  }</span>

  /**
   * converts a BitSet into a list of attribute indexes
   *
   * @param group
   *            the BitSet to convert
   * @return an array of attribute indexes
   */
  protected int[] attributeList(BitSet group) {
<span class="nc" id="L893">    int count = 0;</span>

    // count how many were selected
<span class="nc bnc" id="L896" title="All 2 branches missed.">    for (int i = 0; i &lt; m_numAttribs; i++) {</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">      if (group.get(i)) {</span>
<span class="nc" id="L898">        count++;</span>
      }
    }

<span class="nc" id="L902">    int[] list = new int[count];</span>
<span class="nc" id="L903">    count = 0;</span>

<span class="nc bnc" id="L905" title="All 2 branches missed.">    for (int i = 0; i &lt; m_numAttribs; i++) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">      if (group.get(i)) {</span>
<span class="nc" id="L907">        list[count++] = i;</span>
      }
    }

<span class="nc" id="L911">    return list;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L920">    return RevisionUtils.extract(&quot;$Revision: 5605 $&quot;);</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>