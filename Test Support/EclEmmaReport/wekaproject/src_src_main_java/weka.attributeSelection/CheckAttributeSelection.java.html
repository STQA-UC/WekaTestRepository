<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CheckAttributeSelection.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.attributeSelection</a> &gt; <span class="el_source">CheckAttributeSelection.java</span></div><h1>CheckAttributeSelection.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * CheckAttributeSelection.java
 * Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.attributeSelection;

import weka.core.Attribute;
import weka.core.CheckScheme;
import weka.core.FastVector;
import weka.core.Instances;
import weka.core.MultiInstanceCapabilitiesHandler;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SerializationHelper;
import weka.core.SerializedObject;
import weka.core.TestInstances;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 * Class for examining the capabilities and finding problems with 
 * attribute selection schemes. If you implement an attribute selection using 
 * the WEKA.libraries, you should run the checks on it to ensure robustness 
 * and correct operation. Passing all the tests of this object does not mean
 * bugs in the attribute selection don't exist, but this will help find some
 * common ones. &lt;p/&gt;
 * 
 * Typical usage: &lt;p/&gt;
 * &lt;code&gt;java weka.attributeSelection.CheckAttributeSelection -W ASscheme_name 
 * -- ASscheme_options &lt;/code&gt;&lt;p/&gt;
 * 
 * CheckAttributeSelection reports on the following:
 * &lt;ul&gt;
 *    &lt;li&gt; Scheme abilities 
 *      &lt;ul&gt;
 *         &lt;li&gt; Possible command line options to the scheme &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can predict nominal, numeric, string, 
 *              date or relational class attributes. &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle numeric predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle nominal predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle string predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle date predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle relational predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle multi-instance data &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle missing predictor values &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle missing class values &lt;/li&gt;
 *         &lt;li&gt; Whether a nominal scheme only handles 2 class problems &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme can handle instance weights &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Correct functioning 
 *      &lt;ul&gt;
 *         &lt;li&gt; Correct initialisation during search (i.e. no result
 *              changes when search is performed repeatedly) &lt;/li&gt;
 *         &lt;li&gt; Whether the scheme alters the data pased to it 
 *              (number of instances, instance order, instance weights, etc) &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Degenerate cases 
 *      &lt;ul&gt;
 *         &lt;li&gt; building scheme with zero instances &lt;/li&gt;
 *         &lt;li&gt; all but one predictor attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all predictor attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all but one class values missing &lt;/li&gt;
 *         &lt;li&gt; all class values missing &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 * &lt;/ul&gt;
 * Running CheckAttributeSelection with the debug option set will output the 
 * training dataset for any failed tests.&lt;p/&gt;
 *
 * The &lt;code&gt;weka.attributeSelection.AbstractAttributeSelectionTest&lt;/code&gt; 
 * uses this class to test all the schemes. Any changes here, have to be 
 * checked in that abstract test class, too. &lt;p/&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  Turn on debugging output.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;
 *  The number of instances in the datasets (default 20).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -nominal &amp;lt;num&amp;gt;
 *  The number of nominal attributes (default 2).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -nominal-values &amp;lt;num&amp;gt;
 *  The number of values for nominal attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -numeric &amp;lt;num&amp;gt;
 *  The number of numeric attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -string &amp;lt;num&amp;gt;
 *  The number of string attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -date &amp;lt;num&amp;gt;
 *  The number of date attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -relational &amp;lt;num&amp;gt;
 *  The number of relational attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -num-instances-relational &amp;lt;num&amp;gt;
 *  The number of instances in relational/bag attributes (default 10).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -words &amp;lt;comma-separated-list&amp;gt;
 *  The words to use in string attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -word-separators &amp;lt;chars&amp;gt;
 *  The word separators to use in string attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -eval name [options]
 *  Full name and options of the evaluator analyzed.
 *  eg: weka.attributeSelection.CfsSubsetEval&lt;/pre&gt;
 * 
 * &lt;pre&gt; -search name [options]
 *  Full name and options of the search method analyzed.
 *  eg: weka.attributeSelection.Ranker&lt;/pre&gt;
 * 
 * &lt;pre&gt; -test &amp;lt;eval|search&amp;gt;
 *  The scheme to test, either the evaluator or the search method.
 *  (Default: eval)&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to evaluator weka.attributeSelection.CfsSubsetEval:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -M
 *  Treat missing values as a seperate value.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L
 *  Don't include locally predictive attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to search method weka.attributeSelection.Ranker:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
 *  Specify a starting set of attributes.
 *  Eg. 1,3,5-7.
 *  Any starting attributes specified are
 *  ignored during the ranking.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T &amp;lt;threshold&amp;gt;
 *  Specify a theshold by which attributes
 *  may be discarded from the ranking.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num to select&amp;gt;
 *  Specify number of attributes to select&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Len Trigg (trigg@cs.waikato.ac.nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 4783 $
 * @see TestInstances
 */
<span class="nc" id="L184">public class CheckAttributeSelection </span>
  extends CheckScheme {

  /*
   * Note about test methods:
   * - methods return array of booleans
   * - first index: success or not
   * - second index: acceptable or not (e.g., Exception is OK)
   *
   * FracPete (fracpete at waikato dot ac dot nz)
   */
  
  /*** The evaluator to be examined */
<span class="nc" id="L197">  protected ASEvaluation m_Evaluator = new CfsSubsetEval();</span>
  
  /*** The search method to be used */
<span class="nc" id="L200">  protected ASSearch m_Search = new Ranker();</span>
  
  /** whether to test the evaluator (default) or the search method */
<span class="nc" id="L203">  protected boolean m_TestEvaluator = true;</span>
  
  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {
<span class="nc" id="L211">    Vector result = new Vector();</span>
    
<span class="nc" id="L213">    Enumeration en = super.listOptions();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    while (en.hasMoreElements())</span>
<span class="nc" id="L215">      result.addElement(en.nextElement());</span>
    
<span class="nc" id="L217">    result.addElement(new Option(</span>
<span class="nc" id="L218">        &quot;\tFull name and options of the evaluator analyzed.\n&quot;</span>
        +&quot;\teg: weka.attributeSelection.CfsSubsetEval&quot;,
<span class="nc" id="L220">        &quot;eval&quot;, 1, &quot;-eval name [options]&quot;));</span>
    
<span class="nc" id="L222">    result.addElement(new Option(</span>
<span class="nc" id="L223">        &quot;\tFull name and options of the search method analyzed.\n&quot;</span>
        +&quot;\teg: weka.attributeSelection.Ranker&quot;,
<span class="nc" id="L225">        &quot;search&quot;, 1, &quot;-search name [options]&quot;));</span>
    
<span class="nc" id="L227">    result.addElement(new Option(</span>
<span class="nc" id="L228">        &quot;\tThe scheme to test, either the evaluator or the search method.\n&quot;</span>
        +&quot;\t(Default: eval)&quot;,
<span class="nc" id="L230">        &quot;test&quot;, 1, &quot;-test &lt;eval|search&gt;&quot;));</span>
    
<span class="nc bnc" id="L232" title="All 4 branches missed.">    if ((m_Evaluator != null) &amp;&amp; (m_Evaluator instanceof OptionHandler)) {</span>
<span class="nc" id="L233">      result.addElement(new Option(&quot;&quot;, &quot;&quot;, 0, </span>
<span class="nc" id="L234">          &quot;\nOptions specific to evaluator &quot;</span>
<span class="nc" id="L235">          + m_Evaluator.getClass().getName()</span>
<span class="nc" id="L236">          + &quot;:&quot;));</span>
<span class="nc" id="L237">      Enumeration enm = ((OptionHandler) m_Evaluator).listOptions();</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">      while (enm.hasMoreElements())</span>
<span class="nc" id="L239">        result.addElement(enm.nextElement());</span>
    }
    
<span class="nc bnc" id="L242" title="All 4 branches missed.">    if ((m_Search != null) &amp;&amp; (m_Search instanceof OptionHandler)) {</span>
<span class="nc" id="L243">      result.addElement(new Option(&quot;&quot;, &quot;&quot;, 0, </span>
<span class="nc" id="L244">          &quot;\nOptions specific to search method &quot;</span>
<span class="nc" id="L245">          + m_Search.getClass().getName()</span>
<span class="nc" id="L246">          + &quot;:&quot;));</span>
<span class="nc" id="L247">      Enumeration enm = ((OptionHandler) m_Search).listOptions();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">      while (enm.hasMoreElements())</span>
<span class="nc" id="L249">        result.addElement(enm.nextElement());</span>
    }
    
<span class="nc" id="L252">    return result.elements();</span>
  }
  
  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -D
   *  Turn on debugging output.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;
   *  The number of instances in the datasets (default 20).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -nominal &amp;lt;num&amp;gt;
   *  The number of nominal attributes (default 2).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -nominal-values &amp;lt;num&amp;gt;
   *  The number of values for nominal attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -numeric &amp;lt;num&amp;gt;
   *  The number of numeric attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -string &amp;lt;num&amp;gt;
   *  The number of string attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -date &amp;lt;num&amp;gt;
   *  The number of date attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -relational &amp;lt;num&amp;gt;
   *  The number of relational attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -num-instances-relational &amp;lt;num&amp;gt;
   *  The number of instances in relational/bag attributes (default 10).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -words &amp;lt;comma-separated-list&amp;gt;
   *  The words to use in string attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -word-separators &amp;lt;chars&amp;gt;
   *  The word separators to use in string attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -eval name [options]
   *  Full name and options of the evaluator analyzed.
   *  eg: weka.attributeSelection.CfsSubsetEval&lt;/pre&gt;
   * 
   * &lt;pre&gt; -search name [options]
   *  Full name and options of the search method analyzed.
   *  eg: weka.attributeSelection.Ranker&lt;/pre&gt;
   * 
   * &lt;pre&gt; -test &amp;lt;eval|search&amp;gt;
   *  The scheme to test, either the evaluator or the search method.
   *  (Default: eval)&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to evaluator weka.attributeSelection.CfsSubsetEval:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -M
   *  Treat missing values as a seperate value.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L
   *  Don't include locally predictive attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to search method weka.attributeSelection.Ranker:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
   *  Specify a starting set of attributes.
   *  Eg. 1,3,5-7.
   *  Any starting attributes specified are
   *  ignored during the ranking.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -T &amp;lt;threshold&amp;gt;
   *  Specify a theshold by which attributes
   *  may be discarded from the ranking.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num to select&amp;gt;
   *  Specify number of attributes to select&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String      tmpStr;
    String[]	tmpOptions;
    
<span class="nc" id="L345">    super.setOptions(options);</span>
    
<span class="nc" id="L347">    tmpStr     = Utils.getOption(&quot;eval&quot;, options);</span>
<span class="nc" id="L348">    tmpOptions = Utils.splitOptions(tmpStr);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">    if (tmpOptions.length != 0) {</span>
<span class="nc" id="L350">      tmpStr        = tmpOptions[0];</span>
<span class="nc" id="L351">      tmpOptions[0] = &quot;&quot;;</span>
<span class="nc" id="L352">      setEvaluator(</span>
<span class="nc" id="L353">	  (ASEvaluation) forName(</span>
<span class="nc" id="L354">	      &quot;weka.attributeSelection&quot;, </span>
<span class="nc" id="L355">	      ASEvaluation.class, </span>
<span class="nc" id="L356">	      tmpStr, </span>
<span class="nc" id="L357">	      tmpOptions));</span>
    }
    
<span class="nc" id="L360">    tmpStr     = Utils.getOption(&quot;search&quot;, options);</span>
<span class="nc" id="L361">    tmpOptions = Utils.splitOptions(tmpStr);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">    if (tmpOptions.length != 0) {</span>
<span class="nc" id="L363">      tmpStr        = tmpOptions[0];</span>
<span class="nc" id="L364">      tmpOptions[0] = &quot;&quot;;</span>
<span class="nc" id="L365">      setSearch(</span>
<span class="nc" id="L366">	  (ASSearch) forName(</span>
<span class="nc" id="L367">	      &quot;weka.attributeSelection&quot;, </span>
<span class="nc" id="L368">	      ASSearch.class, </span>
<span class="nc" id="L369">	      tmpStr, </span>
<span class="nc" id="L370">	      tmpOptions));</span>
    }

<span class="nc" id="L373">    tmpStr = Utils.getOption(&quot;test&quot;, options);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">    setTestEvaluator(!tmpStr.equalsIgnoreCase(&quot;search&quot;));</span>
<span class="nc" id="L375">  }</span>
  
  /**
   * Gets the current settings of the CheckAttributeSelection.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector	result;
    String[]	options;
    int		i;
    
<span class="nc" id="L387">    result = new Vector();</span>
    
<span class="nc" id="L389">    options = super.getOptions();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L391">      result.add(options[i]);</span>
    
<span class="nc" id="L393">    result.add(&quot;-eval&quot;);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    if (getEvaluator() instanceof OptionHandler)</span>
<span class="nc" id="L395">      result.add(</span>
<span class="nc" id="L396">	  getEvaluator().getClass().getName() </span>
<span class="nc" id="L397">	  + &quot; &quot; </span>
<span class="nc" id="L398">	  + Utils.joinOptions(((OptionHandler) getEvaluator()).getOptions()));</span>
    else
<span class="nc" id="L400">      result.add(</span>
<span class="nc" id="L401">	  getEvaluator().getClass().getName());</span>

<span class="nc" id="L403">    result.add(&quot;-search&quot;);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">    if (getSearch() instanceof OptionHandler)</span>
<span class="nc" id="L405">      result.add(</span>
<span class="nc" id="L406">	  getSearch().getClass().getName() </span>
<span class="nc" id="L407">	  + &quot; &quot; </span>
<span class="nc" id="L408">	  + Utils.joinOptions(((OptionHandler) getSearch()).getOptions()));</span>
    else
<span class="nc" id="L410">      result.add(</span>
<span class="nc" id="L411">	  getSearch().getClass().getName());</span>
    
<span class="nc" id="L413">    result.add(&quot;-test&quot;);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">    if (getTestEvaluator())</span>
<span class="nc" id="L415">      result.add(&quot;eval&quot;);</span>
    else
<span class="nc" id="L417">      result.add(&quot;search&quot;);</span>
    
<span class="nc" id="L419">    return (String[]) result.toArray(new String[result.size()]);</span>
  }
  
  /**
   * Begin the tests, reporting results to System.out
   */
  public void doTests() {
    
<span class="nc bnc" id="L427" title="All 2 branches missed.">    if (getTestObject() == null) {</span>
<span class="nc" id="L428">      println(&quot;\n=== No scheme set ===&quot;);</span>
<span class="nc" id="L429">      return;</span>
    }
<span class="nc" id="L431">    println(&quot;\n=== Check on scheme: &quot;</span>
<span class="nc" id="L432">        + getTestObject().getClass().getName()</span>
<span class="nc" id="L433">        + &quot; ===\n&quot;);</span>
    
    // Start tests
<span class="nc" id="L436">    m_ClasspathProblems = false;</span>
<span class="nc" id="L437">    println(&quot;--&gt; Checking for interfaces&quot;);</span>
<span class="nc" id="L438">    canTakeOptions();</span>
<span class="nc" id="L439">    boolean weightedInstancesHandler = weightedInstancesHandler()[0];</span>
<span class="nc" id="L440">    boolean multiInstanceHandler = multiInstanceHandler()[0];</span>
<span class="nc" id="L441">    println(&quot;--&gt; Scheme tests&quot;);</span>
<span class="nc" id="L442">    declaresSerialVersionUID();</span>
<span class="nc" id="L443">    testsPerClassType(Attribute.NOMINAL,    weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L444">    testsPerClassType(Attribute.NUMERIC,    weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L445">    testsPerClassType(Attribute.DATE,       weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L446">    testsPerClassType(Attribute.STRING,     weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L447">    testsPerClassType(Attribute.RELATIONAL, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L448">  }</span>
  
  /**
   * Set the evaluator to test. 
   *
   * @param value	the evaluator to use.
   */
  public void setEvaluator(ASEvaluation value) {
<span class="nc" id="L456">    m_Evaluator = value;</span>
<span class="nc" id="L457">  }</span>
  
  /**
   * Get the current evaluator
   *
   * @return 		the current evaluator
   */
  public ASEvaluation getEvaluator() {
<span class="nc" id="L465">    return m_Evaluator;</span>
  }
  
  /**
   * Set the search method to test. 
   *
   * @param value	the search method to use.
   */
  public void setSearch(ASSearch value) {
<span class="nc" id="L474">    m_Search = value;</span>
<span class="nc" id="L475">  }</span>
  
  /**
   * Get the current search method
   *
   * @return 		the current search method
   */
  public ASSearch getSearch() {
<span class="nc" id="L483">    return m_Search;</span>
  }

  /**
   * Sets whether the evaluator or the search method is being tested.
   * 
   * @param value	if true then the evaluator will be tested
   */
  public void setTestEvaluator(boolean value) {
<span class="nc" id="L492">    m_TestEvaluator = value;</span>
<span class="nc" id="L493">  }</span>
  
  /**
   * Gets whether the evaluator is being tested or the search method.
   * 
   * @return		true if the evaluator is being tested
   */
  public boolean getTestEvaluator() {
<span class="nc" id="L501">    return m_TestEvaluator;</span>
  }
  
  /**
   * returns either the evaluator or the search method.
   * 
   * @return		the object to be tested
   * @see		#m_TestEvaluator
   */
  protected Object getTestObject() {
<span class="nc bnc" id="L511" title="All 2 branches missed.">    if (getTestEvaluator())</span>
<span class="nc" id="L512">      return getEvaluator();</span>
    else
<span class="nc" id="L514">      return getSearch();</span>
  }
  
  /**
   * returns deep copies of the given object
   * 
   * @param obj		the object to copy
   * @param num		the number of copies
   * @return		the deep copies
   * @throws Exception	if copying fails
   */
  protected Object[] makeCopies(Object obj, int num) throws Exception {
<span class="nc bnc" id="L526" title="All 2 branches missed.">    if (obj == null)</span>
<span class="nc" id="L527">      throw new Exception(&quot;No object set&quot;);</span>

<span class="nc" id="L529">    Object[] objs = new Object[num];</span>
<span class="nc" id="L530">    SerializedObject so = new SerializedObject(obj);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">    for(int i = 0; i &lt; objs.length; i++) {</span>
<span class="nc" id="L532">      objs[i] = so.getObject();</span>
    }
    
<span class="nc" id="L535">    return objs;</span>
  }
  
  /**
   * Performs a attribute selection with the given search and evaluation scheme 
   * on the provided data. The generated AttributeSelection object is returned.
   * 
   * @param search	the search scheme to use
   * @param eval	the evaluator to use
   * @param data	the data to work on
   * @return		the used attribute selection object
   * @throws Exception	if the attribute selection fails
   */
  protected AttributeSelection search(ASSearch search, ASEvaluation eval, 
      Instances data) throws Exception {
    
    AttributeSelection	result;
    
<span class="nc" id="L553">    result = new AttributeSelection();</span>
<span class="nc" id="L554">    result.setSeed(42);</span>
<span class="nc" id="L555">    result.setSearch(search);</span>
<span class="nc" id="L556">    result.setEvaluator(eval);</span>
<span class="nc" id="L557">    result.SelectAttributes(data);</span>
    
<span class="nc" id="L559">    return result;</span>
  }
  
  /**
   * Run a battery of tests for a given class attribute type
   *
   * @param classType true if the class attribute should be numeric
   * @param weighted true if the scheme says it handles weights
   * @param multiInstance true if the scheme handles multi-instance data
   */
  protected void testsPerClassType(int classType, 
                                   boolean weighted,
                                   boolean multiInstance) {
    
<span class="nc" id="L573">    boolean PNom = canPredict(true,  false, false, false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L574">    boolean PNum = canPredict(false, true,  false, false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L575">    boolean PStr = canPredict(false, false, true,  false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L576">    boolean PDat = canPredict(false, false, false, true,  false, multiInstance, classType)[0];</span>
    boolean PRel;
<span class="nc bnc" id="L578" title="All 2 branches missed.">    if (!multiInstance)</span>
<span class="nc" id="L579">      PRel = canPredict(false, false, false, false,  true, multiInstance, classType)[0];</span>
    else
<span class="nc" id="L581">      PRel = false;</span>

<span class="nc bnc" id="L583" title="All 10 branches missed.">    if (PNom || PNum || PStr || PDat || PRel) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">      if (weighted)</span>
<span class="nc" id="L585">        instanceWeights(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
      
<span class="nc bnc" id="L587" title="All 2 branches missed.">      if (classType == Attribute.NOMINAL)</span>
<span class="nc" id="L588">        canHandleNClasses(PNom, PNum, PStr, PDat, PRel, multiInstance, 4);</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">      if (!multiInstance) {</span>
<span class="nc" id="L591">	canHandleClassAsNthAttribute(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, 0);</span>
<span class="nc" id="L592">	canHandleClassAsNthAttribute(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, 1);</span>
      }
      
<span class="nc" id="L595">      canHandleZeroTraining(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
<span class="nc" id="L596">      boolean handleMissingPredictors = canHandleMissing(PNom, PNum, PStr, PDat, PRel, </span>
<span class="nc" id="L597">          multiInstance, classType, </span>
<span class="nc" id="L598">          true, false, 20)[0];</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">      if (handleMissingPredictors)</span>
<span class="nc" id="L600">        canHandleMissing(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, true, false, 100);</span>
      
<span class="nc" id="L602">      boolean handleMissingClass = canHandleMissing(PNom, PNum, PStr, PDat, PRel, </span>
<span class="nc" id="L603">          multiInstance, classType, </span>
<span class="nc" id="L604">          false, true, 20)[0];</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">      if (handleMissingClass)</span>
<span class="nc" id="L606">        canHandleMissing(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, false, true, 100);</span>
      
<span class="nc" id="L608">      correctSearchInitialisation(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
<span class="nc" id="L609">      datasetIntegrity(PNom, PNum, PStr, PDat, PRel, multiInstance, classType,</span>
<span class="nc" id="L610">          handleMissingPredictors, handleMissingClass);</span>
    }
<span class="nc" id="L612">  }</span>
  
  /**
   * Checks whether the scheme can take command line options.
   *
   * @return index 0 is true if the scheme can take options
   */
  protected boolean[] canTakeOptions() {
    
<span class="nc" id="L621">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L623">    print(&quot;options...&quot;);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">    if (getTestObject() instanceof OptionHandler) {</span>
<span class="nc" id="L625">      println(&quot;yes&quot;);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L627">        println(&quot;\n=== Full report ===&quot;);</span>
<span class="nc" id="L628">        Enumeration enu = ((OptionHandler) getTestObject()).listOptions();</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        while (enu.hasMoreElements()) {</span>
<span class="nc" id="L630">          Option option = (Option) enu.nextElement();</span>
<span class="nc" id="L631">          print(option.synopsis() + &quot;\n&quot; </span>
<span class="nc" id="L632">              + option.description() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L634">        println(&quot;\n&quot;);</span>
      }
<span class="nc" id="L636">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L639">      println(&quot;no&quot;);</span>
<span class="nc" id="L640">      result[0] = false;</span>
    }
    
<span class="nc" id="L643">    return result;</span>
  }
  
  /**
   * Checks whether the scheme says it can handle instance weights.
   *
   * @return true if the scheme handles instance weights
   */
  protected boolean[] weightedInstancesHandler() {
    
<span class="nc" id="L653">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L655">    print(&quot;weighted instances scheme...&quot;);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">    if (getTestObject() instanceof WeightedInstancesHandler) {</span>
<span class="nc" id="L657">      println(&quot;yes&quot;);</span>
<span class="nc" id="L658">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L661">      println(&quot;no&quot;);</span>
<span class="nc" id="L662">      result[0] = false;</span>
    }
    
<span class="nc" id="L665">    return result;</span>
  }
  
  /**
   * Checks whether the scheme handles multi-instance data.
   * 
   * @return true if the scheme handles multi-instance data
   */
  protected boolean[] multiInstanceHandler() {
<span class="nc" id="L674">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L676">    print(&quot;multi-instance scheme...&quot;);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">    if (getTestObject() instanceof MultiInstanceCapabilitiesHandler) {</span>
<span class="nc" id="L678">      println(&quot;yes&quot;);</span>
<span class="nc" id="L679">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L682">      println(&quot;no&quot;);</span>
<span class="nc" id="L683">      result[0] = false;</span>
    }
    
<span class="nc" id="L686">    return result;</span>
  }
  
  /**
   * tests for a serialVersionUID. Fails in case the schemes don't declare
   * a UID (both must!).
   *
   * @return index 0 is true if the scheme declares a UID
   */
  protected boolean[] declaresSerialVersionUID() {
<span class="nc" id="L696">    boolean[] result = new boolean[2];</span>
    boolean eval;
    boolean search;
    
<span class="nc" id="L700">    print(&quot;serialVersionUID...&quot;);</span>
    
<span class="nc bnc" id="L702" title="All 2 branches missed.">    eval   = !SerializationHelper.needsUID(m_Evaluator.getClass());</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">    search = !SerializationHelper.needsUID(m_Search.getClass());</span>
    
<span class="nc bnc" id="L705" title="All 4 branches missed.">    result[0] = eval &amp;&amp; search;</span>
    
<span class="nc bnc" id="L707" title="All 2 branches missed.">    if (result[0])</span>
<span class="nc" id="L708">      println(&quot;yes&quot;);</span>
    else
<span class="nc" id="L710">      println(&quot;no&quot;);</span>
    
<span class="nc" id="L712">    return result;</span>
  }
  
  /**
   * Checks basic prediction of the scheme, for simple non-troublesome
   * datasets.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canPredict(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="nc" id="L738">    print(&quot;basic predict&quot;);</span>
<span class="nc" id="L739">    printAttributeSummary(</span>
<span class="nc" id="L740">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L741">    print(&quot;...&quot;);</span>
<span class="nc" id="L742">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L743">    accepts.addElement(&quot;unary&quot;);</span>
<span class="nc" id="L744">    accepts.addElement(&quot;binary&quot;);</span>
<span class="nc" id="L745">    accepts.addElement(&quot;nominal&quot;);</span>
<span class="nc" id="L746">    accepts.addElement(&quot;numeric&quot;);</span>
<span class="nc" id="L747">    accepts.addElement(&quot;string&quot;);</span>
<span class="nc" id="L748">    accepts.addElement(&quot;date&quot;);</span>
<span class="nc" id="L749">    accepts.addElement(&quot;relational&quot;);</span>
<span class="nc" id="L750">    accepts.addElement(&quot;multi-instance&quot;);</span>
<span class="nc" id="L751">    accepts.addElement(&quot;not in classpath&quot;);</span>
<span class="nc" id="L752">    int numTrain = getNumInstances(), numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L753">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L755">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="nc" id="L756">        datePredictor, relationalPredictor, </span>
<span class="nc" id="L757">        multiInstance,</span>
<span class="nc" id="L758">        classType, </span>
<span class="nc" id="L759">        missingLevel, predictorMissing, classMissing,</span>
<span class="nc" id="L760">        numTrain, numClasses, </span>
<span class="nc" id="L761">        accepts);</span>
  }
  
  /**
   * Checks whether nominal schemes can handle more than two classes.
   * If a scheme is only designed for two-class problems it should
   * throw an appropriate exception for multi-class problems.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param numClasses the number of classes to test
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleNClasses(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int numClasses) {
    
<span class="nc" id="L788">    print(&quot;more than two class problems&quot;);</span>
<span class="nc" id="L789">    printAttributeSummary(</span>
<span class="nc" id="L790">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, Attribute.NOMINAL);</span>
<span class="nc" id="L791">    print(&quot;...&quot;);</span>
<span class="nc" id="L792">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L793">    accepts.addElement(&quot;number&quot;);</span>
<span class="nc" id="L794">    accepts.addElement(&quot;class&quot;);</span>
<span class="nc" id="L795">    int numTrain = getNumInstances(), missingLevel = 0;</span>
<span class="nc" id="L796">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L798">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="nc" id="L799">                        datePredictor, relationalPredictor, </span>
<span class="nc" id="L800">                        multiInstance,</span>
<span class="nc" id="L801">                        Attribute.NOMINAL,</span>
<span class="nc" id="L802">                        missingLevel, predictorMissing, classMissing,</span>
<span class="nc" id="L803">                        numTrain, numClasses, </span>
<span class="nc" id="L804">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle class attributes as Nth attribute.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class attribute (0-based, -1 means last attribute)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   * @see TestInstances#CLASS_IS_LAST
   */
  protected boolean[] canHandleClassAsNthAttribute(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int classIndex) {
    
<span class="nc bnc" id="L832" title="All 2 branches missed.">    if (classIndex == TestInstances.CLASS_IS_LAST)</span>
<span class="nc" id="L833">      print(&quot;class attribute as last attribute&quot;);</span>
    else
<span class="nc" id="L835">      print(&quot;class attribute as &quot; + (classIndex + 1) + &quot;. attribute&quot;);</span>
<span class="nc" id="L836">    printAttributeSummary(</span>
<span class="nc" id="L837">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L838">    print(&quot;...&quot;);</span>
<span class="nc" id="L839">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L840">    int numTrain = getNumInstances(), numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L841">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L843">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="nc" id="L844">                        datePredictor, relationalPredictor, </span>
<span class="nc" id="L845">                        multiInstance,</span>
<span class="nc" id="L846">                        classType,</span>
<span class="nc" id="L847">                        classIndex,</span>
<span class="nc" id="L848">                        missingLevel, predictorMissing, classMissing,</span>
<span class="nc" id="L849">                        numTrain, numClasses, </span>
<span class="nc" id="L850">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle zero training instances.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleZeroTraining(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="nc" id="L875">    print(&quot;handle zero training instances&quot;);</span>
<span class="nc" id="L876">    printAttributeSummary(</span>
<span class="nc" id="L877">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L878">    print(&quot;...&quot;);</span>
<span class="nc" id="L879">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L880">    accepts.addElement(&quot;train&quot;);</span>
<span class="nc" id="L881">    accepts.addElement(&quot;value&quot;);</span>
<span class="nc" id="L882">    int numTrain = 0, numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L883">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L885">    return runBasicTest(</span>
<span class="nc" id="L886">              nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="nc" id="L887">              datePredictor, relationalPredictor, </span>
<span class="nc" id="L888">              multiInstance,</span>
<span class="nc" id="L889">              classType, </span>
<span class="nc" id="L890">              missingLevel, predictorMissing, classMissing,</span>
<span class="nc" id="L891">              numTrain, numClasses, </span>
<span class="nc" id="L892">              accepts);</span>
  }
  
  /**
   * Checks whether the scheme correctly initialises models when 
   * ASSearch.search is called. This test calls search with
   * one training dataset. ASSearch is then called on a training set with 
   * different structure, and then again with the original training set. 
   * If the equals method of the ASEvaluation class returns false, this is 
   * noted as incorrect search initialisation.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is always false
   */
  protected boolean[] correctSearchInitialisation(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {

<span class="nc" id="L921">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L922">    print(&quot;correct initialisation during search&quot;);</span>
<span class="nc" id="L923">    printAttributeSummary(</span>
<span class="nc" id="L924">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L925">    print(&quot;...&quot;);</span>
<span class="nc" id="L926">    int numTrain = getNumInstances(), </span>
<span class="nc" id="L927">    numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L928">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L930">    Instances train1 = null;</span>
<span class="nc" id="L931">    Instances train2 = null;</span>
<span class="nc" id="L932">    ASSearch search = null;</span>
<span class="nc" id="L933">    ASEvaluation evaluation1A = null;</span>
<span class="nc" id="L934">    ASEvaluation evaluation1B = null;</span>
<span class="nc" id="L935">    ASEvaluation evaluation2 = null;</span>
<span class="nc" id="L936">    AttributeSelection attsel1A = null;</span>
<span class="nc" id="L937">    AttributeSelection attsel1B = null;</span>
<span class="nc" id="L938">    int stage = 0;</span>
    try {
      
      // Make two train sets with different numbers of attributes
<span class="nc" id="L942">      train1 = makeTestDataset(42, numTrain, </span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                               nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                               numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                               stringPredictor     ? getNumString()     : 0, </span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                               datePredictor       ? getNumDate()       : 0, </span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                               relationalPredictor ? getNumRelational() : 0, </span>
<span class="nc" id="L948">                               numClasses, </span>
<span class="nc" id="L949">                               classType,</span>
<span class="nc" id="L950">                               multiInstance);</span>
<span class="nc" id="L951">      train2 = makeTestDataset(84, numTrain, </span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">                               nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                               numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">                               stringPredictor     ? getNumString()      : 0, </span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">                               datePredictor       ? getNumDate()        : 0, </span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">                               relationalPredictor ? getNumRelational()  : 0, </span>
<span class="nc" id="L957">                               numClasses, </span>
<span class="nc" id="L958">                               classType,</span>
<span class="nc" id="L959">                               multiInstance);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L961">        addMissing(train1, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L962">        addMissing(train2, missingLevel, predictorMissing, classMissing);</span>
      }
      
<span class="nc" id="L965">      search = ASSearch.makeCopies(getSearch(), 1)[0];</span>
<span class="nc" id="L966">      evaluation1A = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L967">      evaluation1B = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L968">      evaluation2 = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L969">    } catch (Exception ex) {</span>
<span class="nc" id="L970">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L973">      stage = 0;</span>
<span class="nc" id="L974">      attsel1A = search(search, evaluation1A, train1);</span>
      
<span class="nc" id="L976">      stage = 1;</span>
<span class="nc" id="L977">      search(search, evaluation2, train2);</span>
      
<span class="nc" id="L979">      stage = 2;</span>
<span class="nc" id="L980">      attsel1B = search(search, evaluation1B, train1);</span>
      
<span class="nc" id="L982">      stage = 3;</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">      if (!attsel1A.toResultsString().equals(attsel1B.toResultsString())) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L985">          println(</span>
<span class="nc" id="L986">              &quot;\n=== Full report ===\n&quot;</span>
              + &quot;\nFirst search\n&quot;
<span class="nc" id="L988">              + attsel1A.toResultsString()</span>
<span class="nc" id="L989">              + &quot;\n\n&quot;);</span>
<span class="nc" id="L990">          println(</span>
<span class="nc" id="L991">              &quot;\nSecond search\n&quot;</span>
<span class="nc" id="L992">              + attsel1B.toResultsString()</span>
<span class="nc" id="L993">              + &quot;\n\n&quot;);</span>
        }
<span class="nc" id="L995">        throw new Exception(&quot;Results differ between search calls&quot;);</span>
      }
<span class="nc" id="L997">      println(&quot;yes&quot;);</span>
<span class="nc" id="L998">      result[0] = true;</span>
      
      if (false &amp;&amp; m_Debug) {
        println(
            &quot;\n=== Full report ===\n&quot;
            + &quot;\nFirst search\n&quot;
            + evaluation1A.toString()
            + &quot;\n\n&quot;);
        println(
            &quot;\nSecond search\n&quot;
            + evaluation1B.toString()
            + &quot;\n\n&quot;);
      }
    } 
<span class="nc" id="L1012">    catch (Exception ex) {</span>
<span class="nc" id="L1013">      println(&quot;no&quot;);</span>
<span class="nc" id="L1014">      result[0] = false;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1016">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1017">        print(&quot;Problem during  training&quot;);</span>
<span class="nc bnc" id="L1018" title="All 5 branches missed.">        switch (stage) {</span>
          case 0:
<span class="nc" id="L1020">            print(&quot; of dataset 1&quot;);</span>
<span class="nc" id="L1021">            break;</span>
          case 1:
<span class="nc" id="L1023">            print(&quot; of dataset 2&quot;);</span>
<span class="nc" id="L1024">            break;</span>
          case 2:
<span class="nc" id="L1026">            print(&quot; of dataset 1 (2nd build)&quot;);</span>
<span class="nc" id="L1027">            break;</span>
          case 3:
<span class="nc" id="L1029">            print(&quot;, comparing results from builds of dataset 1&quot;);</span>
            break;	  
        }
<span class="nc" id="L1032">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L1033">        println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L1034">        println(&quot;=== Train1 Dataset ===\n&quot;</span>
<span class="nc" id="L1035">            + train1.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1036">        println(&quot;=== Train2 Dataset ===\n&quot;</span>
<span class="nc" id="L1037">            + train2.toString() + &quot;\n&quot;);</span>
      }
    }
    
<span class="nc" id="L1041">    return result;</span>
  }
  
  /**
   * Checks basic missing value handling of the scheme. If the missing
   * values cause an exception to be thrown by the scheme, this will be
   * recorded.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param missingLevel the percentage of missing values
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleMissing(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      boolean predictorMissing,
      boolean classMissing,
      int missingLevel) {
    
<span class="nc bnc" id="L1075" title="All 2 branches missed.">    if (missingLevel == 100)</span>
<span class="nc" id="L1076">      print(&quot;100% &quot;);</span>
<span class="nc" id="L1077">    print(&quot;missing&quot;);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">    if (predictorMissing) {</span>
<span class="nc" id="L1079">      print(&quot; predictor&quot;);</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">      if (classMissing)</span>
<span class="nc" id="L1081">        print(&quot; and&quot;);</span>
    }
<span class="nc bnc" id="L1083" title="All 2 branches missed.">    if (classMissing)</span>
<span class="nc" id="L1084">      print(&quot; class&quot;);</span>
<span class="nc" id="L1085">    print(&quot; values&quot;);</span>
<span class="nc" id="L1086">    printAttributeSummary(</span>
<span class="nc" id="L1087">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L1088">    print(&quot;...&quot;);</span>
<span class="nc" id="L1089">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L1090">    accepts.addElement(&quot;missing&quot;);</span>
<span class="nc" id="L1091">    accepts.addElement(&quot;value&quot;);</span>
<span class="nc" id="L1092">    accepts.addElement(&quot;train&quot;);</span>
<span class="nc" id="L1093">    accepts.addElement(&quot;no attributes&quot;);</span>
<span class="nc" id="L1094">    int numTrain = getNumInstances(), numClasses = 2;</span>
    
<span class="nc" id="L1096">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="nc" id="L1097">        datePredictor, relationalPredictor, </span>
<span class="nc" id="L1098">        multiInstance,</span>
<span class="nc" id="L1099">        classType, </span>
<span class="nc" id="L1100">        missingLevel, predictorMissing, classMissing,</span>
<span class="nc" id="L1101">        numTrain, numClasses, </span>
<span class="nc" id="L1102">        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle instance weights.
   * This test compares the scheme performance on two datasets
   * that are identical except for the training weights. If the 
   * results change, then the scheme must be using the weights. It
   * may be possible to get a false positive from this test if the 
   * weight changes aren't significant enough to induce a change
   * in scheme performance (but the weights are chosen to minimize
   * the likelihood of this).
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 true if the test was passed
   */
  protected boolean[] instanceWeights(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="nc" id="L1133">    print(&quot;scheme uses instance weights&quot;);</span>
<span class="nc" id="L1134">    printAttributeSummary(</span>
<span class="nc" id="L1135">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L1136">    print(&quot;...&quot;);</span>
<span class="nc" id="L1137">    int numTrain = 2*getNumInstances(), </span>
<span class="nc" id="L1138">    numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L1139">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="nc" id="L1141">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1142">    Instances train = null;</span>
<span class="nc" id="L1143">    ASSearch[] search = null;</span>
<span class="nc" id="L1144">    ASEvaluation evaluationB = null;</span>
<span class="nc" id="L1145">    ASEvaluation evaluationI = null;</span>
<span class="nc" id="L1146">    AttributeSelection attselB = null;</span>
<span class="nc" id="L1147">    AttributeSelection attselI = null;</span>
<span class="nc" id="L1148">    boolean evalFail = false;</span>
    try {
<span class="nc" id="L1150">      train = makeTestDataset(42, numTrain, </span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">                              nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">                              numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                              stringPredictor     ? getNumString()      : 0, </span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                              datePredictor       ? getNumDate()        : 0, </span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                              relationalPredictor ? getNumRelational()  : 0, </span>
<span class="nc" id="L1156">                              numClasses, </span>
<span class="nc" id="L1157">                              classType,</span>
<span class="nc" id="L1158">                              multiInstance);</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">      if (missingLevel &gt; 0)</span>
<span class="nc" id="L1160">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1161">      search = ASSearch.makeCopies(getSearch(), 2);</span>
<span class="nc" id="L1162">      evaluationB = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L1163">      evaluationI = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L1164">      attselB = search(search[0], evaluationB, train);</span>
<span class="nc" id="L1165">    } catch (Exception ex) {</span>
<span class="nc" id="L1166">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
      
      // Now modify instance weights and re-built/test
<span class="nc bnc" id="L1171" title="All 2 branches missed.">      for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1172">        train.instance(i).setWeight(0);</span>
      }
<span class="nc" id="L1174">      Random random = new Random(1);</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">      for (int i = 0; i &lt; train.numInstances() / 2; i++) {</span>
<span class="nc" id="L1176">        int inst = Math.abs(random.nextInt()) % train.numInstances();</span>
<span class="nc" id="L1177">        int weight = Math.abs(random.nextInt()) % 10 + 1;</span>
<span class="nc" id="L1178">        train.instance(inst).setWeight(weight);</span>
      }
<span class="nc" id="L1180">      attselI = search(search[1], evaluationI, train);</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">      if (attselB.toResultsString().equals(attselI.toResultsString())) {</span>
        //	println(&quot;no&quot;);
<span class="nc" id="L1183">        evalFail = true;</span>
<span class="nc" id="L1184">        throw new Exception(&quot;evalFail&quot;);</span>
      }
      
<span class="nc" id="L1187">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1188">      result[0] = true;</span>
<span class="nc" id="L1189">    } catch (Exception ex) {</span>
<span class="nc" id="L1190">      println(&quot;no&quot;);</span>
<span class="nc" id="L1191">      result[0] = false;</span>
      
<span class="nc bnc" id="L1193" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1194">        println(&quot;\n=== Full Report ===&quot;);</span>
        
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        if (evalFail) {</span>
<span class="nc" id="L1197">          println(&quot;Results don't differ between non-weighted and &quot;</span>
              + &quot;weighted instance models.&quot;);
<span class="nc" id="L1199">          println(&quot;Here are the results:\n&quot;);</span>
<span class="nc" id="L1200">          println(&quot;\nboth methods\n&quot;);</span>
<span class="nc" id="L1201">          println(evaluationB.toString());</span>
        } else {
<span class="nc" id="L1203">          print(&quot;Problem during training&quot;);</span>
<span class="nc" id="L1204">          println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L1206">        println(&quot;Here is the dataset:\n&quot;);</span>
<span class="nc" id="L1207">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1208">            + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1209">        println(&quot;=== Train Weights ===\n&quot;);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1211">          println(&quot; &quot; + (i + 1) </span>
<span class="nc" id="L1212">              + &quot;    &quot; + train.instance(i).weight());</span>
        }
      }
    }
    
<span class="nc" id="L1217">    return result;</span>
  }
  
  /**
   * Checks whether the scheme alters the training dataset during
   * training. If the scheme needs to modify the training
   * data it should take a copy of the training data. Currently checks
   * for changes to header structure, number of instances, order of
   * instances, instance weights.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param predictorMissing true if we know the scheme can handle
   * (at least) moderate missing predictor values
   * @param classMissing true if we know the scheme can handle
   * (at least) moderate missing class values
   * @return index 0 is true if the test was passed
   */
  protected boolean[] datasetIntegrity(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      boolean predictorMissing,
      boolean classMissing) {
    
<span class="nc" id="L1251">    print(&quot;scheme doesn't alter original datasets&quot;);</span>
<span class="nc" id="L1252">    printAttributeSummary(</span>
<span class="nc" id="L1253">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="nc" id="L1254">    print(&quot;...&quot;);</span>
<span class="nc" id="L1255">    int numTrain = getNumInstances(), </span>
<span class="nc" id="L1256">    numClasses = 2, missingLevel = 20;</span>
    
<span class="nc" id="L1258">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1259">    Instances train = null;</span>
<span class="nc" id="L1260">    Instances trainCopy = null;</span>
<span class="nc" id="L1261">    ASSearch search = null;</span>
<span class="nc" id="L1262">    ASEvaluation evaluation = null;</span>
    try {
<span class="nc" id="L1264">      train = makeTestDataset(42, numTrain, </span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">                              nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">                              numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">                              stringPredictor     ? getNumString()     : 0, </span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">                              datePredictor       ? getNumDate()       : 0, </span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">                              relationalPredictor ? getNumRelational() : 0, </span>
<span class="nc" id="L1270">                              numClasses, </span>
<span class="nc" id="L1271">                              classType,</span>
<span class="nc" id="L1272">                              multiInstance);</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      if (missingLevel &gt; 0)</span>
<span class="nc" id="L1274">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1275">      search = ASSearch.makeCopies(getSearch(), 1)[0];</span>
<span class="nc" id="L1276">      evaluation = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L1277">      trainCopy = new Instances(train);</span>
<span class="nc" id="L1278">    } catch (Exception ex) {</span>
<span class="nc" id="L1279">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L1282">      search(search, evaluation, trainCopy);</span>
<span class="nc" id="L1283">      compareDatasets(train, trainCopy);</span>
      
<span class="nc" id="L1285">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1286">      result[0] = true;</span>
<span class="nc" id="L1287">    } catch (Exception ex) {</span>
<span class="nc" id="L1288">      println(&quot;no&quot;);</span>
<span class="nc" id="L1289">      result[0] = false;</span>
      
<span class="nc bnc" id="L1291" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1292">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1293">        print(&quot;Problem during training&quot;);</span>
<span class="nc" id="L1294">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L1295">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1296">        println(&quot;=== Train Dataset (original) ===\n&quot;</span>
<span class="nc" id="L1297">            + trainCopy.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1298">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1299">            + train.toString() + &quot;\n&quot;);</span>
      }
    }
    
<span class="nc" id="L1303">    return result;</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param missingLevel the percentage of missing values
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor,
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int missingLevel,
      boolean predictorMissing,
      boolean classMissing,
      int numTrain,
      int numClasses,
      FastVector accepts) {
    
<span class="nc" id="L1340">    return runBasicTest(</span>
<span class="nc" id="L1341">		nominalPredictor, </span>
<span class="nc" id="L1342">		numericPredictor,</span>
<span class="nc" id="L1343">		stringPredictor,</span>
<span class="nc" id="L1344">		datePredictor,</span>
<span class="nc" id="L1345">		relationalPredictor,</span>
<span class="nc" id="L1346">		multiInstance,</span>
<span class="nc" id="L1347">		classType, </span>
<span class="nc" id="L1348">		TestInstances.CLASS_IS_LAST,</span>
<span class="nc" id="L1349">		missingLevel,</span>
<span class="nc" id="L1350">		predictorMissing,</span>
<span class="nc" id="L1351">		classMissing,</span>
<span class="nc" id="L1352">		numTrain,</span>
<span class="nc" id="L1353">		numClasses,</span>
<span class="nc" id="L1354">		accepts);</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the attribute index of the class
   * @param missingLevel the percentage of missing values
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor,
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int classIndex,
      int missingLevel,
      boolean predictorMissing,
      boolean classMissing,
      int numTrain,
      int numClasses,
      FastVector accepts) {
    
<span class="nc" id="L1393">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1394">    Instances train = null;</span>
<span class="nc" id="L1395">    ASSearch search = null;</span>
<span class="nc" id="L1396">    ASEvaluation evaluation = null;</span>
    try {
<span class="nc" id="L1398">      train = makeTestDataset(42, numTrain, </span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                              nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                              numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                              stringPredictor     ? getNumString()     : 0,</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">                              datePredictor       ? getNumDate()       : 0,</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                              relationalPredictor ? getNumRelational() : 0,</span>
<span class="nc" id="L1404">                              numClasses, </span>
<span class="nc" id="L1405">                              classType,</span>
<span class="nc" id="L1406">                              classIndex,</span>
<span class="nc" id="L1407">                              multiInstance);</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">      if (missingLevel &gt; 0)</span>
<span class="nc" id="L1409">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1410">      search = ASSearch.makeCopies(getSearch(), 1)[0];</span>
<span class="nc" id="L1411">      evaluation = ASEvaluation.makeCopies(getEvaluator(), 1)[0];</span>
<span class="nc" id="L1412">    } catch (Exception ex) {</span>
<span class="nc" id="L1413">      ex.printStackTrace();</span>
<span class="nc" id="L1414">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L1417">      search(search, evaluation, train);</span>
<span class="nc" id="L1418">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1419">      result[0] = true;</span>
    } 
<span class="nc" id="L1421">    catch (Exception ex) {</span>
<span class="nc" id="L1422">      boolean acceptable = false;</span>
      String msg;
<span class="nc bnc" id="L1424" title="All 2 branches missed.">      if (ex.getMessage() == null)</span>
<span class="nc" id="L1425">	msg = &quot;&quot;;</span>
      else
<span class="nc" id="L1427">        msg = ex.getMessage().toLowerCase();</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">      if (msg.indexOf(&quot;not in classpath&quot;) &gt; -1)</span>
<span class="nc" id="L1429">	m_ClasspathProblems = true;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">      for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">	if (msg.indexOf((String)accepts.elementAt(i)) &gt;= 0) {</span>
<span class="nc" id="L1432">	  acceptable = true;</span>
	}
      }
      
<span class="nc bnc" id="L1436" title="All 2 branches missed.">      println(&quot;no&quot; + (acceptable ? &quot; (OK error message)&quot; : &quot;&quot;));</span>
<span class="nc" id="L1437">      result[1] = acceptable;</span>
      
<span class="nc bnc" id="L1439" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1440">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1441">        print(&quot;Problem during training&quot;);</span>
<span class="nc" id="L1442">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">        if (!acceptable) {</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">          if (accepts.size() &gt; 0) {</span>
<span class="nc" id="L1445">            print(&quot;Error message doesn't mention &quot;);</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">            for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">              if (i != 0) {</span>
<span class="nc" id="L1448">                print(&quot; or &quot;);</span>
              }
<span class="nc" id="L1450">              print('&quot;' + (String)accepts.elementAt(i) + '&quot;');</span>
            }
          }
<span class="nc" id="L1453">          println(&quot;here is the dataset:\n&quot;);</span>
<span class="nc" id="L1454">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1455">              + train.toString() + &quot;\n&quot;);</span>
        }
      }
    }
    
<span class="nc" id="L1460">    return result;</span>
  }
  
  /**
   * Make a simple set of instances, which can later be modified
   * for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numNominal the number of nominal attributes
   * @param numNumeric the number of numeric attributes
   * @param numString the number of string attributes
   * @param numDate the number of date attributes
   * @param numRelational the number of relational attributes
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param multiInstance whether the dataset should a multi-instance dataset
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, int numInstances, 
                                      int numNominal, int numNumeric, 
                                      int numString, int numDate,
                                      int numRelational,
                                      int numClasses, int classType,
                                      boolean multiInstance)
    throws Exception {
    
<span class="nc" id="L1489">    return makeTestDataset(</span>
<span class="nc" id="L1490">		seed, </span>
<span class="nc" id="L1491">		numInstances,</span>
<span class="nc" id="L1492">		numNominal,</span>
<span class="nc" id="L1493">		numNumeric,</span>
<span class="nc" id="L1494">		numString,</span>
<span class="nc" id="L1495">		numDate, </span>
<span class="nc" id="L1496">		numRelational,</span>
<span class="nc" id="L1497">		numClasses, </span>
<span class="nc" id="L1498">		classType,</span>
<span class="nc" id="L1499">		TestInstances.CLASS_IS_LAST,</span>
<span class="nc" id="L1500">		multiInstance);</span>
  }
  
  /**
   * Make a simple set of instances with variable position of the class 
   * attribute, which can later be modified for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numNominal the number of nominal attributes
   * @param numNumeric the number of numeric attributes
   * @param numString the number of string attributes
   * @param numDate the number of date attributes
   * @param numRelational the number of relational attributes
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class (0-based, -1 as last)
   * @param multiInstance whether the dataset should a multi-instance dataset
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see TestInstances#CLASS_IS_LAST
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, int numInstances, 
                                      int numNominal, int numNumeric, 
                                      int numString, int numDate,
                                      int numRelational,
                                      int numClasses, int classType,
                                      int classIndex,
                                      boolean multiInstance)
  throws Exception {
    
<span class="nc" id="L1532">    TestInstances dataset = new TestInstances();</span>
    
<span class="nc" id="L1534">    dataset.setSeed(seed);</span>
<span class="nc" id="L1535">    dataset.setNumInstances(numInstances);</span>
<span class="nc" id="L1536">    dataset.setNumNominal(numNominal);</span>
<span class="nc" id="L1537">    dataset.setNumNumeric(numNumeric);</span>
<span class="nc" id="L1538">    dataset.setNumString(numString);</span>
<span class="nc" id="L1539">    dataset.setNumDate(numDate);</span>
<span class="nc" id="L1540">    dataset.setNumRelational(numRelational);</span>
<span class="nc" id="L1541">    dataset.setNumClasses(numClasses);</span>
<span class="nc" id="L1542">    dataset.setClassType(classType);</span>
<span class="nc" id="L1543">    dataset.setClassIndex(classIndex);</span>
<span class="nc" id="L1544">    dataset.setNumClasses(numClasses);</span>
<span class="nc" id="L1545">    dataset.setMultiInstance(multiInstance);</span>
<span class="nc" id="L1546">    dataset.setWords(getWords());</span>
<span class="nc" id="L1547">    dataset.setWordSeparators(getWordSeparators());</span>
    
<span class="nc" id="L1549">    return process(dataset.generate());</span>
  }
  
  /**
   * Print out a short summary string for the dataset characteristics
   *
   * @param nominalPredictor true if nominal predictor attributes are present
   * @param numericPredictor true if numeric predictor attributes are present
   * @param stringPredictor true if string predictor attributes are present
   * @param datePredictor true if date predictor attributes are present
   * @param relationalPredictor true if relational predictor attributes are present
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   */
  protected void printAttributeSummary(boolean nominalPredictor, 
                                       boolean numericPredictor, 
                                       boolean stringPredictor, 
                                       boolean datePredictor, 
                                       boolean relationalPredictor, 
                                       boolean multiInstance,
                                       int classType) {
    
<span class="nc" id="L1571">    String str = &quot;&quot;;</span>

<span class="nc bnc" id="L1573" title="All 2 branches missed.">    if (numericPredictor)</span>
<span class="nc" id="L1574">      str += &quot; numeric&quot;;</span>
    
<span class="nc bnc" id="L1576" title="All 2 branches missed.">    if (nominalPredictor) {</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L1578">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L1579">      str += &quot; nominal&quot;;</span>
    }
    
<span class="nc bnc" id="L1582" title="All 2 branches missed.">    if (stringPredictor) {</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L1584">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L1585">      str += &quot; string&quot;;</span>
    }
    
<span class="nc bnc" id="L1588" title="All 2 branches missed.">    if (datePredictor) {</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L1590">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L1591">      str += &quot; date&quot;;</span>
    }
    
<span class="nc bnc" id="L1594" title="All 2 branches missed.">    if (relationalPredictor) {</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L1596">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L1597">      str += &quot; relational&quot;;</span>
    }
    
<span class="nc" id="L1600">    str += &quot; predictors)&quot;;</span>
    
<span class="nc bnc" id="L1602" title="All 6 branches missed.">    switch (classType) {</span>
      case Attribute.NUMERIC:
<span class="nc" id="L1604">        str = &quot; (numeric class,&quot; + str;</span>
<span class="nc" id="L1605">        break;</span>
      case Attribute.NOMINAL:
<span class="nc" id="L1607">        str = &quot; (nominal class,&quot; + str;</span>
<span class="nc" id="L1608">        break;</span>
      case Attribute.STRING:
<span class="nc" id="L1610">        str = &quot; (string class,&quot; + str;</span>
<span class="nc" id="L1611">        break;</span>
      case Attribute.DATE:
<span class="nc" id="L1613">        str = &quot; (date class,&quot; + str;</span>
<span class="nc" id="L1614">        break;</span>
      case Attribute.RELATIONAL:
<span class="nc" id="L1616">        str = &quot; (relational class,&quot; + str;</span>
        break;
    }
    
<span class="nc" id="L1620">    print(str);</span>
<span class="nc" id="L1621">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1629">    return RevisionUtils.extract(&quot;$Revision: 4783 $&quot;);</span>
  }
  
  /**
   * Test method for this class
   * 
   * @param args the commandline parameters
   */
  public static void main(String [] args) {
<span class="nc" id="L1638">    runCheck(new CheckAttributeSelection(), args);</span>
<span class="nc" id="L1639">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>