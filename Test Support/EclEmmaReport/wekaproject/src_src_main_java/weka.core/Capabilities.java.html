<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Capabilities.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core</a> &gt; <span class="el_source">Capabilities.java</span></div><h1>Capabilities.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * Capabilities.java
 * Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 */

package weka.core;

import weka.core.converters.ConverterUtils.DataSource;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Vector;

/**
 * A class that describes the capabilites (e.g., handling certain types of
 * attributes, missing values, types of classes, etc.) of a specific
 * classifier. By default, the classifier is capable of nothing. This
 * ensures that new features have to be enabled explicitly. &lt;p/&gt;
 * 
 * A common code fragment for making use of the capabilities in a classifier 
 * would be this:
 * &lt;pre&gt;
 * public void &lt;b&gt;buildClassifier&lt;/b&gt;(Instances instances) sthrows Exception {
 *   // can the classifier handle the data?
 *   getCapabilities().&lt;b&gt;testWithFail(instances)&lt;/b&gt;;
 *   ...
 *   // possible deletion of instances with missing class labels, etc.
 * &lt;/pre&gt;
 * For only testing a single attribute, use this:
 * &lt;pre&gt;
 *   ...
 *   Attribute att = instances.attribute(0);
 *   getCapabilities().&lt;b&gt;testWithFail(att)&lt;/b&gt;;
 *   ...
 * &lt;/pre&gt;
 * Or for testing the class attribute (uses the capabilities that are 
 * especially for the class):
 * &lt;pre&gt;
 *   ...
 *   Attribute att = instances.classAttribute();
 *   getCapabilities().&lt;b&gt;testWithFail(att, &lt;i&gt;true&lt;/i&gt;)&lt;/b&gt;;
 *   ...
 * &lt;/pre&gt;
 * 
 * @author  FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 9140 $
 */
public class Capabilities 
  implements Cloneable, Serializable, RevisionHandler {
  
  /** serialversion UID */
  static final long serialVersionUID = -5478590032325567849L;  

  /** the properties file for managing the tests */
  public final static String PROPERTIES_FILE = &quot;weka/core/Capabilities.props&quot;;

  /** the actual properties */
  protected static Properties PROPERTIES;
  
  /** defines an attribute type */
  private final static int ATTRIBUTE = 1;
  
  /** defines a class type */
  private final static int CLASS = 2;
  
  /** defines an attribute capability */
  private final static int ATTRIBUTE_CAPABILITY = 4;
  
  /** defines a class capability */
  private final static int CLASS_CAPABILITY = 8;
  
  /** defines a other capability */
  private final static int OTHER_CAPABILITY = 16;

  /** enumeration of all capabilities */
<span class="fc" id="L97">  public enum Capability {</span>
    // attributes
    /** can handle nominal attributes */
<span class="fc" id="L100">    NOMINAL_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Nominal attributes&quot;),</span>
    /** can handle binary attributes */
<span class="fc" id="L102">    BINARY_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Binary attributes&quot;),</span>
    /** can handle unary attributes */
<span class="fc" id="L104">    UNARY_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Unary attributes&quot;),</span>
    /** can handle empty nominal attributes */
<span class="fc" id="L106">    EMPTY_NOMINAL_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Empty nominal attributes&quot;),</span>
    /** can handle numeric attributes */
<span class="fc" id="L108">    NUMERIC_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Numeric attributes&quot;),</span>
    /** can handle date attributes */
<span class="fc" id="L110">    DATE_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Date attributes&quot;),</span>
    /** can handle string attributes */
<span class="fc" id="L112">    STRING_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;String attributes&quot;),</span>
    /** can handle relational attributes */
<span class="fc" id="L114">    RELATIONAL_ATTRIBUTES(ATTRIBUTE + ATTRIBUTE_CAPABILITY, &quot;Relational attributes&quot;),</span>
    /** can handle missing values in attributes */
<span class="fc" id="L116">    MISSING_VALUES(ATTRIBUTE_CAPABILITY, &quot;Missing values&quot;),</span>
    // class
    /** can handle data without class attribute, eg clusterers */
<span class="fc" id="L119">    NO_CLASS(CLASS_CAPABILITY, &quot;No class&quot;),</span>
    /** can handle nominal classes */
<span class="fc" id="L121">    NOMINAL_CLASS(CLASS + CLASS_CAPABILITY, &quot;Nominal class&quot;),</span>
    /** can handle binary classes */
<span class="fc" id="L123">    BINARY_CLASS(CLASS + CLASS_CAPABILITY, &quot;Binary class&quot;),</span>
    /** can handle unary classes */
<span class="fc" id="L125">    UNARY_CLASS(CLASS + CLASS_CAPABILITY, &quot;Unary class&quot;),</span>
    /** can handle empty nominal classes */
<span class="fc" id="L127">    EMPTY_NOMINAL_CLASS(CLASS + CLASS_CAPABILITY, &quot;Empty nominal class&quot;),</span>
    /** can handle numeric classes */
<span class="fc" id="L129">    NUMERIC_CLASS(CLASS + CLASS_CAPABILITY, &quot;Numeric class&quot;),</span>
    /** can handle date classes */
<span class="fc" id="L131">    DATE_CLASS(CLASS + CLASS_CAPABILITY, &quot;Date class&quot;),</span>
    /** can handle string classes */
<span class="fc" id="L133">    STRING_CLASS(CLASS + CLASS_CAPABILITY, &quot;String class&quot;),</span>
    /** can handle relational classes */
<span class="fc" id="L135">    RELATIONAL_CLASS(CLASS + CLASS_CAPABILITY, &quot;Relational class&quot;),</span>
    /** can handle missing values in class attribute */
<span class="fc" id="L137">    MISSING_CLASS_VALUES(CLASS_CAPABILITY, &quot;Missing class values&quot;),</span>
    // other
    /** can handle multi-instance data */
<span class="fc" id="L140">    ONLY_MULTIINSTANCE(OTHER_CAPABILITY, &quot;Only multi-Instance data&quot;);</span>

    /** the flags for the capabilities */
<span class="fc" id="L143">    private int m_Flags = 0;</span>
    
    /** the display string */
    private String m_Display;
    
    /**
     * initializes the capability with the given flags
     * 
     * @param flags	&quot;meta-data&quot; for the capability
     * @param display	the display string (must be unique!)
     */
<span class="fc" id="L154">    private Capability(int flags, String display) {</span>
<span class="fc" id="L155">      m_Flags   = flags;</span>
<span class="fc" id="L156">      m_Display = display;</span>
<span class="fc" id="L157">    }</span>
    
    /**
     * returns true if the capability is an attribute
     * 
     * @return true if the capability is an attribute
     */
    public boolean isAttribute() {
<span class="fc bfc" id="L165" title="All 2 branches covered.">      return ((m_Flags &amp; ATTRIBUTE) == ATTRIBUTE);</span>
    }
    
    /**
     * returns true if the capability is a class
     * 
     * @return true if the capability is a class
     */
    public boolean isClass() {
<span class="fc bfc" id="L174" title="All 2 branches covered.">      return ((m_Flags &amp; CLASS) == CLASS);</span>
    }
    
    /**
     * returns true if the capability is an attribute capability
     * 
     * @return true if the capability is an attribute capability
     */
    public boolean isAttributeCapability() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">      return ((m_Flags &amp; ATTRIBUTE_CAPABILITY) == ATTRIBUTE_CAPABILITY);</span>
    }
    
    /**
     * returns true if the capability is a class capability
     * 
     * @return true if the capability is a class capability
     */
    public boolean isOtherCapability() {
<span class="nc bnc" id="L192" title="All 2 branches missed.">      return ((m_Flags &amp; OTHER_CAPABILITY) == OTHER_CAPABILITY);</span>
    }
    
    /**
     * returns true if the capability is a other capability
     * 
     * @return true if the capability is a other capability
     */
    public boolean isClassCapability() {
<span class="fc bfc" id="L201" title="All 2 branches covered.">      return ((m_Flags &amp; CLASS_CAPABILITY) == CLASS_CAPABILITY);</span>
    }
    
    /**
     * returns the display string of the capability
     * 
     * @return the display string
     */
    public String toString() {
<span class="nc" id="L210">      return m_Display;</span>
    }
  };

  /** the object that owns this capabilities instance */
  protected CapabilitiesHandler m_Owner;
  
  /** the hashset for storing the active capabilities */
  protected HashSet m_Capabilities;
  
  /** the hashset for storing dependent capabilities, eg for meta-classifiers */
  protected HashSet m_Dependencies;
  
  /** the reason why the test failed, used to throw an exception */
<span class="fc" id="L224">  protected Exception m_FailReason = null;</span>

  /** the minimum number of instances in a dataset */
<span class="fc" id="L227">  protected int m_MinimumNumberInstances = 1;</span>

  /** whether to perform any tests at all */
  protected boolean m_Test;

  /** whether to perform data based tests */
  protected boolean m_InstancesTest;

  /** whether to perform attribute based tests */
  protected boolean m_AttributeTest;

  /** whether to test for missing values */
  protected boolean m_MissingValuesTest;

  /** whether to test for missing class values */
  protected boolean m_MissingClassValuesTest;

  /** whether to test for minimum number of instances */
  protected boolean m_MinimumNumberInstancesTest;
  
  /**
   * initializes the capabilities for the given owner
   * 
   * @param owner       the object that produced this Capabilities instance
   */
  public Capabilities(CapabilitiesHandler owner) {
<span class="fc" id="L253">    super();</span>

<span class="fc" id="L255">    setOwner(owner);</span>
<span class="fc" id="L256">    m_Capabilities = new HashSet();</span>
<span class="fc" id="L257">    m_Dependencies = new HashSet();</span>

    // load properties
<span class="fc bfc" id="L260" title="All 2 branches covered.">    if (PROPERTIES == null) {</span>
      try {
<span class="fc" id="L262">        PROPERTIES = Utils.readProperties(PROPERTIES_FILE);</span>
      }
<span class="nc" id="L264">      catch (Exception e) {</span>
<span class="nc" id="L265">	e.printStackTrace();</span>
<span class="nc" id="L266">	PROPERTIES = new Properties();</span>
      }
    }
    
<span class="fc" id="L270">    m_Test                       = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;Test&quot;, &quot;true&quot;));</span>
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">    m_InstancesTest              = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;InstancesTest&quot;, &quot;true&quot;)) &amp;&amp; m_Test;</span>
<span class="pc bpc" id="L272" title="2 of 4 branches missed.">    m_AttributeTest              = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;AttributeTest&quot;, &quot;true&quot;)) &amp;&amp; m_Test;</span>
<span class="pc bpc" id="L273" title="2 of 4 branches missed.">    m_MissingValuesTest          = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;MissingValuesTest&quot;, &quot;true&quot;)) &amp;&amp; m_Test;</span>
<span class="pc bpc" id="L274" title="2 of 4 branches missed.">    m_MissingClassValuesTest     = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;MissingClassValuesTest&quot;, &quot;true&quot;)) &amp;&amp; m_Test;</span>
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">    m_MinimumNumberInstancesTest = Boolean.parseBoolean(PROPERTIES.getProperty(&quot;MinimumNumberInstancesTest&quot;, &quot;true&quot;)) &amp;&amp; m_Test;</span>
        
<span class="fc bfc" id="L277" title="All 2 branches covered.">    if (owner instanceof weka.classifiers.UpdateableClassifier ||</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        owner instanceof weka.clusterers.UpdateableClusterer) {</span>
<span class="fc" id="L279">      setMinimumNumberInstances(0);</span>
    }
<span class="fc" id="L281">  }</span>
  
  /**
   * Creates and returns a copy of this object.
   * 
   * @return	a clone of this object
   */
  public Object clone() {
    Capabilities    result;

<span class="fc" id="L291">    result = new Capabilities(m_Owner);</span>
<span class="fc" id="L292">    result.assign(this);</span>

<span class="fc" id="L294">    return result;</span>
  }
  
  /**
   * retrieves the data from the given Capabilities object
   * 
   * @param c	  the capabilities object to initialize with
   */
  public void assign(Capabilities c) {
<span class="fc bfc" id="L303" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
      // capability
<span class="fc bfc" id="L305" title="All 2 branches covered.">      if (c.handles(cap))</span>
<span class="fc" id="L306">        enable(cap);</span>
      else
<span class="fc" id="L308">	disable(cap);</span>
      // dependency
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">      if (c.hasDependency(cap))</span>
<span class="nc" id="L311">        enableDependency(cap);</span>
      else
<span class="fc" id="L313">	disableDependency(cap);</span>
    }

<span class="fc" id="L316">    setMinimumNumberInstances(c.getMinimumNumberInstances());</span>
<span class="fc" id="L317">  }</span>

  /**
   * performs an AND conjunction with the capabilities of the given 
   * Capabilities object and updates itself
   *
   * @param c     the capabilities to AND with
   */
  public void and(Capabilities c) {
<span class="fc bfc" id="L326" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
      // capability
<span class="fc bfc" id="L328" title="All 4 branches covered.">      if (handles(cap) &amp;&amp; c.handles(cap))</span>
<span class="fc" id="L329">        m_Capabilities.add(cap);</span>
      else
<span class="fc" id="L331">        m_Capabilities.remove(cap);</span>
      // dependency
<span class="pc bpc" id="L333" title="3 of 4 branches missed.">      if (hasDependency(cap) &amp;&amp; c.hasDependency(cap))</span>
<span class="nc" id="L334">        m_Dependencies.add(cap);</span>
      else
<span class="fc" id="L336">        m_Dependencies.remove(cap);</span>
    }
    
    // minimum number of instances that both handlers need at least to work
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">    if (c.getMinimumNumberInstances() &gt; getMinimumNumberInstances())</span>
<span class="nc" id="L341">      setMinimumNumberInstances(c.getMinimumNumberInstances());</span>
<span class="fc" id="L342">  }</span>

  /**
   * performs an OR conjunction with the capabilities of the given 
   * Capabilities object and updates itself
   *
   * @param c     the capabilities to OR with
   */
  public void or(Capabilities c) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
      // capability
<span class="fc bfc" id="L353" title="All 4 branches covered.">      if (handles(cap) || c.handles(cap))</span>
<span class="fc" id="L354">        m_Capabilities.add(cap);</span>
      else
<span class="fc" id="L356">        m_Capabilities.remove(cap);</span>
      // dependency
<span class="pc bpc" id="L358" title="2 of 4 branches missed.">      if (hasDependency(cap) || c.hasDependency(cap))</span>
<span class="nc" id="L359">        m_Dependencies.add(cap);</span>
      else
<span class="fc" id="L361">        m_Dependencies.remove(cap);</span>
    }
    
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">    if (c.getMinimumNumberInstances() &lt; getMinimumNumberInstances())</span>
<span class="nc" id="L365">      setMinimumNumberInstances(c.getMinimumNumberInstances());</span>
<span class="fc" id="L366">  }</span>
  
  /**
   * Returns true if the currently set capabilities support at least all of
   * the capabiliites of the given Capabilities object (checks only the enum!)
   * 
   * @param c	the capabilities to support at least
   * @return	true if all the requested capabilities are supported
   */
  public boolean supports(Capabilities c) {
    boolean	result;
    
<span class="nc" id="L378">    result = true;</span>
    
<span class="nc bnc" id="L380" title="All 2 branches missed.">    for (Capability cap: Capability.values()) {</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">      if (c.handles(cap) &amp;&amp; !handles(cap)) {</span>
<span class="nc" id="L382">	result = false;</span>
<span class="nc" id="L383">	break;</span>
      }
    }

<span class="nc" id="L387">    return result;</span>
  }
  
  /**
   * Returns true if the currently set capabilities support (or have a 
   * dependency) at least all of the capabilities of the given Capabilities 
   * object (checks only the enum!)
   * 
   * @param c	the capabilities (or dependencies) to support at least
   * @return	true if all the requested capabilities are supported (or at 
   * 		least have a dependency)
   */
  public boolean supportsMaybe(Capabilities c) {
    boolean	result;
    
<span class="nc" id="L402">    result = true;</span>
    
<span class="nc bnc" id="L404" title="All 2 branches missed.">    for (Capability cap: Capability.values()) {</span>
<span class="nc bnc" id="L405" title="All 6 branches missed.">      if (c.handles(cap) &amp;&amp; !(handles(cap) || hasDependency(cap))) {</span>
<span class="nc" id="L406">	result = false;</span>
<span class="nc" id="L407">	break;</span>
      }
    }

<span class="nc" id="L411">    return result;</span>
  }

  /**
   * sets the owner of this capabilities object
   * 
   * @param value       the new owner
   */
  public void setOwner(CapabilitiesHandler value) {
<span class="fc" id="L420">    m_Owner = value;</span>
<span class="fc" id="L421">  }</span>
  
  /**
   * returns the owner of this capabilities object
   * 
   * @return            the current owner of this capabilites object
   */
  public CapabilitiesHandler getOwner() {
<span class="fc" id="L429">    return m_Owner;</span>
  }

  /**
   * sets the minimum number of instances that have to be in the dataset
   * 
   * @param value       the minimum number of instances
   */
  public void setMinimumNumberInstances(int value) {
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">    if (value &gt;= 0)</span>
<span class="fc" id="L439">      m_MinimumNumberInstances = value;</span>
<span class="fc" id="L440">  }</span>
  
  /**
   * returns the minimum number of instances that have to be in the dataset
   * 
   * @return            the minimum number of instances
   */
  public int getMinimumNumberInstances() {
<span class="fc" id="L448">    return m_MinimumNumberInstances;</span>
  }
  
  /**
   * Returns an Iterator over the stored capabilities
   * 
   * @return iterator over the current capabilities
   */
  public Iterator capabilities() {
<span class="fc" id="L457">    return m_Capabilities.iterator();</span>
  }
  
  /**
   * Returns an Iterator over the stored dependencies
   * 
   * @return iterator over the current dependencies
   */
  public Iterator dependencies() {
<span class="nc" id="L466">    return m_Dependencies.iterator();</span>
  }
  
  /**
   * enables the given capability. 
   * Enabling NOMINAL_ATTRIBUTES also enables BINARY_ATTRIBUTES, 
   * UNARY_ATTRIBUTES and EMPTY_NOMINAL_ATTRIBUTES. 
   * Enabling BINARY_ATTRIBUTES also enables UNARY_ATTRIBUTES and 
   * EMPTY_NOMINAL_ATTRIBUTES. 
   * Enabling UNARY_ATTRIBUTES also enables EMPTY_NOMINAL_ATTRIBUTES.
   * But NOMINAL_CLASS only enables BINARY_CLASS, since normal schemes in Weka
   * don't work with datasets that have only 1 class label (or none).
   *
   * @param c     the capability to enable
   */
  public void enable(Capability c) {
    // attributes
<span class="fc bfc" id="L483" title="All 2 branches covered.">    if (c == Capability.NOMINAL_ATTRIBUTES) {</span>
<span class="fc" id="L484">      enable(Capability.BINARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L486" title="All 2 branches covered.">    else if (c == Capability.BINARY_ATTRIBUTES) {</span>
<span class="fc" id="L487">      enable(Capability.UNARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L489" title="All 2 branches covered.">    else if (c == Capability.UNARY_ATTRIBUTES) {</span>
<span class="fc" id="L490">      enable(Capability.EMPTY_NOMINAL_ATTRIBUTES);</span>
    }
    // class
<span class="fc bfc" id="L493" title="All 2 branches covered.">    else if (c == Capability.NOMINAL_CLASS) {</span>
<span class="fc" id="L494">      enable(Capability.BINARY_CLASS);</span>
    }

<span class="fc" id="L497">    m_Capabilities.add(c);</span>
<span class="fc" id="L498">  }</span>
  
  /**
   * enables the dependency flag for the given capability
   * Enabling NOMINAL_ATTRIBUTES also enables BINARY_ATTRIBUTES, 
   * UNARY_ATTRIBUTES and EMPTY_NOMINAL_ATTRIBUTES. 
   * Enabling BINARY_ATTRIBUTES also enables UNARY_ATTRIBUTES and 
   * EMPTY_NOMINAL_ATTRIBUTES. 
   * Enabling UNARY_ATTRIBUTES also enables EMPTY_NOMINAL_ATTRIBUTES.
   * But NOMINAL_CLASS only enables BINARY_CLASS, since normal schemes in Weka
   * don't work with datasets that have only 1 class label (or none).
   *
   * @param c     the capability to enable the dependency flag for
   */
  public void enableDependency(Capability c) {
    // attributes
<span class="fc bfc" id="L514" title="All 2 branches covered.">    if (c == Capability.NOMINAL_ATTRIBUTES) {</span>
<span class="fc" id="L515">      enableDependency(Capability.BINARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L517" title="All 2 branches covered.">    else if (c == Capability.BINARY_ATTRIBUTES) {</span>
<span class="fc" id="L518">      enableDependency(Capability.UNARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L520" title="All 2 branches covered.">    else if (c == Capability.UNARY_ATTRIBUTES) {</span>
<span class="fc" id="L521">      enableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);</span>
    }
    // class
<span class="fc bfc" id="L524" title="All 2 branches covered.">    else if (c == Capability.NOMINAL_CLASS) {</span>
<span class="fc" id="L525">      enableDependency(Capability.BINARY_CLASS);</span>
    }

<span class="fc" id="L528">    m_Dependencies.add(c);</span>
<span class="fc" id="L529">  }</span>
  
  /**
   * enables all class types
   * 
   * @see #disableAllClasses()
   * @see #getClassCapabilities()
   */
  public void enableAllClasses() {
<span class="fc bfc" id="L538" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">      if (cap.isClass())</span>
<span class="fc" id="L540">	enable(cap);</span>
    }
<span class="fc" id="L542">  }</span>
  
  /**
   * enables all class type dependencies
   * 
   * @see #disableAllClassDependencies()
   * @see #getClassCapabilities()
   */
  public void enableAllClassDependencies() {
<span class="fc bfc" id="L551" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">      if (cap.isClass())</span>
<span class="fc" id="L553">	enableDependency(cap);</span>
    }
<span class="fc" id="L555">  }</span>
  
  /**
   * enables all attribute types
   * 
   * @see #disableAllAttributes()
   * @see #getAttributeCapabilities()
   */
  public void enableAllAttributes() {
<span class="fc bfc" id="L564" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">      if (cap.isAttribute())</span>
<span class="fc" id="L566">	enable(cap);</span>
    }
<span class="fc" id="L568">  }</span>
  
  /**
   * enables all attribute type dependencies
   * 
   * @see #disableAllAttributeDependencies()
   * @see #getAttributeCapabilities()
   */
  public void enableAllAttributeDependencies() {
<span class="fc bfc" id="L577" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">      if (cap.isAttribute())</span>
<span class="fc" id="L579">	enableDependency(cap);</span>
    }
<span class="fc" id="L581">  }</span>
  
  /**
   * enables all attribute and class types (including dependencies)
   */
  public void enableAll() {
<span class="fc" id="L587">    enableAllAttributes();</span>
<span class="fc" id="L588">    enableAllAttributeDependencies();</span>
<span class="fc" id="L589">    enableAllClasses();</span>
<span class="fc" id="L590">    enableAllClassDependencies();</span>
<span class="fc" id="L591">    enable(Capability.MISSING_VALUES);</span>
<span class="fc" id="L592">    enable(Capability.MISSING_CLASS_VALUES);</span>
<span class="fc" id="L593">  }</span>

  /**
   * disables the given capability
   * Disabling NOMINAL_ATTRIBUTES also disables BINARY_ATTRIBUTES, 
   * UNARY_ATTRIBUTES and EMPTY_NOMINAL_ATTRIBUTES. 
   * Disabling BINARY_ATTRIBUTES also disables UNARY_ATTRIBUTES and 
   * EMPTY_NOMINAL_ATTRIBUTES. 
   * Disabling UNARY_ATTRIBUTES also disables EMPTY_NOMINAL_ATTRIBUTES.
   * The same hierarchy applies to the class capabilities.
   *
   * @param c     the capability to disable
   */
  public void disable(Capability c) {
    // attributes
<span class="fc bfc" id="L608" title="All 2 branches covered.">    if (c == Capability.NOMINAL_ATTRIBUTES) {</span>
<span class="fc" id="L609">      disable(Capability.BINARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L611" title="All 2 branches covered.">    else if (c == Capability.BINARY_ATTRIBUTES) {</span>
<span class="fc" id="L612">      disable(Capability.UNARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L614" title="All 2 branches covered.">    else if (c == Capability.UNARY_ATTRIBUTES) {</span>
<span class="fc" id="L615">      disable(Capability.EMPTY_NOMINAL_ATTRIBUTES);</span>
    }
    // class
<span class="fc bfc" id="L618" title="All 2 branches covered.">    else if (c == Capability.NOMINAL_CLASS) {</span>
<span class="fc" id="L619">      disable(Capability.BINARY_CLASS);</span>
    }
<span class="fc bfc" id="L621" title="All 2 branches covered.">    else if (c == Capability.BINARY_CLASS) {</span>
<span class="fc" id="L622">      disable(Capability.UNARY_CLASS);</span>
    }
<span class="fc bfc" id="L624" title="All 2 branches covered.">    else if (c == Capability.UNARY_CLASS) {</span>
<span class="fc" id="L625">      disable(Capability.EMPTY_NOMINAL_CLASS);</span>
    }

<span class="fc" id="L628">    m_Capabilities.remove(c);</span>
<span class="fc" id="L629">  }</span>

  /**
   * disables the dependency of the given capability
   * Disabling NOMINAL_ATTRIBUTES also disables BINARY_ATTRIBUTES, 
   * UNARY_ATTRIBUTES and EMPTY_NOMINAL_ATTRIBUTES. 
   * Disabling BINARY_ATTRIBUTES also disables UNARY_ATTRIBUTES and 
   * EMPTY_NOMINAL_ATTRIBUTES. 
   * Disabling UNARY_ATTRIBUTES also disables EMPTY_NOMINAL_ATTRIBUTES.
   * The same hierarchy applies to the class capabilities.
   *
   * @param c     the capability to disable the dependency flag for
   */
  public void disableDependency(Capability c) {
    // attributes
<span class="fc bfc" id="L644" title="All 2 branches covered.">    if (c == Capability.NOMINAL_ATTRIBUTES) {</span>
<span class="fc" id="L645">      disableDependency(Capability.BINARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L647" title="All 2 branches covered.">    else if (c == Capability.BINARY_ATTRIBUTES) {</span>
<span class="fc" id="L648">      disableDependency(Capability.UNARY_ATTRIBUTES);</span>
    }
<span class="fc bfc" id="L650" title="All 2 branches covered.">    else if (c == Capability.UNARY_ATTRIBUTES) {</span>
<span class="fc" id="L651">      disableDependency(Capability.EMPTY_NOMINAL_ATTRIBUTES);</span>
    }
    // class
<span class="fc bfc" id="L654" title="All 2 branches covered.">    else if (c == Capability.NOMINAL_CLASS) {</span>
<span class="fc" id="L655">      disableDependency(Capability.BINARY_CLASS);</span>
    }
<span class="fc bfc" id="L657" title="All 2 branches covered.">    else if (c == Capability.BINARY_CLASS) {</span>
<span class="fc" id="L658">      disableDependency(Capability.UNARY_CLASS);</span>
    }
<span class="fc bfc" id="L660" title="All 2 branches covered.">    else if (c == Capability.UNARY_CLASS) {</span>
<span class="fc" id="L661">      disableDependency(Capability.EMPTY_NOMINAL_CLASS);</span>
    }

<span class="fc" id="L664">    m_Dependencies.remove(c);</span>
<span class="fc" id="L665">  }</span>
  
  /**
   * disables all class types
   * 
   * @see #enableAllClasses()
   * @see #getClassCapabilities()
   */
  public void disableAllClasses() {
<span class="fc bfc" id="L674" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">      if (cap.isClass())</span>
<span class="fc" id="L676">	disable(cap);</span>
    }
<span class="fc" id="L678">  }</span>
  
  /**
   * disables all class type dependencies
   * 
   * @see #enableAllClassDependencies()
   * @see #getClassCapabilities()
   */
  public void disableAllClassDependencies() {
<span class="fc bfc" id="L687" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">      if (cap.isClass())</span>
<span class="fc" id="L689">	disableDependency(cap);</span>
    }
<span class="fc" id="L691">  }</span>
  
  /**
   * disables all attribute types
   * 
   * @see #enableAllAttributes()
   * @see #getAttributeCapabilities()
   */
  public void disableAllAttributes() {
<span class="fc bfc" id="L700" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">      if (cap.isAttribute())</span>
<span class="fc" id="L702">	disable(cap);</span>
    }
<span class="fc" id="L704">  }</span>
  
  /**
   * disables all attribute type dependencies
   * 
   * @see #enableAllAttributeDependencies()
   * @see #getAttributeCapabilities()
   */
  public void disableAllAttributeDependencies() {
<span class="fc bfc" id="L713" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">      if (cap.isAttribute())</span>
<span class="fc" id="L715">	disableDependency(cap);</span>
    }
<span class="fc" id="L717">  }</span>
  
  /**
   * disables all attribute and class types (including dependencies)
   */
  public void disableAll() {
<span class="fc" id="L723">    disableAllAttributes();</span>
<span class="fc" id="L724">    disableAllAttributeDependencies();</span>
<span class="fc" id="L725">    disableAllClasses();</span>
<span class="fc" id="L726">    disableAllClassDependencies();</span>
<span class="fc" id="L727">    disable(Capability.MISSING_VALUES);</span>
<span class="fc" id="L728">    disable(Capability.MISSING_CLASS_VALUES);</span>
<span class="fc" id="L729">    disable(Capability.NO_CLASS);</span>
<span class="fc" id="L730">  }</span>
  
  /**
   * returns all class capabilities
   * 
   * @return		all capabilities regarding the class
   * @see #enableAllClasses()
   * @see #disableAllClasses()
   */
  public Capabilities getClassCapabilities() {
    Capabilities	result;
    
<span class="fc" id="L742">    result = new Capabilities(getOwner());</span>
    
<span class="fc bfc" id="L744" title="All 2 branches covered.">    for (Capability cap: Capability.values()) {</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">      if (cap.isClassCapability()) {</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">	if (handles(cap))</span>
<span class="fc" id="L747">	  result.m_Capabilities.add(cap);</span>
      }
    }
    
<span class="fc" id="L751">    return result;</span>
  }
  
  /**
   * returns all attribute capabilities
   * 
   * @return		all capabilities regarding attributes
   * @see #enableAllAttributes()
   * @see #disableAllAttributes()
   */
  public Capabilities getAttributeCapabilities() {
    Capabilities	result;
    
<span class="nc" id="L764">    result = new Capabilities(getOwner());</span>
    
<span class="nc bnc" id="L766" title="All 2 branches missed.">    for (Capability cap: Capability.values()) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">      if (cap.isAttributeCapability()) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">	if (handles(cap))</span>
<span class="nc" id="L769">	  result.m_Capabilities.add(cap);</span>
      }
    }
    
<span class="nc" id="L773">    return result;</span>
  }
  
  /**
   * returns all other capabilities, besides class and attribute related ones
   * 
   * @return		all other capabilities, besides class and attribute 
   * 			related ones
   */
  public Capabilities getOtherCapabilities() {
    Capabilities	result;
    
<span class="nc" id="L785">    result = new Capabilities(getOwner());</span>
    
<span class="nc bnc" id="L787" title="All 2 branches missed.">    for (Capability cap: Capability.values()) {</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">      if (cap.isOtherCapability()) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">	if (handles(cap))</span>
<span class="nc" id="L790">	  result.m_Capabilities.add(cap);</span>
      }
    }
    
<span class="nc" id="L794">    return result;</span>
  }

  /**
   * returns true if the classifier handler has the specified capability
   *
   * @param c     the capability to test
   * @return      true if the classifier handler has the capability
   */
  public boolean handles(Capability c) {
<span class="fc" id="L804">    return m_Capabilities.contains(c);</span>
  }

  /**
   * returns true if the classifier handler has a dependency for the specified 
   * capability
   *
   * @param c     the capability to test
   * @return      true if the classifier handler has a dependency for the 
   *               capability
   */
  public boolean hasDependency(Capability c) {
<span class="fc" id="L816">    return m_Dependencies.contains(c);</span>
  }
  
  /**
   * Checks whether there are any dependencies at all
   * 
   * @return true if there is at least one dependency for a capability
   */
  public boolean hasDependencies() {
<span class="nc bnc" id="L825" title="All 2 branches missed.">    return (m_Dependencies.size() &gt; 0);</span>
  }

  /**
   * returns the reason why the tests failed, is null if tests succeeded
   * 
   * @return		the reason why the tests failed
   */
  public Exception getFailReason() {
<span class="nc" id="L834">    return m_FailReason;</span>
  }
  
  /**
   * Generates the message for, e.g., an exception. Adds the classname before the
   * actual message and returns that string.
   * 
   * @param msg		the actual content of the message, e.g., exception
   * @return		the new message
   */
  protected String createMessage(String msg) {
    String	result;
    
<span class="fc" id="L847">    result = &quot;&quot;;</span>
    
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">    if (getOwner() != null)</span>
<span class="fc" id="L850">      result = getOwner().getClass().getName();</span>
    else
<span class="nc" id="L852">      result = &quot;&lt;anonymous&gt;&quot;;</span>
      
<span class="fc" id="L854">    result += &quot;: &quot; + msg;</span>
    
<span class="fc" id="L856">    return result;</span>
  }
  
  /**
   * Test the given attribute, whether it can be processed by the handler,
   * given its capabilities. The method assumes that the specified attribute
   * is not the class attribute.
   * 
   * @param att		the attribute to test
   * @return		true if all the tests succeeded
   * @see		#test(Attribute, boolean)
   */
  public boolean test(Attribute att) {
<span class="fc" id="L869">    return test(att, false);</span>
  }
  
  /**
   * Test the given attribute, whether it can be processed by the handler,
   * given its capabilities.
   * 
   * @param att		the attribute to test
   * @param isClass	whether this attribute is the class attribute
   * @return		true if all the tests succeeded
   * @see		#m_AttributeTest
   */
  public boolean test(Attribute att, boolean isClass) {
    boolean		result;
    Capability		cap;
    Capability		capBinary;
    Capability		capUnary;
    Capability		capEmpty;
    String		errorStr;
    
<span class="fc" id="L889">    result = true;</span>
    
    // shall we test the data?
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">    if (!m_AttributeTest)</span>
<span class="nc" id="L893">      return result;</span>

    // for exception
<span class="fc bfc" id="L896" title="All 2 branches covered.">    if (isClass)</span>
<span class="fc" id="L897">      errorStr  = &quot;class&quot;;</span>
    else
<span class="fc" id="L899">      errorStr  = &quot;attributes&quot;;</span>
    
<span class="pc bpc" id="L901" title="1 of 6 branches missed.">    switch (att.type()) {</span>
      case Attribute.NOMINAL:
<span class="fc bfc" id="L903" title="All 2 branches covered.">	if (isClass) {</span>
<span class="fc" id="L904">	  cap       = Capability.NOMINAL_CLASS;</span>
<span class="fc" id="L905">	  capBinary = Capability.BINARY_CLASS;</span>
<span class="fc" id="L906">	  capUnary  = Capability.UNARY_CLASS;</span>
<span class="fc" id="L907">	  capEmpty  = Capability.EMPTY_NOMINAL_CLASS;</span>
	}
	else {
<span class="fc" id="L910">	  cap       = Capability.NOMINAL_ATTRIBUTES;</span>
<span class="fc" id="L911">	  capBinary = Capability.BINARY_ATTRIBUTES;</span>
<span class="fc" id="L912">	  capUnary  = Capability.UNARY_ATTRIBUTES;</span>
<span class="fc" id="L913">	  capEmpty  = Capability.EMPTY_NOMINAL_ATTRIBUTES;</span>
	}
	
<span class="fc bfc" id="L916" title="All 4 branches covered.">        if (handles(cap) &amp;&amp; (att.numValues() &gt; 2))</span>
<span class="fc" id="L917">          break;</span>
<span class="fc bfc" id="L918" title="All 4 branches covered.">        else if (handles(capBinary) &amp;&amp; (att.numValues() == 2))</span>
<span class="fc" id="L919">          break;</span>
<span class="pc bpc" id="L920" title="1 of 4 branches missed.">        else if (handles(capUnary) &amp;&amp; (att.numValues() == 1))</span>
<span class="fc" id="L921">          break;</span>
<span class="pc bpc" id="L922" title="3 of 4 branches missed.">        else if (handles(capEmpty) &amp;&amp; (att.numValues() == 0))</span>
<span class="nc" id="L923">          break;</span>

<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        if (att.numValues() == 0) {</span>
<span class="nc" id="L926">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="nc" id="L927">              createMessage(&quot;Cannot handle empty nominal &quot; + errorStr + &quot;!&quot;));</span>
<span class="nc" id="L928">          result = false;</span>
        }
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">        if (att.numValues() == 1) {</span>
<span class="nc" id="L931">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="nc" id="L932">              createMessage(&quot;Cannot handle unary &quot; + errorStr + &quot;!&quot;));</span>
<span class="nc" id="L933">          result = false;</span>
        }
<span class="fc bfc" id="L935" title="All 2 branches covered.">        else if (att.numValues() == 2) {</span>
<span class="fc" id="L936">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L937">              createMessage(&quot;Cannot handle binary &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L938">          result = false;</span>
        }
        else {
<span class="fc" id="L941">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L942">              createMessage(&quot;Cannot handle multi-valued nominal &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L943">          result = false;</span>
        }
<span class="fc" id="L945">        break;</span>

      case Attribute.NUMERIC:
<span class="fc bfc" id="L948" title="All 2 branches covered.">	if (isClass)</span>
<span class="fc" id="L949">	  cap = Capability.NUMERIC_CLASS;</span>
	else
<span class="fc" id="L951">	  cap = Capability.NUMERIC_ATTRIBUTES;</span>
	
<span class="fc bfc" id="L953" title="All 2 branches covered.">        if (!handles(cap)) {</span>
<span class="fc" id="L954">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L955">                              createMessage(&quot;Cannot handle numeric &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L956">          result = false;</span>
        }
<span class="fc" id="L958">        break;</span>

      case Attribute.DATE:
<span class="fc bfc" id="L961" title="All 2 branches covered.">	if (isClass)</span>
<span class="fc" id="L962">	  cap = Capability.DATE_CLASS;</span>
	else
<span class="fc" id="L964">	  cap = Capability.DATE_ATTRIBUTES;</span>
	
<span class="fc bfc" id="L966" title="All 2 branches covered.">        if (!handles(cap)) {</span>
<span class="fc" id="L967">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L968">                              createMessage(&quot;Cannot handle date &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L969">          result = false;</span>
        }
<span class="fc" id="L971">        break;</span>

      case Attribute.STRING:
<span class="fc bfc" id="L974" title="All 2 branches covered.">	if (isClass)</span>
<span class="fc" id="L975">	  cap = Capability.STRING_CLASS;</span>
	else
<span class="fc" id="L977">	  cap = Capability.STRING_ATTRIBUTES;</span>
	
<span class="fc bfc" id="L979" title="All 2 branches covered.">        if (!handles(cap)) {</span>
<span class="fc" id="L980">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L981">                              createMessage(&quot;Cannot handle string &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L982">          result = false;</span>
        }
<span class="fc" id="L984">        break;</span>

      case Attribute.RELATIONAL:
<span class="fc bfc" id="L987" title="All 2 branches covered.">	if (isClass)</span>
<span class="fc" id="L988">	  cap = Capability.RELATIONAL_CLASS;</span>
	else
<span class="fc" id="L990">	  cap = Capability.RELATIONAL_ATTRIBUTES;</span>
	
<span class="fc bfc" id="L992" title="All 2 branches covered.">        if (!handles(cap)) {</span>
<span class="fc" id="L993">          m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="fc" id="L994">                              createMessage(&quot;Cannot handle relational &quot; + errorStr + &quot;!&quot;));</span>
<span class="fc" id="L995">          result = false;</span>
        }
        // attributes in the relation of this attribute must be tested
        // separately with a different Capabilites object
<span class="fc" id="L999">        break;</span>

      default:
<span class="nc" id="L1002">        m_FailReason = new UnsupportedAttributeTypeException(</span>
<span class="nc" id="L1003">                            createMessage(&quot;Cannot handle unknown attribute type '&quot; </span>
<span class="nc" id="L1004">                                        + att.type() + &quot;'!&quot;));</span>
<span class="nc" id="L1005">        result = false;</span>
    }
    
<span class="fc" id="L1008">    return result;</span>
  }
  
  /**
   * Tests the given data, whether it can be processed by the handler,
   * given its capabilities. Classifiers implementing the 
   * &lt;code&gt;MultiInstanceCapabilitiesHandler&lt;/code&gt; interface are checked 
   * automatically for their multi-instance Capabilities (if no bags, then
   * only the bag-structure, otherwise only the first bag).
   *
   * @param data 	the data to test
   * @return		true if all the tests succeeded
   * @see 		#test(Instances, int, int)
   */
  public boolean test(Instances data) {
<span class="fc" id="L1023">    return test(data, 0, data.numAttributes() - 1);</span>
  }
  
  /**
   * Tests a certain range of attributes of the given data, whether it can be 
   * processed by the handler, given its capabilities. Classifiers 
   * implementing the &lt;code&gt;MultiInstanceCapabilitiesHandler&lt;/code&gt; interface 
   * are checked automatically for their multi-instance Capabilities (if no 
   * bags, then only the bag-structure, otherwise only the first bag).
   *
   * @param data 	the data to test
   * @param fromIndex	the range of attributes - start (incl.)
   * @param toIndex	the range of attributes - end (incl.)
   * @return		true if all the tests succeeded
   * @see 		MultiInstanceCapabilitiesHandler
   * @see 		#m_InstancesTest
   * @see		#m_MissingValuesTest
   * @see		#m_MissingClassValuesTest
   * @see		#m_MinimumNumberInstancesTest
   */
  public boolean test(Instances data, int fromIndex, int toIndex) {
    int         	i;
    int         	n;
    int			m;
    Attribute   	att;
    Instance    	inst;
    boolean		testClass;
    Capabilities	cap;
    boolean		missing;
    Iterator		iter;
    
    // shall we test the data?
<span class="pc bpc" id="L1055" title="1 of 2 branches missed.">    if (!m_InstancesTest)</span>
<span class="nc" id="L1056">      return true;</span>
    
    // no Capabilities? -&gt; warning
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">    if (    (m_Capabilities.size() == 0) </span>
<span class="pc bpc" id="L1060" title="3 of 4 branches missed.">	 || ((m_Capabilities.size() == 1) &amp;&amp; handles(Capability.NO_CLASS)) )</span>
<span class="nc" id="L1061">      System.err.println(createMessage(&quot;No capabilities set!&quot;));</span>
    
    // any attributes?
<span class="fc bfc" id="L1064" title="All 2 branches covered.">    if (toIndex - fromIndex &lt; 0) {</span>
<span class="fc" id="L1065">      m_FailReason = new WekaException(</span>
<span class="fc" id="L1066">                          createMessage(&quot;No attributes!&quot;));</span>
<span class="fc" id="L1067">      return false;</span>
    }

    // do wee need to test the class attribute, i.e., is the class attribute
    // within the range of attributes?
<span class="fc bfc" id="L1072" title="All 2 branches covered.">    testClass =    (data.classIndex() &gt; -1) </span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">    		&amp;&amp; (data.classIndex() &gt;= fromIndex)</span>
<span class="pc bpc" id="L1074" title="1 of 2 branches missed.">    		&amp;&amp; (data.classIndex() &lt;= toIndex);</span>
    
    // attributes
<span class="fc bfc" id="L1077" title="All 2 branches covered.">    for (i = fromIndex; i &lt;= toIndex; i++) {</span>
<span class="fc" id="L1078">      att = data.attribute(i);</span>
      
      // class is handled separately
<span class="fc bfc" id="L1081" title="All 2 branches covered.">      if (i == data.classIndex())</span>
<span class="fc" id="L1082">        continue;</span>
      
      // check attribute types
<span class="fc bfc" id="L1085" title="All 2 branches covered.">      if (!test(att))</span>
<span class="fc" id="L1086">	return false;</span>
    }

    // class
<span class="pc bpc" id="L1090" title="1 of 4 branches missed.">    if (!handles(Capability.NO_CLASS) &amp;&amp; (data.classIndex() == -1)) {</span>
<span class="nc" id="L1091">      m_FailReason = new UnassignedClassException(</span>
<span class="nc" id="L1092">	  createMessage(&quot;Class attribute not set!&quot;));</span>
<span class="nc" id="L1093">      return false;</span>
    }
      
    // special case: no class attribute can be handled
<span class="pc bpc" id="L1097" title="1 of 4 branches missed.">    if (handles(Capability.NO_CLASS) &amp;&amp; (data.classIndex() &gt; -1)) {</span>
<span class="nc" id="L1098">      cap  = getClassCapabilities();</span>
<span class="nc" id="L1099">      cap.disable(Capability.NO_CLASS);</span>
<span class="nc" id="L1100">      iter = cap.capabilities();</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">      if (!iter.hasNext()) {</span>
<span class="nc" id="L1102">	m_FailReason = new WekaException(</span>
<span class="nc" id="L1103">	    createMessage(&quot;Cannot handle any class attribute!&quot;));</span>
<span class="nc" id="L1104">	return false;</span>
      }
    }
      
<span class="pc bpc" id="L1108" title="1 of 4 branches missed.">    if (testClass &amp;&amp; !handles(Capability.NO_CLASS)) {</span>
<span class="fc" id="L1109">      att = data.classAttribute();</span>
<span class="fc bfc" id="L1110" title="All 2 branches covered.">      if (!test(att, true))</span>
<span class="fc" id="L1111">	return false;</span>

      // special handling of RELATIONAL class
      // TODO: store additional Capabilities for this case
      
      // missing class labels
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">      if (m_MissingClassValuesTest) {</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">	if (!handles(Capability.MISSING_CLASS_VALUES)) {</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">	  for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">	    if (data.instance(i).classIsMissing()) {</span>
<span class="fc" id="L1121">	      m_FailReason = new WekaException(</span>
<span class="fc" id="L1122">		  createMessage(&quot;Cannot handle missing class values!&quot;));</span>
<span class="fc" id="L1123">	      return false;</span>
	    }
	  }
	}
	else {
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">	  if (m_MinimumNumberInstancesTest) {</span>
<span class="fc" id="L1129">	    int hasClass = 0;</span>
	    
<span class="fc bfc" id="L1131" title="All 2 branches covered.">	    for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc bfc" id="L1132" title="All 2 branches covered.">	      if (!data.instance(i).classIsMissing())</span>
<span class="fc" id="L1133">		hasClass++;</span>
	    }
	    
	    // not enough instances with class labels?
<span class="fc bfc" id="L1137" title="All 2 branches covered.">	    if (hasClass &lt; getMinimumNumberInstances()) {</span>
<span class="fc" id="L1138">	      m_FailReason = new WekaException(</span>
<span class="fc" id="L1139">		  createMessage(&quot;Not enough training instances with class labels (required: &quot; </span>
<span class="fc" id="L1140">		      + getMinimumNumberInstances() </span>
<span class="fc" id="L1141">		      + &quot;, provided: &quot; </span>
<span class="fc" id="L1142">		      + hasClass + &quot;)!&quot;));</span>
<span class="fc" id="L1143">	      return false;</span>
	    }
	  }
	}
      }
    }

    // missing values
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">    if (m_MissingValuesTest) {</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">      if (!handles(Capability.MISSING_VALUES)) {</span>
<span class="fc" id="L1153">	missing = false;</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">	for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc" id="L1155">	  inst = data.instance(i);</span>
	  
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">	  if (inst instanceof SparseInstance) {</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">	    for (m = 0; m &lt; inst.numValues(); m++) {</span>
<span class="nc" id="L1159">	      n = inst.index(m);</span>
	      
	      // out of scope?
<span class="nc bnc" id="L1162" title="All 2 branches missed.">	      if (n &lt; fromIndex)</span>
<span class="nc" id="L1163">		continue;</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">	      if (n &gt; toIndex)</span>
<span class="nc" id="L1165">		break;</span>

	      // skip class
<span class="nc bnc" id="L1168" title="All 2 branches missed.">	      if (n == inst.classIndex())</span>
<span class="nc" id="L1169">		continue;</span>
	      

<span class="nc bnc" id="L1172" title="All 2 branches missed.">	      if (inst.isMissing(n)) {</span>
<span class="nc" id="L1173">		missing = true;</span>
<span class="nc" id="L1174">		break;</span>
	      }
	    }
	  }
	  else {
<span class="fc bfc" id="L1179" title="All 2 branches covered.">	    for (n = fromIndex; n &lt;= toIndex; n++) {</span>
	      // skip class
<span class="fc bfc" id="L1181" title="All 2 branches covered.">	      if (n == inst.classIndex())</span>
<span class="fc" id="L1182">		continue;</span>

<span class="fc bfc" id="L1184" title="All 2 branches covered.">	      if (inst.isMissing(n)) {</span>
<span class="fc" id="L1185">		missing = true;</span>
<span class="fc" id="L1186">		break;</span>
	      }
	    }
	  }
	  
<span class="fc bfc" id="L1191" title="All 2 branches covered.">	  if (missing) {</span>
<span class="fc" id="L1192">	    m_FailReason = new NoSupportForMissingValuesException(</span>
<span class="fc" id="L1193">		createMessage(&quot;Cannot handle missing values!&quot;));</span>
<span class="fc" id="L1194">	    return false;</span>
	  }
	}
      }
    }
    
    // instances
<span class="pc bpc" id="L1201" title="1 of 2 branches missed.">    if (m_MinimumNumberInstancesTest) {</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">      if (data.numInstances() &lt; getMinimumNumberInstances()) {</span>
<span class="fc" id="L1203">	m_FailReason = new WekaException(</span>
<span class="fc" id="L1204">	    createMessage(&quot;Not enough training instances (required: &quot; </span>
<span class="fc" id="L1205">		+ getMinimumNumberInstances() </span>
<span class="fc" id="L1206">		+ &quot;, provided: &quot; </span>
<span class="fc" id="L1207">		+ data.numInstances() + &quot;)!&quot;));</span>
<span class="fc" id="L1208">	return false;</span>
      }
    }

    // Multi-Instance? -&gt; check structure (regardless of attribute range!)
<span class="fc bfc" id="L1213" title="All 2 branches covered.">    if (handles(Capability.ONLY_MULTIINSTANCE)) {</span>
      // number of attributes?
<span class="fc bfc" id="L1215" title="All 2 branches covered.">      if (data.numAttributes() != 3) {</span>
<span class="fc" id="L1216">        m_FailReason = new WekaException(</span>
<span class="fc" id="L1217">                            createMessage(&quot;Incorrect Multi-Instance format, must be 'bag-id, bag, class'!&quot;));</span>
<span class="fc" id="L1218">        return false;</span>
      }
      
      // type of attributes and position of class?
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">      if (    !data.attribute(0).isNominal() </span>
<span class="pc bpc" id="L1223" title="1 of 2 branches missed.">           || !data.attribute(1).isRelationValued() </span>
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">           || (data.classIndex() != data.numAttributes() - 1) ) {</span>
<span class="nc" id="L1225">        m_FailReason = new WekaException(</span>
<span class="nc" id="L1226">            createMessage(&quot;Incorrect Multi-Instance format, must be 'NOMINAL att, RELATIONAL att, CLASS att'!&quot;));</span>
<span class="nc" id="L1227">        return false;</span>
      }

      // check data immediately
<span class="pc bpc" id="L1231" title="1 of 2 branches missed.">      if (getOwner() instanceof MultiInstanceCapabilitiesHandler) {</span>
<span class="fc" id="L1232">	MultiInstanceCapabilitiesHandler handler = (MultiInstanceCapabilitiesHandler) getOwner();</span>
<span class="fc" id="L1233">	cap = handler.getMultiInstanceCapabilities();</span>
	boolean result;
<span class="pc bpc" id="L1235" title="1 of 4 branches missed.">	if (data.numInstances() &gt; 0 &amp;&amp; data.attribute(1).numValues() &gt; 0)</span>
<span class="fc" id="L1236">	  result = cap.test(data.attribute(1).relation(0));</span>
	else
<span class="fc" id="L1238">	  result = cap.test(data.attribute(1).relation());</span>
	
<span class="fc bfc" id="L1240" title="All 2 branches covered.">	if (!result) {</span>
<span class="fc" id="L1241">	  m_FailReason = cap.m_FailReason;</span>
<span class="fc" id="L1242">	  return false;</span>
	}
      }
    }
    
    // passed all tests!
<span class="fc" id="L1248">    return true;</span>
  }

  /**
   * tests the given attribute by calling the test(Attribute,boolean) method 
   * and throws an exception if the test fails. The method assumes that the
   * specified attribute is not the class attribute.
   *
   * @param att        	the attribute to test
   * @throws Exception  in case the attribute doesn't pass the tests
   * @see 		#test(Attribute,boolean)
   */
  public void testWithFail(Attribute att) throws Exception {
<span class="nc" id="L1261">    test(att, false);</span>
<span class="nc" id="L1262">  }</span>

  /**
   * tests the given attribute by calling the test(Attribute,boolean) method 
   * and throws an exception if the test fails.
   *
   * @param att        	the attribute to test
   * @param isClass	whether this attribute is the class attribute
   * @throws Exception  in case the attribute doesn't pass the tests
   * @see 		#test(Attribute,boolean)
   */
  public void testWithFail(Attribute att, boolean isClass) throws Exception {
<span class="nc bnc" id="L1274" title="All 2 branches missed.">    if (!test(att, isClass))</span>
<span class="nc" id="L1275">      throw m_FailReason;</span>
<span class="nc" id="L1276">  }</span>

  /**
   * tests the given data by calling the test(Instances,int,int) method and 
   * throws an exception if the test fails.
   *
   * @param data        the data to test
   * @param fromIndex	the range of attributes - start (incl.)
   * @param toIndex	the range of attributes - end (incl.)
   * @throws Exception  in case the data doesn't pass the tests
   * @see 		#test(Instances,int,int)
   */
  public void testWithFail(Instances data, int fromIndex, int toIndex) throws Exception {
<span class="nc bnc" id="L1289" title="All 2 branches missed.">    if (!test(data, fromIndex, toIndex))</span>
<span class="nc" id="L1290">      throw m_FailReason;</span>
<span class="nc" id="L1291">  }</span>

  /**
   * tests the given data by calling the test(Instances) method and throws 
   * an exception if the test fails.
   *
   * @param data        the data to test
   * @throws Exception  in case the data doesn't pass the tests
   * @see 		#test(Instances)
   */
  public void testWithFail(Instances data) throws Exception {
<span class="fc bfc" id="L1302" title="All 2 branches covered.">    if (!test(data))</span>
<span class="fc" id="L1303">      throw m_FailReason;</span>
<span class="fc" id="L1304">  }</span>
  
  /**
   * returns a string representation of the capabilities
   * 
   * @return 	a string representation of this object
   */
  public String toString() {
    Vector		sorted;
    StringBuffer	result;
    
<span class="nc" id="L1315">    result = new StringBuffer();</span>

    // capabilities
<span class="nc" id="L1318">    sorted = new Vector(m_Capabilities);</span>
<span class="nc" id="L1319">    Collections.sort(sorted);</span>
<span class="nc" id="L1320">    result.append(&quot;Capabilities: &quot; + sorted.toString() + &quot;\n&quot;);</span>

    // dependencies
<span class="nc" id="L1323">    sorted = new Vector(m_Dependencies);</span>
<span class="nc" id="L1324">    Collections.sort(sorted);</span>
<span class="nc" id="L1325">    result.append(&quot;Dependencies: &quot; + sorted.toString() + &quot;\n&quot;);</span>
    
    // other stuff
<span class="nc" id="L1328">    result.append(&quot;min # Instance: &quot; + getMinimumNumberInstances() + &quot;\n&quot;);</span>
    
<span class="nc" id="L1330">    return result.toString();</span>
  }
  
  /**
   * turns the capabilities object into source code. The returned source code
   * is a block that creates a Capabilities object named 'objectname' and
   * enables all the capabilities of this Capabilities object.
   * 
   * @param objectname	the name of the Capabilities object being instantiated
   * @return		the generated source code
   */
  public String toSource(String objectname) {
<span class="nc" id="L1342">    return toSource(objectname, 0);</span>
  }
    
  /**
   * turns the capabilities object into source code. The returned source code
   * is a block that creates a Capabilities object named 'objectname' and
   * enables all the capabilities of this Capabilities object.
   * 
   * @param objectname	the name of the Capabilities object being instantiated
   * @param indent	the number of blanks to indent
   * @return		the generated source code
   */
  public String toSource(String objectname, int indent) {
    StringBuffer	result;
    String		capsName;
    String		capName;
    String		indentStr;
    int			i;
    
<span class="nc" id="L1361">    result = new StringBuffer();</span>

<span class="nc" id="L1363">    capsName = Capabilities.class.getName();</span>
<span class="nc" id="L1364">    capName  = Capabilities.Capability.class.getName().replaceAll(&quot;\\$&quot;, &quot;.&quot;);</span>
    
<span class="nc" id="L1366">    indentStr = &quot;&quot;;</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">    for (i = 0; i &lt; indent; i++)</span>
<span class="nc" id="L1368">      indentStr += &quot; &quot;;</span>
    
    // object name
<span class="nc" id="L1371">    result.append(indentStr + capsName + &quot; &quot; + objectname + &quot; = new &quot; + capsName + &quot;(this);\n&quot;);</span>
    
<span class="nc" id="L1373">    List&lt;Capability&gt; capsList = new ArrayList&lt;Capability&gt;();</span>
<span class="nc" id="L1374">    boolean hasNominalAtt = false;</span>
<span class="nc" id="L1375">    boolean hasBinaryAtt = false;</span>
<span class="nc" id="L1376">    boolean hasUnaryAtt = false;</span>
<span class="nc" id="L1377">    boolean hasEmptyNomAtt = false;</span>
<span class="nc" id="L1378">    boolean hasNominalClass = false;</span>
    // capabilities
<span class="nc" id="L1380">    result.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">    for (Capability cap: Capability.values()) {</span>
      // capability
<span class="nc bnc" id="L1383" title="All 2 branches missed.">      if (handles(cap)) {</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">        if (cap == Capability.NOMINAL_ATTRIBUTES) {</span>
<span class="nc" id="L1385">          hasNominalAtt = true;</span>
        }
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (cap == Capability.NOMINAL_CLASS) {</span>
<span class="nc" id="L1388">          hasNominalClass = true;</span>
        }
<span class="nc bnc" id="L1390" title="All 2 branches missed.">        if (cap == Capability.BINARY_ATTRIBUTES) {</span>
<span class="nc" id="L1391">          hasBinaryAtt = true;</span>
        }
<span class="nc bnc" id="L1393" title="All 2 branches missed.">        if (cap == Capability.UNARY_ATTRIBUTES) {</span>
<span class="nc" id="L1394">          hasUnaryAtt = true;</span>
        }
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        if (cap == Capability.EMPTY_NOMINAL_ATTRIBUTES) {</span>
<span class="nc" id="L1397">          hasEmptyNomAtt = true;</span>
        }
<span class="nc" id="L1399">        capsList.add(cap);              </span>
      }
    }
    
<span class="nc bnc" id="L1403" title="All 2 branches missed.">    for (Capability cap : capsList) {</span>
<span class="nc bnc" id="L1404" title="All 4 branches missed.">      if ((cap == Capability.BINARY_ATTRIBUTES &amp;&amp; hasNominalAtt) ||</span>
<span class="nc bnc" id="L1405" title="All 4 branches missed.">          (cap == Capability.UNARY_ATTRIBUTES &amp;&amp; hasBinaryAtt) ||</span>
<span class="nc bnc" id="L1406" title="All 4 branches missed.">          (cap == Capability.EMPTY_NOMINAL_ATTRIBUTES &amp;&amp; hasUnaryAtt) ||</span>
<span class="nc bnc" id="L1407" title="All 4 branches missed.">          (cap == Capability.BINARY_CLASS &amp;&amp; hasNominalClass)) {</span>
<span class="nc" id="L1408">        continue;</span>
      }
<span class="nc" id="L1410">      result.append(</span>
<span class="nc" id="L1411">          indentStr + objectname + &quot;.enable(&quot; + capName + &quot;.&quot; + cap.name() + &quot;);\n&quot;);</span>
      // dependency
<span class="nc bnc" id="L1413" title="All 2 branches missed.">      if (hasDependency(cap))</span>
<span class="nc" id="L1414">        result.append(</span>
<span class="nc" id="L1415">            indentStr + objectname + &quot;.enableDependency(&quot; + capName + &quot;.&quot; + cap.name() + &quot;);\n&quot;);</span>
    }

    // other
<span class="nc" id="L1419">    result.append(&quot;\n&quot;);</span>
<span class="nc" id="L1420">    result.append(</span>
<span class="nc" id="L1421">	indentStr + objectname + &quot;.setMinimumNumberInstances(&quot; </span>
<span class="nc" id="L1422">	+ getMinimumNumberInstances() + &quot;);\n&quot;);</span>

<span class="nc" id="L1424">    result.append(&quot;\n&quot;);</span>
    
<span class="nc" id="L1426">    return result.toString();</span>
  }
  
  /**
   * returns a Capabilities object specific for this data. The multi-instance
   * capability is not checked as well as the minimum number of instances
   * is not set.
   * 
   * @param data	the data to base the capabilities on
   * @return		a data-specific capabilities object
   * @throws Exception	in case an error occurrs, e.g., an unknown attribute 
   * 			type
   */
  public static Capabilities forInstances(Instances data) throws Exception {
<span class="nc" id="L1440">    return forInstances(data, false);</span>
  }
  
  /**
   * returns a Capabilities object specific for this data. The minimum number 
   * of instances is not set, the check for multi-instance data is optional.
   * 
   * @param data	the data to base the capabilities on
   * @param multi	if true then the structure is checked, too
   * @return		a data-specific capabilities object
   * @throws Exception	in case an error occurrs, e.g., an unknown attribute 
   * 			type
   */
  public static Capabilities forInstances(Instances data, boolean multi) throws Exception {
    Capabilities	result;
    Capabilities	multiInstance;
    int			i;
    int			n;
    int			m;
    Instance		inst;
    boolean		missing;
    
<span class="nc" id="L1462">    result = new Capabilities(null);</span>
    
    // class
<span class="nc bnc" id="L1465" title="All 2 branches missed.">    if (data.classIndex() == -1) {</span>
<span class="nc" id="L1466">      result.enable(Capability.NO_CLASS);</span>
    }
    else {
<span class="nc bnc" id="L1469" title="All 6 branches missed.">      switch (data.classAttribute().type()) {</span>
	case Attribute.NOMINAL:
<span class="nc bnc" id="L1471" title="All 2 branches missed.">	  if (data.classAttribute().numValues() == 1)</span>
<span class="nc" id="L1472">	    result.enable(Capability.UNARY_CLASS);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">	  else if (data.classAttribute().numValues() == 2)</span>
<span class="nc" id="L1474">	    result.enable(Capability.BINARY_CLASS);</span>
	  else
<span class="nc" id="L1476">	    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="nc" id="L1477">	  break;</span>
	  
	case Attribute.NUMERIC:
<span class="nc" id="L1480">	  result.enable(Capability.NUMERIC_CLASS);</span>
<span class="nc" id="L1481">	  break;</span>
	  
	case Attribute.STRING:
<span class="nc" id="L1484">	  result.enable(Capability.STRING_CLASS);</span>
<span class="nc" id="L1485">	  break;</span>
	  
	case Attribute.DATE:
<span class="nc" id="L1488">	  result.enable(Capability.DATE_CLASS);</span>
<span class="nc" id="L1489">	  break;</span>
	  
	case Attribute.RELATIONAL:
<span class="nc" id="L1492">	  result.enable(Capability.RELATIONAL_CLASS);</span>
<span class="nc" id="L1493">	  break;</span>
	  
	default:
<span class="nc" id="L1496">	  throw new UnsupportedAttributeTypeException(</span>
<span class="nc" id="L1497">	      &quot;Unknown class attribute type '&quot; + data.classAttribute() + &quot;'!&quot;);</span>
      }
      
      // missing class values
<span class="nc bnc" id="L1501" title="All 2 branches missed.">      for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">	if (data.instance(i).classIsMissing()) {</span>
<span class="nc" id="L1503">	  result.enable(Capability.MISSING_CLASS_VALUES);</span>
<span class="nc" id="L1504">	  break;</span>
	}
      }
    }
    
    // attributes
<span class="nc bnc" id="L1510" title="All 2 branches missed.">    for (i = 0; i &lt; data.numAttributes(); i++) {</span>
      // skip class
<span class="nc bnc" id="L1512" title="All 2 branches missed.">      if (i == data.classIndex())</span>
<span class="nc" id="L1513">	continue;</span>

<span class="nc bnc" id="L1515" title="All 6 branches missed.">      switch (data.attribute(i).type()) {</span>
	case Attribute.NOMINAL:
<span class="nc" id="L1517">	  result.enable(Capability.UNARY_ATTRIBUTES);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">	  if (data.attribute(i).numValues() == 2)</span>
<span class="nc" id="L1519">	    result.enable(Capability.BINARY_ATTRIBUTES);</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">	  else if (data.attribute(i).numValues() &gt; 2)</span>
<span class="nc" id="L1521">	    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="nc" id="L1522">	  break;</span>

	case Attribute.NUMERIC:
<span class="nc" id="L1525">	  result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="nc" id="L1526">	  break;</span>
		
	case Attribute.DATE:
<span class="nc" id="L1529">	  result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="nc" id="L1530">	  break;</span>

	case Attribute.STRING:
<span class="nc" id="L1533">	  result.enable(Capability.STRING_ATTRIBUTES);</span>
<span class="nc" id="L1534">	  break;</span>
	  
	case Attribute.RELATIONAL:
<span class="nc" id="L1537">	  result.enable(Capability.RELATIONAL_ATTRIBUTES);</span>
<span class="nc" id="L1538">	  break;</span>
	  
	default:
<span class="nc" id="L1541">	  throw new UnsupportedAttributeTypeException(</span>
<span class="nc" id="L1542">	      &quot;Unknown attribute type '&quot; + data.attribute(i).type() + &quot;'!&quot;);</span>
      }
    }
    
    // missing values
<span class="nc" id="L1547">    missing = false;</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">    for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L1549">      inst = data.instance(i);</span>

<span class="nc bnc" id="L1551" title="All 2 branches missed.">      if (inst instanceof SparseInstance) {</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">	for (m = 0; m &lt; inst.numValues(); m++) {</span>
<span class="nc" id="L1553">	  n = inst.index(m);</span>

	  // skip class
<span class="nc bnc" id="L1556" title="All 2 branches missed.">	  if (n == inst.classIndex())</span>
<span class="nc" id="L1557">	    continue;</span>

<span class="nc bnc" id="L1559" title="All 2 branches missed.">	  if (inst.isMissing(n)) {</span>
<span class="nc" id="L1560">	    missing = true;</span>
<span class="nc" id="L1561">	    break;</span>
	  }
	}
      }
      else {
<span class="nc bnc" id="L1566" title="All 2 branches missed.">	for (n = 0; n &lt; data.numAttributes(); n++) {</span>
	  // skip class
<span class="nc bnc" id="L1568" title="All 2 branches missed.">	  if (n == inst.classIndex())</span>
<span class="nc" id="L1569">	    continue;</span>

<span class="nc bnc" id="L1571" title="All 2 branches missed.">	  if (inst.isMissing(n)) {</span>
<span class="nc" id="L1572">	    missing = true;</span>
<span class="nc" id="L1573">	    break;</span>
	  }
	}
      }

<span class="nc bnc" id="L1578" title="All 2 branches missed.">      if (missing) {</span>
<span class="nc" id="L1579">	result.enable(Capability.MISSING_VALUES);</span>
<span class="nc" id="L1580">	break;</span>
      }
    }

    // multi-instance data?
<span class="nc bnc" id="L1585" title="All 2 branches missed.">    if (multi) {</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">      if (    (data.numAttributes() == 3)</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">	   &amp;&amp; (data.attribute(0).isNominal())		// bag-id</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">	   &amp;&amp; (data.attribute(1).isRelationValued()) 	// bag</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">	   &amp;&amp; (data.classIndex() == data.numAttributes() - 1) ) {</span>
<span class="nc" id="L1590">	multiInstance = new Capabilities(null);</span>
<span class="nc" id="L1591">	multiInstance.or(result.getClassCapabilities());</span>
<span class="nc" id="L1592">	multiInstance.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="nc" id="L1593">	multiInstance.enable(Capability.RELATIONAL_ATTRIBUTES);</span>
<span class="nc" id="L1594">	multiInstance.enable(Capability.ONLY_MULTIINSTANCE);</span>
<span class="nc" id="L1595">	result.assign(multiInstance);</span>
      }
    }
    
<span class="nc" id="L1599">    return result;</span>
  }
  
  /**
   * loads the given dataset and prints the Capabilities necessary to 
   * process it. &lt;p/&gt;
   * 
   * Valid parameters: &lt;p/&gt;
   * 
   * -file filename &lt;br/&gt;
   *  the file to load
   *  
   * -c index
   *  the explicit index of the class attribute (default: none)
   * 
   * @param args	the commandline arguments
   * @throws Exception	if something goes wrong
   */
  public static void main(String[] args) throws Exception {
    String 		tmpStr;
    String		filename;
    DataSource 		source;
    Instances 		data;
    int 		classIndex;
    Capabilities 	cap;
    Iterator		iter;

<span class="nc bnc" id="L1626" title="All 2 branches missed.">    if (args.length == 0) {</span>
<span class="nc" id="L1627">      System.out.println(</span>
<span class="nc" id="L1628">	  &quot;\nUsage: &quot; + Capabilities.class.getName() </span>
<span class="nc" id="L1629">	  + &quot; -file &lt;dataset&gt; [-c &lt;class index&gt;]\n&quot;);</span>
<span class="nc" id="L1630">      return;</span>
    }
    
    // get parameters
<span class="nc" id="L1634">    tmpStr = Utils.getOption(&quot;file&quot;, args);</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">    if (tmpStr.length() == 0)</span>
<span class="nc" id="L1636">      throw new Exception(&quot;No file provided with option '-file'!&quot;);</span>
    else
<span class="nc" id="L1638">      filename = tmpStr;</span>

<span class="nc" id="L1640">    tmpStr = Utils.getOption(&quot;c&quot;, args);</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">    if (tmpStr.length() != 0) {</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">      if (tmpStr.equals(&quot;first&quot;))</span>
<span class="nc" id="L1643">	classIndex = 0;</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">      else if (tmpStr.equals(&quot;last&quot;))</span>
<span class="nc" id="L1645">	classIndex = -2;  // last</span>
      else
<span class="nc" id="L1647">	classIndex = Integer.parseInt(tmpStr) - 1;</span>
    }
    else {
<span class="nc" id="L1650">      classIndex = -3;  // not set</span>
    }
    
    // load data
<span class="nc" id="L1654">    source = new DataSource(filename);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">    if (classIndex == -3)</span>
<span class="nc" id="L1656">      data = source.getDataSet();</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">    else if (classIndex == -2)</span>
<span class="nc" id="L1658">      data = source.getDataSet(source.getStructure().numAttributes() - 1);</span>
    else
<span class="nc" id="L1660">      data = source.getDataSet(classIndex);</span>

    // determine and print capabilities
<span class="nc" id="L1663">    cap = forInstances(data);</span>
<span class="nc" id="L1664">    System.out.println(&quot;File: &quot; + filename);</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">    System.out.println(&quot;Class index: &quot; + ((data.classIndex() == -1) ? &quot;not set&quot; : &quot;&quot; + (data.classIndex() + 1)));</span>
<span class="nc" id="L1666">    System.out.println(&quot;Capabilities:&quot;);</span>
<span class="nc" id="L1667">    iter = cap.capabilities();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">    while (iter.hasNext())</span>
<span class="nc" id="L1669">      System.out.println(&quot;- &quot; + iter.next());</span>
<span class="nc" id="L1670">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1678">    return RevisionUtils.extract(&quot;$Revision: 9140 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>