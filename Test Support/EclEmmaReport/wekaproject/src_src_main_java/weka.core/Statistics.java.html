<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Statistics.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core</a> &gt; <span class="el_source">Statistics.java</span></div><h1>Statistics.java</h1><pre class="source lang-java linenums">package weka.core;

/**
 * Class implementing some distributions, tests, etc. The code is mostly adapted from the CERN
 * Jet Java libraries:
 * 
 * Copyright 2001 University of Waikato
 * Copyright 1999 CERN - European Organization for Nuclear Research.
 * Permission to use, copy, modify, distribute and sell this software and its documentation for
 * any purpose is hereby granted without fee, provided that the above copyright notice appear
 * in all copies and that both that copyright notice and this permission notice appear in
 * supporting documentation. 
 * CERN and the University of Waikato make no representations about the suitability of this 
 * software for any purpose. It is provided &quot;as is&quot; without expressed or implied warranty.
 *
 * @author peter.gedeck@pharma.Novartis.com
 * @author wolfgang.hoschek@cern.ch
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @author Richard Kirkby (rkirkby@cs.waikato.ac.nz)
 * @version $Revision: 5619 $
 */
<span class="pc" id="L22">public class Statistics</span>
  implements RevisionHandler {

  /** Some constants */
  protected static final double MACHEP =  1.11022302462515654042E-16;
  protected static final double MAXLOG =  7.09782712893383996732E2;
  protected static final double MINLOG = -7.451332191019412076235E2;
  protected static final double MAXGAM = 171.624376956302725;
  protected static final double SQTPI  =  2.50662827463100050242E0;
  protected static final double SQRTH  =  7.07106781186547524401E-1;
  protected static final double LOGPI  =  1.14472988584940017414;
  
  protected static final double big    =  4.503599627370496e15;
  protected static final double biginv =  2.22044604925031308085e-16;

  /*************************************************
   *    COEFFICIENTS FOR METHOD  normalInverse()   *
   *************************************************/
  /* approximation for 0 &lt;= |y - 0.5| &lt;= 3/8 */
<span class="fc" id="L41">  protected static final double P0[] = {</span>
<span class="fc" id="L42">    -5.99633501014107895267E1,</span>
<span class="fc" id="L43">    9.80010754185999661536E1,</span>
<span class="fc" id="L44">    -5.66762857469070293439E1,</span>
<span class="fc" id="L45">    1.39312609387279679503E1,</span>
<span class="fc" id="L46">    -1.23916583867381258016E0,</span>
  };
<span class="fc" id="L48">  protected static final double Q0[] = {</span>
    /* 1.00000000000000000000E0,*/
<span class="fc" id="L50">    1.95448858338141759834E0,</span>
<span class="fc" id="L51">    4.67627912898881538453E0,</span>
<span class="fc" id="L52">    8.63602421390890590575E1,</span>
<span class="fc" id="L53">    -2.25462687854119370527E2,</span>
<span class="fc" id="L54">    2.00260212380060660359E2,</span>
<span class="fc" id="L55">    -8.20372256168333339912E1,</span>
<span class="fc" id="L56">    1.59056225126211695515E1,</span>
<span class="fc" id="L57">    -1.18331621121330003142E0,</span>
  };
  
  /* Approximation for interval z = sqrt(-2 log y ) between 2 and 8
   * i.e., y between exp(-2) = .135 and exp(-32) = 1.27e-14.
   */
<span class="fc" id="L63">  protected static final double P1[] = {</span>
<span class="fc" id="L64">    4.05544892305962419923E0,</span>
<span class="fc" id="L65">    3.15251094599893866154E1,</span>
<span class="fc" id="L66">    5.71628192246421288162E1,</span>
<span class="fc" id="L67">    4.40805073893200834700E1,</span>
<span class="fc" id="L68">    1.46849561928858024014E1,</span>
<span class="fc" id="L69">    2.18663306850790267539E0,</span>
<span class="fc" id="L70">    -1.40256079171354495875E-1,</span>
<span class="fc" id="L71">    -3.50424626827848203418E-2,</span>
<span class="fc" id="L72">    -8.57456785154685413611E-4,</span>
  };
<span class="fc" id="L74">  protected static final double Q1[] = {</span>
    /*  1.00000000000000000000E0,*/
<span class="fc" id="L76">    1.57799883256466749731E1,</span>
<span class="fc" id="L77">    4.53907635128879210584E1,</span>
<span class="fc" id="L78">    4.13172038254672030440E1,</span>
<span class="fc" id="L79">    1.50425385692907503408E1,</span>
<span class="fc" id="L80">    2.50464946208309415979E0,</span>
<span class="fc" id="L81">    -1.42182922854787788574E-1,</span>
<span class="fc" id="L82">    -3.80806407691578277194E-2,</span>
<span class="fc" id="L83">    -9.33259480895457427372E-4,</span>
  };
  
  /* Approximation for interval z = sqrt(-2 log y ) between 8 and 64
   * i.e., y between exp(-32) = 1.27e-14 and exp(-2048) = 3.67e-890.
   */
<span class="fc" id="L89">  protected static final double  P2[] = {</span>
<span class="fc" id="L90">    3.23774891776946035970E0,</span>
<span class="fc" id="L91">    6.91522889068984211695E0,</span>
<span class="fc" id="L92">    3.93881025292474443415E0,</span>
<span class="fc" id="L93">    1.33303460815807542389E0,</span>
<span class="fc" id="L94">    2.01485389549179081538E-1,</span>
<span class="fc" id="L95">    1.23716634817820021358E-2,</span>
<span class="fc" id="L96">    3.01581553508235416007E-4,</span>
<span class="fc" id="L97">    2.65806974686737550832E-6,</span>
<span class="fc" id="L98">    6.23974539184983293730E-9,</span>
  };
<span class="fc" id="L100">  protected static final double  Q2[] = {</span>
    /*  1.00000000000000000000E0,*/
<span class="fc" id="L102">    6.02427039364742014255E0,</span>
<span class="fc" id="L103">    3.67983563856160859403E0,</span>
<span class="fc" id="L104">    1.37702099489081330271E0,</span>
<span class="fc" id="L105">    2.16236993594496635890E-1,</span>
<span class="fc" id="L106">    1.34204006088543189037E-2,</span>
<span class="fc" id="L107">    3.28014464682127739104E-4,</span>
<span class="fc" id="L108">    2.89247864745380683936E-6,</span>
<span class="fc" id="L109">    6.79019408009981274425E-9,</span>
  };
  
  /**
   * Computes standard error for observed values of a binomial
   * random variable.
   *
   * @param p the probability of success
   * @param n the size of the sample
   * @return the standard error
   */
  public static double binomialStandardError(double p, int n) {
    
<span class="nc bnc" id="L122" title="All 2 branches missed.">    if (n == 0) {</span>
<span class="nc" id="L123">      return 0; </span>
    }
<span class="nc" id="L125">    return Math.sqrt((p*(1-p))/(double) n);</span>
  }
  
  /**
   * Returns chi-squared probability for given value and degrees
   * of freedom. (The probability that the chi-squared variate
   * will be greater than x for the given degrees of freedom.)
   *
   * @param x the value
   * @param v the number of degrees of freedom
   * @return the chi-squared probability
   */
  public static double chiSquaredProbability(double x, double v) { 

<span class="nc bnc" id="L139" title="All 4 branches missed.">    if( x &lt; 0.0 || v &lt; 1.0 ) return 0.0;</span>
<span class="nc" id="L140">    return incompleteGammaComplement( v/2.0, x/2.0 );</span>
  }

  /**
   * Computes probability of F-ratio.
   *
   * @param F the F-ratio
   * @param df1 the first number of degrees of freedom
   * @param df2 the second number of degrees of freedom
   * @return the probability of the F-ratio.
   */
  public static double FProbability(double F, int df1, int df2) {
    
<span class="nc" id="L153">    return incompleteBeta( df2/2.0, df1/2.0, df2/(df2+df1*F) );</span>
  }

  /**
   * Returns the area under the Normal (Gaussian) probability density
   * function, integrated from minus infinity to &lt;tt&gt;x&lt;/tt&gt;
   * (assumes mean is zero, variance is one).
   * &lt;pre&gt;
   *                            x
   *                             -
   *                   1        | |          2
   *  normal(x)  = ---------    |    exp( - t /2 ) dt
   *               sqrt(2pi)  | |
   *                           -
   *                          -inf.
   *
   *             =  ( 1 + erf(z) ) / 2
   *             =  erfc(z) / 2
   * &lt;/pre&gt;
   * where &lt;tt&gt;z = x/sqrt(2)&lt;/tt&gt;.
   * Computation is via the functions &lt;tt&gt;errorFunction&lt;/tt&gt; and &lt;tt&gt;errorFunctionComplement&lt;/tt&gt;.
   *
   * @param a the z-value
   * @return the probability of the z value according to the normal pdf
   */
  public static double normalProbability(double a) { 

    double x, y, z;
 
<span class="fc" id="L182">    x = a * SQRTH;</span>
<span class="fc" id="L183">    z = Math.abs(x);</span>
 
<span class="fc bfc" id="L185" title="All 2 branches covered.">    if( z &lt; SQRTH ) y = 0.5 + 0.5 * errorFunction(x);</span>
    else {
<span class="fc" id="L187">      y = 0.5 * errorFunctionComplemented(z);</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">      if( x &gt; 0 )  y = 1.0 - y;</span>
    } 
<span class="fc" id="L190">    return y;</span>
  }

  /**
   * Returns the value, &lt;tt&gt;x&lt;/tt&gt;, for which the area under the
   * Normal (Gaussian) probability density function (integrated from
   * minus infinity to &lt;tt&gt;x&lt;/tt&gt;) is equal to the argument &lt;tt&gt;y&lt;/tt&gt;
   * (assumes mean is zero, variance is one).
   * &lt;p&gt;
   * For small arguments &lt;tt&gt;0 &lt; y &lt; exp(-2)&lt;/tt&gt;, the program computes
   * &lt;tt&gt;z = sqrt( -2.0 * log(y) )&lt;/tt&gt;;  then the approximation is
   * &lt;tt&gt;x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z)&lt;/tt&gt;.
   * There are two rational functions P/Q, one for &lt;tt&gt;0 &lt; y &lt; exp(-32)&lt;/tt&gt;
   * and the other for &lt;tt&gt;y&lt;/tt&gt; up to &lt;tt&gt;exp(-2)&lt;/tt&gt;. 
   * For larger arguments,
   * &lt;tt&gt;w = y - 0.5&lt;/tt&gt;, and  &lt;tt&gt;x/sqrt(2pi) = w + w**3 R(w**2)/S(w**2))&lt;/tt&gt;.
   *
   * @param y0 the area under the normal pdf
   * @return the z-value
   */
  public static double normalInverse(double y0) { 

    double x, y, z, y2, x0, x1;
    int code;

<span class="fc" id="L215">    final double s2pi = Math.sqrt(2.0*Math.PI);</span>

<span class="pc bpc" id="L217" title="1 of 2 branches missed.">    if( y0 &lt;= 0.0 ) throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">    if( y0 &gt;= 1.0 ) throw new IllegalArgumentException();</span>
<span class="fc" id="L219">    code = 1;</span>
<span class="fc" id="L220">    y = y0;</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">    if( y &gt; (1.0 - 0.13533528323661269189) ) { /* 0.135... = exp(-2) */</span>
<span class="fc" id="L222">      y = 1.0 - y;</span>
<span class="fc" id="L223">      code = 0;</span>
    }

<span class="fc bfc" id="L226" title="All 2 branches covered.">    if( y &gt; 0.13533528323661269189 ) {</span>
<span class="fc" id="L227">      y = y - 0.5;</span>
<span class="fc" id="L228">      y2 = y * y;</span>
<span class="fc" id="L229">      x = y + y * (y2 * polevl( y2, P0, 4)/p1evl( y2, Q0, 8 ));</span>
<span class="fc" id="L230">      x = x * s2pi; </span>
<span class="fc" id="L231">      return(x);</span>
    }

<span class="fc" id="L234">    x = Math.sqrt( -2.0 * Math.log(y) );</span>
<span class="fc" id="L235">    x0 = x - Math.log(x)/x;</span>

<span class="fc" id="L237">    z = 1.0/x;</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if( x &lt; 8.0 ) /* y &gt; exp(-32) = 1.2664165549e-14 */</span>
<span class="fc" id="L239">      x1 = z * polevl( z, P1, 8 )/p1evl( z, Q1, 8 );</span>
    else
<span class="nc" id="L241">      x1 = z * polevl( z, P2, 8 )/p1evl( z, Q2, 8 );</span>
<span class="fc" id="L242">    x = x0 - x1;</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">    if( code != 0 )</span>
<span class="nc" id="L244">      x = -x;</span>
<span class="fc" id="L245">    return( x );</span>
  }

  /**
   * Returns natural logarithm of gamma function.
   *
   * @param x the value
   * @return natural logarithm of gamma function
   */
  public static double lnGamma(double x) {

    double p, q, w, z;
 
<span class="fc" id="L258">    double A[] = {</span>
<span class="fc" id="L259">      8.11614167470508450300E-4,</span>
<span class="fc" id="L260">      -5.95061904284301438324E-4,</span>
<span class="fc" id="L261">      7.93650340457716943945E-4,</span>
<span class="fc" id="L262">      -2.77777777730099687205E-3,</span>
<span class="fc" id="L263">      8.33333333333331927722E-2</span>
    };
<span class="fc" id="L265">    double B[] = {</span>
<span class="fc" id="L266">      -1.37825152569120859100E3,</span>
<span class="fc" id="L267">      -3.88016315134637840924E4,</span>
<span class="fc" id="L268">      -3.31612992738871184744E5,</span>
<span class="fc" id="L269">      -1.16237097492762307383E6,</span>
<span class="fc" id="L270">      -1.72173700820839662146E6,</span>
<span class="fc" id="L271">      -8.53555664245765465627E5</span>
    };
<span class="fc" id="L273">    double C[] = {</span>
      /* 1.00000000000000000000E0, */
<span class="fc" id="L275">      -3.51815701436523470549E2,</span>
<span class="fc" id="L276">      -1.70642106651881159223E4,</span>
<span class="fc" id="L277">      -2.20528590553854454839E5,</span>
<span class="fc" id="L278">      -1.13933444367982507207E6,</span>
<span class="fc" id="L279">      -2.53252307177582951285E6,</span>
<span class="fc" id="L280">      -2.01889141433532773231E6</span>
    };
 
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">    if( x &lt; -34.0 ) {</span>
<span class="nc" id="L284">      q = -x;</span>
<span class="nc" id="L285">      w = lnGamma(q);</span>
<span class="nc" id="L286">      p = Math.floor(q);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">      if( p == q ) throw new ArithmeticException(&quot;lnGamma: Overflow&quot;);</span>
<span class="nc" id="L288">      z = q - p;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">      if( z &gt; 0.5 ) {</span>
<span class="nc" id="L290">	p += 1.0;</span>
<span class="nc" id="L291">	z = p - q;</span>
      }
<span class="nc" id="L293">      z = q * Math.sin( Math.PI * z );</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">      if( z == 0.0 ) throw new </span>
<span class="nc" id="L295">	ArithmeticException(&quot;lnGamma: Overflow&quot;);</span>
<span class="nc" id="L296">      z = LOGPI - Math.log( z ) - w;</span>
<span class="nc" id="L297">      return z;</span>
    }
 
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if( x &lt; 13.0 ) {</span>
<span class="fc" id="L301">      z = 1.0;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">      while( x &gt;= 3.0 ) {</span>
<span class="fc" id="L303">	x -= 1.0;</span>
<span class="fc" id="L304">	z *= x;</span>
      }
<span class="fc bfc" id="L306" title="All 2 branches covered.">      while( x &lt; 2.0 ) {</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">	if( x == 0.0 ) throw new </span>
<span class="nc" id="L308">	  ArithmeticException(&quot;lnGamma: Overflow&quot;);</span>
<span class="fc" id="L309">	z /= x;</span>
<span class="fc" id="L310">	x += 1.0;</span>
      }
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">      if( z &lt; 0.0 ) z = -z;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">      if( x == 2.0 ) return Math.log(z);</span>
<span class="fc" id="L314">      x -= 2.0;</span>
<span class="fc" id="L315">      p = x * polevl( x, B, 5 ) / p1evl( x, C, 6);</span>
<span class="fc" id="L316">      return( Math.log(z) + p );</span>
    }
 
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    if( x &gt; 2.556348e305 ) throw new ArithmeticException(&quot;lnGamma: Overflow&quot;);</span>
 
<span class="fc" id="L321">    q = ( x - 0.5 ) * Math.log(x) - x + 0.91893853320467274178;</span>
  
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">    if( x &gt; 1.0e8 ) return( q );</span>
 
<span class="fc" id="L325">    p = 1.0/(x*x);</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">    if( x &gt;= 1000.0 )</span>
<span class="nc" id="L327">      q += ((   7.9365079365079365079365e-4 * p</span>
<span class="nc" id="L328">		- 2.7777777777777777777778e-3) *p</span>
<span class="nc" id="L329">	    + 0.0833333333333333333333) / x;</span>
    else
<span class="fc" id="L331">      q += polevl( p, A, 4 ) / x;</span>
<span class="fc" id="L332">    return q;</span>
  }

  /**
   * Returns the error function of the normal distribution.
   * The integral is
   * &lt;pre&gt;
   *                           x 
   *                            -
   *                 2         | |          2
   *   erf(x)  =  --------     |    exp( - t  ) dt.
   *              sqrt(pi)   | |
   *                          -
   *                           0
   * &lt;/pre&gt;
   * &lt;b&gt;Implementation:&lt;/b&gt;
   * For &lt;tt&gt;0 &lt;= |x| &lt; 1, erf(x) = x * P4(x**2)/Q5(x**2)&lt;/tt&gt;; otherwise
   * &lt;tt&gt;erf(x) = 1 - erfc(x)&lt;/tt&gt;.
   * &lt;p&gt;
   * Code adapted from the &lt;A HREF=&quot;http://www.sci.usq.edu.au/staff/leighb/graph/Top.html&quot;&gt;
   * Java 2D Graph Package 2.4&lt;/A&gt;,
   * which in turn is a port from the
   * &lt;A HREF=&quot;http://people.ne.mediaone.net/moshier/index.html#Cephes&quot;&gt;Cephes 2.2&lt;/A&gt;
   * Math Library (C).
   *
   * @param a the argument to the function.
   */
  public static double errorFunction(double x) { 
    double y, z;
<span class="fc" id="L361">    final double T[] = {</span>
<span class="fc" id="L362">      9.60497373987051638749E0,</span>
<span class="fc" id="L363">      9.00260197203842689217E1,</span>
<span class="fc" id="L364">      2.23200534594684319226E3,</span>
<span class="fc" id="L365">      7.00332514112805075473E3,</span>
<span class="fc" id="L366">      5.55923013010394962768E4</span>
    };
<span class="fc" id="L368">    final double U[] = {</span>
      //1.00000000000000000000E0,
<span class="fc" id="L370">      3.35617141647503099647E1,</span>
<span class="fc" id="L371">      5.21357949780152679795E2,</span>
<span class="fc" id="L372">      4.59432382970980127987E3,</span>
<span class="fc" id="L373">      2.26290000613890934246E4,</span>
<span class="fc" id="L374">      4.92673942608635921086E4</span>
    };
  
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if( Math.abs(x) &gt; 1.0 ) return( 1.0 - errorFunctionComplemented(x) );</span>
<span class="fc" id="L378">    z = x * x;</span>
<span class="fc" id="L379">    y = x * polevl( z, T, 4 ) / p1evl( z, U, 5 );</span>
<span class="fc" id="L380">    return y;</span>
  }

  /**
   * Returns the complementary Error function of the normal distribution.
   * &lt;pre&gt;
   *  1 - erf(x) =
   *
   *                           inf. 
   *                             -
   *                  2         | |          2
   *   erfc(x)  =  --------     |    exp( - t  ) dt
   *               sqrt(pi)   | |
   *                           -
   *                            x
   * &lt;/pre&gt;
   * &lt;b&gt;Implementation:&lt;/b&gt;
   * For small x, &lt;tt&gt;erfc(x) = 1 - erf(x)&lt;/tt&gt;; otherwise rational
   * approximations are computed.
   * &lt;p&gt;
   * Code adapted from the &lt;A HREF=&quot;http://www.sci.usq.edu.au/staff/leighb/graph/Top.html&quot;&gt;
   * Java 2D Graph Package 2.4&lt;/A&gt;,
   * which in turn is a port from the
   * &lt;A HREF=&quot;http://people.ne.mediaone.net/moshier/index.html#Cephes&quot;&gt;Cephes 2.2&lt;/A&gt;
   * Math Library (C).
   *
   * @param a the argument to the function.
   */
  public static double errorFunctionComplemented(double a) { 
    double x,y,z,p,q;
  
<span class="fc" id="L411">    double P[] = {</span>
<span class="fc" id="L412">      2.46196981473530512524E-10,</span>
<span class="fc" id="L413">      5.64189564831068821977E-1,</span>
<span class="fc" id="L414">      7.46321056442269912687E0,</span>
<span class="fc" id="L415">      4.86371970985681366614E1,</span>
<span class="fc" id="L416">      1.96520832956077098242E2,</span>
<span class="fc" id="L417">      5.26445194995477358631E2,</span>
<span class="fc" id="L418">      9.34528527171957607540E2,</span>
<span class="fc" id="L419">      1.02755188689515710272E3,</span>
<span class="fc" id="L420">      5.57535335369399327526E2</span>
    };
<span class="fc" id="L422">    double Q[] = {</span>
      //1.0
<span class="fc" id="L424">      1.32281951154744992508E1,</span>
<span class="fc" id="L425">      8.67072140885989742329E1,</span>
<span class="fc" id="L426">      3.54937778887819891062E2,</span>
<span class="fc" id="L427">      9.75708501743205489753E2,</span>
<span class="fc" id="L428">      1.82390916687909736289E3,</span>
<span class="fc" id="L429">      2.24633760818710981792E3,</span>
<span class="fc" id="L430">      1.65666309194161350182E3,</span>
<span class="fc" id="L431">      5.57535340817727675546E2</span>
    };
  
<span class="fc" id="L434">    double R[] = {</span>
<span class="fc" id="L435">      5.64189583547755073984E-1,</span>
<span class="fc" id="L436">      1.27536670759978104416E0,</span>
<span class="fc" id="L437">      5.01905042251180477414E0,</span>
<span class="fc" id="L438">      6.16021097993053585195E0,</span>
<span class="fc" id="L439">      7.40974269950448939160E0,</span>
<span class="fc" id="L440">      2.97886665372100240670E0</span>
    };
<span class="fc" id="L442">    double S[] = {</span>
      //1.00000000000000000000E0, 
<span class="fc" id="L444">      2.26052863220117276590E0,</span>
<span class="fc" id="L445">      9.39603524938001434673E0,</span>
<span class="fc" id="L446">      1.20489539808096656605E1,</span>
<span class="fc" id="L447">      1.70814450747565897222E1,</span>
<span class="fc" id="L448">      9.60896809063285878198E0,</span>
<span class="fc" id="L449">      3.36907645100081516050E0</span>
    };
  
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">    if( a &lt; 0.0 )   x = -a;</span>
<span class="fc" id="L453">    else            x = a;</span>
  
<span class="fc bfc" id="L455" title="All 2 branches covered.">    if( x &lt; 1.0 )   return 1.0 - errorFunction(a);</span>
  
<span class="fc" id="L457">    z = -a * a;</span>
  
<span class="fc bfc" id="L459" title="All 2 branches covered.">    if( z &lt; -MAXLOG ) {</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">      if( a &lt; 0 )  return( 2.0 );</span>
<span class="fc" id="L461">      else         return( 0.0 );</span>
    }
  
<span class="fc" id="L464">    z = Math.exp(z);</span>
  
<span class="fc bfc" id="L466" title="All 2 branches covered.">    if( x &lt; 8.0 ) {</span>
<span class="fc" id="L467">      p = polevl( x, P, 8 );</span>
<span class="fc" id="L468">      q = p1evl( x, Q, 8 );</span>
    } else {
<span class="fc" id="L470">      p = polevl( x, R, 5 );</span>
<span class="fc" id="L471">      q = p1evl( x, S, 6 );</span>
    }
  
<span class="fc" id="L474">    y = (z * p)/q;</span>
  
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    if( a &lt; 0 ) y = 2.0 - y;</span>
  
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">    if( y == 0.0 ) {</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">      if( a &lt; 0 ) return 2.0;</span>
<span class="nc" id="L480">      else        return( 0.0 );</span>
    }
<span class="fc" id="L482">    return y;</span>
  }
  
  /**
   * Evaluates the given polynomial of degree &lt;tt&gt;N&lt;/tt&gt; at &lt;tt&gt;x&lt;/tt&gt;.
   * Evaluates polynomial when coefficient of N is 1.0.
   * Otherwise same as &lt;tt&gt;polevl()&lt;/tt&gt;.
   * &lt;pre&gt;
   *                     2          N
   * y  =  C  + C x + C x  +...+ C x
   *        0    1     2          N
   *
   * Coefficients are stored in reverse order:
   *
   * coef[0] = C  , ..., coef[N] = C  .
   *            N                   0
   * &lt;/pre&gt;
   * The function &lt;tt&gt;p1evl()&lt;/tt&gt; assumes that &lt;tt&gt;coef[N] = 1.0&lt;/tt&gt; and is
   * omitted from the array.  Its calling arguments are
   * otherwise the same as &lt;tt&gt;polevl()&lt;/tt&gt;.
   * &lt;p&gt;
   * In the interest of speed, there are no checks for out of bounds arithmetic.
   *
   * @param x argument to the polynomial.
   * @param coef the coefficients of the polynomial.
   * @param N the degree of the polynomial.
   */
  public static double p1evl( double x, double coef[], int N ) {
  
    double ans;
<span class="fc" id="L512">    ans = x + coef[0];</span>
  
<span class="fc bfc" id="L514" title="All 2 branches covered.">    for(int i=1; i&lt;N; i++) ans = ans*x+coef[i];</span>
  
<span class="fc" id="L516">    return ans;</span>
  }

  /**
   * Evaluates the given polynomial of degree &lt;tt&gt;N&lt;/tt&gt; at &lt;tt&gt;x&lt;/tt&gt;.
   * &lt;pre&gt;
   *                     2          N
   * y  =  C  + C x + C x  +...+ C x
   *        0    1     2          N
   *
   * Coefficients are stored in reverse order:
   *
   * coef[0] = C  , ..., coef[N] = C  .
   *            N                   0
   * &lt;/pre&gt;
   * In the interest of speed, there are no checks for out of bounds arithmetic.
   *
   * @param x argument to the polynomial.
   * @param coef the coefficients of the polynomial.
   * @param N the degree of the polynomial.
   */
  static double polevl( double x, double coef[], int N ) {

    double ans;
<span class="fc" id="L540">    ans = coef[0];</span>
  
<span class="fc bfc" id="L542" title="All 2 branches covered.">    for(int i=1; i&lt;=N; i++) ans = ans*x+coef[i];</span>
  
<span class="fc" id="L544">    return ans;</span>
  }

  /**
   * Returns the Incomplete Gamma function.
   * @param a the parameter of the gamma distribution.
   * @param x the integration end point.
   */
  public static double incompleteGamma(double a, double x) 
    { 
 
    double ans, ax, c, r;
 
<span class="nc bnc" id="L557" title="All 4 branches missed.">    if( x &lt;= 0 || a &lt;= 0 ) return 0.0;</span>
 
<span class="nc bnc" id="L559" title="All 4 branches missed.">    if( x &gt; 1.0 &amp;&amp; x &gt; a ) return 1.0 - incompleteGammaComplement(a,x);</span>

    /* Compute  x**a * exp(-x) / gamma(a)  */
<span class="nc" id="L562">    ax = a * Math.log(x) - x - lnGamma(a);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">    if( ax &lt; -MAXLOG ) return( 0.0 );</span>

<span class="nc" id="L565">    ax = Math.exp(ax);</span>

    /* power series */
<span class="nc" id="L568">    r = a;</span>
<span class="nc" id="L569">    c = 1.0;</span>
<span class="nc" id="L570">    ans = 1.0;</span>

    do {
<span class="nc" id="L573">      r += 1.0;</span>
<span class="nc" id="L574">      c *= x/r;</span>
<span class="nc" id="L575">      ans += c;</span>
    }
<span class="nc bnc" id="L577" title="All 2 branches missed.">    while( c/ans &gt; MACHEP );</span>
 
<span class="nc" id="L579">    return( ans * ax/a );</span>
  }

  /**
   * Returns the Complemented Incomplete Gamma function.
   * @param a the parameter of the gamma distribution.
   * @param x the integration start point.
   */
  public static double incompleteGammaComplement( double a, double x ) {

    double ans, ax, c, yc, r, t, y, z;
    double pk, pkm1, pkm2, qk, qkm1, qkm2;

<span class="nc bnc" id="L592" title="All 4 branches missed.">    if( x &lt;= 0 || a &lt;= 0 ) return 1.0;</span>
 
<span class="nc bnc" id="L594" title="All 4 branches missed.">    if( x &lt; 1.0 || x &lt; a ) return 1.0 - incompleteGamma(a,x);</span>
 
<span class="nc" id="L596">    ax = a * Math.log(x) - x - lnGamma(a);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">    if( ax &lt; -MAXLOG ) return 0.0;</span>
 
<span class="nc" id="L599">    ax = Math.exp(ax);</span>
 
    /* continued fraction */
<span class="nc" id="L602">    y = 1.0 - a;</span>
<span class="nc" id="L603">    z = x + y + 1.0;</span>
<span class="nc" id="L604">    c = 0.0;</span>
<span class="nc" id="L605">    pkm2 = 1.0;</span>
<span class="nc" id="L606">    qkm2 = x;</span>
<span class="nc" id="L607">    pkm1 = x + 1.0;</span>
<span class="nc" id="L608">    qkm1 = z * x;</span>
<span class="nc" id="L609">    ans = pkm1/qkm1;</span>
 
    do {
<span class="nc" id="L612">      c += 1.0;</span>
<span class="nc" id="L613">      y += 1.0;</span>
<span class="nc" id="L614">      z += 2.0;</span>
<span class="nc" id="L615">      yc = y * c;</span>
<span class="nc" id="L616">      pk = pkm1 * z  -  pkm2 * yc;</span>
<span class="nc" id="L617">      qk = qkm1 * z  -  qkm2 * yc;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">      if( qk != 0 ) {</span>
<span class="nc" id="L619">	r = pk/qk;</span>
<span class="nc" id="L620">        t = Math.abs( (ans - r)/r );</span>
<span class="nc" id="L621">	ans = r;</span>
      } else
<span class="nc" id="L623">	t = 1.0;</span>

<span class="nc" id="L625">      pkm2 = pkm1;</span>
<span class="nc" id="L626">      pkm1 = pk;</span>
<span class="nc" id="L627">      qkm2 = qkm1;</span>
<span class="nc" id="L628">      qkm1 = qk;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">      if( Math.abs(pk) &gt; big ) {</span>
<span class="nc" id="L630">	pkm2 *= biginv;</span>
<span class="nc" id="L631">        pkm1 *= biginv;</span>
<span class="nc" id="L632">	qkm2 *= biginv;</span>
<span class="nc" id="L633">	qkm1 *= biginv;</span>
      }
<span class="nc bnc" id="L635" title="All 2 branches missed.">    } while( t &gt; MACHEP );</span>
 
<span class="nc" id="L637">    return ans * ax;</span>
  }

  /**
   * Returns the Gamma function of the argument.
   */
  public static double gamma(double x) {

<span class="fc" id="L645">    double P[] = {</span>
<span class="fc" id="L646">      1.60119522476751861407E-4,</span>
<span class="fc" id="L647">      1.19135147006586384913E-3,</span>
<span class="fc" id="L648">      1.04213797561761569935E-2,</span>
<span class="fc" id="L649">      4.76367800457137231464E-2,</span>
<span class="fc" id="L650">      2.07448227648435975150E-1,</span>
<span class="fc" id="L651">      4.94214826801497100753E-1,</span>
<span class="fc" id="L652">      9.99999999999999996796E-1</span>
    };
<span class="fc" id="L654">    double Q[] = {</span>
<span class="fc" id="L655">      -2.31581873324120129819E-5,</span>
<span class="fc" id="L656">      5.39605580493303397842E-4,</span>
<span class="fc" id="L657">      -4.45641913851797240494E-3,</span>
<span class="fc" id="L658">      1.18139785222060435552E-2,</span>
<span class="fc" id="L659">      3.58236398605498653373E-2,</span>
<span class="fc" id="L660">      -2.34591795718243348568E-1,</span>
<span class="fc" id="L661">      7.14304917030273074085E-2,</span>
<span class="fc" id="L662">      1.00000000000000000320E0</span>
    };

    double p, z;
    int i;

<span class="fc" id="L668">    double q = Math.abs(x);</span>

<span class="pc bpc" id="L670" title="1 of 2 branches missed.">    if( q &gt; 33.0 ) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      if( x &lt; 0.0 ) {</span>
<span class="nc" id="L672">	p = Math.floor(q);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">	if( p == q ) throw new ArithmeticException(&quot;gamma: overflow&quot;);</span>
<span class="nc" id="L674">	i = (int)p;</span>
<span class="nc" id="L675">	z = q - p;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">	if( z &gt; 0.5 ) {</span>
<span class="nc" id="L677">	  p += 1.0;</span>
<span class="nc" id="L678">	  z = q - p;</span>
	}
<span class="nc" id="L680">	z = q * Math.sin( Math.PI * z );</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">	if( z == 0.0 ) throw new ArithmeticException(&quot;gamma: overflow&quot;);</span>
<span class="nc" id="L682">	z = Math.abs(z);</span>
<span class="nc" id="L683">	z = Math.PI/(z * stirlingFormula(q) );</span>

<span class="nc" id="L685">	return -z;</span>
      } else {
<span class="nc" id="L687">	return stirlingFormula(x);</span>
      }
    }

<span class="fc" id="L691">    z = 1.0;</span>
<span class="fc bfc" id="L692" title="All 2 branches covered.">    while( x &gt;= 3.0 ) {</span>
<span class="fc" id="L693">      x -= 1.0;</span>
<span class="fc" id="L694">      z *= x;</span>
    }

<span class="pc bpc" id="L697" title="1 of 2 branches missed.">    while( x &lt; 0.0 ) {</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">      if( x == 0.0 ) {</span>
<span class="nc" id="L699">	throw new ArithmeticException(&quot;gamma: singular&quot;);</span>
      } else
<span class="nc bnc" id="L701" title="All 2 branches missed.">	if( x &gt; -1.E-9 ) {</span>
<span class="nc" id="L702">	  return( z/((1.0 + 0.5772156649015329 * x) * x) );</span>
	}
<span class="nc" id="L704">      z /= x;</span>
<span class="nc" id="L705">      x += 1.0;</span>
    }

<span class="fc bfc" id="L708" title="All 2 branches covered.">    while( x &lt; 2.0 ) {</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">      if( x == 0.0 ) {</span>
<span class="nc" id="L710">	throw new ArithmeticException(&quot;gamma: singular&quot;);</span>
      } else
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">	if( x &lt; 1.e-9 ) {</span>
<span class="nc" id="L713">	  return( z/((1.0 + 0.5772156649015329 * x) * x) );</span>
	}
<span class="fc" id="L715">      z /= x;</span>
<span class="fc" id="L716">      x += 1.0;</span>
    }

<span class="pc bpc" id="L719" title="3 of 4 branches missed.">    if( (x == 2.0) || (x == 3.0) ) 	return z;</span>

<span class="nc" id="L721">    x -= 2.0;</span>
<span class="nc" id="L722">    p = polevl( x, P, 6 );</span>
<span class="nc" id="L723">    q = polevl( x, Q, 7 );</span>
<span class="nc" id="L724">    return  z * p / q;</span>
  }

  /**
   * Returns the Gamma function computed by Stirling's formula.
   * The polynomial STIR is valid for 33 &lt;= x &lt;= 172.
   */
  static double stirlingFormula(double x) {

<span class="nc" id="L733">    double STIR[] = {</span>
<span class="nc" id="L734">      7.87311395793093628397E-4,</span>
<span class="nc" id="L735">      -2.29549961613378126380E-4,</span>
<span class="nc" id="L736">      -2.68132617805781232825E-3,</span>
<span class="nc" id="L737">      3.47222221605458667310E-3,</span>
<span class="nc" id="L738">      8.33333333333482257126E-2,</span>
    };
<span class="nc" id="L740">    double MAXSTIR = 143.01608;</span>

<span class="nc" id="L742">    double w = 1.0/x;</span>
<span class="nc" id="L743">    double  y = Math.exp(x);</span>

<span class="nc" id="L745">    w = 1.0 + w * polevl( w, STIR, 4 );</span>

<span class="nc bnc" id="L747" title="All 2 branches missed.">    if( x &gt; MAXSTIR ) {</span>
      /* Avoid overflow in Math.pow() */
<span class="nc" id="L749">      double v = Math.pow( x, 0.5 * x - 0.25 );</span>
<span class="nc" id="L750">      y = v * (v / y);</span>
    } else {
<span class="nc" id="L752">      y = Math.pow( x, x - 0.5 ) / y;</span>
    }
<span class="nc" id="L754">    y = SQTPI * y * w;</span>
<span class="nc" id="L755">    return y;</span>
  }

  /**
   * Returns the Incomplete Beta Function evaluated from zero to &lt;tt&gt;xx&lt;/tt&gt;.
   *
   * @param aa the alpha parameter of the beta distribution.
   * @param bb the beta parameter of the beta distribution.
   * @param xx the integration end point.
   */
  public static double incompleteBeta( double aa, double bb, double xx ) {

    double a, b, t, x, xc, w, y;
    boolean flag;

<span class="pc bpc" id="L770" title="2 of 4 branches missed.">    if( aa &lt;= 0.0 || bb &lt;= 0.0 ) throw new </span>
<span class="nc" id="L771">      ArithmeticException(&quot;ibeta: Domain error!&quot;);</span>

<span class="pc bpc" id="L773" title="2 of 4 branches missed.">    if( (xx &lt;= 0.0) || ( xx &gt;= 1.0) ) {</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">      if( xx == 0.0 ) return 0.0;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">      if( xx == 1.0 ) return 1.0;</span>
<span class="nc" id="L776">      throw new ArithmeticException(&quot;ibeta: Domain error!&quot;);</span>
    }

<span class="fc" id="L779">    flag = false;</span>
<span class="pc bpc" id="L780" title="2 of 4 branches missed.">    if( (bb * xx) &lt;= 1.0 &amp;&amp; xx &lt;= 0.95) {</span>
<span class="fc" id="L781">      t = powerSeries(aa, bb, xx);</span>
<span class="fc" id="L782">      return t;</span>
    }

<span class="nc" id="L785">    w = 1.0 - xx;</span>

    /* Reverse a and b if x is greater than the mean. */
<span class="nc bnc" id="L788" title="All 2 branches missed.">    if( xx &gt; (aa/(aa+bb)) ) {</span>
<span class="nc" id="L789">      flag = true;</span>
<span class="nc" id="L790">      a = bb;</span>
<span class="nc" id="L791">      b = aa;</span>
<span class="nc" id="L792">      xc = xx;</span>
<span class="nc" id="L793">      x = w;</span>
    } else {
<span class="nc" id="L795">      a = aa;</span>
<span class="nc" id="L796">      b = bb;</span>
<span class="nc" id="L797">      xc = w;</span>
<span class="nc" id="L798">      x = xx;</span>
    }

<span class="nc bnc" id="L801" title="All 6 branches missed.">    if( flag  &amp;&amp; (b * x) &lt;= 1.0 &amp;&amp; x &lt;= 0.95) {</span>
<span class="nc" id="L802">      t = powerSeries(a, b, x);</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">      if( t &lt;= MACHEP ) 	t = 1.0 - MACHEP;</span>
<span class="nc" id="L804">      else  		        t = 1.0 - t;</span>
<span class="nc" id="L805">      return t;</span>
    }

    /* Choose expansion for better convergence. */
<span class="nc" id="L809">    y = x * (a+b-2.0) - (a-1.0);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">    if( y &lt; 0.0 )</span>
<span class="nc" id="L811">      w = incompleteBetaFraction1( a, b, x );</span>
    else
<span class="nc" id="L813">      w = incompleteBetaFraction2( a, b, x ) / xc;</span>

    /* Multiply w by the factor
       a      b   _             _     _
       x  (1-x)   | (a+b) / ( a | (a) | (b) ) .   */

<span class="nc" id="L819">    y = a * Math.log(x);</span>
<span class="nc" id="L820">    t = b * Math.log(xc);</span>
<span class="nc bnc" id="L821" title="All 6 branches missed.">    if( (a+b) &lt; MAXGAM &amp;&amp; Math.abs(y) &lt; MAXLOG &amp;&amp; Math.abs(t) &lt; MAXLOG ) {</span>
<span class="nc" id="L822">      t = Math.pow(xc,b);</span>
<span class="nc" id="L823">      t *= Math.pow(x,a);</span>
<span class="nc" id="L824">      t /= a;</span>
<span class="nc" id="L825">      t *= w;</span>
<span class="nc" id="L826">      t *= gamma(a+b) / (gamma(a) * gamma(b));</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">      if( flag ) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">	if( t &lt;= MACHEP ) 	t = 1.0 - MACHEP;</span>
<span class="nc" id="L829">	else  		        t = 1.0 - t;</span>
      }
<span class="nc" id="L831">      return t;</span>
    }
    /* Resort to logarithms.  */
<span class="nc" id="L834">    y += t + lnGamma(a+b) - lnGamma(a) - lnGamma(b);</span>
<span class="nc" id="L835">    y += Math.log(w/a);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">    if( y &lt; MINLOG )</span>
<span class="nc" id="L837">      t = 0.0;</span>
    else
<span class="nc" id="L839">      t = Math.exp(y);</span>

<span class="nc bnc" id="L841" title="All 2 branches missed.">    if( flag ) {</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">      if( t &lt;= MACHEP ) 	t = 1.0 - MACHEP;</span>
<span class="nc" id="L843">      else  		        t = 1.0 - t;</span>
    }
<span class="nc" id="L845">    return t;</span>
  }   

  /**
   * Continued fraction expansion #1 for incomplete beta integral.
   */
  public static double incompleteBetaFraction1( double a, double b, double x ) {

    double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;
    double k1, k2, k3, k4, k5, k6, k7, k8;
    double r, t, ans, thresh;
    int n;

<span class="nc" id="L858">    k1 = a;</span>
<span class="nc" id="L859">    k2 = a + b;</span>
<span class="nc" id="L860">    k3 = a;</span>
<span class="nc" id="L861">    k4 = a + 1.0;</span>
<span class="nc" id="L862">    k5 = 1.0;</span>
<span class="nc" id="L863">    k6 = b - 1.0;</span>
<span class="nc" id="L864">    k7 = k4;</span>
<span class="nc" id="L865">    k8 = a + 2.0;</span>

<span class="nc" id="L867">    pkm2 = 0.0;</span>
<span class="nc" id="L868">    qkm2 = 1.0;</span>
<span class="nc" id="L869">    pkm1 = 1.0;</span>
<span class="nc" id="L870">    qkm1 = 1.0;</span>
<span class="nc" id="L871">    ans = 1.0;</span>
<span class="nc" id="L872">    r = 1.0;</span>
<span class="nc" id="L873">    n = 0;</span>
<span class="nc" id="L874">    thresh = 3.0 * MACHEP;</span>
    do {
<span class="nc" id="L876">      xk = -( x * k1 * k2 )/( k3 * k4 );</span>
<span class="nc" id="L877">      pk = pkm1 +  pkm2 * xk;</span>
<span class="nc" id="L878">      qk = qkm1 +  qkm2 * xk;</span>
<span class="nc" id="L879">      pkm2 = pkm1;</span>
<span class="nc" id="L880">      pkm1 = pk;</span>
<span class="nc" id="L881">      qkm2 = qkm1;</span>
<span class="nc" id="L882">      qkm1 = qk;</span>

<span class="nc" id="L884">      xk = ( x * k5 * k6 )/( k7 * k8 );</span>
<span class="nc" id="L885">      pk = pkm1 +  pkm2 * xk;</span>
<span class="nc" id="L886">      qk = qkm1 +  qkm2 * xk;</span>
<span class="nc" id="L887">      pkm2 = pkm1;</span>
<span class="nc" id="L888">      pkm1 = pk;</span>
<span class="nc" id="L889">      qkm2 = qkm1;</span>
<span class="nc" id="L890">      qkm1 = qk;</span>

<span class="nc bnc" id="L892" title="All 2 branches missed.">      if( qk != 0 )		r = pk/qk;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">      if( r != 0 ) {</span>
<span class="nc" id="L894">	t = Math.abs( (ans - r)/r );</span>
<span class="nc" id="L895">	ans = r;</span>
      }	else
<span class="nc" id="L897">	t = 1.0;</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">      if( t &lt; thresh ) return ans;</span>

<span class="nc" id="L901">      k1 += 1.0;</span>
<span class="nc" id="L902">      k2 += 1.0;</span>
<span class="nc" id="L903">      k3 += 2.0;</span>
<span class="nc" id="L904">      k4 += 2.0;</span>
<span class="nc" id="L905">      k5 += 1.0;</span>
<span class="nc" id="L906">      k6 -= 1.0;</span>
<span class="nc" id="L907">      k7 += 2.0;</span>
<span class="nc" id="L908">      k8 += 2.0;</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">      if( (Math.abs(qk) + Math.abs(pk)) &gt; big ) {</span>
<span class="nc" id="L911">	pkm2 *= biginv;</span>
<span class="nc" id="L912">	pkm1 *= biginv;</span>
<span class="nc" id="L913">	qkm2 *= biginv;</span>
<span class="nc" id="L914">	qkm1 *= biginv;</span>
      }
<span class="nc bnc" id="L916" title="All 4 branches missed.">      if( (Math.abs(qk) &lt; biginv) || (Math.abs(pk) &lt; biginv) ) {</span>
<span class="nc" id="L917">	pkm2 *= big;</span>
<span class="nc" id="L918">	pkm1 *= big;</span>
<span class="nc" id="L919">	qkm2 *= big;</span>
<span class="nc" id="L920">	qkm1 *= big;</span>
      }
<span class="nc bnc" id="L922" title="All 2 branches missed.">    } while( ++n &lt; 300 );</span>

<span class="nc" id="L924">    return ans;</span>
  }   

  /**
   * Continued fraction expansion #2 for incomplete beta integral.
   */
  public static double incompleteBetaFraction2( double a, double b, double x ) {

    double xk, pk, pkm1, pkm2, qk, qkm1, qkm2;
    double k1, k2, k3, k4, k5, k6, k7, k8;
    double r, t, ans, z, thresh;
    int n;

<span class="nc" id="L937">    k1 = a;</span>
<span class="nc" id="L938">    k2 = b - 1.0;</span>
<span class="nc" id="L939">    k3 = a;</span>
<span class="nc" id="L940">    k4 = a + 1.0;</span>
<span class="nc" id="L941">    k5 = 1.0;</span>
<span class="nc" id="L942">    k6 = a + b;</span>
<span class="nc" id="L943">    k7 = a + 1.0;;</span>
<span class="nc" id="L944">    k8 = a + 2.0;</span>

<span class="nc" id="L946">    pkm2 = 0.0;</span>
<span class="nc" id="L947">    qkm2 = 1.0;</span>
<span class="nc" id="L948">    pkm1 = 1.0;</span>
<span class="nc" id="L949">    qkm1 = 1.0;</span>
<span class="nc" id="L950">    z = x / (1.0-x);</span>
<span class="nc" id="L951">    ans = 1.0;</span>
<span class="nc" id="L952">    r = 1.0;</span>
<span class="nc" id="L953">    n = 0;</span>
<span class="nc" id="L954">    thresh = 3.0 * MACHEP;</span>
    do {
<span class="nc" id="L956">      xk = -( z * k1 * k2 )/( k3 * k4 );</span>
<span class="nc" id="L957">      pk = pkm1 +  pkm2 * xk;</span>
<span class="nc" id="L958">      qk = qkm1 +  qkm2 * xk;</span>
<span class="nc" id="L959">      pkm2 = pkm1;</span>
<span class="nc" id="L960">      pkm1 = pk;</span>
<span class="nc" id="L961">      qkm2 = qkm1;</span>
<span class="nc" id="L962">      qkm1 = qk;</span>

<span class="nc" id="L964">      xk = ( z * k5 * k6 )/( k7 * k8 );</span>
<span class="nc" id="L965">      pk = pkm1 +  pkm2 * xk;</span>
<span class="nc" id="L966">      qk = qkm1 +  qkm2 * xk;</span>
<span class="nc" id="L967">      pkm2 = pkm1;</span>
<span class="nc" id="L968">      pkm1 = pk;</span>
<span class="nc" id="L969">      qkm2 = qkm1;</span>
<span class="nc" id="L970">      qkm1 = qk;</span>

<span class="nc bnc" id="L972" title="All 2 branches missed.">      if( qk != 0 )  r = pk/qk;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">      if( r != 0 ) {</span>
<span class="nc" id="L974">	t = Math.abs( (ans - r)/r );</span>
<span class="nc" id="L975">	ans = r;</span>
      } else
<span class="nc" id="L977">	t = 1.0;</span>

<span class="nc bnc" id="L979" title="All 2 branches missed.">      if( t &lt; thresh ) return ans;</span>

<span class="nc" id="L981">      k1 += 1.0;</span>
<span class="nc" id="L982">      k2 -= 1.0;</span>
<span class="nc" id="L983">      k3 += 2.0;</span>
<span class="nc" id="L984">      k4 += 2.0;</span>
<span class="nc" id="L985">      k5 += 1.0;</span>
<span class="nc" id="L986">      k6 += 1.0;</span>
<span class="nc" id="L987">      k7 += 2.0;</span>
<span class="nc" id="L988">      k8 += 2.0;</span>

<span class="nc bnc" id="L990" title="All 2 branches missed.">      if( (Math.abs(qk) + Math.abs(pk)) &gt; big ) {</span>
<span class="nc" id="L991">	pkm2 *= biginv;</span>
<span class="nc" id="L992">	pkm1 *= biginv;</span>
<span class="nc" id="L993">	qkm2 *= biginv;</span>
<span class="nc" id="L994">	qkm1 *= biginv;</span>
      }
<span class="nc bnc" id="L996" title="All 4 branches missed.">      if( (Math.abs(qk) &lt; biginv) || (Math.abs(pk) &lt; biginv) ) {</span>
<span class="nc" id="L997">	pkm2 *= big;</span>
<span class="nc" id="L998">	pkm1 *= big;</span>
<span class="nc" id="L999">	qkm2 *= big;</span>
<span class="nc" id="L1000">	qkm1 *= big;</span>
      }
<span class="nc bnc" id="L1002" title="All 2 branches missed.">    } while( ++n &lt; 300 );</span>

<span class="nc" id="L1004">    return ans;</span>
  }

  /**
   * Power series for incomplete beta integral.
   * Use when b*x is small and x not too close to 1.  
   */
  static double powerSeries( double a, double b, double x ) {

    double s, t, u, v, n, t1, z, ai;
    
<span class="fc" id="L1015">    ai = 1.0 / a;</span>
<span class="fc" id="L1016">    u = (1.0 - b) * x;</span>
<span class="fc" id="L1017">    v = u / (a + 1.0);</span>
<span class="fc" id="L1018">    t1 = v;</span>
<span class="fc" id="L1019">    t = u;</span>
<span class="fc" id="L1020">    n = 2.0;</span>
<span class="fc" id="L1021">    s = 0.0;</span>
<span class="fc" id="L1022">    z = MACHEP * ai;</span>
<span class="pc bpc" id="L1023" title="1 of 2 branches missed.">    while( Math.abs(v) &gt; z ) {</span>
<span class="nc" id="L1024">      u = (n - b) * x / n;</span>
<span class="nc" id="L1025">      t *= u;</span>
<span class="nc" id="L1026">      v = t / (a + n);</span>
<span class="nc" id="L1027">      s += v; </span>
<span class="nc" id="L1028">      n += 1.0;</span>
    }
<span class="fc" id="L1030">    s += t1;</span>
<span class="fc" id="L1031">    s += ai;</span>

<span class="fc" id="L1033">    u = a * Math.log(x);</span>
<span class="pc bpc" id="L1034" title="2 of 4 branches missed.">    if( (a+b) &lt; MAXGAM &amp;&amp; Math.abs(u) &lt; MAXLOG ) {</span>
<span class="fc" id="L1035">      t = gamma(a+b)/(gamma(a)*gamma(b));</span>
<span class="fc" id="L1036">      s = s * t * Math.pow(x,a);</span>
    } else {
<span class="nc" id="L1038">      t = lnGamma(a+b) - lnGamma(a) - lnGamma(b) + u + Math.log(s);</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">      if( t &lt; MINLOG ) 	s = 0.0;</span>
<span class="nc" id="L1040">      else  	            s = Math.exp(t);</span>
    }
<span class="fc" id="L1042">    return s;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1051">    return RevisionUtils.extract(&quot;$Revision: 5619 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   */
  public static void main(String[] ops) {

<span class="nc" id="L1059">    System.out.println(&quot;Binomial standard error (0.5, 100): &quot; + </span>
<span class="nc" id="L1060">		       Statistics.binomialStandardError(0.5, 100));</span>
<span class="nc" id="L1061">    System.out.println(&quot;Chi-squared probability (2.558, 10): &quot; +</span>
<span class="nc" id="L1062">		       Statistics.chiSquaredProbability(2.558, 10));</span>
<span class="nc" id="L1063">    System.out.println(&quot;Normal probability (0.2): &quot; +</span>
<span class="nc" id="L1064">		       Statistics.normalProbability(0.2));</span>
<span class="nc" id="L1065">    System.out.println(&quot;F probability (5.1922, 4, 5): &quot; +</span>
<span class="nc" id="L1066">		       Statistics.FProbability(5.1922, 4, 5));</span>
<span class="nc" id="L1067">    System.out.println(&quot;lnGamma(6): &quot;+ Statistics.lnGamma(6));</span>
<span class="nc" id="L1068">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>