<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    Utils.java
 *    Copyright (C) 1999-2004 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.core;

import java.io.File;
import java.io.FileInputStream;
import java.lang.reflect.Array;
import java.util.Properties;
import java.util.Random;

/**
 * Class implementing some simple utility methods.
 * 
 * @author Eibe Frank
 * @author Yong Wang
 * @author Len Trigg
 * @author Julien Prados
 * @version $Revision: 9737 $
 */
<span class="fc" id="L40">public final class Utils implements RevisionHandler {</span>

  /** The natural logarithm of 2. */
<span class="fc" id="L43">  public static double log2 = Math.log(2);</span>

  /** The small deviation allowed in double comparisons. */
<span class="fc" id="L46">  public static double SMALL = 1e-6;</span>

  /**
   * Reads properties that inherit from three locations. Properties are first
   * defined in the system resource location (i.e. in the CLASSPATH). These
   * default properties must exist. Properties defined in the users home
   * directory (optional) override default settings. Properties defined in the
   * current directory (optional) override all these settings.
   * 
   * @param resourceName the location of the resource that should be loaded.
   *          e.g.: &quot;weka/core/Utils.props&quot;. (The use of hardcoded forward
   *          slashes here is OK - see jdk1.1/docs/guide/misc/resources.html)
   *          This routine will also look for the file (in this case)
   *          &quot;Utils.props&quot; in the users home directory and the current
   *          directory.
   * @return the Properties
   * @exception Exception if no default properties are defined, or if an error
   *              occurs reading the properties files.
   */
  public static Properties readProperties(String resourceName) throws Exception {

<span class="fc" id="L67">    Properties defaultProps = new Properties();</span>
    try {
      // Apparently hardcoded slashes are OK here
      // jdk1.1/docs/guide/misc/resources.html
      // defaultProps.load(ClassLoader.getSystemResourceAsStream(resourceName));
<span class="fc" id="L72">      defaultProps.load((new Utils()).getClass().getClassLoader()</span>
<span class="fc" id="L73">          .getResourceAsStream(resourceName));</span>
<span class="nc" id="L74">    } catch (Exception ex) {</span>
      /*
       * throw new Exception(&quot;Problem reading default properties: &quot; +
       * ex.getMessage());
       */
<span class="nc" id="L79">      System.err.println(&quot;Warning, unable to load properties file from &quot;</span>
          + &quot;system resource (Utils.java)&quot;);
    }

    // Hardcoded slash is OK here
    // eg: see jdk1.1/docs/guide/misc/resources.html
<span class="fc" id="L85">    int slInd = resourceName.lastIndexOf('/');</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">    if (slInd != -1) {</span>
<span class="fc" id="L87">      resourceName = resourceName.substring(slInd + 1);</span>
    }

    // Allow a properties file in the home directory to override
<span class="fc" id="L91">    Properties userProps = new Properties(defaultProps);</span>
<span class="fc" id="L92">    File propFile = new File(System.getProperties().getProperty(&quot;user.home&quot;)</span>
<span class="fc" id="L93">        + File.separatorChar + resourceName);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">    if (propFile.exists()) {</span>
      try {
<span class="nc" id="L96">        userProps.load(new FileInputStream(propFile));</span>
<span class="nc" id="L97">      } catch (Exception ex) {</span>
<span class="nc" id="L98">        throw new Exception(&quot;Problem reading user properties: &quot; + propFile);</span>
      }
    }

    // Allow a properties file in the current directory to override
<span class="fc" id="L103">    Properties localProps = new Properties(userProps);</span>
<span class="fc" id="L104">    propFile = new File(resourceName);</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    if (propFile.exists()) {</span>
      try {
<span class="nc" id="L107">        localProps.load(new FileInputStream(propFile));</span>
<span class="nc" id="L108">      } catch (Exception ex) {</span>
<span class="nc" id="L109">        throw new Exception(&quot;Problem reading local properties: &quot; + propFile);</span>
      }
    }

<span class="fc" id="L113">    return localProps;</span>
  }

  /**
   * Returns the correlation coefficient of two double vectors.
   * 
   * @param y1 double vector 1
   * @param y2 double vector 2
   * @param n the length of two double vectors
   * @return the correlation coefficient
   */
  public static final double correlation(double y1[], double y2[], int n) {

    int i;
<span class="fc" id="L127">    double av1 = 0.0, av2 = 0.0, y11 = 0.0, y22 = 0.0, y12 = 0.0, c;</span>

<span class="pc bpc" id="L129" title="1 of 2 branches missed.">    if (n &lt;= 1) {</span>
<span class="nc" id="L130">      return 1.0;</span>
    }
<span class="fc bfc" id="L132" title="All 2 branches covered.">    for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L133">      av1 += y1[i];</span>
<span class="fc" id="L134">      av2 += y2[i];</span>
    }
<span class="fc" id="L136">    av1 /= n;</span>
<span class="fc" id="L137">    av2 /= n;</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">    for (i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L139">      y11 += (y1[i] - av1) * (y1[i] - av1);</span>
<span class="fc" id="L140">      y22 += (y2[i] - av2) * (y2[i] - av2);</span>
<span class="fc" id="L141">      y12 += (y1[i] - av1) * (y2[i] - av2);</span>
    }
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">    if (y11 * y22 == 0.0) {</span>
<span class="nc" id="L144">      c = 1.0;</span>
    } else {
<span class="fc" id="L146">      c = y12 / Math.sqrt(Math.abs(y11 * y22));</span>
    }

<span class="fc" id="L149">    return c;</span>
  }

  /**
   * Removes all occurrences of a string from another string.
   * 
   * @param inString the string to remove substrings from.
   * @param substring the substring to remove.
   * @return the input string with occurrences of substring removed.
   */
  public static String removeSubstring(String inString, String substring) {

<span class="nc" id="L161">    StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L162">    int oldLoc = 0, loc = 0;</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">    while ((loc = inString.indexOf(substring, oldLoc)) != -1) {</span>
<span class="nc" id="L164">      result.append(inString.substring(oldLoc, loc));</span>
<span class="nc" id="L165">      oldLoc = loc + substring.length();</span>
    }
<span class="nc" id="L167">    result.append(inString.substring(oldLoc));</span>
<span class="nc" id="L168">    return result.toString();</span>
  }

  /**
   * Replaces with a new string, all occurrences of a string from another
   * string.
   * 
   * @param inString the string to replace substrings in.
   * @param subString the substring to replace.
   * @param replaceString the replacement substring
   * @return the input string with occurrences of substring replaced.
   */
  public static String replaceSubstring(String inString, String subString,
      String replaceString) {

<span class="nc" id="L183">    StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L184">    int oldLoc = 0, loc = 0;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">    while ((loc = inString.indexOf(subString, oldLoc)) != -1) {</span>
<span class="nc" id="L186">      result.append(inString.substring(oldLoc, loc));</span>
<span class="nc" id="L187">      result.append(replaceString);</span>
<span class="nc" id="L188">      oldLoc = loc + subString.length();</span>
    }
<span class="nc" id="L190">    result.append(inString.substring(oldLoc));</span>
<span class="nc" id="L191">    return result.toString();</span>
  }

  /**
   * Pads a string to a specified length, inserting spaces on the left as
   * required. If the string is too long, characters are removed (from the
   * right).
   * 
   * @param inString the input string
   * @param length the desired length of the output string
   * @return the output string
   */
  public static String padLeft(String inString, int length) {

<span class="nc" id="L205">    return fixStringLength(inString, length, false);</span>
  }

  /**
   * Pads a string to a specified length, inserting spaces on the right as
   * required. If the string is too long, characters are removed (from the
   * right).
   * 
   * @param inString the input string
   * @param length the desired length of the output string
   * @return the output string
   */
  public static String padRight(String inString, int length) {

<span class="nc" id="L219">    return fixStringLength(inString, length, true);</span>
  }

  /**
   * Pads a string to a specified length, inserting spaces as required. If the
   * string is too long, characters are removed (from the right).
   * 
   * @param inString the input string
   * @param length the desired length of the output string
   * @param right true if inserted spaces should be added to the right
   * @return the output string
   */
  private static/* @pure@ */String fixStringLength(String inString, int length,
      boolean right) {

<span class="nc bnc" id="L234" title="All 2 branches missed.">    if (inString.length() &lt; length) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">      while (inString.length() &lt; length) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        inString = (right ? inString.concat(&quot; &quot;) : &quot; &quot;.concat(inString));</span>
      }
<span class="nc bnc" id="L238" title="All 2 branches missed.">    } else if (inString.length() &gt; length) {</span>
<span class="nc" id="L239">      inString = inString.substring(0, length);</span>
    }
<span class="nc" id="L241">    return inString;</span>
  }

  /**
   * Rounds a double and converts it into String.
   * 
   * @param value the double value
   * @param afterDecimalPoint the (maximum) number of digits permitted after the
   *          decimal point
   * @return the double as a formatted string
   */
  public static/* @pure@ */String doubleToString(double value,
      int afterDecimalPoint) {

    StringBuffer stringBuffer;
    double temp;
    int dotPosition;
    long precisionValue;

<span class="fc" id="L260">    temp = value * Math.pow(10.0, afterDecimalPoint);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">    if (Math.abs(temp) &lt; Long.MAX_VALUE) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">      precisionValue = (temp &gt; 0) ? (long) (temp + 0.5) : -(long) (Math</span>
<span class="fc" id="L263">          .abs(temp) + 0.5);</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">      if (precisionValue == 0) {</span>
<span class="fc" id="L265">        stringBuffer = new StringBuffer(String.valueOf(0));</span>
      } else {
<span class="fc" id="L267">        stringBuffer = new StringBuffer(String.valueOf(precisionValue));</span>
      }
<span class="fc bfc" id="L269" title="All 2 branches covered.">      if (afterDecimalPoint == 0) {</span>
<span class="fc" id="L270">        return stringBuffer.toString();</span>
      }
<span class="fc" id="L272">      dotPosition = stringBuffer.length() - afterDecimalPoint;</span>
<span class="fc bfc" id="L273" title="All 6 branches covered.">      while (((precisionValue &lt; 0) &amp;&amp; (dotPosition &lt; 1)) || (dotPosition &lt; 0)) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (precisionValue &lt; 0) {</span>
<span class="fc" id="L275">          stringBuffer.insert(1, '0');</span>
        } else {
<span class="fc" id="L277">          stringBuffer.insert(0, '0');</span>
        }
<span class="fc" id="L279">        dotPosition++;</span>
      }
<span class="fc" id="L281">      stringBuffer.insert(dotPosition, '.');</span>
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">      if ((precisionValue &lt; 0) &amp;&amp; (stringBuffer.charAt(1) == '.')) {</span>
<span class="fc" id="L283">        stringBuffer.insert(1, '0');</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">      } else if (stringBuffer.charAt(0) == '.') {</span>
<span class="fc" id="L285">        stringBuffer.insert(0, '0');</span>
      }
<span class="fc" id="L287">      int currentPos = stringBuffer.length() - 1;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">      while ((currentPos &gt; dotPosition)</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">          &amp;&amp; (stringBuffer.charAt(currentPos) == '0')) {</span>
<span class="fc" id="L290">        stringBuffer.setCharAt(currentPos--, ' ');</span>
      }
<span class="fc bfc" id="L292" title="All 2 branches covered.">      if (stringBuffer.charAt(currentPos) == '.') {</span>
<span class="fc" id="L293">        stringBuffer.setCharAt(currentPos, ' ');</span>
      }

<span class="fc" id="L296">      return stringBuffer.toString().trim();</span>
    }
<span class="fc" id="L298">    return new String(&quot;&quot; + value);</span>
  }

  /**
   * Rounds a double and converts it into a formatted decimal-justified String.
   * Trailing 0's are replaced with spaces.
   * 
   * @param value the double value
   * @param width the width of the string
   * @param afterDecimalPoint the number of digits after the decimal point
   * @return the double as a formatted string
   */
  public static/* @pure@ */String doubleToString(double value, int width,
      int afterDecimalPoint) {

<span class="fc" id="L313">    String tempString = doubleToString(value, afterDecimalPoint);</span>
    char[] result;
    int dotPosition;

<span class="pc bpc" id="L317" title="1 of 4 branches missed.">    if ((afterDecimalPoint &gt;= width) || (tempString.indexOf('E') != -1)) { // Protects</span>
                                                                           // sci
                                                                           // notation
<span class="fc" id="L320">      return tempString;</span>
    }

    // Initialize result
<span class="fc" id="L324">    result = new char[width];</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (int i = 0; i &lt; result.length; i++) {</span>
<span class="fc" id="L326">      result[i] = ' ';</span>
    }

<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (afterDecimalPoint &gt; 0) {</span>
      // Get position of decimal point and insert decimal point
<span class="fc" id="L331">      dotPosition = tempString.indexOf('.');</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">      if (dotPosition == -1) {</span>
<span class="fc" id="L333">        dotPosition = tempString.length();</span>
      } else {
<span class="fc" id="L335">        result[width - afterDecimalPoint - 1] = '.';</span>
      }
    } else {
<span class="fc" id="L338">      dotPosition = tempString.length();</span>
    }

<span class="fc" id="L341">    int offset = width - afterDecimalPoint - dotPosition;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">    if (afterDecimalPoint &gt; 0) {</span>
<span class="fc" id="L343">      offset--;</span>
    }

    // Not enough room to decimal align within the supplied width
<span class="fc bfc" id="L347" title="All 2 branches covered.">    if (offset &lt; 0) {</span>
<span class="fc" id="L348">      return tempString;</span>
    }

    // Copy characters before decimal point
<span class="fc bfc" id="L352" title="All 2 branches covered.">    for (int i = 0; i &lt; dotPosition; i++) {</span>
<span class="fc" id="L353">      result[offset + i] = tempString.charAt(i);</span>
    }

    // Copy characters after decimal point
<span class="fc bfc" id="L357" title="All 2 branches covered.">    for (int i = dotPosition + 1; i &lt; tempString.length(); i++) {</span>
<span class="fc" id="L358">      result[offset + i] = tempString.charAt(i);</span>
    }

<span class="fc" id="L361">    return new String(result);</span>
  }

  /**
   * Returns the basic class of an array class (handles multi-dimensional
   * arrays).
   * 
   * @param c the array to inspect
   * @return the class of the innermost elements
   */
  public static Class getArrayClass(Class c) {
<span class="nc bnc" id="L372" title="All 2 branches missed.">    if (c.getComponentType().isArray())</span>
<span class="nc" id="L373">      return getArrayClass(c.getComponentType());</span>
    else
<span class="nc" id="L375">      return c.getComponentType();</span>
  }

  /**
   * Returns the dimensions of the given array. Even though the parameter is of
   * type &quot;Object&quot; one can hand over primitve arrays, e.g. int[3] or
   * double[2][4].
   * 
   * @param array the array to determine the dimensions for
   * @return the dimensions of the array
   */
  public static int getArrayDimensions(Class array) {
<span class="nc bnc" id="L387" title="All 2 branches missed.">    if (array.getComponentType().isArray())</span>
<span class="nc" id="L388">      return 1 + getArrayDimensions(array.getComponentType());</span>
    else
<span class="nc" id="L390">      return 1;</span>
  }

  /**
   * Returns the dimensions of the given array. Even though the parameter is of
   * type &quot;Object&quot; one can hand over primitve arrays, e.g. int[3] or
   * double[2][4].
   * 
   * @param array the array to determine the dimensions for
   * @return the dimensions of the array
   */
  public static int getArrayDimensions(Object array) {
<span class="nc" id="L402">    return getArrayDimensions(array.getClass());</span>
  }

  /**
   * Returns the given Array in a string representation. Even though the
   * parameter is of type &quot;Object&quot; one can hand over primitve arrays, e.g.
   * int[3] or double[2][4].
   * 
   * @param array the array to return in a string representation
   * @return the array as string
   */
  public static String arrayToString(Object array) {
    String result;
    int dimensions;
    int i;

<span class="nc" id="L418">    result = &quot;&quot;;</span>
<span class="nc" id="L419">    dimensions = getArrayDimensions(array);</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">    if (dimensions == 0) {</span>
<span class="nc" id="L422">      result = &quot;null&quot;;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">    } else if (dimensions == 1) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">      for (i = 0; i &lt; Array.getLength(array); i++) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (i &gt; 0)</span>
<span class="nc" id="L426">          result += &quot;,&quot;;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (Array.get(array, i) == null)</span>
<span class="nc" id="L428">          result += &quot;null&quot;;</span>
        else
<span class="nc" id="L430">          result += Array.get(array, i).toString();</span>
      }
    } else {
<span class="nc bnc" id="L433" title="All 2 branches missed.">      for (i = 0; i &lt; Array.getLength(array); i++) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (i &gt; 0)</span>
<span class="nc" id="L435">          result += &quot;,&quot;;</span>
<span class="nc" id="L436">        result += &quot;[&quot; + arrayToString(Array.get(array, i)) + &quot;]&quot;;</span>
      }
    }

<span class="nc" id="L440">    return result;</span>
  }

  /**
   * Tests if a is equal to b.
   * 
   * @param a a double
   * @param b a double
   */
  public static/* @pure@ */boolean eq(double a, double b) {

<span class="fc bfc" id="L451" title="All 6 branches covered.">    return (a == b) || (a - b &lt; SMALL) &amp;&amp; (b - a &lt; SMALL);</span>
  }

  /**
   * Checks if the given array contains any non-empty options.
   * 
   * @param options an array of strings
   * @exception Exception if there are any non-empty options
   */
  public static void checkForRemainingOptions(String[] options)
      throws Exception {

<span class="fc" id="L463">    int illegalOptionsFound = 0;</span>
<span class="fc" id="L464">    StringBuffer text = new StringBuffer();</span>

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">    if (options == null) {</span>
<span class="nc" id="L467">      return;</span>
    }
<span class="fc bfc" id="L469" title="All 2 branches covered.">    for (int i = 0; i &lt; options.length; i++) {</span>
<span class="pc bpc" id="L470" title="1 of 2 branches missed.">      if (options[i].length() &gt; 0) {</span>
<span class="nc" id="L471">        illegalOptionsFound++;</span>
<span class="nc" id="L472">        text.append(options[i] + ' ');</span>
      }
    }
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">    if (illegalOptionsFound &gt; 0) {</span>
<span class="nc" id="L476">      throw new Exception(&quot;Illegal options: &quot; + text);</span>
    }
<span class="fc" id="L478">  }</span>

  /**
   * Checks if the given array contains the flag &quot;-Char&quot;. Stops searching at the
   * first marker &quot;--&quot;. If the flag is found, it is replaced with the empty
   * string.
   * 
   * @param flag the character indicating the flag.
   * @param options the array of strings containing all the options.
   * @return true if the flag was found
   * @exception Exception if an illegal option was found
   */
  public static boolean getFlag(char flag, String[] options) throws Exception {

<span class="fc" id="L492">    return getFlag(&quot;&quot; + flag, options);</span>
  }

  /**
   * Checks if the given array contains the flag &quot;-String&quot;. Stops searching at
   * the first marker &quot;--&quot;. If the flag is found, it is replaced with the empty
   * string.
   * 
   * @param flag the String indicating the flag.
   * @param options the array of strings containing all the options.
   * @return true if the flag was found
   * @exception Exception if an illegal option was found
   */
  public static boolean getFlag(String flag, String[] options) throws Exception {

<span class="fc" id="L507">    int pos = getOptionPos(flag, options);</span>

<span class="fc bfc" id="L509" title="All 2 branches covered.">    if (pos &gt; -1)</span>
<span class="fc" id="L510">      options[pos] = &quot;&quot;;</span>

<span class="fc bfc" id="L512" title="All 2 branches covered.">    return (pos &gt; -1);</span>
  }

  /**
   * Gets an option indicated by a flag &quot;-Char&quot; from the given array of strings.
   * Stops searching at the first marker &quot;--&quot;. Replaces flag and option with
   * empty strings.
   * 
   * @param flag the character indicating the option.
   * @param options the array of strings containing all the options.
   * @return the indicated option or an empty string
   * @exception Exception if the option indicated by the flag can't be found
   */
  public static/* @non_null@ */String getOption(char flag, String[] options)
      throws Exception {

<span class="fc" id="L528">    return getOption(&quot;&quot; + flag, options);</span>
  }

  /**
   * Gets an option indicated by a flag &quot;-String&quot; from the given array of
   * strings. Stops searching at the first marker &quot;--&quot;. Replaces flag and option
   * with empty strings.
   * 
   * @param flag the String indicating the option.
   * @param options the array of strings containing all the options.
   * @return the indicated option or an empty string
   * @exception Exception if the option indicated by the flag can't be found
   */
  public static/* @non_null@ */String getOption(String flag, String[] options)
      throws Exception {

    String newString;
<span class="fc" id="L545">    int i = getOptionPos(flag, options);</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">    if (i &gt; -1) {</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">      if (options[i].equals(&quot;-&quot; + flag)) {</span>
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        if (i + 1 == options.length) {</span>
<span class="nc" id="L550">          throw new Exception(&quot;No value given for -&quot; + flag + &quot; option.&quot;);</span>
        }
<span class="fc" id="L552">        options[i] = &quot;&quot;;</span>
<span class="fc" id="L553">        newString = new String(options[i + 1]);</span>
<span class="fc" id="L554">        options[i + 1] = &quot;&quot;;</span>
<span class="fc" id="L555">        return newString;</span>
      }
<span class="nc bnc" id="L557" title="All 2 branches missed.">      if (options[i].charAt(1) == '-') {</span>
<span class="nc" id="L558">        return &quot;&quot;;</span>
      }
    }

<span class="fc" id="L562">    return &quot;&quot;;</span>
  }

  /**
   * Gets the index of an option or flag indicated by a flag &quot;-Char&quot; from the
   * given array of strings. Stops searching at the first marker &quot;--&quot;.
   * 
   * @param flag the character indicating the option.
   * @param options the array of strings containing all the options.
   * @return the position if found, or -1 otherwise
   */
  public static int getOptionPos(char flag, String[] options) {
<span class="nc" id="L574">    return getOptionPos(&quot;&quot; + flag, options);</span>
  }

  /**
   * Gets the index of an option or flag indicated by a flag &quot;-String&quot; from the
   * given array of strings. Stops searching at the first marker &quot;--&quot;.
   * 
   * @param flag the String indicating the option.
   * @param options the array of strings containing all the options.
   * @return the position if found, or -1 otherwise
   */
  public static int getOptionPos(String flag, String[] options) {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">    if (options == null)</span>
<span class="nc" id="L587">      return -1;</span>

<span class="fc bfc" id="L589" title="All 2 branches covered.">    for (int i = 0; i &lt; options.length; i++) {</span>
<span class="fc bfc" id="L590" title="All 4 branches covered.">      if ((options[i].length() &gt; 0) &amp;&amp; (options[i].charAt(0) == '-')) {</span>
        // Check if it is a negative number
        try {
<span class="fc" id="L593">          Double.valueOf(options[i]);</span>
<span class="fc" id="L594">        } catch (NumberFormatException e) {</span>
          // found?
<span class="fc bfc" id="L596" title="All 2 branches covered.">          if (options[i].equals(&quot;-&quot; + flag))</span>
<span class="fc" id="L597">            return i;</span>
          // did we reach &quot;--&quot;?
<span class="fc bfc" id="L599" title="All 2 branches covered.">          if (options[i].charAt(1) == '-')</span>
<span class="fc" id="L600">            return -1;</span>
        }
      }
    }

<span class="fc" id="L605">    return -1;</span>
  }

  /**
   * Quotes a string if it contains special characters.
   * 
   * The following rules are applied:
   * 
   * A character is backquoted version of it is one of &lt;tt&gt;&quot; ' % \ \n \r \t&lt;/tt&gt;
   * .
   * 
   * A string is enclosed within single quotes if a character has been
   * backquoted using the previous rule above or contains &lt;tt&gt;{ }&lt;/tt&gt; or is
   * exactly equal to the strings &lt;tt&gt;, ? space or &quot;&quot;&lt;/tt&gt; (empty string).
   * 
   * A quoted question mark distinguishes it from the missing value which is
   * represented as an unquoted question mark in arff files.
   * 
   * @param string the string to be quoted
   * @return the string (possibly quoted)
   * @see #unquote(String)
   */
  public static/* @pure@ */String quote(String string) {
<span class="fc" id="L628">    boolean quote = false;</span>

    // backquote the following characters
<span class="pc bpc" id="L631" title="2 of 4 branches missed.">    if ((string.indexOf('\n') != -1) || (string.indexOf('\r') != -1)</span>
<span class="pc bpc" id="L632" title="2 of 4 branches missed.">        || (string.indexOf('\'') != -1) || (string.indexOf('&quot;') != -1)</span>
<span class="pc bpc" id="L633" title="2 of 4 branches missed.">        || (string.indexOf('\\') != -1) || (string.indexOf('\t') != -1)</span>
<span class="pc bpc" id="L634" title="2 of 4 branches missed.">        || (string.indexOf('%') != -1) || (string.indexOf('\u001E') != -1)) {</span>
<span class="nc" id="L635">      string = backQuoteChars(string);</span>
<span class="nc" id="L636">      quote = true;</span>
    }

    // Enclose the string in 's if the string contains a recently added
    // backquote or contains one of the following characters.
<span class="pc bpc" id="L641" title="2 of 4 branches missed.">    if ((quote == true) || (string.indexOf('{') != -1)</span>
<span class="pc bpc" id="L642" title="2 of 4 branches missed.">        || (string.indexOf('}') != -1) || (string.indexOf(',') != -1)</span>
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">        || (string.equals(&quot;?&quot;)) || (string.indexOf(' ') != -1)</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        || (string.equals(&quot;&quot;))) {</span>
<span class="nc" id="L645">      string = (&quot;'&quot;.concat(string)).concat(&quot;'&quot;);</span>
    }

<span class="fc" id="L648">    return string;</span>
  }

  /**
   * unquotes are previously quoted string (but only if necessary), i.e., it
   * removes the single quotes around it. Inverse to quote(String).
   * 
   * @param string the string to process
   * @return the unquoted string
   * @see #quote(String)
   */
  public static String unquote(String string) {
<span class="nc bnc" id="L660" title="All 4 branches missed.">    if (string.startsWith(&quot;'&quot;) &amp;&amp; string.endsWith(&quot;'&quot;)) {</span>
<span class="nc" id="L661">      string = string.substring(1, string.length() - 1);</span>

<span class="nc bnc" id="L663" title="All 4 branches missed.">      if ((string.indexOf(&quot;\\n&quot;) != -1) || (string.indexOf(&quot;\\r&quot;) != -1)</span>
<span class="nc bnc" id="L664" title="All 4 branches missed.">          || (string.indexOf(&quot;\\'&quot;) != -1) || (string.indexOf(&quot;\\\&quot;&quot;) != -1)</span>
<span class="nc bnc" id="L665" title="All 4 branches missed.">          || (string.indexOf(&quot;\\\\&quot;) != -1) || (string.indexOf(&quot;\\t&quot;) != -1)</span>
<span class="nc bnc" id="L666" title="All 4 branches missed.">          || (string.indexOf(&quot;\\%&quot;) != -1) || (string.indexOf(&quot;\\u001E&quot;) != -1)) {</span>
<span class="nc" id="L667">        string = unbackQuoteChars(string);</span>
      }
    }

<span class="nc" id="L671">    return string;</span>
  }

  /**
   * Converts carriage returns and new lines in a string into \r and \n.
   * Backquotes the following characters: ` &quot; \ \t and %
   * 
   * @param string the string
   * @return the converted string
   * @see #unbackQuoteChars(String)
   */
  public static/* @pure@ */String backQuoteChars(String string) {

    int index;
    StringBuffer newStringBuffer;

    // replace each of the following characters with the backquoted version
<span class="fc" id="L688">    char charsFind[] = { '\\', '\'', '\t', '\n', '\r', '&quot;', '%', '\u001E' };</span>
<span class="fc" id="L689">    String charsReplace[] = { &quot;\\\\&quot;, &quot;\\'&quot;, &quot;\\t&quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\\&quot;&quot;,</span>
<span class="fc" id="L690">        &quot;\\%&quot;, &quot;\\u001E&quot; };</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">    for (int i = 0; i &lt; charsFind.length; i++) {</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">      if (string.indexOf(charsFind[i]) != -1) {</span>
<span class="nc" id="L693">        newStringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        while ((index = string.indexOf(charsFind[i])) != -1) {</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">          if (index &gt; 0) {</span>
<span class="nc" id="L696">            newStringBuffer.append(string.substring(0, index));</span>
          }
<span class="nc" id="L698">          newStringBuffer.append(charsReplace[i]);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">          if ((index + 1) &lt; string.length()) {</span>
<span class="nc" id="L700">            string = string.substring(index + 1);</span>
          } else {
<span class="nc" id="L702">            string = &quot;&quot;;</span>
          }
        }
<span class="nc" id="L705">        newStringBuffer.append(string);</span>
<span class="nc" id="L706">        string = newStringBuffer.toString();</span>
      }
    }

<span class="fc" id="L710">    return string;</span>
  }

  /**
   * Converts carriage returns and new lines in a string into \r and \n.
   * 
   * @param string the string
   * @return the converted string
   */
  public static String convertNewLines(String string) {
    int index;

    // Replace with \n
<span class="nc" id="L723">    StringBuffer newStringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">    while ((index = string.indexOf('\n')) != -1) {</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">      if (index &gt; 0) {</span>
<span class="nc" id="L726">        newStringBuffer.append(string.substring(0, index));</span>
      }
<span class="nc" id="L728">      newStringBuffer.append('\\');</span>
<span class="nc" id="L729">      newStringBuffer.append('n');</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">      if ((index + 1) &lt; string.length()) {</span>
<span class="nc" id="L731">        string = string.substring(index + 1);</span>
      } else {
<span class="nc" id="L733">        string = &quot;&quot;;</span>
      }
    }
<span class="nc" id="L736">    newStringBuffer.append(string);</span>
<span class="nc" id="L737">    string = newStringBuffer.toString();</span>

    // Replace with \r
<span class="nc" id="L740">    newStringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">    while ((index = string.indexOf('\r')) != -1) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">      if (index &gt; 0) {</span>
<span class="nc" id="L743">        newStringBuffer.append(string.substring(0, index));</span>
      }
<span class="nc" id="L745">      newStringBuffer.append('\\');</span>
<span class="nc" id="L746">      newStringBuffer.append('r');</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">      if ((index + 1) &lt; string.length()) {</span>
<span class="nc" id="L748">        string = string.substring(index + 1);</span>
      } else {
<span class="nc" id="L750">        string = &quot;&quot;;</span>
      }
    }
<span class="nc" id="L753">    newStringBuffer.append(string);</span>
<span class="nc" id="L754">    return newStringBuffer.toString();</span>
  }

  /**
   * Reverts \r and \n in a string into carriage returns and new lines.
   * 
   * @param string the string
   * @return the converted string
   */
  public static String revertNewLines(String string) {
    int index;

    // Replace with \n
<span class="nc" id="L767">    StringBuffer newStringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">    while ((index = string.indexOf(&quot;\\n&quot;)) != -1) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">      if (index &gt; 0) {</span>
<span class="nc" id="L770">        newStringBuffer.append(string.substring(0, index));</span>
      }
<span class="nc" id="L772">      newStringBuffer.append('\n');</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">      if ((index + 2) &lt; string.length()) {</span>
<span class="nc" id="L774">        string = string.substring(index + 2);</span>
      } else {
<span class="nc" id="L776">        string = &quot;&quot;;</span>
      }
    }
<span class="nc" id="L779">    newStringBuffer.append(string);</span>
<span class="nc" id="L780">    string = newStringBuffer.toString();</span>

    // Replace with \r
<span class="nc" id="L783">    newStringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">    while ((index = string.indexOf(&quot;\\r&quot;)) != -1) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">      if (index &gt; 0) {</span>
<span class="nc" id="L786">        newStringBuffer.append(string.substring(0, index));</span>
      }
<span class="nc" id="L788">      newStringBuffer.append('\r');</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">      if ((index + 2) &lt; string.length()) {</span>
<span class="nc" id="L790">        string = string.substring(index + 2);</span>
      } else {
<span class="nc" id="L792">        string = &quot;&quot;;</span>
      }
    }
<span class="nc" id="L795">    newStringBuffer.append(string);</span>

<span class="nc" id="L797">    return newStringBuffer.toString();</span>
  }

  /**
   * Returns the secondary set of options (if any) contained in the supplied
   * options array. The secondary set is defined to be any options after the
   * first &quot;--&quot;. These options are removed from the original options array.
   * 
   * @param options the input array of options
   * @return the array of secondary options
   */
  public static String[] partitionOptions(String[] options) {

<span class="fc bfc" id="L810" title="All 2 branches covered.">    for (int i = 0; i &lt; options.length; i++) {</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">      if (options[i].equals(&quot;--&quot;)) {</span>
<span class="fc" id="L812">        options[i++] = &quot;&quot;;</span>
<span class="fc" id="L813">        String[] result = new String[options.length - i];</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">        for (int j = i; j &lt; options.length; j++) {</span>
<span class="fc" id="L815">          result[j - i] = options[j];</span>
<span class="fc" id="L816">          options[j] = &quot;&quot;;</span>
        }
<span class="fc" id="L818">        return result;</span>
      }
    }
<span class="fc" id="L821">    return new String[0];</span>
  }

  /**
   * The inverse operation of backQuoteChars(). Converts back-quoted carriage
   * returns and new lines in a string to the corresponding character ('\r' and
   * '\n'). Also &quot;un&quot;-back-quotes the following characters: ` &quot; \ \t and %
   * 
   * @param string the string
   * @return the converted string
   * @see #backQuoteChars(String)
   */
  public static String unbackQuoteChars(String string) {

    int index;
    StringBuffer newStringBuffer;

    // replace each of the following characters with the backquoted version
<span class="fc" id="L839">    String charsFind[] = { &quot;\\\\&quot;, &quot;\\'&quot;, &quot;\\t&quot;, &quot;\\n&quot;, &quot;\\r&quot;, &quot;\\\&quot;&quot;, &quot;\\%&quot;,</span>
<span class="fc" id="L840">        &quot;\\u001E&quot; };</span>
<span class="fc" id="L841">    char charsReplace[] = { '\\', '\'', '\t', '\n', '\r', '&quot;', '%', '\u001E' };</span>
<span class="fc" id="L842">    int pos[] = new int[charsFind.length];</span>
    int curPos;

<span class="fc" id="L845">    String str = new String(string);</span>
<span class="fc" id="L846">    newStringBuffer = new StringBuffer();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">    while (str.length() &gt; 0) {</span>
      // get positions and closest character to replace
<span class="fc" id="L849">      curPos = str.length();</span>
<span class="fc" id="L850">      index = -1;</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">      for (int i = 0; i &lt; pos.length; i++) {</span>
<span class="fc" id="L852">        pos[i] = str.indexOf(charsFind[i]);</span>
<span class="pc bpc" id="L853" title="3 of 4 branches missed.">        if ((pos[i] &gt; -1) &amp;&amp; (pos[i] &lt; curPos)) {</span>
<span class="nc" id="L854">          index = i;</span>
<span class="nc" id="L855">          curPos = pos[i];</span>
        }
      }

      // replace character if found, otherwise finished
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">      if (index == -1) {</span>
<span class="fc" id="L861">        newStringBuffer.append(str);</span>
<span class="fc" id="L862">        str = &quot;&quot;;</span>
      } else {
<span class="nc" id="L864">        newStringBuffer.append(str.substring(0, pos[index]));</span>
<span class="nc" id="L865">        newStringBuffer.append(charsReplace[index]);</span>
<span class="nc" id="L866">        str = str.substring(pos[index] + charsFind[index].length());</span>
      }
    }

<span class="fc" id="L870">    return newStringBuffer.toString();</span>
  }

  /**
   * Split up a string containing options into an array of strings, one for each
   * option.
   * 
   * @param quotedOptionString the string containing the options
   * @return the array of options
   * @throws Exception in case of an unterminated string, unknown character or a
   *           parse error
   */
  public static String[] splitOptions(String quotedOptionString)
      throws Exception {

<span class="fc" id="L885">    FastVector optionsVec = new FastVector();</span>
<span class="fc" id="L886">    String str = new String(quotedOptionString);</span>
    int i;

<span class="fc" id="L889">    while (true) {</span>

      // trimLeft
<span class="fc" id="L892">      i = 0;</span>
<span class="fc bfc" id="L893" title="All 4 branches covered.">      while ((i &lt; str.length()) &amp;&amp; (Character.isWhitespace(str.charAt(i))))</span>
<span class="fc" id="L894">        i++;</span>
<span class="fc" id="L895">      str = str.substring(i);</span>

      // stop when str is empty
<span class="fc bfc" id="L898" title="All 2 branches covered.">      if (str.length() == 0)</span>
<span class="fc" id="L899">        break;</span>

      // if str start with a double quote
<span class="fc bfc" id="L902" title="All 2 branches covered.">      if (str.charAt(0) == '&quot;') {</span>

        // find the first not anti-slached double quote
<span class="fc" id="L905">        i = 1;</span>
<span class="pc bpc" id="L906" title="1 of 2 branches missed.">        while (i &lt; str.length()) {</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">          if (str.charAt(i) == str.charAt(0))</span>
<span class="fc" id="L908">            break;</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">          if (str.charAt(i) == '\\') {</span>
<span class="nc" id="L910">            i += 1;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            if (i &gt;= str.length())</span>
<span class="nc" id="L912">              throw new Exception(&quot;String should not finish with \\&quot;);</span>
          }
<span class="fc" id="L914">          i += 1;</span>
        }
<span class="pc bpc" id="L916" title="1 of 2 branches missed.">        if (i &gt;= str.length())</span>
<span class="nc" id="L917">          throw new Exception(&quot;Quote parse error.&quot;);</span>

        // add the founded string to the option vector (without quotes)
<span class="fc" id="L920">        String optStr = str.substring(1, i);</span>
<span class="fc" id="L921">        optStr = unbackQuoteChars(optStr);</span>
<span class="fc" id="L922">        optionsVec.addElement(optStr);</span>
<span class="fc" id="L923">        str = str.substring(i + 1);</span>
      } else {
        // find first whiteSpace
<span class="fc" id="L926">        i = 0;</span>
<span class="fc bfc" id="L927" title="All 4 branches covered.">        while ((i &lt; str.length()) &amp;&amp; (!Character.isWhitespace(str.charAt(i))))</span>
<span class="fc" id="L928">          i++;</span>

        // add the founded string to the option vector
<span class="fc" id="L931">        String optStr = str.substring(0, i);</span>
<span class="fc" id="L932">        optionsVec.addElement(optStr);</span>
<span class="fc" id="L933">        str = str.substring(i);</span>
      }
    }

    // convert optionsVec to an array of String
<span class="fc" id="L938">    String[] options = new String[optionsVec.size()];</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">    for (i = 0; i &lt; optionsVec.size(); i++) {</span>
<span class="fc" id="L940">      options[i] = (String) optionsVec.elementAt(i);</span>
    }
<span class="fc" id="L942">    return options;</span>
  }

  /**
   * Joins all the options in an option array into a single string, as might be
   * used on the command line.
   * 
   * @param optionArray the array of options
   * @return the string containing all options.
   */
  public static String joinOptions(String[] optionArray) {

<span class="fc" id="L954">    String optionString = &quot;&quot;;</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">    for (int i = 0; i &lt; optionArray.length; i++) {</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">      if (optionArray[i].equals(&quot;&quot;)) {</span>
<span class="fc" id="L957">        continue;</span>
      }
<span class="fc" id="L959">      boolean escape = false;</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">      for (int n = 0; n &lt; optionArray[i].length(); n++) {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">        if (Character.isWhitespace(optionArray[i].charAt(n))) {</span>
<span class="fc" id="L962">          escape = true;</span>
<span class="fc" id="L963">          break;</span>
        }
      }
<span class="fc bfc" id="L966" title="All 2 branches covered.">      if (escape) {</span>
<span class="fc" id="L967">        optionString += '&quot;' + backQuoteChars(optionArray[i]) + '&quot;';</span>
      } else {
<span class="fc" id="L969">        optionString += optionArray[i];</span>
      }
<span class="fc" id="L971">      optionString += &quot; &quot;;</span>
    }
<span class="fc" id="L973">    return optionString.trim();</span>
  }

  /**
   * Creates a new instance of an object given it's class name and (optional)
   * arguments to pass to it's setOptions method. If the object implements
   * OptionHandler and the options parameter is non-null, the object will have
   * it's options set. Example use:
   * &lt;p&gt;
   * 
   * &lt;code&gt; &lt;pre&gt;
   * String classifierName = Utils.getOption('W', options);
   * Classifier c = (Classifier)Utils.forName(Classifier.class,
   *                                          classifierName,
   *                                          options);
   * setClassifier(c);
   * &lt;/pre&gt;&lt;/code&gt;
   * 
   * @param classType the class that the instantiated object should be
   *          assignable to -- an exception is thrown if this is not the case
   * @param className the fully qualified class name of the object
   * @param options an array of options suitable for passing to setOptions. May
   *          be null. Any options accepted by the object will be removed from
   *          the array.
   * @return the newly created object, ready for use.
   * @exception Exception if the class name is invalid, or if the class is not
   *              assignable to the desired class type, or the options supplied
   *              are not acceptable to the object
   */
  public static Object forName(Class classType, String className,
      String[] options) throws Exception {

<span class="fc" id="L1005">    Class c = null;</span>
    try {
<span class="fc" id="L1007">      c = Class.forName(className);</span>
<span class="nc" id="L1008">    } catch (Exception ex) {</span>
<span class="nc" id="L1009">      throw new Exception(&quot;Can't find class called: &quot; + className);</span>
    }
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">    if (!classType.isAssignableFrom(c)) {</span>
<span class="nc" id="L1012">      throw new Exception(classType.getName() + &quot; is not assignable from &quot;</span>
<span class="nc" id="L1013">          + className);</span>
    }
<span class="fc" id="L1015">    Object o = c.newInstance();</span>
<span class="pc bpc" id="L1016" title="1 of 4 branches missed.">    if ((o instanceof OptionHandler) &amp;&amp; (options != null)) {</span>
<span class="fc" id="L1017">      ((OptionHandler) o).setOptions(options);</span>
<span class="fc" id="L1018">      Utils.checkForRemainingOptions(options);</span>
    }
<span class="fc" id="L1020">    return o;</span>
  }

  /**
   * Computes entropy for an array of integers.
   * 
   * @param counts array of counts
   * @return - a log2 a - b log2 b - c log2 c + (a+b+c) log2 (a+b+c) when given
   *         array [a b c]
   */
  public static/* @pure@ */double info(int counts[]) {

<span class="nc" id="L1032">    int total = 0;</span>
<span class="nc" id="L1033">    double x = 0;</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">    for (int j = 0; j &lt; counts.length; j++) {</span>
<span class="nc" id="L1035">      x -= xlogx(counts[j]);</span>
<span class="nc" id="L1036">      total += counts[j];</span>
    }
<span class="nc" id="L1038">    return x + xlogx(total);</span>
  }

  /**
   * Tests if a is smaller or equal to b.
   * 
   * @param a a double
   * @param b a double
   */
  public static/* @pure@ */boolean smOrEq(double a, double b) {

<span class="pc bpc" id="L1049" title="1 of 4 branches missed.">    return (a - b &lt; SMALL) || (a &lt;= b);</span>
  }

  /**
   * Tests if a is greater or equal to b.
   * 
   * @param a a double
   * @param b a double
   */
  public static/* @pure@ */boolean grOrEq(double a, double b) {

<span class="pc bpc" id="L1060" title="1 of 4 branches missed.">    return (b - a &lt; SMALL) || (a &gt;= b);</span>
  }

  /**
   * Tests if a is smaller than b.
   * 
   * @param a a double
   * @param b a double
   */
  public static/* @pure@ */boolean sm(double a, double b) {

<span class="fc bfc" id="L1071" title="All 2 branches covered.">    return (b - a &gt; SMALL);</span>
  }

  /**
   * Tests if a is greater than b.
   * 
   * @param a a double
   * @param b a double
   */
  public static/* @pure@ */boolean gr(double a, double b) {

<span class="fc bfc" id="L1082" title="All 2 branches covered.">    return (a - b &gt; SMALL);</span>
  }

  /**
   * Returns the kth-smallest value in the array.
   * 
   * @param array the array of integers
   * @param k the value of k
   * @return the kth-smallest value
   */
  public static int kthSmallestValue(int[] array, int k) {

<span class="nc" id="L1094">    int[] index = initialIndex(array.length);</span>
<span class="nc" id="L1095">    return array[index[select(array, index, 0, array.length - 1, k)]];</span>
  }

  /**
   * Returns the kth-smallest value in the array
   * 
   * @param array the array of double
   * @param k the value of k
   * @return the kth-smallest value
   */
  public static double kthSmallestValue(double[] array, int k) {

<span class="nc" id="L1107">    int[] index = initialIndex(array.length);</span>
<span class="nc" id="L1108">    return array[index[select(array, index, 0, array.length - 1, k)]];</span>
  }

  /**
   * Returns the logarithm of a for base 2.
   * 
   * @param a a double
   * @return the logarithm for base 2
   */
  public static/* @pure@ */double log2(double a) {

<span class="fc" id="L1119">    return Math.log(a) / log2;</span>
  }

  /**
   * Returns index of maximum element in a given array of doubles. First maximum
   * is returned.
   * 
   * @param doubles the array of doubles
   * @return the index of the maximum element
   */
  public static/* @pure@ */int maxIndex(double[] doubles) {

<span class="fc" id="L1131">    double maximum = 0;</span>
<span class="fc" id="L1132">    int maxIndex = 0;</span>

<span class="fc bfc" id="L1134" title="All 2 branches covered.">    for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc bfc" id="L1135" title="All 4 branches covered.">      if ((i == 0) || (doubles[i] &gt; maximum)) {</span>
<span class="fc" id="L1136">        maxIndex = i;</span>
<span class="fc" id="L1137">        maximum = doubles[i];</span>
      }
    }

<span class="fc" id="L1141">    return maxIndex;</span>
  }

  /**
   * Returns index of maximum element in a given array of integers. First
   * maximum is returned.
   * 
   * @param ints the array of integers
   * @return the index of the maximum element
   */
  public static/* @pure@ */int maxIndex(int[] ints) {

<span class="fc" id="L1153">    int maximum = 0;</span>
<span class="fc" id="L1154">    int maxIndex = 0;</span>

<span class="fc bfc" id="L1156" title="All 2 branches covered.">    for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="fc bfc" id="L1157" title="All 4 branches covered.">      if ((i == 0) || (ints[i] &gt; maximum)) {</span>
<span class="fc" id="L1158">        maxIndex = i;</span>
<span class="fc" id="L1159">        maximum = ints[i];</span>
      }
    }

<span class="fc" id="L1163">    return maxIndex;</span>
  }

  /**
   * Computes the mean for an array of doubles.
   * 
   * @param vector the array
   * @return the mean
   */
  public static/* @pure@ */double mean(double[] vector) {

<span class="nc" id="L1174">    double sum = 0;</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">    if (vector.length == 0) {</span>
<span class="nc" id="L1177">      return 0;</span>
    }
<span class="nc bnc" id="L1179" title="All 2 branches missed.">    for (int i = 0; i &lt; vector.length; i++) {</span>
<span class="nc" id="L1180">      sum += vector[i];</span>
    }
<span class="nc" id="L1182">    return sum / vector.length;</span>
  }

  /**
   * Returns index of minimum element in a given array of integers. First
   * minimum is returned.
   * 
   * @param ints the array of integers
   * @return the index of the minimum element
   */
  public static/* @pure@ */int minIndex(int[] ints) {

<span class="nc" id="L1194">    int minimum = 0;</span>
<span class="nc" id="L1195">    int minIndex = 0;</span>

<span class="nc bnc" id="L1197" title="All 2 branches missed.">    for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">      if ((i == 0) || (ints[i] &lt; minimum)) {</span>
<span class="nc" id="L1199">        minIndex = i;</span>
<span class="nc" id="L1200">        minimum = ints[i];</span>
      }
    }

<span class="nc" id="L1204">    return minIndex;</span>
  }

  /**
   * Returns index of minimum element in a given array of doubles. First minimum
   * is returned.
   * 
   * @param doubles the array of doubles
   * @return the index of the minimum element
   */
  public static/* @pure@ */int minIndex(double[] doubles) {

<span class="fc" id="L1216">    double minimum = 0;</span>
<span class="fc" id="L1217">    int minIndex = 0;</span>

<span class="fc bfc" id="L1219" title="All 2 branches covered.">    for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc bfc" id="L1220" title="All 4 branches covered.">      if ((i == 0) || (doubles[i] &lt; minimum)) {</span>
<span class="fc" id="L1221">        minIndex = i;</span>
<span class="fc" id="L1222">        minimum = doubles[i];</span>
      }
    }

<span class="fc" id="L1226">    return minIndex;</span>
  }

  /**
   * Normalizes the doubles in the array by their sum.
   * 
   * @param doubles the array of double
   * @exception IllegalArgumentException if sum is Zero or NaN
   */
  public static void normalize(double[] doubles) {

<span class="fc" id="L1237">    double sum = 0;</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">    for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc" id="L1239">      sum += doubles[i];</span>
    }
<span class="fc" id="L1241">    normalize(doubles, sum);</span>
<span class="fc" id="L1242">  }</span>

  /**
   * Normalizes the doubles in the array using the given value.
   * 
   * @param doubles the array of double
   * @param sum the value by which the doubles are to be normalized
   * @exception IllegalArgumentException if sum is zero or NaN
   */
  public static void normalize(double[] doubles, double sum) {

<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">    if (Double.isNaN(sum)) {</span>
<span class="nc" id="L1254">      throw new IllegalArgumentException(&quot;Can't normalize array. Sum is NaN.&quot;);</span>
    }
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">    if (sum == 0) {</span>
      // Maybe this should just be a return.
<span class="nc" id="L1258">      throw new IllegalArgumentException(&quot;Can't normalize array. Sum is zero.&quot;);</span>
    }
<span class="fc bfc" id="L1260" title="All 2 branches covered.">    for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc" id="L1261">      doubles[i] /= sum;</span>
    }
<span class="fc" id="L1263">  }</span>

  /**
   * Converts an array containing the natural logarithms of probabilities stored
   * in a vector back into probabilities. The probabilities are assumed to sum
   * to one.
   * 
   * @param a an array holding the natural logarithms of the probabilities
   * @return the converted array
   */
  public static double[] logs2probs(double[] a) {

<span class="fc" id="L1275">    double max = a[maxIndex(a)];</span>
<span class="fc" id="L1276">    double sum = 0.0;</span>

<span class="fc" id="L1278">    double[] result = new double[a.length];</span>
<span class="fc bfc" id="L1279" title="All 2 branches covered.">    for (int i = 0; i &lt; a.length; i++) {</span>
<span class="fc" id="L1280">      result[i] = Math.exp(a[i] - max);</span>
<span class="fc" id="L1281">      sum += result[i];</span>
    }

<span class="fc" id="L1284">    normalize(result, sum);</span>

<span class="fc" id="L1286">    return result;</span>
  }

  /**
   * Returns the log-odds for a given probabilitiy.
   * 
   * @param prob the probabilitiy
   * 
   * @return the log-odds after the probability has been mapped to [Utils.SMALL,
   *         1-Utils.SMALL]
   */
  public static/* @pure@ */double probToLogOdds(double prob) {

<span class="nc bnc" id="L1299" title="All 4 branches missed.">    if (gr(prob, 1) || (sm(prob, 0))) {</span>
<span class="nc" id="L1300">      throw new IllegalArgumentException(&quot;probToLogOdds: probability must &quot;</span>
<span class="nc" id="L1301">          + &quot;be in [0,1] &quot; + prob);</span>
    }
<span class="nc" id="L1303">    double p = SMALL + (1.0 - 2 * SMALL) * prob;</span>
<span class="nc" id="L1304">    return Math.log(p / (1 - p));</span>
  }

  /**
   * Rounds a double to the next nearest integer value. The JDK version of it
   * doesn't work properly.
   * 
   * @param value the double value
   * @return the resulting integer value
   */
  public static/* @pure@ */int round(double value) {

<span class="nc bnc" id="L1316" title="All 2 branches missed.">    int roundedValue = value &gt; 0 ? (int) (value + 0.5) : -(int) (Math</span>
<span class="nc" id="L1317">        .abs(value) + 0.5);</span>

<span class="nc" id="L1319">    return roundedValue;</span>
  }

  /**
   * Rounds a double to the next nearest integer value in a probabilistic
   * fashion (e.g. 0.8 has a 20% chance of being rounded down to 0 and a 80%
   * chance of being rounded up to 1). In the limit, the average of the rounded
   * numbers generated by this procedure should converge to the original double.
   * 
   * @param value the double value
   * @param rand the random number generator
   * @return the resulting integer value
   */
  public static int probRound(double value, Random rand) {

<span class="nc bnc" id="L1334" title="All 2 branches missed.">    if (value &gt;= 0) {</span>
<span class="nc" id="L1335">      double lower = Math.floor(value);</span>
<span class="nc" id="L1336">      double prob = value - lower;</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">      if (rand.nextDouble() &lt; prob) {</span>
<span class="nc" id="L1338">        return (int) lower + 1;</span>
      } else {
<span class="nc" id="L1340">        return (int) lower;</span>
      }
    } else {
<span class="nc" id="L1343">      double lower = Math.floor(Math.abs(value));</span>
<span class="nc" id="L1344">      double prob = Math.abs(value) - lower;</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">      if (rand.nextDouble() &lt; prob) {</span>
<span class="nc" id="L1346">        return -((int) lower + 1);</span>
      } else {
<span class="nc" id="L1348">        return -(int) lower;</span>
      }
    }
  }

  /**
   * Replaces all &quot;missing values&quot; in the given array of double values with
   * MAX_VALUE.
   * 
   * @param array the array to be modified.
   */
  public static void replaceMissingWithMAX_VALUE(double[] array) {

<span class="fc bfc" id="L1361" title="All 2 branches covered.">    for (int i = 0; i &lt; array.length; i++) {</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">      if (Instance.isMissingValue(array[i])) {</span>
<span class="fc" id="L1363">        array[i] = Double.MAX_VALUE;</span>
      }
    }
<span class="fc" id="L1366">  }</span>

  /**
   * Rounds a double to the given number of decimal places.
   * 
   * @param value the double value
   * @param afterDecimalPoint the number of digits after the decimal point
   * @return the double rounded to the given precision
   */
  public static/* @pure@ */double roundDouble(double value,
      int afterDecimalPoint) {

<span class="nc" id="L1378">    double mask = Math.pow(10.0, afterDecimalPoint);</span>

<span class="nc" id="L1380">    return (Math.round(value * mask)) / mask;</span>
  }

  /**
   * Sorts a given array of integers in ascending order and returns an array of
   * integers with the positions of the elements of the original array in the
   * sorted array. The sort is stable. (Equal elements remain in their original
   * order.)
   * 
   * @param array this array is not changed by the method!
   * @return an array of integers with the positions in the sorted array.
   */
  public static/* @pure@ */int[] sort(int[] array) {

<span class="fc" id="L1394">    int[] index = new int[array.length];</span>
<span class="fc" id="L1395">    int[] newIndex = new int[array.length];</span>
    int[] helpIndex;
    int numEqual;

<span class="fc bfc" id="L1399" title="All 2 branches covered.">    for (int i = 0; i &lt; index.length; i++) {</span>
<span class="fc" id="L1400">      index[i] = i;</span>
    }
<span class="fc" id="L1402">    quickSort(array, index, 0, array.length - 1);</span>

    // Make sort stable
<span class="fc" id="L1405">    int i = 0;</span>
<span class="fc bfc" id="L1406" title="All 2 branches covered.">    while (i &lt; index.length) {</span>
<span class="fc" id="L1407">      numEqual = 1;</span>
<span class="pc bpc" id="L1408" title="1 of 4 branches missed.">      for (int j = i + 1; ((j &lt; index.length) &amp;&amp; (array[index[i]] == array[index[j]])); j++) {</span>
<span class="nc" id="L1409">        numEqual++;</span>
      }
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">      if (numEqual &gt; 1) {</span>
<span class="nc" id="L1412">        helpIndex = new int[numEqual];</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        for (int j = 0; j &lt; numEqual; j++) {</span>
<span class="nc" id="L1414">          helpIndex[j] = i + j;</span>
        }
<span class="nc" id="L1416">        quickSort(index, helpIndex, 0, numEqual - 1);</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">        for (int j = 0; j &lt; numEqual; j++) {</span>
<span class="nc" id="L1418">          newIndex[i + j] = index[helpIndex[j]];</span>
        }
<span class="nc" id="L1420">        i += numEqual;</span>
      } else {
<span class="fc" id="L1422">        newIndex[i] = index[i];</span>
<span class="fc" id="L1423">        i++;</span>
      }
    }
<span class="fc" id="L1426">    return newIndex;</span>
  }

  /**
   * Sorts a given array of doubles in ascending order and returns an array of
   * integers with the positions of the elements of the original array in the
   * sorted array. NOTE THESE CHANGES: the sort is no longer stable and it
   * doesn't use safe floating-point comparisons anymore. Occurrences of
   * Double.NaN are treated as Double.MAX_VALUE.
   * 
   * @param array this array is not changed by the method!
   * @return an array of integers with the positions in the sorted array.
   */
  public static/* @pure@ */int[] sort(/* @non_null@ */double[] array) {

<span class="fc" id="L1441">    int[] index = initialIndex(array.length);</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">    if (array.length &gt; 1) {</span>
<span class="fc" id="L1443">      array = array.clone();</span>
<span class="fc" id="L1444">      replaceMissingWithMAX_VALUE(array);</span>
<span class="fc" id="L1445">      quickSort(array, index, 0, array.length - 1);</span>
    }
<span class="fc" id="L1447">    return index;</span>
  }

  /**
   * Sorts a given array of doubles in ascending order and returns an array of
   * integers with the positions of the elements of the original array in the
   * sorted array. Missing values in the given array are replaced by
   * Double.MAX_VALUE, so the array is modified in that case!
   * 
   * @param array the array to be sorted, which is modified if it has missing
   *          values
   * @return an array of integers with the positions in the sorted array.
   */
  public static/* @pure@ */int[] sortWithNoMissingValues(
      /* @non_null@ */double[] array) {

<span class="fc" id="L1463">    int[] index = initialIndex(array.length);</span>
<span class="fc bfc" id="L1464" title="All 2 branches covered.">    if (array.length &gt; 1) {</span>
<span class="fc" id="L1465">      quickSort(array, index, 0, array.length - 1);</span>
    }
<span class="fc" id="L1467">    return index;</span>
  }

  /**
   * Sorts a given array of doubles in ascending order and returns an array of
   * integers with the positions of the elements of the original array in the
   * sorted array. The sort is stable (Equal elements remain in their original
   * order.) Occurrences of Double.NaN are treated as Double.MAX_VALUE
   * 
   * @param array this array is not changed by the method!
   * @return an array of integers with the positions in the sorted array.
   */
  public static/* @pure@ */int[] stableSort(double[] array) {

<span class="fc" id="L1481">    int[] index = initialIndex(array.length);</span>

<span class="pc bpc" id="L1483" title="1 of 2 branches missed.">    if (array.length &gt; 1) {</span>

<span class="fc" id="L1485">      int[] newIndex = new int[array.length];</span>
      int[] helpIndex;
      int numEqual;

<span class="fc" id="L1489">      array = array.clone();</span>
<span class="fc" id="L1490">      replaceMissingWithMAX_VALUE(array);</span>
<span class="fc" id="L1491">      quickSort(array, index, 0, array.length - 1);</span>

      // Make sort stable

<span class="fc" id="L1495">      int i = 0;</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">      while (i &lt; index.length) {</span>
<span class="fc" id="L1497">        numEqual = 1;</span>
<span class="fc bfc" id="L1498" title="All 4 branches covered.">        for (int j = i + 1; ((j &lt; index.length) &amp;&amp; Utils.eq(array[index[i]],</span>
<span class="fc" id="L1499">            array[index[j]])); j++)</span>
<span class="fc" id="L1500">          numEqual++;</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">        if (numEqual &gt; 1) {</span>
<span class="fc" id="L1502">          helpIndex = new int[numEqual];</span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">          for (int j = 0; j &lt; numEqual; j++)</span>
<span class="fc" id="L1504">            helpIndex[j] = i + j;</span>
<span class="fc" id="L1505">          quickSort(index, helpIndex, 0, numEqual - 1);</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">          for (int j = 0; j &lt; numEqual; j++)</span>
<span class="fc" id="L1507">            newIndex[i + j] = index[helpIndex[j]];</span>
<span class="fc" id="L1508">          i += numEqual;</span>
        } else {
<span class="fc" id="L1510">          newIndex[i] = index[i];</span>
<span class="fc" id="L1511">          i++;</span>
        }
      }
<span class="fc" id="L1514">      return newIndex;</span>
    } else {
<span class="nc" id="L1516">      return index;</span>
    }
  }

  /**
   * Computes the variance for an array of doubles.
   * 
   * @param vector the array
   * @return the variance
   */
  public static/* @pure@ */double variance(double[] vector) {

<span class="nc" id="L1528">    double sum = 0, sumSquared = 0;</span>

<span class="nc bnc" id="L1530" title="All 2 branches missed.">    if (vector.length &lt;= 1) {</span>
<span class="nc" id="L1531">      return 0;</span>
    }
<span class="nc bnc" id="L1533" title="All 2 branches missed.">    for (int i = 0; i &lt; vector.length; i++) {</span>
<span class="nc" id="L1534">      sum += vector[i];</span>
<span class="nc" id="L1535">      sumSquared += (vector[i] * vector[i]);</span>
    }
<span class="nc" id="L1537">    double result = (sumSquared - (sum * sum / vector.length))</span>
<span class="nc" id="L1538">        / (vector.length - 1);</span>

    // We don't like negative variance
<span class="nc bnc" id="L1541" title="All 2 branches missed.">    if (result &lt; 0) {</span>
<span class="nc" id="L1542">      return 0;</span>
    } else {
<span class="nc" id="L1544">      return result;</span>
    }
  }

  /**
   * Computes the sum of the elements of an array of doubles.
   * 
   * @param doubles the array of double
   * @return the sum of the elements
   */
  public static/* @pure@ */double sum(double[] doubles) {

<span class="fc" id="L1556">    double sum = 0;</span>

<span class="fc bfc" id="L1558" title="All 2 branches covered.">    for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="fc" id="L1559">      sum += doubles[i];</span>
    }
<span class="fc" id="L1561">    return sum;</span>
  }

  /**
   * Computes the sum of the elements of an array of integers.
   * 
   * @param ints the array of integers
   * @return the sum of the elements
   */
  public static/* @pure@ */int sum(int[] ints) {

<span class="fc" id="L1572">    int sum = 0;</span>

<span class="fc bfc" id="L1574" title="All 2 branches covered.">    for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="fc" id="L1575">      sum += ints[i];</span>
    }
<span class="fc" id="L1577">    return sum;</span>
  }

  /**
   * Returns c*log2(c) for a given integer value c.
   * 
   * @param c an integer value
   * @return c*log2(c) (but is careful to return 0 if c is 0)
   */
  public static/* @pure@ */double xlogx(int c) {

<span class="nc bnc" id="L1588" title="All 2 branches missed.">    if (c == 0) {</span>
<span class="nc" id="L1589">      return 0.0;</span>
    }
<span class="nc" id="L1591">    return c * Utils.log2(c);</span>
  }

  /**
   * Initial index, filled with values from 0 to size - 1.
   */
  private static int[] initialIndex(int size) {

<span class="fc" id="L1599">    int[] index = new int[size];</span>
<span class="fc bfc" id="L1600" title="All 2 branches covered.">    for (int i = 0; i &lt; size; i++) {</span>
<span class="fc" id="L1601">      index[i] = i;</span>
    }
<span class="fc" id="L1603">    return index;</span>
  }

  /**
   * Sorts left, right, and center elements only, returns resulting center as
   * pivot.
   */
  private static int sortLeftRightAndCenter(double[] array, int[] index, int l,
      int r) {

<span class="fc" id="L1613">    int c = (l + r) / 2;</span>
<span class="fc" id="L1614">    conditionalSwap(array, index, l, c);</span>
<span class="fc" id="L1615">    conditionalSwap(array, index, l, r);</span>
<span class="fc" id="L1616">    conditionalSwap(array, index, c, r);</span>
<span class="fc" id="L1617">    return c;</span>
  }

  /**
   * Swaps two elements in the given integer array.
   */
  private static void swap(int[] index, int l, int r) {

<span class="fc" id="L1625">    int help = index[l];</span>
<span class="fc" id="L1626">    index[l] = index[r];</span>
<span class="fc" id="L1627">    index[r] = help;</span>
<span class="fc" id="L1628">  }</span>

  /**
   * Conditional swap for quick sort.
   */
  private static void conditionalSwap(double[] array, int[] index, int left,
      int right) {

<span class="fc bfc" id="L1636" title="All 2 branches covered.">    if (array[index[left]] &gt; array[index[right]]) {</span>
<span class="fc" id="L1637">      int help = index[left];</span>
<span class="fc" id="L1638">      index[left] = index[right];</span>
<span class="fc" id="L1639">      index[right] = help;</span>
    }
<span class="fc" id="L1641">  }</span>

  /**
   * Partitions the instances around a pivot. Used by quicksort and
   * kthSmallestValue.
   * 
   * @param array the array of doubles to be sorted
   * @param index the index into the array of doubles
   * @param l the first index of the subset
   * @param r the last index of the subset
   * 
   * @return the index of the middle element
   */
  private static int partition(double[] array, int[] index, int l, int r,
      double pivot) {

<span class="fc" id="L1657">    r--;</span>
<span class="fc" id="L1658">    while (true) {</span>
<span class="fc bfc" id="L1659" title="All 2 branches covered.">      while ((array[index[++l]] &lt; pivot))</span>
        ;
<span class="fc bfc" id="L1661" title="All 2 branches covered.">      while ((array[index[--r]] &gt; pivot))</span>
        ;
<span class="fc bfc" id="L1663" title="All 2 branches covered.">      if (l &gt;= r) {</span>
<span class="fc" id="L1664">        return l;</span>
      }
<span class="fc" id="L1666">      swap(index, l, r);</span>
    }
  }

  /**
   * Partitions the instances around a pivot. Used by quicksort and
   * kthSmallestValue.
   * 
   * @param array the array of integers to be sorted
   * @param index the index into the array of integers
   * @param l the first index of the subset
   * @param r the last index of the subset
   * 
   * @return the index of the middle element
   */
  private static int partition(int[] array, int[] index, int l, int r) {

<span class="fc" id="L1683">    double pivot = array[index[(l + r) / 2]];</span>
    int help;

<span class="fc bfc" id="L1686" title="All 2 branches covered.">    while (l &lt; r) {</span>
<span class="fc bfc" id="L1687" title="All 4 branches covered.">      while ((array[index[l]] &lt; pivot) &amp;&amp; (l &lt; r)) {</span>
<span class="fc" id="L1688">        l++;</span>
      }
<span class="pc bpc" id="L1690" title="1 of 4 branches missed.">      while ((array[index[r]] &gt; pivot) &amp;&amp; (l &lt; r)) {</span>
<span class="fc" id="L1691">        r--;</span>
      }
<span class="fc bfc" id="L1693" title="All 2 branches covered.">      if (l &lt; r) {</span>
<span class="fc" id="L1694">        help = index[l];</span>
<span class="fc" id="L1695">        index[l] = index[r];</span>
<span class="fc" id="L1696">        index[r] = help;</span>
<span class="fc" id="L1697">        l++;</span>
<span class="fc" id="L1698">        r--;</span>
      }
    }
<span class="fc bfc" id="L1701" title="All 4 branches covered.">    if ((l == r) &amp;&amp; (array[index[r]] &gt; pivot)) {</span>
<span class="fc" id="L1702">      r--;</span>
    }

<span class="fc" id="L1705">    return r;</span>
  }

  /**
   * Implements quicksort with median-of-three method and explicit sort for
   * problems of size three or less.
   * 
   * @param array the array of doubles to be sorted
   * @param index the index into the array of doubles
   * @param left the first index of the subset to be sorted
   * @param right the last index of the subset to be sorted
   */
  // @ requires 0 &lt;= first &amp;&amp; first &lt;= right &amp;&amp; right &lt; array.length;
  // @ requires (\forall int i; 0 &lt;= i &amp;&amp; i &lt; index.length; 0 &lt;= index[i] &amp;&amp;
  // index[i] &lt; array.length);
  // @ requires array != index;
  // assignable index;
  private static void quickSort(/* @non_null@ */double[] array, /* @non_null@ */
      int[] index, int left, int right) {

<span class="fc" id="L1725">    int diff = right - left;</span>

<span class="fc bfc" id="L1727" title="All 4 branches covered.">    switch (diff) {</span>
    case 0:

      // No need to do anything
<span class="fc" id="L1731">      return;</span>
    case 1:

      // Swap two elements if necessary
<span class="fc" id="L1735">      conditionalSwap(array, index, left, right);</span>
<span class="fc" id="L1736">      return;</span>
    case 2:

      // Just need to sort three elements
<span class="fc" id="L1740">      conditionalSwap(array, index, left, left + 1);</span>
<span class="fc" id="L1741">      conditionalSwap(array, index, left, right);</span>
<span class="fc" id="L1742">      conditionalSwap(array, index, left + 1, right);</span>
<span class="fc" id="L1743">      return;</span>
    default:

      // Establish pivot
<span class="fc" id="L1747">      int pivotLocation = sortLeftRightAndCenter(array, index, left, right);</span>

      // Move pivot to the right, partition, and restore pivot
<span class="fc" id="L1750">      swap(index, pivotLocation, right - 1);</span>
<span class="fc" id="L1751">      int center = partition(array, index, left, right, array[index[right - 1]]);</span>
<span class="fc" id="L1752">      swap(index, center, right - 1);</span>

      // Sort recursively
<span class="fc" id="L1755">      quickSort(array, index, left, center - 1);</span>
<span class="fc" id="L1756">      quickSort(array, index, center + 1, right);</span>
    }
<span class="fc" id="L1758">  }</span>

  /**
   * Implements quicksort according to Manber's &quot;Introduction to Algorithms&quot;.
   * 
   * @param array the array of integers to be sorted
   * @param index the index into the array of integers
   * @param left the first index of the subset to be sorted
   * @param right the last index of the subset to be sorted
   */
  // @ requires 0 &lt;= first &amp;&amp; first &lt;= right &amp;&amp; right &lt; array.length;
  // @ requires (\forall int i; 0 &lt;= i &amp;&amp; i &lt; index.length; 0 &lt;= index[i] &amp;&amp;
  // index[i] &lt; array.length);
  // @ requires array != index;
  // assignable index;
  private static void quickSort(/* @non_null@ */int[] array, /* @non_null@ */
      int[] index, int left, int right) {

<span class="fc bfc" id="L1776" title="All 2 branches covered.">    if (left &lt; right) {</span>
<span class="fc" id="L1777">      int middle = partition(array, index, left, right);</span>
<span class="fc" id="L1778">      quickSort(array, index, left, middle);</span>
<span class="fc" id="L1779">      quickSort(array, index, middle + 1, right);</span>
    }
<span class="fc" id="L1781">  }</span>

  /**
   * Implements computation of the kth-smallest element according to Manber's
   * &quot;Introduction to Algorithms&quot;.
   * 
   * @param array the array of double
   * @param index the index into the array of doubles
   * @param left the first index of the subset
   * @param right the last index of the subset
   * @param k the value of k
   * 
   * @return the index of the kth-smallest element
   */
  // @ requires 0 &lt;= first &amp;&amp; first &lt;= right &amp;&amp; right &lt; array.length;
  private static int select(/* @non_null@ */double[] array, /* @non_null@ */
      int[] index, int left, int right, int k) {

<span class="nc" id="L1799">    int diff = right - left;</span>
<span class="nc bnc" id="L1800" title="All 4 branches missed.">    switch (diff) {</span>
    case 0:

      // Nothing to be done
<span class="nc" id="L1804">      return left;</span>
    case 1:

      // Swap two elements if necessary
<span class="nc" id="L1808">      conditionalSwap(array, index, left, right);</span>
<span class="nc" id="L1809">      return left + k - 1;</span>
    case 2:

      // Just need to sort three elements
<span class="nc" id="L1813">      conditionalSwap(array, index, left, left + 1);</span>
<span class="nc" id="L1814">      conditionalSwap(array, index, left, right);</span>
<span class="nc" id="L1815">      conditionalSwap(array, index, left + 1, right);</span>
<span class="nc" id="L1816">      return left + k - 1;</span>
    default:

      // Establish pivot
<span class="nc" id="L1820">      int pivotLocation = sortLeftRightAndCenter(array, index, left, right);</span>

      // Move pivot to the right, partition, and restore pivot
<span class="nc" id="L1823">      swap(index, pivotLocation, right - 1);</span>
<span class="nc" id="L1824">      int center = partition(array, index, left, right, array[index[right - 1]]);</span>
<span class="nc" id="L1825">      swap(index, center, right - 1);</span>

      // Proceed recursively
<span class="nc bnc" id="L1828" title="All 2 branches missed.">      if ((center - left + 1) &gt;= k) {</span>
<span class="nc" id="L1829">        return select(array, index, left, center, k);</span>
      } else {
<span class="nc" id="L1831">        return select(array, index, center + 1, right, k - (center - left + 1));</span>
      }
    }
  }

  /**
   * Converts a File's absolute path to a path relative to the user (ie start)
   * directory. Includes an additional workaround for Cygwin, which doesn't like
   * upper case drive letters.
   * 
   * @param absolute the File to convert to relative path
   * @return a File with a path that is relative to the user's directory
   * @exception Exception if the path cannot be constructed
   */
  public static File convertToRelativePath(File absolute) throws Exception {
    File result;
    String fileStr;

<span class="nc" id="L1849">    result = null;</span>

    // if we're running windows, it could be Cygwin
<span class="nc bnc" id="L1852" title="All 2 branches missed.">    if (File.separator.equals(&quot;\\&quot;)) {</span>
      // Cygwin doesn't like upper case drives -&gt; try lower case drive
      try {
<span class="nc" id="L1855">        fileStr = absolute.getPath();</span>
<span class="nc" id="L1856">        fileStr = fileStr.substring(0, 1).toLowerCase() + fileStr.substring(1);</span>
<span class="nc" id="L1857">        result = createRelativePath(new File(fileStr));</span>
<span class="nc" id="L1858">      } catch (Exception e) {</span>
        // no luck with Cygwin workaround, convert it like it is
<span class="nc" id="L1860">        result = createRelativePath(absolute);</span>
      }
    } else {
<span class="nc" id="L1863">      result = createRelativePath(absolute);</span>
    }

<span class="nc" id="L1866">    return result;</span>
  }

  /**
   * Converts a File's absolute path to a path relative to the user (ie start)
   * directory.
   * 
   * @param absolute the File to convert to relative path
   * @return a File with a path that is relative to the user's directory
   * @exception Exception if the path cannot be constructed
   */
  protected static File createRelativePath(File absolute) throws Exception {
<span class="nc" id="L1878">    File userDir = new File(System.getProperty(&quot;user.dir&quot;));</span>
<span class="nc" id="L1879">    String userPath = userDir.getAbsolutePath() + File.separator;</span>
<span class="nc" id="L1880">    String targetPath = (new File(absolute.getParent())).getPath()</span>
<span class="nc" id="L1881">        + File.separator;</span>
<span class="nc" id="L1882">    String fileName = absolute.getName();</span>
<span class="nc" id="L1883">    StringBuffer relativePath = new StringBuffer();</span>
    // relativePath.append(&quot;.&quot;+File.separator);
    // System.err.println(&quot;User dir &quot;+userPath);
    // System.err.println(&quot;Target path &quot;+targetPath);

    // file is in user dir (or subdir)
<span class="nc" id="L1889">    int subdir = targetPath.indexOf(userPath);</span>
<span class="nc bnc" id="L1890" title="All 2 branches missed.">    if (subdir == 0) {</span>
<span class="nc bnc" id="L1891" title="All 2 branches missed.">      if (userPath.length() == targetPath.length()) {</span>
<span class="nc" id="L1892">        relativePath.append(fileName);</span>
      } else {
<span class="nc" id="L1894">        int ll = userPath.length();</span>
<span class="nc" id="L1895">        relativePath.append(targetPath.substring(ll));</span>
<span class="nc" id="L1896">        relativePath.append(fileName);</span>
      }
    } else {
<span class="nc" id="L1899">      int sepCount = 0;</span>
<span class="nc" id="L1900">      String temp = new String(userPath);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">      while (temp.indexOf(File.separator) != -1) {</span>
<span class="nc" id="L1902">        int ind = temp.indexOf(File.separator);</span>
<span class="nc" id="L1903">        sepCount++;</span>
<span class="nc" id="L1904">        temp = temp.substring(ind + 1, temp.length());</span>
      }

<span class="nc" id="L1907">      String targetTemp = new String(targetPath);</span>
<span class="nc" id="L1908">      String userTemp = new String(userPath);</span>
<span class="nc" id="L1909">      int tcount = 0;</span>
<span class="nc bnc" id="L1910" title="All 2 branches missed.">      while (targetTemp.indexOf(File.separator) != -1) {</span>
<span class="nc" id="L1911">        int ind = targetTemp.indexOf(File.separator);</span>
<span class="nc" id="L1912">        int ind2 = userTemp.indexOf(File.separator);</span>
<span class="nc" id="L1913">        String tpart = targetTemp.substring(0, ind + 1);</span>
<span class="nc" id="L1914">        String upart = userTemp.substring(0, ind2 + 1);</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">        if (tpart.compareTo(upart) != 0) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">          if (tcount == 0) {</span>
<span class="nc" id="L1917">            tcount = -1;</span>
          }
<span class="nc" id="L1919">          break;</span>
        }
<span class="nc" id="L1921">        tcount++;</span>
<span class="nc" id="L1922">        targetTemp = targetTemp.substring(ind + 1, targetTemp.length());</span>
<span class="nc" id="L1923">        userTemp = userTemp.substring(ind2 + 1, userTemp.length());</span>
      }
<span class="nc bnc" id="L1925" title="All 2 branches missed.">      if (tcount == -1) {</span>
        // then target file is probably on another drive (under windows)
<span class="nc" id="L1927">        throw new Exception(&quot;Can't construct a path to file relative to user &quot;</span>
            + &quot;dir.&quot;);
      }
<span class="nc bnc" id="L1930" title="All 2 branches missed.">      if (targetTemp.indexOf(File.separator) == -1) {</span>
<span class="nc" id="L1931">        targetTemp = &quot;&quot;;</span>
      }
<span class="nc bnc" id="L1933" title="All 2 branches missed.">      for (int i = 0; i &lt; sepCount - tcount; i++) {</span>
<span class="nc" id="L1934">        relativePath.append(&quot;..&quot; + File.separator);</span>
      }
<span class="nc" id="L1936">      relativePath.append(targetTemp + fileName);</span>
    }
    // System.err.println(&quot;new path : &quot;+relativePath.toString());
<span class="nc" id="L1939">    return new File(relativePath.toString());</span>
  }

  /**
   * Implements computation of the kth-smallest element according to Manber's
   * &quot;Introduction to Algorithms&quot;.
   * 
   * @param array the array of integers
   * @param index the index into the array of integers
   * @param left the first index of the subset
   * @param right the last index of the subset
   * @param k the value of k
   * 
   * @return the index of the kth-smallest element
   */
  // @ requires 0 &lt;= first &amp;&amp; first &lt;= right &amp;&amp; right &lt; array.length;
  private static int select(/* @non_null@ */int[] array, /* @non_null@ */
      int[] index, int left, int right, int k) {

<span class="nc bnc" id="L1958" title="All 2 branches missed.">    if (left == right) {</span>
<span class="nc" id="L1959">      return left;</span>
    } else {
<span class="nc" id="L1961">      int middle = partition(array, index, left, right);</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">      if ((middle - left + 1) &gt;= k) {</span>
<span class="nc" id="L1963">        return select(array, index, left, middle, k);</span>
      } else {
<span class="nc" id="L1965">        return select(array, index, middle + 1, right, k - (middle - left + 1));</span>
      }
    }
  }

  /**
   * Returns the revision string.
   * 
   * @return the revision
   */
  public String getRevision() {
<span class="nc" id="L1976">    return RevisionUtils.extract(&quot;$Revision: 9737 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   * 
   * @param ops some dummy options
   */
  public static void main(String[] ops) {

<span class="nc" id="L1986">    double[] doublesWithNaN = { 4.5, 6.7, Double.NaN, 3.4, 4.8, 1.2, 3.4 };</span>
<span class="nc" id="L1987">    double[] doubles = { 4.5, 6.7, 6.7, 3.4, 4.8, 1.2, 3.4, 6.7, 6.7, 3.4 };</span>
<span class="nc" id="L1988">    int[] ints = { 12, 6, 2, 18, 16, 6, 7, 5, 18, 18, 17 };</span>

    try {

      // Option handling
<span class="nc" id="L1993">      System.out.println(&quot;First option split up:&quot;);</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">      if (ops.length &gt; 0) {</span>
<span class="nc" id="L1995">        String[] firstOptionSplitUp = Utils.splitOptions(ops[0]);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        for (int i = 0; i &lt; firstOptionSplitUp.length; i++) {</span>
<span class="nc" id="L1997">          System.out.println(firstOptionSplitUp[i]);</span>
        }
      }
<span class="nc" id="L2000">      System.out.println(&quot;Partitioned options: &quot;);</span>
<span class="nc" id="L2001">      String[] partitionedOptions = Utils.partitionOptions(ops);</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">      for (int i = 0; i &lt; partitionedOptions.length; i++) {</span>
<span class="nc" id="L2003">        System.out.println(partitionedOptions[i]);</span>
      }
<span class="nc" id="L2005">      System.out.println(&quot;Get position of flag -f: &quot;</span>
<span class="nc" id="L2006">          + Utils.getOptionPos('f', ops));</span>
<span class="nc" id="L2007">      System.out.println(&quot;Get flag -f: &quot; + Utils.getFlag('f', ops));</span>
<span class="nc" id="L2008">      System.out.println(&quot;Get position of option -o: &quot;</span>
<span class="nc" id="L2009">          + Utils.getOptionPos('o', ops));</span>
<span class="nc" id="L2010">      System.out.println(&quot;Get option -o: &quot; + Utils.getOption('o', ops));</span>
<span class="nc" id="L2011">      System.out.println(&quot;Checking for remaining options... &quot;);</span>
<span class="nc" id="L2012">      Utils.checkForRemainingOptions(ops);</span>

      // Statistics
<span class="nc" id="L2015">      System.out.println(&quot;Original array with NaN (doubles): &quot;);</span>
<span class="nc bnc" id="L2016" title="All 2 branches missed.">      for (int i = 0; i &lt; doublesWithNaN.length; i++) {</span>
<span class="nc" id="L2017">        System.out.print(doublesWithNaN[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2019">      System.out.println();</span>
<span class="nc" id="L2020">      System.out.println(&quot;Original array (doubles): &quot;);</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">      for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="nc" id="L2022">        System.out.print(doubles[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2024">      System.out.println();</span>
<span class="nc" id="L2025">      System.out.println(&quot;Original array (ints): &quot;);</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">      for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="nc" id="L2027">        System.out.print(ints[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2029">      System.out.println();</span>
<span class="nc" id="L2030">      System.out.println(&quot;Correlation: &quot;</span>
<span class="nc" id="L2031">          + Utils.correlation(doubles, doubles, doubles.length));</span>
<span class="nc" id="L2032">      System.out.println(&quot;Mean: &quot; + Utils.mean(doubles));</span>
<span class="nc" id="L2033">      System.out.println(&quot;Variance: &quot; + Utils.variance(doubles));</span>
<span class="nc" id="L2034">      System.out.println(&quot;Sum (doubles): &quot; + Utils.sum(doubles));</span>
<span class="nc" id="L2035">      System.out.println(&quot;Sum (ints): &quot; + Utils.sum(ints));</span>
<span class="nc" id="L2036">      System.out.println(&quot;Max index (doubles): &quot; + Utils.maxIndex(doubles));</span>
<span class="nc" id="L2037">      System.out.println(&quot;Max index (ints): &quot; + Utils.maxIndex(ints));</span>
<span class="nc" id="L2038">      System.out.println(&quot;Min index (doubles): &quot; + Utils.minIndex(doubles));</span>
<span class="nc" id="L2039">      System.out.println(&quot;Min index (ints): &quot; + Utils.minIndex(ints));</span>
<span class="nc" id="L2040">      System.out.println(&quot;Median (doubles): &quot;</span>
<span class="nc" id="L2041">          + Utils.kthSmallestValue(doubles, doubles.length / 2));</span>
<span class="nc" id="L2042">      System.out.println(&quot;Median (ints): &quot;</span>
<span class="nc" id="L2043">          + Utils.kthSmallestValue(ints, ints.length / 2));</span>

      // Sorting and normalizing
<span class="nc" id="L2046">      System.out.println(&quot;Sorted array with NaN (doubles): &quot;);</span>
<span class="nc" id="L2047">      int[] sorted = Utils.sort(doublesWithNaN);</span>
<span class="nc bnc" id="L2048" title="All 2 branches missed.">      for (int i = 0; i &lt; doublesWithNaN.length; i++) {</span>
<span class="nc" id="L2049">        System.out.print(doublesWithNaN[sorted[i]] + &quot; &quot;);</span>
      }
<span class="nc" id="L2051">      System.out.println();</span>
<span class="nc" id="L2052">      System.out.println(&quot;Sorted array (doubles): &quot;);</span>
<span class="nc" id="L2053">      sorted = Utils.sort(doubles);</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">      for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="nc" id="L2055">        System.out.print(doubles[sorted[i]] + &quot; &quot;);</span>
      }
<span class="nc" id="L2057">      System.out.println();</span>
<span class="nc" id="L2058">      System.out.println(&quot;Sorted array (ints): &quot;);</span>
<span class="nc" id="L2059">      sorted = Utils.sort(ints);</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">      for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="nc" id="L2061">        System.out.print(ints[sorted[i]] + &quot; &quot;);</span>
      }
<span class="nc" id="L2063">      System.out.println();</span>
<span class="nc" id="L2064">      System.out.println(&quot;Indices from stable sort (doubles): &quot;);</span>
<span class="nc" id="L2065">      sorted = Utils.stableSort(doubles);</span>
<span class="nc bnc" id="L2066" title="All 2 branches missed.">      for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="nc" id="L2067">        System.out.print(sorted[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2069">      System.out.println();</span>
<span class="nc" id="L2070">      System.out.println(&quot;Indices from sort (ints): &quot;);</span>
<span class="nc" id="L2071">      sorted = Utils.sort(ints);</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">      for (int i = 0; i &lt; ints.length; i++) {</span>
<span class="nc" id="L2073">        System.out.print(sorted[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2075">      System.out.println();</span>
<span class="nc" id="L2076">      System.out.println(&quot;Normalized array (doubles): &quot;);</span>
<span class="nc" id="L2077">      Utils.normalize(doubles);</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">      for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="nc" id="L2079">        System.out.print(doubles[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2081">      System.out.println();</span>
<span class="nc" id="L2082">      System.out.println(&quot;Normalized again (doubles): &quot;);</span>
<span class="nc" id="L2083">      Utils.normalize(doubles, Utils.sum(doubles));</span>
<span class="nc bnc" id="L2084" title="All 2 branches missed.">      for (int i = 0; i &lt; doubles.length; i++) {</span>
<span class="nc" id="L2085">        System.out.print(doubles[i] + &quot; &quot;);</span>
      }
<span class="nc" id="L2087">      System.out.println();</span>

      // Pretty-printing
<span class="nc" id="L2090">      System.out.println(&quot;-4.58: &quot; + Utils.doubleToString(-4.57826535, 2));</span>
<span class="nc" id="L2091">      System.out.println(&quot;-6.78: &quot; + Utils.doubleToString(-6.78214234, 6, 2));</span>

      // Comparisons
<span class="nc" id="L2094">      System.out.println(&quot;5.70001 == 5.7 ? &quot; + Utils.eq(5.70001, 5.7));</span>
<span class="nc" id="L2095">      System.out.println(&quot;5.70001 &gt; 5.7 ? &quot; + Utils.gr(5.70001, 5.7));</span>
<span class="nc" id="L2096">      System.out.println(&quot;5.70001 &gt;= 5.7 ? &quot; + Utils.grOrEq(5.70001, 5.7));</span>
<span class="nc" id="L2097">      System.out.println(&quot;5.7 &lt; 5.70001 ? &quot; + Utils.sm(5.7, 5.70001));</span>
<span class="nc" id="L2098">      System.out.println(&quot;5.7 &lt;= 5.70001 ? &quot; + Utils.smOrEq(5.7, 5.70001));</span>

      // Math
<span class="nc" id="L2101">      System.out.println(&quot;Info (ints): &quot; + Utils.info(ints));</span>
<span class="nc" id="L2102">      System.out.println(&quot;log2(4.6): &quot; + Utils.log2(4.6));</span>
<span class="nc" id="L2103">      System.out.println(&quot;5 * log(5): &quot; + Utils.xlogx(5));</span>
<span class="nc" id="L2104">      System.out.println(&quot;5.5 rounded: &quot; + Utils.round(5.5));</span>
<span class="nc" id="L2105">      System.out.println(&quot;5.55555 rounded to 2 decimal places: &quot;</span>
<span class="nc" id="L2106">          + Utils.roundDouble(5.55555, 2));</span>

      // Arrays
<span class="nc" id="L2109">      System.out.println(&quot;Array-Dimensions of 'new int[][]': &quot;</span>
<span class="nc" id="L2110">          + Utils.getArrayDimensions(new int[][] {}));</span>
<span class="nc" id="L2111">      System.out.println(&quot;Array-Dimensions of 'new int[][]{{1,2,3},{4,5,6}}': &quot;</span>
<span class="nc" id="L2112">          + Utils.getArrayDimensions(new int[][] { { 1, 2, 3 }, { 4, 5, 6 } }));</span>
<span class="nc" id="L2113">      String[][][] s = new String[3][4][];</span>
<span class="nc" id="L2114">      System.out.println(&quot;Array-Dimensions of 'new String[3][4][]': &quot;</span>
<span class="nc" id="L2115">          + Utils.getArrayDimensions(s));</span>
<span class="nc" id="L2116">    } catch (Exception e) {</span>
<span class="nc" id="L2117">      e.printStackTrace();</span>
    }
<span class="nc" id="L2119">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>