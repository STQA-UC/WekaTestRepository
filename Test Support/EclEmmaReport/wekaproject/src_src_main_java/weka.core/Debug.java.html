<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Debug.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core</a> &gt; <span class="el_source">Debug.java</span></div><h1>Debug.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * Debug.java
 * Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 */

package weka.core;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.logging.FileHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * A helper class for debug output, logging, clocking, etc.
 * 
 * @author  fracpete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 7519 $
 */
<span class="fc" id="L45">public class Debug</span>
  implements Serializable, RevisionHandler {

  /** for serialization */
  private static final long serialVersionUID = 66171861743328020L;
  
  /** the log level All */
<span class="fc" id="L52">  public final static Level ALL = Level.ALL;</span>
  /** the log level Vonfig */
<span class="fc" id="L54">  public final static Level CONFIG = Level.CONFIG;</span>
  /** the log level Fine */
<span class="fc" id="L56">  public final static Level FINE = Level.FINE;</span>
  /** the log level Finer */
<span class="fc" id="L58">  public final static Level FINER = Level.FINER;</span>
  /** the log level Finest */
<span class="fc" id="L60">  public final static Level FINEST = Level.FINEST;</span>
  /** the log level Info */
<span class="fc" id="L62">  public final static Level INFO = Level.INFO;</span>
  /** the log level Off - i.e., no logging */
<span class="fc" id="L64">  public final static Level OFF = Level.OFF;</span>
  /** the log level Severe */
<span class="fc" id="L66">  public final static Level SEVERE = Level.SEVERE;</span>
  /** the log level Warning */
<span class="fc" id="L68">  public final static Level WARNING = Level.WARNING;</span>

  /** whether logging is enabled */
<span class="nc" id="L71">  protected boolean m_Enabled = true;</span>
  
  /** for logging */
  protected Log m_Log;
  
  /** for clocking */
<span class="nc" id="L77">  protected Clock m_Clock = new Clock();</span>
  
  /**
   * A little helper class for clocking and outputting times. It measures the
   * CPU time if possible, otherwise it's just based on the system time. In 
   * case one just wants to measure time (e.g., database queries don't take up
   * much CPU time, but still might take a long time to finish), then one can
   * disable the use of CPU time as well.
   *
   * @author FracPete (fracpete at waikato dot ac dot nz)
   * @version $Revision: 7519 $ 
   * @see ThreadMXBean#isThreadCpuTimeEnabled()
   */
<span class="fc" id="L90">  public static class Clock </span>
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    private static final long serialVersionUID = 4622161807307942201L;
    
    /** the output format in milli-seconds */
    public final static int FORMAT_MILLISECONDS = 0;
    
    /** the output format in seconds, with fraction of msecs */
    public final static int FORMAT_SECONDS = 1;
    
    /** the output format in hours:minutes:seconds, with fraction of msecs */
    public final static int FORMAT_HHMMSS = 2;
    
    /** the output formats */
<span class="fc" id="L106">    public static final Tag[] TAGS_FORMAT = {</span>
<span class="fc" id="L107">      new Tag(FORMAT_MILLISECONDS, &quot;milli-seconds&quot;),</span>
<span class="fc" id="L108">      new Tag(FORMAT_SECONDS, &quot;seconds&quot;),</span>
<span class="fc" id="L109">      new Tag(FORMAT_HHMMSS, &quot;hh:mm:ss&quot;)</span>
    };
    
    /** the format of the output */
<span class="nc" id="L113">    public int m_OutputFormat = FORMAT_SECONDS;</span>
    
    /** the start time */
    protected long m_Start;
    
    /** the end time */
    protected long m_Stop;
    
    /** whether the time is still clocked */
    protected boolean m_Running;
    
    /** the thread ID */
    protected long m_ThreadID;
    
    /** whether the system can measure the CPU time */
    protected boolean m_CanMeasureCpuTime;
    
    /** whether to use the CPU time (by default TRUE) */
    protected boolean m_UseCpuTime;
    
    /** the thread monitor, if the system can measure the CPU time */
    protected transient ThreadMXBean m_ThreadMonitor;
    
    /**
     * automatically starts the clock with FORMAT_SECONDS format and CPU
     * time if available
     * 
     * @see		#m_OutputFormat
     */
    public Clock() {
<span class="nc" id="L143">      this(true);</span>
<span class="nc" id="L144">    }</span>
    
    /**
     * automatically starts the clock with the given output format and CPU
     * time if available
     * 
     * @param format	the output format
     * @see		#m_OutputFormat
     */
    public Clock(int format) {
<span class="nc" id="L154">      this(true, format);</span>
<span class="nc" id="L155">    }</span>
    
    /**
     * starts the clock depending on &lt;code&gt;start&lt;/code&gt; immediately with the
     * FORMAT_SECONDS output format and CPU time if available
     * 
     * @param start	whether to start the clock immediately
     * @see		#m_OutputFormat
     */
    public Clock(boolean start) {
<span class="nc" id="L165">      this(start, FORMAT_SECONDS);</span>
<span class="nc" id="L166">    }</span>
    
    /**
     * starts the clock depending on &lt;code&gt;start&lt;/code&gt; immediately, using
     * CPU time if available
     * 
     * @param start	whether to start the clock immediately
     * @param format	the format
     * @see		#m_OutputFormat
     */
<span class="nc" id="L176">    public Clock(boolean start, int format) {</span>
<span class="nc" id="L177">      m_Running    = false;</span>
<span class="nc" id="L178">      m_Start      = 0;</span>
<span class="nc" id="L179">      m_Stop       = 0;</span>
<span class="nc" id="L180">      m_UseCpuTime = true;</span>
<span class="nc" id="L181">      setOutputFormat(format);</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">      if (start)</span>
<span class="nc" id="L184">	start();</span>
<span class="nc" id="L185">    }</span>
    
    /**
     * initializes the clocking, ensure to get the correct thread ID.
     */
    protected void init() {
<span class="nc" id="L191">      m_ThreadMonitor = null;</span>
<span class="nc" id="L192">      m_ThreadMonitor = getThreadMonitor();</span>

      // can we measure cpu time?
<span class="nc" id="L195">      m_CanMeasureCpuTime = m_ThreadMonitor.isThreadCpuTimeSupported();</span>
<span class="nc" id="L196">    }</span>
    
    /**
     * whether the measurement is based on the msecs returned from the System
     * class or on the more accurate CPU time. Also depends on whether the 
     * usage of the CPU time was disabled or enabled.
     * 
     * @return		true if the more accurate CPU time of the thread is 
     * 			used and the use of CPU time hasn't been disabled
     * @see System#currentTimeMillis()
     * @see ThreadMXBean#isThreadCpuTimeEnabled()
     * @see #getUseCpuTime()
     */
    public boolean isCpuTime() {
<span class="nc bnc" id="L210" title="All 4 branches missed.">      return m_UseCpuTime &amp;&amp; m_CanMeasureCpuTime;</span>
    }

    /**
     * enables/disables the use of CPU time (if measurement of CPU time is 
     * available). The actual use of CPU time still depends on whether the 
     * system supports it. Resets the current timer, if running.
     * 
     * @param value	if true the CPU time is used (if possible)
     */
    public void setUseCpuTime(boolean value) {
<span class="nc" id="L221">      m_UseCpuTime = value;</span>
      
      // we have to re-initialize the start time, otherwise we get bogus
      // results
<span class="nc bnc" id="L225" title="All 2 branches missed.">      if (m_Running) {</span>
<span class="nc" id="L226">	stop();</span>
<span class="nc" id="L227">	start();</span>
      }
<span class="nc" id="L229">    }</span>

    /**
     * returns whether the use of CPU is time is enabled/disabled (regardless
     * whether the system supports it or not)
     * 
     * @return		true the CPU time is used (if possible)
     */
    public boolean getUseCpuTime() {
<span class="nc" id="L238">      return m_UseCpuTime;</span>
    }
    
    /**
     * Returns a new thread monitor if the current one is null (e.g., due to
     * serialization) or the currently set one. The thread ID is also updated
     * if necessary.
     * 
     * @return		the thread monitor to use
     */
    protected ThreadMXBean getThreadMonitor() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">      if (m_ThreadMonitor == null) {</span>
<span class="nc" id="L250">	m_ThreadMonitor = ManagementFactory.getThreadMXBean();</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">	if (m_CanMeasureCpuTime &amp;&amp; !m_ThreadMonitor.isThreadCpuTimeEnabled())</span>
<span class="nc" id="L252">	  m_ThreadMonitor.setThreadCpuTimeEnabled(true);</span>
<span class="nc" id="L253">	m_ThreadID = Thread.currentThread().getId();</span>
      }
      
<span class="nc" id="L256">      return m_ThreadMonitor;</span>
    }
    
    /**
     * returns the current time in msec
     * 
     * @return		the current time
     */
    protected long getCurrentTime() {
      long	result;
      
<span class="nc bnc" id="L267" title="All 2 branches missed.">      if (isCpuTime())</span>
<span class="nc" id="L268">	result = getThreadMonitor().getThreadUserTime(m_ThreadID) / 1000000;</span>
      else
<span class="nc" id="L270">	result = System.currentTimeMillis();</span>
      
<span class="nc" id="L272">      return result;</span>
    }
    
    /**
     * saves the current system time (or CPU time) in msec as start time
     * 
     * @see       #m_Start
     */
    public void start() {
      // make sure that we get the right thread ID!
<span class="nc" id="L282">      init();</span>

<span class="nc" id="L284">      m_Start   = getCurrentTime();</span>
<span class="nc" id="L285">      m_Stop    = m_Start;</span>
<span class="nc" id="L286">      m_Running = true;</span>
<span class="nc" id="L287">    }</span>
    
    /**
     * saves the current system (or CPU time) in msec as stop time
     * 
     * @see       #m_Stop
     */
    public void stop() {
<span class="nc" id="L295">      m_Stop    = getCurrentTime();</span>
<span class="nc" id="L296">      m_Running = false;</span>
<span class="nc" id="L297">    }</span>
    
    /**
     * returns the start time
     * 
     * @return	the start time
     */
    public long getStart() {
<span class="nc" id="L305">      return m_Start;</span>
    }
    
    /**
     * returns the stop time or, if still running, the current time
     * 
     * @return 	the stop time
     */
    public long getStop() {
      long	result;
      
<span class="nc bnc" id="L316" title="All 2 branches missed.">      if (isRunning())</span>
<span class="nc" id="L317">	result = getCurrentTime();</span>
      else
<span class="nc" id="L319">	result = m_Stop;</span>
      
<span class="nc" id="L321">      return result;</span>
    }
    
    /**
     * whether the time is still being clocked
     * 
     * @return		true if the time is still being clocked
     */
    public boolean isRunning() {
<span class="nc" id="L330">      return m_Running;</span>
    }
    
    /**
     * sets the format of the output
     * 
     * @param value       the format of the output
     * @see               #m_OutputFormat
     */
    public void setOutputFormat(int value) {
<span class="nc bnc" id="L340" title="All 2 branches missed.">      if (value == FORMAT_MILLISECONDS)</span>
<span class="nc" id="L341">	m_OutputFormat = value;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">      else if (value == FORMAT_SECONDS)</span>
<span class="nc" id="L343">	m_OutputFormat = value;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">      else if (value == FORMAT_HHMMSS)</span>
<span class="nc" id="L345">	m_OutputFormat = value;</span>
      else
<span class="nc" id="L347">	System.out.println(&quot;Format '&quot; + value + &quot;' is not recognized!&quot;);</span>
<span class="nc" id="L348">    }</span>
    
    /**
     * returns the output format
     * 
     * @return		the output format
     * @see		#m_OutputFormat
     */
    public int getOutputFormat() {
<span class="nc" id="L357">      return m_OutputFormat;</span>
    }
    
    /**
     * returns the elapsed time, getStop() - getStart(), as string
     * 
     * @return	the elapsed time as string
     * @see       #getStart()
     * @see       #getStop()
     */
    public String toString() {
      String    result;
      long      elapsed;
      long      hours;
      long      mins;
      long      secs;
      long      msecs;
      
<span class="nc" id="L375">      result  = &quot;&quot;;</span>
<span class="nc" id="L376">      elapsed = getStop() - getStart();</span>
      
<span class="nc bnc" id="L378" title="All 4 branches missed.">      switch (getOutputFormat()) {</span>
	case FORMAT_HHMMSS:
<span class="nc" id="L380">	  hours   = elapsed / (3600 * 1000);</span>
<span class="nc" id="L381">	  elapsed = elapsed % (3600 * 1000);</span>
<span class="nc" id="L382">	  mins    = elapsed / (60 * 1000);</span>
<span class="nc" id="L383">	  elapsed = elapsed % (60 * 1000);</span>
<span class="nc" id="L384">	  secs    = elapsed / 1000;</span>
<span class="nc" id="L385">	  msecs   = elapsed % 1000;</span>
	  
<span class="nc bnc" id="L387" title="All 2 branches missed.">	  if (hours &gt; 0)</span>
<span class="nc" id="L388">	    result += &quot;&quot; + hours + &quot;:&quot;;</span>
	  
<span class="nc bnc" id="L390" title="All 2 branches missed.">	  if (mins &lt; 10)</span>
<span class="nc" id="L391">	    result += &quot;0&quot; + mins + &quot;:&quot;;</span>
	  else
<span class="nc" id="L393">	    result += &quot;&quot;  + mins + &quot;:&quot;;</span>
	  
<span class="nc bnc" id="L395" title="All 2 branches missed.">	  if (secs &lt; 10)</span>
<span class="nc" id="L396">	    result += &quot;0&quot; + secs + &quot;.&quot;;</span>
	  else
<span class="nc" id="L398">	    result += &quot;&quot; + secs + &quot;.&quot;;</span>
	  
<span class="nc" id="L400">	  result += Utils.doubleToString(</span>
<span class="nc" id="L401">	      (double) msecs / (double) 1000, 3).replaceAll(&quot;.*\\.&quot;, &quot;&quot;);</span>
<span class="nc" id="L402">	  break;</span>
	  
	case FORMAT_SECONDS:
<span class="nc" id="L405">	  result = Utils.doubleToString((double) elapsed / (double) 1000, 3) + &quot;s&quot;;</span>
<span class="nc" id="L406">	  break;</span>
	  
	case FORMAT_MILLISECONDS:
<span class="nc" id="L409">	  result = &quot;&quot; + elapsed + &quot;ms&quot;;</span>
<span class="nc" id="L410">	  break;</span>
	  
	default:
<span class="nc" id="L413">	  result = &quot;&lt;unknown time format&gt;&quot;;</span>
      }
      
<span class="nc" id="L416">      return result;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L425">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }
  
  /**
   * A class that can be used for timestamps in files, The toString() method
   * simply returns the associated Date object in a timestamp format. For
   * formatting options, see java.text.SimpleDateFormat.
   *
   * @author FracPete (fracpete at waikato dot ac dot nz)
   * @version $Revision: 7519 $ 
   * @see SimpleDateFormat
   */
  public static class Timestamp
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    private static final long serialVersionUID = -6099868388466922753L;

    /** the default format */
    public final static String DEFAULT_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;
    
    /** the actual date */
    protected Date m_Stamp;
    
    /** the format of the timestamp */
    protected String m_Format;
    
    /** handles the format of the output */
    protected SimpleDateFormat m_Formatter;
    
    /**
     * creates a timestamp with the current date and time and the default
     * format.
     */
    public Timestamp() {
<span class="nc" id="L461">      this(DEFAULT_FORMAT);</span>
<span class="nc" id="L462">    }</span>
    
    /**
     * creates a timestamp with the current date and time and the specified
     * format.
     * 
     * @param format	the format of the timestamp
     * @see		SimpleDateFormat
     */
    public Timestamp(String format) {
<span class="nc" id="L472">      this(new Date(), format);</span>
<span class="nc" id="L473">    }</span>
    
    /**
     * creates a timestamp with the given date and the default format.
     * 
     * @param stamp	the associated date/time for the timestamp
     */
    public Timestamp(Date stamp) {
<span class="nc" id="L481">      this(stamp, DEFAULT_FORMAT);</span>
<span class="nc" id="L482">    }</span>
    
    /**
     * creates a timestamp with the given date and format.
     * 
     * @param stamp	the associated date/time for the timestamp
     * @param format	the format of the timestamp
     * @see		SimpleDateFormat
     */
    public Timestamp(Date stamp, String format) {
<span class="nc" id="L492">      super();</span>
      
<span class="nc" id="L494">      m_Stamp = stamp;</span>
<span class="nc" id="L495">      setFormat(format);</span>
<span class="nc" id="L496">    }</span>
    
    /**
     * sets the format for the timestamp
     * 
     * @param value	the format string
     * @see		SimpleDateFormat
     */
    public void setFormat(String value) {
      try {
<span class="nc" id="L506">	m_Formatter = new SimpleDateFormat(value);</span>
<span class="nc" id="L507">	m_Format    = value;</span>
      }
<span class="nc" id="L509">      catch (Exception e) {</span>
<span class="nc" id="L510">	m_Formatter = new SimpleDateFormat(DEFAULT_FORMAT);</span>
<span class="nc" id="L511">	m_Format    = DEFAULT_FORMAT;</span>
      }
<span class="nc" id="L513">    }</span>
    
    /**
     * returns the current timestamp format
     * 
     * @return		the current format
     */
    public String getFormat() {
<span class="nc" id="L521">      return m_Format;</span>
    }
    
    /**
     * returns the associated date/time
     * 
     * @return		the timestamp value
     */
    public Date getStamp() {
<span class="nc" id="L530">      return m_Stamp;</span>
    }
    
    /**
     * returns the timestamp as string in the specified format
     * 
     * @return		the timestamp as string
     */
    public String toString() {
<span class="nc" id="L539">      return m_Formatter.format(getStamp());</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L548">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }
  
  /**
   * A little, simple helper class for logging stuff. Uses simple file access
   * and not the java.util.logging stuff (see Log for that). Uses the 
   * writeToFile methods of the Debug class.
   * 
   * @see Debug.Log
   * @see Debug#writeToFile(String, String)
   * @see Debug#writeToFile(String, String, boolean)
   */
  public static class SimpleLog 
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    private static final long serialVersionUID = -2671928223819510830L;
    
    /** the file to write to (if null then only stdout is used) */
<span class="nc" id="L568">    protected String m_Filename = null;</span>
    
    /**
     * default constructor, uses only stdout
     */
    public SimpleLog() {
<span class="nc" id="L574">      this(null);</span>
<span class="nc" id="L575">    }</span>
    
    /**
     * Creates a logger that writes into the specified file. Appends to the 
     * file by default.
     * 
     * @param filename	the file to write to, if null then only stdout is used
     */
    public SimpleLog(String filename) {
<span class="nc" id="L584">      this(filename, true);</span>
<span class="nc" id="L585">    }</span>
    
    /**
     * Creates a logger that writes into the specified file. Appends to the 
     * file by default.
     * 
     * @param filename	the file to write to, if null then only stdout is used
     * @param append	if false, the file will be deleted first
     */
    public SimpleLog(String filename, boolean append) {
<span class="nc" id="L595">      super();</span>
      
<span class="nc" id="L597">      m_Filename = filename;</span>
      
<span class="nc" id="L599">      Debug.writeToFile(m_Filename, &quot;--&gt; Log started&quot;, append);</span>
<span class="nc" id="L600">    }</span>
    
    /**
     * returns the filename of the log, can be null
     * 
     * @return		the filename of the log
     */
    public String getFilename() {
<span class="nc" id="L608">      return m_Filename;</span>
    }
    
    /**
     * logs the given message to the file
     * 
     * @param message	the message to log
     */
    public void log(String message) {
      String	log;
      
<span class="nc" id="L619">      log = new Timestamp() + &quot; &quot; + message;</span>
      
<span class="nc bnc" id="L621" title="All 2 branches missed.">      if (getFilename() != null)</span>
<span class="nc" id="L622">	Debug.writeToFile(getFilename(), log);</span>

<span class="nc" id="L624">      System.out.println(log);</span>
<span class="nc" id="L625">    }</span>
    
    /**
     * a convenience method for dumping the current system info in the 
     * log file
     * 
     * @see SystemInfo
     */
    public void logSystemInfo() {
<span class="nc" id="L634">      log(&quot;SystemInfo:\n&quot; + new SystemInfo().toString());</span>
<span class="nc" id="L635">    }</span>
    
    /**
     * returns a string representation of the logger
     * 
     * @return		a string representation of the logger
     */
    public String toString() {
      String	result;
      
<span class="nc" id="L645">      result =   &quot;Filename: &quot; + getFilename();</span>
      
<span class="nc" id="L647">      return result;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L656">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }
  
  /**
   * A helper class for logging stuff. Uses the java.util.logging
   * package. If this approach seems an &quot;overkill&quot; (it can create quite a few 
   * log files if used in different threads), one can use the 
   * Debug.SimpleLog class.
   *
   * @author FracPete (fracpete at waikato dot ac dot nz)
   * @version $Revision: 7519 $ 
   * @see Debug.SimpleLog
   */
  public static class Log
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    private static final long serialVersionUID = 1458435732111675823L;

    /** the actual logger, if null only stdout is used */
<span class="nc" id="L677">    protected transient Logger m_Logger = null;</span>
    
    /** the filename, if any */
<span class="nc" id="L680">    protected String m_Filename = null;</span>
    
    /** the size of the file (in bytes) */
    protected int m_Size;
    
    /** the number of files for rotating the logs */
    protected int m_NumFiles;

    /** whether the initialization of the logger failed */
<span class="nc" id="L689">    protected boolean m_LoggerInitFailed = false;</span>
    
    /**
     * default constructor, uses only stdout
     */
    public Log() {
<span class="nc" id="L695">      this(null);</span>
<span class="nc" id="L696">    }</span>
    
    /**
     * creates a logger that logs into the specified file, if null then only
     * stdout is used. It uses 1,000,000 bytes for file size and 1 file.
     * 
     * @param filename	the file to log into
     */
    public Log(String filename) {
<span class="nc" id="L705">      this(filename, 1000000, 1);</span>
<span class="nc" id="L706">    }</span>
    
    /**
     * creates a logger that logs into the specified file, if null then only
     * stdout is used.
     * 
     * @param filename	the file to log into
     * @param size	the size of the files in bytes
     * @param numFiles	the number of files for rotating
     */
<span class="nc" id="L716">    public Log(String filename, int size, int numFiles) {</span>
<span class="nc" id="L717">      m_Filename = filename;</span>
<span class="nc" id="L718">      m_Size     = size;</span>
<span class="nc" id="L719">      m_NumFiles = numFiles;</span>
<span class="nc" id="L720">    }</span>
    
    /**
     * initializes and returns the logger if necessary (e.g., due to 
     * serialization).
     * 
     * @return		the logger, can be null, e.g., if no filename provided
     */
    protected Logger getLogger() {
<span class="nc bnc" id="L729" title="All 4 branches missed.">      if ( (m_Logger == null) &amp;&amp; (!m_LoggerInitFailed) ) {</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">	if (m_Filename != null) {</span>
<span class="nc" id="L731">	  m_Logger = Logger.getLogger(m_Filename);</span>
<span class="nc" id="L732">	  Handler fh = null;</span>
	  try{	     
<span class="nc" id="L734">	    fh = new FileHandler(m_Filename, m_Size, m_NumFiles);</span>
<span class="nc" id="L735">	    fh.setFormatter(new SimpleFormatter());</span>
<span class="nc" id="L736">	    m_Logger.addHandler(fh);      </span>
<span class="nc" id="L737">	    m_LoggerInitFailed = false;</span>
	  }
<span class="nc" id="L739">	  catch(Exception e) {</span>
<span class="nc" id="L740">	    System.out.println(&quot;Cannot init fileHandler for logger:&quot; + e.toString());</span>
<span class="nc" id="L741">	    m_Logger = null;</span>
<span class="nc" id="L742">	    m_LoggerInitFailed = true;</span>
	  }  
	}
      }
      
<span class="nc" id="L747">      return m_Logger;</span>
    }
    
    /**
     * turns the string representing a level, e.g., &quot;FINE&quot; or &quot;ALL&quot; into
     * the corresponding level (case-insensitive). The default is ALL.
     * 
     * @param level	the string to return a level for
     * @return		the corresponding level or the default
     */
    public static Level stringToLevel(String level) {
      Level	result;
      
<span class="nc bnc" id="L760" title="All 2 branches missed.">      if (level.equalsIgnoreCase(&quot;ALL&quot;))</span>
<span class="nc" id="L761">        result = ALL;</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;CONFIG&quot;))</span>
<span class="nc" id="L763">        result = CONFIG;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;FINE&quot;))</span>
<span class="nc" id="L765">        result = FINE;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;FINER&quot;))</span>
<span class="nc" id="L767">        result = FINER;</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;FINEST&quot;))</span>
<span class="nc" id="L769">        result = FINEST;</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;INFO&quot;))</span>
<span class="nc" id="L771">        result = INFO;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;OFF&quot;))</span>
<span class="nc" id="L773">        result = OFF;</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;SEVERE&quot;))</span>
<span class="nc" id="L775">        result = SEVERE;</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">      else if (level.equalsIgnoreCase(&quot;WARNING&quot;))</span>
<span class="nc" id="L777">        result = WARNING;</span>
      else
<span class="nc" id="L779">        result = ALL;</span>
      
<span class="nc" id="L781">      return result;</span>
    }
    
    /**
     * returns the filename of the log, can be null
     * 
     * @return		the filename of the log
     */
    public String getFilename() {
<span class="nc" id="L790">      return m_Filename;</span>
    }
    
    /**
     * returns the size of the files
     * 
     * @return		the size of a file
     */
    public int getSize() {
<span class="nc" id="L799">      return m_Size;</span>
    }
    
    /**
     * returns the number of files being used
     * 
     * @return		the number of files
     */
    public int getNumFiles() {
<span class="nc" id="L808">      return m_NumFiles;</span>
    }

    /**
     * logs the given message
     * 
     * @param level	the level of severity
     * @param message	the message to log
     */
    public void log(Level level, String message) {
<span class="nc" id="L818">      log(level, &quot;&quot;, message);</span>
<span class="nc" id="L819">    }</span>
    
    /**
     * prints the given message with the specified level
     * 
     * @param level	the level of logging
     * @param sourceclass	the class that logs the message
     * @param message	the message to print
     */
    public void log(Level level, String sourceclass, String message) {
<span class="nc" id="L829">      log(level, sourceclass, &quot;&quot;, message);</span>
<span class="nc" id="L830">    }</span>
    
    /**
     * prints the given message with the specified level
     * 
     * @param level		the level of logging
     * @param sourceclass		the class that logs the message
     * @param sourcemethod	the method that logs the message
     * @param message		the message to print
     */
    public void log(Level level, String sourceclass, String sourcemethod, String message) {
      Logger	logger;
      
<span class="nc" id="L843">      logger = getLogger();</span>
      
<span class="nc bnc" id="L845" title="All 2 branches missed.">      if (logger != null)</span>
<span class="nc" id="L846">        logger.logp(level, sourceclass, sourcemethod, message);</span>
      else
<span class="nc" id="L848">	System.out.println(message);</span>
<span class="nc" id="L849">    }</span>
    
    /**
     * a convenience method for dumping the current system info in the 
     * log file
     * 
     * @see SystemInfo
     */
    public void logSystemInfo() {
<span class="nc" id="L858">      log(INFO, &quot;SystemInfo:\n&quot; + new SystemInfo().toString());</span>
<span class="nc" id="L859">    }</span>
    
    /**
     * returns a string representation of the logger
     * 
     * @return		a string representation of the logger
     */
    public String toString() {
      String	result;
      
<span class="nc" id="L869">      result =   &quot;Filename: &quot; + getFilename() + &quot;, &quot;</span>
<span class="nc" id="L870">      	       + &quot;Size: &quot; + getSize() + &quot;, &quot;</span>
<span class="nc" id="L871">      	       + &quot;# Files: &quot; + getNumFiles();</span>
      
<span class="nc" id="L873">      return result;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L882">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }

  /**
   * This extended Random class enables one to print the generated random
   * numbers etc., before they are returned. It can either use stdout (default)
   * for outputting the logging information or a Log object (level is then 
   * INFO).
   *
   * @author  FracPete (fracpete at waikato dot ac dot nz)
   * @version $Revision: 7519 $
   */
  public static class Random
    extends java.util.Random
    implements Serializable, RevisionHandler {

    /** for serialization */
    private static final long serialVersionUID = 1256846887618333956L;

    /** whether to output debug information */
<span class="nc" id="L903">    protected boolean m_Debug = false;</span>

    /** the unique ID for this number generator */
    protected long m_ID;
    
    /** for keeping track of unique IDs */
    protected static long m_CurrentID;
    
    /** the log to use for outputting the data, otherwise just stdout */
<span class="nc" id="L912">    protected Log m_Log = null;</span>
    
    /**
     * Creates a new random number generator. With no debugging.
     */
    public Random() {
<span class="nc" id="L918">      this(false);</span>
<span class="nc" id="L919">    }</span>

    /**
     * Creates a new random number generator using a single long seed.
     * With no debugging
     * 
     * @param seed	the seed value
     */
    public Random(long seed) {
<span class="nc" id="L928">      this(seed, false);</span>
<span class="nc" id="L929">    }</span>

    /**
     * Creates a new random number generator. With optional debugging.
     * 
     * @param debug	if true, debugging output is enabled
     */
    public Random(boolean debug) {
<span class="nc" id="L937">      super();</span>
<span class="nc" id="L938">      setDebug(debug);</span>
<span class="nc" id="L939">      m_ID = nextID();</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">      if (getDebug())</span>
<span class="nc" id="L941">        printStackTrace();</span>
<span class="nc" id="L942">    }</span>

    /**
     * Creates a new random number generator using a single long seed.
     * With optional debugging
     * 
     * @param seed	the seed value
     * @param debug	if true, debugging output is enabled
     */
    public Random(long seed, boolean debug) {
<span class="nc" id="L952">      super(seed);</span>
<span class="nc" id="L953">      setDebug(debug);</span>
<span class="nc" id="L954">      m_ID = nextID();</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">      if (getDebug())</span>
<span class="nc" id="L956">        printStackTrace();</span>
<span class="nc" id="L957">    }</span>

    /**
     * sets whether to print the generated random values or not
     * 
     * @param value	if true debugging output is enabled
     */
    public void setDebug(boolean value) {
<span class="nc" id="L965">      m_Debug = value;</span>
<span class="nc" id="L966">    }</span>

    /**
     * returns whether to print the generated random values or not
     * 
     * @return		true if debugging output is enabled
     */
    public boolean getDebug() {
<span class="nc" id="L974">      return m_Debug;</span>
    }
    
    /**
     * the log to use, if it is null then stdout is used
     * 
     * @param value	the log to use
     */
    public void setLog(Log value) {
<span class="nc" id="L983">      m_Log = value;</span>
<span class="nc" id="L984">    }</span>
    
    /**
     * the currently used log, if null then stdout is used for outputting
     * the debugging information
     * 
     * @return		the log, can be null
     */
    public Log getLog() {
<span class="nc" id="L993">      return m_Log;</span>
    }

    /**
     * returns the next unique ID for a number generator
     * 
     * @return		the next unique ID
     */
    protected static long nextID() {
<span class="nc" id="L1002">      m_CurrentID++;</span>
      
<span class="nc" id="L1004">      return m_CurrentID;</span>
    }

    /**
     * returns the unique ID of this number generator
     * 
     * @return		the unique ID of this number generator
     */
    public long getID() {
<span class="nc" id="L1013">      return m_ID;</span>
    }

    /**
     * prints the given message only if m_Debug is TRUE
     * 
     * @param msg	the message to print
     * @see 		#m_Debug
     */
    protected void println(String msg) {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">      if (getDebug()) {</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">	if (getLog() != null)</span>
<span class="nc" id="L1025">	  getLog().log(Level.INFO, m_ID + &quot;: &quot; + msg);</span>
	else
<span class="nc" id="L1027">	  System.out.println(m_ID + &quot;: &quot; + msg);</span>
      }
<span class="nc" id="L1029">    }</span>

    /**
     * prints the current stacktrace
     */
    public void printStackTrace() {
      Throwable		t;
      StringWriter	writer;

<span class="nc" id="L1038">      writer = new StringWriter();</span>
      
      // generate stacktrace
<span class="nc" id="L1041">      t = new Throwable();</span>
<span class="nc" id="L1042">      t.fillInStackTrace();</span>
<span class="nc" id="L1043">      t.printStackTrace(new PrintWriter(writer));</span>

<span class="nc" id="L1045">      println(writer.toString());</span>
<span class="nc" id="L1046">    }</span>

    /**
     * Returns the next pseudorandom, uniformly distributed boolean value from
     * this random number generator's sequence.
     * 
     * @return		random boolean
     */
    public boolean nextBoolean() {
<span class="nc" id="L1055">      boolean result = super.nextBoolean();</span>
<span class="nc" id="L1056">      println(&quot;nextBoolean=&quot; + result);</span>
<span class="nc" id="L1057">      return result;</span>
    }

    /**
     * Generates random bytes and places them into a user-supplied byte array.
     * 
     * @param bytes	array to fill with random bytes
     */
    public void nextBytes(byte[] bytes) {
<span class="nc" id="L1066">      super.nextBytes(bytes);</span>
<span class="nc" id="L1067">      println(&quot;nextBytes=&quot; + Utils.arrayToString(bytes));</span>
<span class="nc" id="L1068">    }</span>

    /**
     * Returns the next pseudorandom, uniformly distributed double value between
     * 0.0 and 1.0 from this random number generator's sequence.
     * 
     * @return		random double
     */
    public double nextDouble() {
<span class="nc" id="L1077">      double result = super.nextDouble();</span>
<span class="nc" id="L1078">      println(&quot;nextDouble=&quot; + result);</span>
<span class="nc" id="L1079">      return result;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed float  value between
     * 0.0 and 1.0 from this random number generator's sequence.
     * 
     * @return		random float
     */
    public float nextFloat() {
<span class="nc" id="L1089">      float result = super.nextFloat();</span>
<span class="nc" id="L1090">      println(&quot;nextFloat=&quot; + result);</span>
<span class="nc" id="L1091">      return result;</span>
    }

    /**
     * Returns the next pseudorandom, Gaussian (&quot;normally&quot;) distributed double
     * value with mean 0.0 and standard deviation 1.0 from this random number
     * generator's sequence.
     * 
     * @return		random double, gaussian distributed
     */
    public double nextGaussian() {
<span class="nc" id="L1102">      double result = super.nextGaussian();</span>
<span class="nc" id="L1103">      println(&quot;nextGaussian=&quot; + result);</span>
<span class="nc" id="L1104">      return result;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed int  value from this
     * random number generator's sequence.
     * 
     * @return		random int
     */
    public int nextInt() {
<span class="nc" id="L1114">      int result = super.nextInt();</span>
<span class="nc" id="L1115">      println(&quot;nextInt=&quot; + result);</span>
<span class="nc" id="L1116">      return result;</span>
    }

    /**
     * Returns a pseudorandom, uniformly distributed int value between 0
     * (inclusive) and the specified value (exclusive), drawn from this random
     * number generator's sequence.
     * 
     * @param n		the upper limit (exclusive)
     * @return		random int
     */
    public int nextInt(int n) {
<span class="nc" id="L1128">      int result = super.nextInt(n);</span>
<span class="nc" id="L1129">      println(&quot;nextInt(&quot; + n + &quot;)=&quot; + result);</span>
<span class="nc" id="L1130">      return result;</span>
    }

    /**
     * Returns the next pseudorandom, uniformly distributed long  value from this
     * random number generator's sequence.
     * 
     * @return		random long
     */
    public long nextLong() {
<span class="nc" id="L1140">      long result = super.nextLong();</span>
<span class="nc" id="L1141">      println(&quot;nextLong=&quot; + result);</span>
<span class="nc" id="L1142">      return result;</span>
    }

    /**
     * Sets the seed of this random number generator using a single long seed.
     * 
     * @param seed	the seed value
     */
    public void setSeed(long seed) {
<span class="nc" id="L1151">      super.setSeed(seed);</span>
<span class="nc" id="L1152">      println(&quot;setSeed(&quot; + seed + &quot;)&quot;);</span>
<span class="nc" id="L1153">    }</span>

    /**
     * returns a string representation of this number generator
     * 
     * @return		a string representation
     */
    public String toString() {
<span class="nc" id="L1161">      return this.getClass().getName() + &quot;: &quot; + getID();</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1170">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }
  /**
   * contains debug methods
   *
   * @author Gabi Schmidberger (gabi at cs dot waikato dot ac dot nz)
   * @version $Revision: 7519 $
   */
<span class="nc" id="L1179">  public static class DBO </span>
    implements Serializable, RevisionHandler {

    /** for serialization */
    static final long serialVersionUID = -5245628124742606784L;  

    /** enables/disables output of debug information */
<span class="nc" id="L1186">    public boolean m_verboseOn = false;</span>

    /** range of outputtyp */
<span class="nc" id="L1189">    public Range m_outputTypes = new Range();</span>

    /** 
     * Set the verbose on flag on
     */
    public void setVerboseOn() {
<span class="nc" id="L1195">      m_verboseOn = true;</span>
<span class="nc" id="L1196">    }</span>

    /** 
     * Initialize ranges, upper limit must be set
     * 
     * @param upper upper limit
     */
    public void initializeRanges(int upper) {
<span class="nc" id="L1204">      m_outputTypes.setUpper(upper);</span>
<span class="nc" id="L1205">    }</span>

    /**
     * Return true if the outputtype is set
     * 
     * @param num value that is reserved for a specific outputtype
     * @return return true if the output type is set
     */
    public boolean outputTypeSet(int num) {
<span class="nc" id="L1214">      return (m_outputTypes.isInRange(num));</span>
    }

     /**
     * Return true if the debug level is set
     * same method as outpuTypeSet but better name
     * 
     * @param num value that is reserved for a specific outputtype
     * @return return true if the debug level is set
     */
    public boolean dl(int num) {
<span class="nc" id="L1225">      return (outputTypeSet(num));</span>
    }

   /**
     * Switches the outputs on that are requested from the option O
     * 
     * @param list list of integers, all are used for an output type
     */
    public void setOutputTypes(String list) {
<span class="nc bnc" id="L1234" title="All 2 branches missed.">      if (list.length() &gt; 0) {</span>
<span class="nc" id="L1235">        m_verboseOn = true; </span>

<span class="nc" id="L1237">        m_outputTypes.setRanges(list);</span>
<span class="nc" id="L1238">        m_outputTypes.setUpper(30);</span>
      }
<span class="nc" id="L1240">    }</span>

    /**
     * Gets the current output type selection
     *
     * @return a string containing a comma separated list of ranges
     */
    public String getOutputTypes() {
<span class="nc" id="L1248">      return m_outputTypes.getRanges();</span>
    }

    /**
     * prints out text + endofline if verbose is on.
     * helps to make debug output commands more visible in text
     * 
     * @param text the text to print
     */
    public void dpln(String text) {
<span class="nc bnc" id="L1258" title="All 2 branches missed.">      if (m_verboseOn) {</span>
<span class="nc" id="L1259">        System.out.println(text);</span>
      }
<span class="nc" id="L1261">    } </span>

    /**
     * prints out text + endofline but only if parameter debug type is set.
     * helps to make debug output commands more visible in text
     *
     * @param debugType the type of the output
     * @param text the text to print
     */
    public void dpln(int debugType, String text) {
<span class="nc bnc" id="L1271" title="All 2 branches missed.">      if (outputTypeSet(debugType)) {</span>
<span class="nc" id="L1272">        System.out.println(text);</span>
      }
<span class="nc" id="L1274">    } </span>

     /**
     * prints out text  if verbose is on.
     * helps to make debug output commands more visible in text
     * 
     * @param text the text to print
     */
    public void dp(String text) {
<span class="nc bnc" id="L1283" title="All 2 branches missed.">      if (m_verboseOn) {</span>
<span class="nc" id="L1284">        System.out.print(text);</span>
      }
<span class="nc" id="L1286">    } </span>

   /**
     * prints out text but only if debug level is set.
     * helps to make debug output commands more visible in text
     *
     * @param debugType the type of the output
     * @param text the text to print
     */
    public void dp(int debugType, String text) {
<span class="nc bnc" id="L1296" title="All 2 branches missed.">     if (outputTypeSet(debugType)) {</span>
<span class="nc" id="L1297">        System.out.print(text);</span>
      }
<span class="nc" id="L1299">    } </span>

    /**
     * prints out text + endofline.
     * helps to make debug output commands more visible in text
     * 
     * @param text the text to print
     */
    public static void pln(String text) {
<span class="nc" id="L1308">      System.out.println(text);</span>
<span class="nc" id="L1309">    } </span>

    /**
     * prints out text.
     * helps to make debug output commands more visible in text
     * 
     * @param text the text to print
     */
    public static void p (String text) {
<span class="nc" id="L1318">      System.out.print(text);</span>
<span class="nc" id="L1319">    } </span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1327">      return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
    }
  }
  
  /**
   * default constructor, prints only to stdout
   */
  public Debug() {
<span class="nc" id="L1335">    this(null);</span>
<span class="nc" id="L1336">  }</span>
  
  /**
   * logs the output to the specified file (and stdout). Size is 1,000,000 bytes 
   * and 1 file.
   * 
   * @param filename	the name of the log
   */
  public Debug(String filename) {
<span class="nc" id="L1345">    this(filename, 1000000, 1);</span>
<span class="nc" id="L1346">  }</span>
  
  /**
   * logs the output
   * 
   * @param filename	the name of the log
   * @param size	the size of the files in bytes
   * @param numFiles	the number of files for rotating
   */
  public Debug(String filename, int size, int numFiles) {
<span class="nc" id="L1356">    super();</span>
    
<span class="nc" id="L1358">    m_Log = newLog(filename, size, numFiles);</span>
<span class="nc" id="L1359">  }</span>
  
  /**
   * turns the string representing a level, e.g., &quot;FINE&quot; or &quot;ALL&quot; into
   * the corresponding level (case-insensitive). The default is ALL.
   * 
   * @param level	the string to return a level for
   * @return		the corresponding level or the default
   */
  public static Level stringToLevel(String level) {
<span class="nc" id="L1369">    return Log.stringToLevel(level);</span>
  }
  
  /**
   * returns a new Log instance
   * 
   * @param filename	the name of the log
   * @param size	the size of the files in bytes
   * @param numFiles	the number of files for rotating
   * @return		the log instance
   */
  public static Log newLog(String filename, int size, int numFiles) {
<span class="nc" id="L1381">    return new Log(filename, size, numFiles);</span>
  }
  
  /**
   * prints the given message with level INFO
   * 
   * @param message	the message to print
   */
  public void log(String message) {
<span class="nc" id="L1390">    log(INFO, message);</span>
<span class="nc" id="L1391">  }</span>
  
  /**
   * prints the given message with the specified level and an empty sourceclass
   * 
   * @param level	the level of logging
   * @param message	the message to print
   */
  public void log(Level level, String message) {
<span class="nc" id="L1400">    log(level, &quot;&quot;, message);</span>
<span class="nc" id="L1401">  }</span>
  
  /**
   * prints the given message with the specified level
   * 
   * @param level	the level of logging
   * @param sourceclass	the class that logs the message
   * @param message	the message to print
   */
  public void log(Level level, String sourceclass, String message) {
<span class="nc" id="L1411">    log(level, sourceclass, &quot;&quot;, message);</span>
<span class="nc" id="L1412">  }</span>
  
  /**
   * prints the given message with the specified level
   * 
   * @param level		the level of logging
   * @param sourceclass		the class that logs the message
   * @param sourcemethod	the method that logs the message
   * @param message		the message to print
   */
  public void log(Level level, String sourceclass, String sourcemethod, String message) {
<span class="nc bnc" id="L1423" title="All 2 branches missed.">    if (getEnabled())</span>
<span class="nc" id="L1424">      m_Log.log(level, sourceclass, sourcemethod, message);</span>
<span class="nc" id="L1425">  }</span>
  
  /**
   * sets whether the logging is enabled or not
   * 
   * @param value	if true logging will be enabled
   */
  public void setEnabled(boolean value) {
<span class="nc" id="L1433">    m_Enabled = value;</span>
<span class="nc" id="L1434">  }</span>
  
  /**
   * returns whether the logging is enabled
   * 
   * @return		true if the logging is enabled
   */
  public boolean getEnabled() {
<span class="nc" id="L1442">    return m_Enabled;</span>
  }
  
  /**
   * returns a new instance of a clock
   * 
   * @return		a new instance of a Clock
   */
  public static Clock newClock() {
<span class="nc" id="L1451">    return new Clock();</span>
  }
  
  /**
   * returns the instance of the Clock that is internally used
   * 
   * @return		the clock that's being used
   */
  public Clock getClock() {
<span class="nc" id="L1460">    return m_Clock;</span>
  }
  
  /**
   * starts the clock
   */
  public void startClock() {
<span class="nc" id="L1467">    m_Clock.start();</span>
<span class="nc" id="L1468">  }</span>
  
  /**
   * stops the clock and prints the message associated with the time, but only
   * if the logging is enabled.
   * 
   * @param message	the message to print
   * @see		#getEnabled()
   */
  public void stopClock(String message) {
<span class="nc" id="L1478">    log(message + &quot;: &quot; + m_Clock);</span>
<span class="nc" id="L1479">  }</span>
  
  /**
   * returns a default debug random object, with no particular seed and 
   * debugging enabled.
   * 
   * @return		a new instance of a Random object
   */
  public static java.util.Random newRandom() {
<span class="nc" id="L1488">    return new Random(true);</span>
  }
  
  /**
   * returns a debug random object with the specified seed and debugging 
   * enabled.
   * 
   * @param seed	the seed value
   * @return		a new instance of a Random object
   */
  public static java.util.Random newRandom(int seed) {
<span class="nc" id="L1499">    return new Random(seed, true);</span>
  }

  /**
   * returns a default timestamp for the current date/time
   * 
   * @return		a new timestamp
   */
  public static Timestamp newTimestamp() {
<span class="nc" id="L1508">    return new Timestamp();</span>
  }
  
  /**
   * returns the system temp directory
   * 
   * @return		the temp directory
   */
  public static String getTempDir() {
<span class="nc" id="L1517">    return System.getProperty(&quot;java.io.tmpdir&quot;);</span>
  }
  
  /**
   * returns the home directory of the user
   * 
   * @return		the user's home directory
   */
  public static String getHomeDir() {
<span class="nc" id="L1526">    return System.getProperty(&quot;user.home&quot;);</span>
  }
  
  /**
   * returns the current working directory of the user
   * 
   * @return		the user's current working directory
   */
  public static String getCurrentDir() {
<span class="nc" id="L1535">    return System.getProperty(&quot;user.dir&quot;);</span>
  }
  
  /**
   * Writes the given object to the specified file. The string representation
   * of the object is appended to the file.
   * 
   * @param filename	the file to write to
   * @param obj		the object to write to the file
   * @return		true if writing was successful
   */
  public static boolean writeToFile(String filename, Object obj) {
<span class="nc" id="L1547">    return writeToFile(filename, obj, true);</span>
  }
  
  /**
   * Writes the given message to the specified file. The message is appended 
   * to the file.
   * 
   * @param filename	the file to write to
   * @param message	the message to write
   * @return		true if writing was successful
   */
  public static boolean writeToFile(String filename, String message) {
<span class="nc" id="L1559">    return writeToFile(filename, message, true);</span>
  }
  
  /**
   * Writes the given object to the specified file. The string representation 
   * of the object is either appended or replaces the current content of the 
   * file.
   * 
   * @param filename	the file to write to
   * @param obj		the object to write to the file
   * @param append	whether to append the message or not
   * @return		true if writing was successful
   */
  public static boolean writeToFile(String filename, Object obj, boolean append) {
<span class="nc" id="L1573">    return writeToFile(filename, obj.toString(), append);</span>
  }
  
  /**
   * Writes the given message to the specified file. The message is either 
   * appended or replaces the current content of the file.
   * 
   * @param filename	the file to write to
   * @param message	the message to write
   * @param append	whether to append the message or not
   * @return		true if writing was successful
   */
  public static boolean writeToFile(String filename, String message, boolean append) {
    boolean		result;
    BufferedWriter	writer;
    
    try {
<span class="nc" id="L1590">      writer = new BufferedWriter(new FileWriter(filename, append));</span>
<span class="nc" id="L1591">      writer.write(message);</span>
<span class="nc" id="L1592">      writer.newLine();</span>
<span class="nc" id="L1593">      writer.flush();</span>
<span class="nc" id="L1594">      writer.close();</span>
<span class="nc" id="L1595">      result = true;</span>
    }
<span class="nc" id="L1597">    catch (Exception e) {</span>
<span class="nc" id="L1598">      result = false;</span>
    }
    
<span class="nc" id="L1601">    return result;</span>
  }
  
  /**
   * writes the serialized object to the speicified file
   * 
   * @param filename	the file to serialize the object to
   * @param o		the object to serialize
   * @return		true if writing was successful
   */
  public static boolean saveToFile(String filename, Object o) {
    boolean 	result;
    
<span class="nc bnc" id="L1614" title="All 2 branches missed.">    if (SerializationHelper.isSerializable(o.getClass())) {</span>
      try {
<span class="nc" id="L1616">	SerializationHelper.write(filename, o);</span>
<span class="nc" id="L1617">	result = true;</span>
      }
<span class="nc" id="L1619">      catch (Exception e) {</span>
<span class="nc" id="L1620">	result = false;</span>
      }
    }
    else {
<span class="nc" id="L1624">      result = false;</span>
    }
    
<span class="nc" id="L1627">    return result;</span>
  }
  
  /**
   * deserializes the content of the file and returns it, null if an error
   * occurred.
   * 
   * @param filename	the name of the file to deserialize
   * @return		the deserialized content, null if problem occurred
   */
  public static Object loadFromFile(String filename) {
    Object	result;
    
    try {
<span class="nc" id="L1641">      result = SerializationHelper.read(filename);</span>
    }
<span class="nc" id="L1643">    catch (Exception e) {</span>
<span class="nc" id="L1644">      result = null;</span>
    }
    
<span class="nc" id="L1647">    return result;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1656">    return RevisionUtils.extract(&quot;$Revision: 7519 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>