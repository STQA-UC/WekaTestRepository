<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>RuleStats.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">RuleStats.java</span></div><h1>RuleStats.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    RuleStats.java
 *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
 */

package weka.classifiers.rules;

import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;

/**
 * This class implements the statistics functions used in the 
 * propositional rule learner, from the simpler ones like count of
 * true/false positive/negatives, filter data based on the ruleset, etc.
 * to the more sophisticated ones such as MDL calculation and rule
 * variants generation for each rule in the ruleset. &lt;p&gt;
 *
 * Obviously the statistics functions listed above need the specific
 * data and the specific ruleset, which are given in order to instantiate
 * an object of this class. &lt;p&gt;
 *  
 * @author Xin Xu (xx5@cs.waikato.ac.nz)
 * @version $Revision: 4608 $
 */
<span class="fc" id="L50">public class RuleStats </span>
  implements Serializable, RevisionHandler {
  
  /** for serialization */
  static final long serialVersionUID = -5708153367675298624L;

  /** The data on which the stats calculation is based */
  private Instances m_Data;

  /** The specific ruleset in question */
  private FastVector m_Ruleset;

  /** The simple stats of each rule */
  private FastVector m_SimpleStats;

  /** The set of instances filtered by the ruleset */
  private FastVector m_Filtered;
    
  /** The total number of possible conditions that could
   *  appear in a rule */
  private double m_Total;
 
  /** The redundancy factor in theory description length */	
<span class="fc" id="L73">  private static double REDUNDANCY_FACTOR = 0.5;</span>
    
  /** The theory weight in the MDL calculation */
<span class="fc" id="L76">  private double MDL_THEORY_WEIGHT = 1.0;</span>

    /** The class distributions predicted by each rule */
    private FastVector m_Distributions;

  /** Default constructor */
<span class="fc" id="L82">  public RuleStats(){</span>
<span class="fc" id="L83">    m_Data = null;</span>
<span class="fc" id="L84">    m_Ruleset = null;</span>
<span class="fc" id="L85">    m_SimpleStats = null;</span>
<span class="fc" id="L86">    m_Filtered = null;</span>
<span class="fc" id="L87">    m_Distributions = null;</span>
<span class="fc" id="L88">    m_Total = -1;</span>
<span class="fc" id="L89">  }</span>

    
  /** 
   * Constructor that provides ruleset and data 
   *
   * @param data the data
   * @param rules the ruleset
   */
  public RuleStats(Instances data, FastVector rules){
<span class="fc" id="L99">    this();</span>
<span class="fc" id="L100">    m_Data = data;</span>
<span class="fc" id="L101">    m_Ruleset = rules;	</span>
<span class="fc" id="L102">  }</span>

  /**
   * Frees up memory after classifier has been built.
   */
  public void cleanUp() {
<span class="fc" id="L108">    m_Data     = null;</span>
<span class="fc" id="L109">    m_Filtered = null;</span>
<span class="fc" id="L110">  }</span>

  /**
   * Set the number of all conditions that could appear 
   * in a rule in this RuleStats object, if the number set
   * is smaller than 0 (typically -1), then it calcualtes
   * based on the data store 
   *
   * @param total the set number
   */
  public void setNumAllConds(double total){
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">    if(total &lt; 0)</span>
<span class="nc" id="L122">      m_Total = numAllConditions(m_Data);    </span>
    else
<span class="fc" id="L124">      m_Total = total;</span>
<span class="fc" id="L125">  }</span>
    
  /** 
   * Set the data of the stats, overwriting the old one if any 
   *
   * @param data the data to be set
   */
  public void setData(Instances data){
<span class="fc" id="L133">    m_Data = data;</span>
<span class="fc" id="L134">  }</span>
    
  /** 
   * Get the data of the stats 
   *
   * @return the data 
   */
  public Instances getData(){
<span class="nc" id="L142">    return m_Data;</span>
  }

    
  /** 
   * Set the ruleset of the stats, overwriting the old one if any 
   *      
   * @param rules the set of rules to be set
   */
  public void setRuleset(FastVector rules){
<span class="nc" id="L152">    m_Ruleset = rules;</span>
<span class="nc" id="L153">  }</span>

    
  /** 
   * Get the ruleset of the stats 
   *      
   * @return the set of rules 
   */
  public FastVector getRuleset(){
<span class="fc" id="L162">    return m_Ruleset;</span>
  }

  /** 
   * Get the size of the ruleset in the stats 
   *      
   * @return the size of ruleset 
   */
  public int getRulesetSize(){
<span class="fc" id="L171">    return m_Ruleset.size();</span>
  }
  
  /** 
   * Get the simple stats of one rule, including 6 parameters:
   * 0: coverage; 1:uncoverage; 2: true positive; 3: true negatives;
   * 4: false positives; 5: false negatives
   *
   * @param index the index of the rule
   * @return the stats
   */
  public double[] getSimpleStats(int index){
<span class="pc bpc" id="L183" title="2 of 4 branches missed.">    if((m_SimpleStats != null) &amp;&amp; (index &lt; m_SimpleStats.size()))</span>
<span class="fc" id="L184">      return (double[])m_SimpleStats.elementAt(index);</span>
	
<span class="nc" id="L186">    return null;</span>
  }    


  /**
   * Get the data after filtering the given rule
   *
   * @param index the index of the rule
   * @return the data covered and uncovered by the rule
   */
  public Instances[] getFiltered(int index){
	
<span class="pc bpc" id="L198" title="2 of 4 branches missed.">    if((m_Filtered != null) &amp;&amp; (index &lt; m_Filtered.size()))</span>
<span class="fc" id="L199">      return (Instances[])m_Filtered.elementAt(index);</span>
	
<span class="nc" id="L201">    return null;</span>
  }    

    /**
     * Get the class distribution predicted by the rule in
     * given position
     *
     * @param index the position index of the rule
     * @return the class distributions
     */
    public double[] getDistributions(int index){
	
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">	if((m_Distributions != null) &amp;&amp; (index &lt; m_Distributions.size()))</span>
<span class="fc" id="L214">	    return (double[])m_Distributions.elementAt(index);</span>
	
<span class="nc" id="L216">	return null;</span>
    }    
    
  /**
   * Set the weight of theory in MDL calcualtion
   *
   * @param weight the weight to be set
   */
  public void setMDLTheoryWeight(double weight){
<span class="nc" id="L225">    MDL_THEORY_WEIGHT = weight;</span>
<span class="nc" id="L226">  } </span>

  /**
   * Compute the number of all possible conditions that could 
   * appear in a rule of a given data.  For nominal attributes,
   * it's the number of values that could appear; for numeric 
   * attributes, it's the number of values * 2, i.e. &lt;= and &gt;=
   * are counted as different possible conditions.
   *
   * @param data the given data
   * @return number of all conditions of the data
   */
  public static double numAllConditions(Instances data){
<span class="fc" id="L239">    double total = 0;</span>
<span class="fc" id="L240">    Enumeration attEnum = data.enumerateAttributes();	</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">    while(attEnum.hasMoreElements()){</span>
<span class="fc" id="L242">      Attribute att= (Attribute)attEnum.nextElement();</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">      if(att.isNominal())</span>
<span class="fc" id="L244">	total += (double)att.numValues();</span>
      else
<span class="fc" id="L246">	total += 2.0 * (double)data.numDistinctValues(att);	</span>
    }
<span class="fc" id="L248">    return total;</span>
  }


  /**
   * Filter the data according to the ruleset and compute the basic
   * stats: coverage/uncoverage, true/false positive/negatives of 
   * each rule
   */
  public void countData(){
<span class="nc bnc" id="L258" title="All 2 branches missed.">    if((m_Filtered != null) ||</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">       (m_Ruleset == null)  ||</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">       (m_Data == null))</span>
<span class="nc" id="L261">      return;</span>
	
<span class="nc" id="L263">    int size = m_Ruleset.size();</span>
<span class="nc" id="L264">    m_Filtered = new FastVector(size);</span>
<span class="nc" id="L265">    m_SimpleStats = new FastVector(size);</span>
<span class="nc" id="L266">    m_Distributions = new FastVector(size);</span>
<span class="nc" id="L267">    Instances data = new Instances(m_Data);</span>
	
<span class="nc bnc" id="L269" title="All 2 branches missed.">    for(int i=0; i &lt; size; i++){</span>
<span class="nc" id="L270">      double[] stats = new double[6];  // 6 statistics parameters</span>
<span class="nc" id="L271">      double[] classCounts = new double[m_Data.classAttribute().numValues()];</span>
<span class="nc" id="L272">      Instances[] filtered = computeSimpleStats(i, data, stats, classCounts);</span>
<span class="nc" id="L273">      m_Filtered.addElement(filtered);</span>
<span class="nc" id="L274">      m_SimpleStats.addElement(stats);</span>
<span class="nc" id="L275">      m_Distributions.addElement(classCounts);</span>
<span class="nc" id="L276">      data = filtered[1];  // Data not covered</span>
    }	
<span class="nc" id="L278">  }</span>
    
    /**
     * Count data from the position index in the ruleset
     * assuming that given data are not covered by the rules
     * in position 0...(index-1), and the statistics of these
     * rules are provided.&lt;br&gt;
     * This procedure is typically useful when a temporary 
     * object of RuleStats is constructed in order to efficiently
     * calculate the relative DL of rule in position index, 
     * thus all other stuff is not needed.
     *
     * @param index the given position
     * @param uncovered the data not covered by rules before index
     * @param prevRuleStats the provided stats of previous rules
     */
    public void countData(int index, Instances uncovered, 
			  double[][] prevRuleStats){
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">	if((m_Filtered != null) ||</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">	   (m_Ruleset == null))</span>
<span class="nc" id="L298">	    return;</span>
	
<span class="fc" id="L300">	int size = m_Ruleset.size();</span>
<span class="fc" id="L301">	m_Filtered = new FastVector(size);</span>
<span class="fc" id="L302">	m_SimpleStats = new FastVector(size);</span>
<span class="fc" id="L303">	Instances[] data = new Instances[2];</span>
<span class="fc" id="L304">	data[1] = uncovered;</span>
	
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">	for(int i=0; i &lt; index; i++){</span>
<span class="nc" id="L307">	    m_SimpleStats.addElement(prevRuleStats[i]);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">	    if(i+1 == index)</span>
<span class="nc" id="L309">		m_Filtered.addElement(data);</span>
	    else
<span class="nc" id="L311">		m_Filtered.addElement(new Object()); // Stuff sth.</span>
	}
	
<span class="fc bfc" id="L314" title="All 2 branches covered.">	for(int j=index; j &lt; size; j++){</span>
<span class="fc" id="L315">	    double[] stats = new double[6];  // 6 statistics parameters</span>
<span class="fc" id="L316">	    Instances[] filtered = computeSimpleStats(j, data[1], stats, null);</span>
<span class="fc" id="L317">	    m_Filtered.addElement(filtered);</span>
<span class="fc" id="L318">	    m_SimpleStats.addElement(stats);</span>
<span class="fc" id="L319">	    data = filtered;  // Data not covered</span>
	}	
<span class="fc" id="L321">    }</span>
    
  /**
   * Find all the instances in the dataset covered/not covered by 
   * the rule in given index, and the correponding simple statistics
   * and predicted class distributions are stored in the given double array,
   * which can be obtained by getSimpleStats() and getDistributions().&lt;br&gt;
   * 
   * @param index the given index, assuming correct
   * @param insts the dataset to be covered by the rule
   * @param stats the given double array to hold stats, side-effected
   * @param dist the given array to hold class distributions, side-effected
   *             if null, the distribution is not necessary 
   * @return the instances covered and not covered by the rule
   */
  private Instances[] computeSimpleStats(int index, Instances insts, 
					 double[] stats, double[] dist){
<span class="fc" id="L338">    Rule rule = (Rule)m_Ruleset.elementAt(index);</span>
	
<span class="fc" id="L340">    Instances[] data = new Instances[2];</span>
<span class="fc" id="L341">    data[0] = new Instances(insts, insts.numInstances());</span>
<span class="fc" id="L342">    data[1] = new Instances(insts, insts.numInstances());</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">    for(int i=0; i&lt;insts.numInstances(); i++){</span>
<span class="fc" id="L345">      Instance datum = insts.instance(i);</span>
<span class="fc" id="L346">      double weight = datum.weight();</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">      if(rule.covers(datum)){</span>
<span class="fc" id="L348">	data[0].add(datum);        // Covered by this rule</span>
<span class="fc" id="L349">	stats[0] += weight;        // Coverage</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">	if((int)datum.classValue() == (int)rule.getConsequent())</span>
<span class="fc" id="L351">	  stats[2] += weight;    // True positives</span>
	else
<span class="fc" id="L353">	  stats[4] += weight;    // False positives</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">	if(dist != null)</span>
<span class="fc" id="L355">	    dist[(int)datum.classValue()] += weight;</span>
      }
      else{
<span class="fc" id="L358">	data[1].add(datum);        // Not covered by this rule</span>
<span class="fc" id="L359">	stats[1] += weight; </span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">	if((int)datum.classValue() != (int)rule.getConsequent())</span>
<span class="fc" id="L361">	  stats[3] += weight;    // True negatives</span>
	else
<span class="fc" id="L363">	  stats[5] += weight;    // False negatives	    </span>
      }
    }
    
<span class="fc" id="L367">    return data;</span>
  }
    
    
  /** 
   * Add a rule to the ruleset and update the stats
   *
   * @param lastRule the rule to be added
   */
  public void addAndUpdate(Rule lastRule){
<span class="fc bfc" id="L377" title="All 2 branches covered.">    if(m_Ruleset == null)</span>
<span class="fc" id="L378">      m_Ruleset = new FastVector();</span>
<span class="fc" id="L379">    m_Ruleset.addElement(lastRule);</span>
  
<span class="fc bfc" id="L381" title="All 2 branches covered.">    Instances data = (m_Filtered == null) ?</span>
<span class="fc" id="L382">      m_Data : ((Instances[])m_Filtered.lastElement())[1];</span>
<span class="fc" id="L383">    double[] stats = new double[6];</span>
<span class="fc" id="L384">    double[] classCounts = new double[m_Data.classAttribute().numValues()];</span>
<span class="fc" id="L385">    Instances[] filtered = </span>
<span class="fc" id="L386">	computeSimpleStats(m_Ruleset.size()-1, data, stats, classCounts);</span>
    
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if(m_Filtered == null)</span>
<span class="fc" id="L389">	m_Filtered = new FastVector();	</span>
<span class="fc" id="L390">    m_Filtered.addElement(filtered);</span>

<span class="fc bfc" id="L392" title="All 2 branches covered.">    if(m_SimpleStats == null)</span>
<span class="fc" id="L393">      m_SimpleStats = new FastVector();	</span>
<span class="fc" id="L394">    m_SimpleStats.addElement(stats);</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">    if(m_Distributions == null)</span>
<span class="fc" id="L397">	m_Distributions = new FastVector();</span>
<span class="fc" id="L398">    m_Distributions.addElement(classCounts);</span>
<span class="fc" id="L399">  }</span>
    
    
  /**
   * Subset description length: &lt;br&gt;
   * S(t,k,p) = -k*log2(p)-(n-k)log2(1-p)
   *
   * Details see Quilan: &quot;MDL and categorical theories (Continued)&quot;,ML95
   *
   * @param t the number of elements in a known set
   * @param k the number of elements in a subset
   * @param p the expected proportion of subset known by recipient
   * @return the subset description length
   */
  public static double subsetDL(double t, double k, double p){
<span class="fc bfc" id="L414" title="All 2 branches covered.">    double rt = Utils.gr(p, 0.0) ? (- k*Utils.log2(p)) : 0.0;</span>
<span class="fc" id="L415">    rt -= (t-k)*Utils.log2(1-p);</span>
<span class="fc" id="L416">    return rt;</span>
  }
    
    
  /** 
   * The description length of the theory for a given rule.  Computed as:&lt;br&gt;
   *                 0.5* [||k||+ S(t, k, k/t)]&lt;br&gt;
   * where k is the number of antecedents of the rule; t is the total
   * possible antecedents that could appear in a rule; ||K|| is the 
   * universal prior for k , log2*(k) and S(t,k,p) = -k*log2(p)-(n-k)log2(1-p)
   * is the subset encoding length.&lt;p&gt;
   *
   * Details see Quilan: &quot;MDL and categorical theories (Continued)&quot;,ML95
   *
   * @param index the index of the given rule (assuming correct)
   * @return the theory DL, weighted if weight != 1.0
   */
  public double theoryDL(int index){
	
<span class="fc" id="L435">    double k = ((Rule)m_Ruleset.elementAt(index)).size();</span>
	
<span class="fc bfc" id="L437" title="All 2 branches covered.">    if(k == 0)</span>
<span class="fc" id="L438">      return 0.0;</span>
	
<span class="fc" id="L440">    double tdl = Utils.log2(k);               	    </span>
<span class="fc bfc" id="L441" title="All 2 branches covered.">    if(k &gt; 1)                           // Approximation</span>
<span class="fc" id="L442">      tdl += 2.0 * Utils.log2(tdl);   // of log2 star	</span>
<span class="fc" id="L443">    tdl += subsetDL(m_Total, k, k/m_Total);</span>
    //System.out.println(&quot;!!!theory: &quot;+MDL_THEORY_WEIGHT * REDUNDANCY_FACTOR * tdl);
<span class="fc" id="L445">    return MDL_THEORY_WEIGHT * REDUNDANCY_FACTOR * tdl;</span>
  }
     

  /** 
   * The description length of data given the parameters of the data
   * based on the ruleset. &lt;p&gt;
   * Details see Quinlan: &quot;MDL and categorical theories (Continued)&quot;,ML95&lt;p&gt;
   *
   * @param expFPOverErr expected FP/(FP+FN)
   * @param cover coverage
   * @param uncover uncoverage
   * @param fp False Positive
   * @param fn False Negative
   * @return the description length
   */
  public static double dataDL(double expFPOverErr, double cover, 
			      double uncover, double fp, double fn){
<span class="fc" id="L463">    double totalBits = Utils.log2(cover+uncover+1.0); // how many data?</span>
    double coverBits, uncoverBits; // What's the error?
    double expErr;                 // Expected FP or FN

<span class="fc bfc" id="L467" title="All 2 branches covered.">    if(Utils.gr(cover, uncover)){</span>
<span class="fc" id="L468">      expErr = expFPOverErr*(fp+fn);</span>
<span class="fc" id="L469">      coverBits = subsetDL(cover, fp, expErr/cover);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">      uncoverBits = Utils.gr(uncover, 0.0) ? </span>
<span class="fc" id="L471">	subsetDL(uncover, fn, fn/uncover) : 0.0;	    </span>
    }
    else{
<span class="fc" id="L474">      expErr = (1.0-expFPOverErr)*(fp+fn);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">      coverBits = Utils.gr(cover, 0.0) ? </span>
<span class="fc" id="L476">	subsetDL(cover, fp, fp/cover) : 0.0;</span>
<span class="fc" id="L477">      uncoverBits = subsetDL(uncover, fn, expErr/uncover);</span>
    }
	
    /*
      System.err.println(&quot;!!!cover: &quot; + cover + &quot;|uncover&quot; + uncover +
      &quot;|coverBits: &quot;+coverBits+&quot;|uncBits: &quot;+ uncoverBits+
      &quot;|FPRate: &quot;+expFPOverErr + &quot;|expErr: &quot;+expErr+
      &quot;|fp: &quot;+fp+&quot;|fn: &quot;+fn+&quot;|total: &quot;+totalBits);
    */
<span class="fc" id="L486">    return (totalBits + coverBits + uncoverBits);</span>
  }

    
  /**
   * Calculate the potential to decrease DL of the ruleset,
   * i.e. the possible DL that could be decreased by deleting
   * the rule whose index and simple statstics are given.  
   * If there's no potentials (i.e. smOrEq 0 &amp;&amp; error rate &lt; 0.5),
   * it returns NaN. &lt;p&gt;
   *
   * The way this procedure does is copied from original RIPPER
   * implementation and is quite bizzare because it 
   * does not update the following rules' stats recursively 
   * any more when testing each rule, which means it assumes
   * after deletion no data covered by the following rules (or
   * regards the deleted rule as the last rule).  Reasonable 
   * assumption?&lt;p&gt;
   *
   * @param index the index of the rule in m_Ruleset to be deleted
   * @param expFPOverErr expected FP/(FP+FN)
   * @param rulesetStat the simple statistics of the ruleset, updated
   *                    if the rule should be deleted
   * @param ruleStat the simple statistics of the rule to be deleted
   * @param checkErr whether check if error rate &gt;= 0.5
   * @return the potential DL that could be decreased
   */
  public double potential(int index, double expFPOverErr, 
			  double[] rulesetStat, double[] ruleStat,
			  boolean checkErr){
    //System.out.println(&quot;!!!inside potential: &quot;);
    // Restore the stats if deleted
<span class="fc" id="L518">    double pcov = rulesetStat[0] - ruleStat[0];</span>
<span class="fc" id="L519">    double puncov = rulesetStat[1] + ruleStat[0];</span>
<span class="fc" id="L520">    double pfp = rulesetStat[4] - ruleStat[4];</span>
<span class="fc" id="L521">    double pfn = rulesetStat[5] + ruleStat[2];</span>

<span class="fc" id="L523">    double dataDLWith = dataDL(expFPOverErr, rulesetStat[0], </span>
<span class="fc" id="L524">			       rulesetStat[1], rulesetStat[4], </span>
<span class="fc" id="L525">			       rulesetStat[5]);</span>
<span class="fc" id="L526">    double theoryDLWith = theoryDL(index);</span>
<span class="fc" id="L527">    double dataDLWithout = dataDL(expFPOverErr, pcov, puncov, pfp, pfn);</span>

<span class="fc" id="L529">    double potential = dataDLWith + theoryDLWith - dataDLWithout;</span>
<span class="fc" id="L530">    double err = ruleStat[4] / ruleStat[0];</span>
    /*System.out.println(&quot;!!!&quot;+dataDLWith +&quot; | &quot;+ 
      theoryDLWith + &quot; | &quot; 
      +dataDLWithout+&quot;|&quot;+ruleStat[4] + &quot; / &quot; + ruleStat[0]);
    */
<span class="fc" id="L535">    boolean overErr = Utils.grOrEq(err, 0.5);</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">    if(!checkErr)</span>
<span class="nc" id="L537">      overErr = false;</span>
	
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">    if(Utils.grOrEq(potential, 0.0) || overErr){ </span>
      // If deleted, update ruleset stats.  Other stats do not matter
<span class="nc" id="L541">      rulesetStat[0] = pcov;</span>
<span class="nc" id="L542">      rulesetStat[1] = puncov;</span>
<span class="nc" id="L543">      rulesetStat[4] = pfp;</span>
<span class="nc" id="L544">      rulesetStat[5] = pfn;</span>
<span class="nc" id="L545">      return potential;</span>
    }
    else
<span class="fc" id="L548">      return Double.NaN;</span>
  }
    
    
  /**
   * Compute the minimal data description length of the ruleset
   * if the rule in the given position is deleted.&lt;br&gt;
   * The min_data_DL_if_deleted = data_DL_if_deleted - potential
   *
   * @param index the index of the rule in question
   * @param expFPRate expected FP/(FP+FN), used in dataDL calculation
   * @param checkErr whether check if error rate &gt;= 0.5
   * @return the minDataDL
   */
  public double minDataDLIfDeleted(int index, double expFPRate,
				   boolean checkErr){
    //System.out.println(&quot;!!!Enter without: &quot;);
<span class="fc" id="L565">    double[] rulesetStat = new double[6]; // Stats of ruleset if deleted</span>
<span class="fc" id="L566">    int more = m_Ruleset.size() - 1 - index; // How many rules after?</span>
<span class="fc" id="L567">    FastVector indexPlus = new FastVector(more); // Their stats</span>
	
    // 0...(index-1) are OK	
<span class="fc bfc" id="L570" title="All 2 branches covered.">    for(int j=0; j&lt;index; j++){</span>
      // Covered stats are cumulative
<span class="fc" id="L572">      rulesetStat[0] += ((double[])m_SimpleStats.elementAt(j))[0];</span>
<span class="fc" id="L573">      rulesetStat[2] += ((double[])m_SimpleStats.elementAt(j))[2];</span>
<span class="fc" id="L574">      rulesetStat[4] += ((double[])m_SimpleStats.elementAt(j))[4];</span>
    }
	
    // Recount data from index+1
<span class="fc bfc" id="L578" title="All 2 branches covered.">    Instances data = (index == 0) ?  </span>
<span class="fc" id="L579">      m_Data : ((Instances[])m_Filtered.elementAt(index-1))[1];	</span>
    //System.out.println(&quot;!!!without: &quot; + data.sumOfWeights());

<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    for(int j=(index+1); j&lt;m_Ruleset.size(); j++){</span>
<span class="nc" id="L583">      double[] stats = new double[6];</span>
<span class="nc" id="L584">      Instances[] split = computeSimpleStats(j, data, stats, null);</span>
<span class="nc" id="L585">      indexPlus.addElement(stats);</span>
<span class="nc" id="L586">      rulesetStat[0] += stats[0];</span>
<span class="nc" id="L587">      rulesetStat[2] += stats[2];</span>
<span class="nc" id="L588">      rulesetStat[4] += stats[4];	   </span>
<span class="nc" id="L589">      data = split[1];</span>
    }
    // Uncovered stats are those of the last rule
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">    if(more &gt; 0){</span>
<span class="nc" id="L593">      rulesetStat[1] = ((double[])indexPlus.lastElement())[1];</span>
<span class="nc" id="L594">      rulesetStat[3] = ((double[])indexPlus.lastElement())[3];</span>
<span class="nc" id="L595">      rulesetStat[5] = ((double[])indexPlus.lastElement())[5];</span>
    }
<span class="fc bfc" id="L597" title="All 2 branches covered.">    else if(index &gt; 0){</span>
<span class="fc" id="L598">      rulesetStat[1] = </span>
<span class="fc" id="L599">	((double[])m_SimpleStats.elementAt(index-1))[1];</span>
<span class="fc" id="L600">      rulesetStat[3] =</span>
<span class="fc" id="L601">	((double[])m_SimpleStats.elementAt(index-1))[3];</span>
<span class="fc" id="L602">      rulesetStat[5] = </span>
<span class="fc" id="L603">	((double[])m_SimpleStats.elementAt(index-1))[5];</span>
    }	
    else{ // Null coverage
<span class="fc" id="L606">      rulesetStat[1] = ((double[])m_SimpleStats.elementAt(0))[0] +</span>
<span class="fc" id="L607">	((double[])m_SimpleStats.elementAt(0))[1];</span>
<span class="fc" id="L608">      rulesetStat[3] = ((double[])m_SimpleStats.elementAt(0))[3] +</span>
<span class="fc" id="L609">	((double[])m_SimpleStats.elementAt(0))[4];</span>
<span class="fc" id="L610">      rulesetStat[5] = ((double[])m_SimpleStats.elementAt(0))[2] +</span>
<span class="fc" id="L611">	((double[])m_SimpleStats.elementAt(0))[5];	    </span>
    }
	
    // Potential 
<span class="fc" id="L615">    double potential = 0;</span>
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">    for(int k=index+1; k&lt;m_Ruleset.size(); k++){</span>
<span class="nc" id="L617">      double[] ruleStat = (double[])indexPlus.elementAt(k-index-1);</span>
<span class="nc" id="L618">      double ifDeleted = potential(k, expFPRate, rulesetStat, </span>
<span class="nc" id="L619">				   ruleStat, checkErr);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">      if(!Double.isNaN(ifDeleted))</span>
<span class="nc" id="L621">	potential += ifDeleted;</span>
    }

    // Data DL of the ruleset without the rule
    // Note that ruleset stats has already been updated to reflect 
    // deletion if any potential		
<span class="fc" id="L627">    double dataDLWithout = dataDL(expFPRate, rulesetStat[0], </span>
<span class="fc" id="L628">				  rulesetStat[1], rulesetStat[4], </span>
<span class="fc" id="L629">				  rulesetStat[5]);</span>
    //System.out.println(&quot;!!!without: &quot;+dataDLWithout + &quot; |potential: &quot;+
    //		   potential);
    // Why subtract potential again?  To reflect change of theory DL??
<span class="fc" id="L633">    return (dataDLWithout - potential);</span>
  }    
    
    
  /**
   * Compute the minimal data description length of the ruleset
   * if the rule in the given position is NOT deleted.&lt;br&gt;
   * The min_data_DL_if_n_deleted = data_DL_if_n_deleted - potential
   *
   * @param index the index of the rule in question
   * @param expFPRate expected FP/(FP+FN), used in dataDL calculation
   * @param checkErr whether check if error rate &gt;= 0.5
   * @return the minDataDL
   */
  public double minDataDLIfExists(int index, double expFPRate,
				  boolean checkErr){
    //	System.out.println(&quot;!!!Enter with: &quot;);
<span class="fc" id="L650">    double[] rulesetStat = new double[6]; // Stats of ruleset if rule exists</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">    for(int j=0; j&lt;m_SimpleStats.size(); j++){</span>
      // Covered stats are cumulative
<span class="fc" id="L653">      rulesetStat[0] += ((double[])m_SimpleStats.elementAt(j))[0];</span>
<span class="fc" id="L654">      rulesetStat[2] += ((double[])m_SimpleStats.elementAt(j))[2];</span>
<span class="fc" id="L655">      rulesetStat[4] += ((double[])m_SimpleStats.elementAt(j))[4];</span>
<span class="fc bfc" id="L656" title="All 2 branches covered.">      if(j == m_SimpleStats.size()-1){ // Last rule</span>
<span class="fc" id="L657">	rulesetStat[1] = ((double[])m_SimpleStats.elementAt(j))[1];</span>
<span class="fc" id="L658">	rulesetStat[3] = ((double[])m_SimpleStats.elementAt(j))[3];</span>
<span class="fc" id="L659">	rulesetStat[5] = ((double[])m_SimpleStats.elementAt(j))[5];</span>
      }	    
    }
	
    // Potential 
<span class="fc" id="L664">    double potential = 0;</span>
<span class="pc bpc" id="L665" title="1 of 2 branches missed.">    for(int k=index+1; k&lt;m_SimpleStats.size(); k++){</span>
<span class="nc" id="L666">      double[] ruleStat = (double[])getSimpleStats(k);</span>
<span class="nc" id="L667">      double ifDeleted = potential(k, expFPRate, rulesetStat, </span>
<span class="nc" id="L668">				   ruleStat, checkErr);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">      if(!Double.isNaN(ifDeleted))</span>
<span class="nc" id="L670">	potential += ifDeleted;</span>
    }
	
    // Data DL of the ruleset without the rule
    // Note that ruleset stats has already been updated to reflect deletion
    // if any potential	
<span class="fc" id="L676">    double dataDLWith = dataDL(expFPRate, rulesetStat[0], </span>
<span class="fc" id="L677">			       rulesetStat[1], rulesetStat[4], </span>
<span class="fc" id="L678">			       rulesetStat[5]);	</span>
    //System.out.println(&quot;!!!with: &quot;+dataDLWith + &quot; |potential: &quot;+
    //		   potential);
<span class="fc" id="L681">    return (dataDLWith - potential);</span>
  }
    
    
  /**
   * The description length (DL) of the ruleset relative to if the
   * rule in the given position is deleted, which is obtained by: &lt;br&gt;
   * MDL if the rule exists - MDL if the rule does not exist &lt;br&gt;
   * Note the minimal possible DL of the ruleset is calculated(i.e. some
   * other rules may also be deleted) instead of the DL of the current
   * ruleset.&lt;p&gt;
   *
   * @param index the given position of the rule in question 
   *              (assuming correct)
   * @param expFPRate expected FP/(FP+FN), used in dataDL calculation
   * @param checkErr whether check if error rate &gt;= 0.5
   * @return the relative DL
   */
  public double relativeDL(int index, double expFPRate, boolean checkErr){ 
		 
<span class="fc" id="L701">    return (minDataDLIfExists(index, expFPRate, checkErr) </span>
<span class="fc" id="L702">	    + theoryDL(index) - </span>
<span class="fc" id="L703">	    minDataDLIfDeleted(index, expFPRate, checkErr));</span>
  }  
    
    
  /**
   * Try to reduce the DL of the ruleset by testing removing the rules
   * one by one in reverse order and update all the stats
   * @param expFPRate expected FP/(FP+FN), used in dataDL calculation
   * @param checkErr whether check if error rate &gt;= 0.5
   */
  public void reduceDL(double expFPRate, boolean checkErr){
	
<span class="fc" id="L715">    boolean needUpdate = false;</span>
<span class="fc" id="L716">    double[] rulesetStat = new double[6];</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">    for(int j=0; j&lt;m_SimpleStats.size(); j++){</span>
      // Covered stats are cumulative
<span class="fc" id="L719">      rulesetStat[0] += ((double[])m_SimpleStats.elementAt(j))[0];</span>
<span class="fc" id="L720">      rulesetStat[2] += ((double[])m_SimpleStats.elementAt(j))[2];</span>
<span class="fc" id="L721">      rulesetStat[4] += ((double[])m_SimpleStats.elementAt(j))[4];</span>
<span class="pc bpc" id="L722" title="1 of 2 branches missed.">      if(j == m_SimpleStats.size()-1){ // Last rule</span>
<span class="fc" id="L723">	rulesetStat[1] = ((double[])m_SimpleStats.elementAt(j))[1];</span>
<span class="fc" id="L724">	rulesetStat[3] = ((double[])m_SimpleStats.elementAt(j))[3];</span>
<span class="fc" id="L725">	rulesetStat[5] = ((double[])m_SimpleStats.elementAt(j))[5];</span>
      }	    
    }
	
    // Potential 
<span class="fc bfc" id="L730" title="All 2 branches covered.">    for(int k=m_SimpleStats.size()-1; k&gt;=0; k--){</span>
	    	
<span class="fc" id="L732">      double[] ruleStat = (double[])m_SimpleStats.elementAt(k);</span>

      // rulesetStat updated
<span class="fc" id="L735">      double ifDeleted = potential(k, expFPRate, rulesetStat, </span>
<span class="fc" id="L736">				   ruleStat, checkErr);</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">      if(!Double.isNaN(ifDeleted)){  </span>
	/*System.err.println(&quot;!!!deleted (&quot;+k+&quot;): save &quot;+ifDeleted
	  +&quot; | &quot;+rulesetStat[0]
	  +&quot; | &quot;+rulesetStat[1]
	  +&quot; | &quot;+rulesetStat[4]
	  +&quot; | &quot;+rulesetStat[5]);
	*/
	
<span class="nc bnc" id="L745" title="All 2 branches missed.">	if(k == (m_SimpleStats.size()-1))</span>
<span class="nc" id="L746">	    removeLast();</span>
	else{
<span class="nc" id="L748">	    m_Ruleset.removeElementAt(k);</span>
<span class="nc" id="L749">	    needUpdate = true;</span>
	}
      }
    }
	
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">    if(needUpdate){</span>
<span class="nc" id="L755">      m_Filtered = null;</span>
<span class="nc" id="L756">      m_SimpleStats = null;</span>
<span class="nc" id="L757">      countData();</span>
    }
<span class="fc" id="L759">  }</span>
    
  /**
   * Remove the last rule in the ruleset as well as it's stats.
   * It might be useful when the last rule was added for testing
   * purpose and then the test failed
   */
  public void removeLast(){
<span class="fc" id="L767">    int last = m_Ruleset.size()-1;</span>
<span class="fc" id="L768">    m_Ruleset.removeElementAt(last);</span>
<span class="fc" id="L769">    m_Filtered.removeElementAt(last);</span>
<span class="fc" id="L770">    m_SimpleStats.removeElementAt(last);	</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">    if(m_Distributions != null)</span>
<span class="fc" id="L772">	m_Distributions.removeElementAt(last);</span>
<span class="fc" id="L773">  }</span>

  /**
   * Static utility function to count the data covered by the 
   * rules after the given index in the given rules, and then
   * remove them.  It returns the data not covered by the
   * successive rules.
   *
   * @param data the data to be processed
   * @param rules the ruleset
   * @param index the given index
   * @return the data after processing
   */
  public static Instances rmCoveredBySuccessives(Instances data, FastVector rules, int index){
<span class="fc" id="L787">    Instances rt = new Instances(data, 0);</span>

<span class="fc bfc" id="L789" title="All 2 branches covered.">    for(int i=0; i &lt; data.numInstances(); i++){</span>
<span class="fc" id="L790">      Instance datum = data.instance(i);</span>
<span class="fc" id="L791">      boolean covered = false;	    </span>
	    
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">      for(int j=index+1; j&lt;rules.size();j++){</span>
<span class="nc" id="L794">	Rule rule = (Rule)rules.elementAt(j);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">	if(rule.covers(datum)){</span>
<span class="nc" id="L796">	  covered = true;</span>
<span class="nc" id="L797">	  break;</span>
	}
      }

<span class="pc bpc" id="L801" title="1 of 2 branches missed.">      if(!covered)</span>
<span class="fc" id="L802">	rt.add(datum);</span>
    }	
<span class="fc" id="L804">    return rt;</span>
  } 
    
  /** 
   * Stratify the given data into the given number of bags based on the class
   * values.  It differs from the &lt;code&gt;Instances.stratify(int fold)&lt;/code&gt;
   * that before stratification it sorts the instances according to the 
   * class order in the header file.  It assumes no missing values in the class.
   * 
   * @param data the given data
   * @param folds the given number of folds
   * @param rand the random object used to randomize the instances
   * @return the stratified instances
   */
  public static final Instances stratify(Instances data, int folds, Random rand){
<span class="pc bpc" id="L819" title="1 of 2 branches missed.">    if(!data.classAttribute().isNominal())</span>
<span class="nc" id="L820">      return data;</span>
	
<span class="fc" id="L822">    Instances result = new Instances(data, 0);</span>
<span class="fc" id="L823">    Instances[] bagsByClasses = new Instances[data.numClasses()];</span>
	
<span class="fc bfc" id="L825" title="All 2 branches covered.">    for(int i=0; i &lt; bagsByClasses.length; i++)</span>
<span class="fc" id="L826">      bagsByClasses[i] = new Instances(data, 0);</span>
	
    // Sort by class	
<span class="fc bfc" id="L829" title="All 2 branches covered.">    for(int j=0; j &lt; data.numInstances(); j++){</span>
<span class="fc" id="L830">      Instance datum = data.instance(j);</span>
<span class="fc" id="L831">      bagsByClasses[(int)datum.classValue()].add(datum);</span>
    }
	
    // Randomize each class
<span class="fc bfc" id="L835" title="All 2 branches covered.">    for(int j=0; j &lt; bagsByClasses.length; j++)</span>
<span class="fc" id="L836">      bagsByClasses[j].randomize(rand);</span>
	
<span class="fc bfc" id="L838" title="All 2 branches covered.">    for(int k=0; k &lt; folds; k++){</span>
<span class="fc" id="L839">      int offset = k, bag = 0;</span>
    oneFold:
<span class="fc" id="L841">      while (true){	</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">	while(offset &gt;= bagsByClasses[bag].numInstances()){</span>
<span class="fc" id="L843">	  offset -= bagsByClasses[bag].numInstances();</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">	  if (++bag &gt;= bagsByClasses.length)// Next bag</span>
<span class="fc" id="L845">	    break oneFold;      	   </span>
	}	
	    
<span class="fc" id="L848">	result.add(bagsByClasses[bag].instance(offset));</span>
<span class="fc" id="L849">	offset += folds;				</span>
      }
    }
	
<span class="fc" id="L853">    return result;</span>
  }

  /** 
   * Compute the combined DL of the ruleset in this class, i.e. theory 
   * DL and data DL.  Note this procedure computes the combined DL
   * according to the current status of the ruleset in this class
   * 
   * @param expFPRate expected FP/(FP+FN), used in dataDL calculation
   * @param predicted the default classification if ruleset covers null
   * @return the combined class
   */
  public double combinedDL(double expFPRate, double predicted){
<span class="nc" id="L866">    double rt = 0;</span>
    
<span class="nc bnc" id="L868" title="All 2 branches missed.">    if(getRulesetSize() &gt; 0) {</span>
<span class="nc" id="L869">      double[] stats = (double[])m_SimpleStats.lastElement();</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">      for(int j=getRulesetSize()-2; j &gt;= 0; j--){</span>
<span class="nc" id="L871">	stats[0] += getSimpleStats(j)[0];</span>
<span class="nc" id="L872">	stats[2] += getSimpleStats(j)[2];</span>
<span class="nc" id="L873">	stats[4] += getSimpleStats(j)[4];</span>
      }
<span class="nc" id="L875">      rt += dataDL(expFPRate, stats[0], stats[1], </span>
<span class="nc" id="L876">		   stats[4], stats[5]);     // Data DL      </span>
    }
    else{ // Null coverage ruleset
<span class="nc" id="L879">      double fn = 0.0;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">      for(int j=0; j &lt; m_Data.numInstances(); j++)</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">	if((int)m_Data.instance(j).classValue() == (int)predicted)</span>
<span class="nc" id="L882">	  fn += m_Data.instance(j).weight();</span>
<span class="nc" id="L883">      rt += dataDL(expFPRate, 0.0, m_Data.sumOfWeights(), 0.0, fn);	</span>
    }     
    
<span class="nc bnc" id="L886" title="All 2 branches missed.">    for(int i=0; i&lt;getRulesetSize(); i++) // Theory DL</span>
<span class="nc" id="L887">      rt += theoryDL(i);     </span>
    
<span class="nc" id="L889">    return rt;</span>
  }
  
  /** 
   * Patition the data into 2, first of which has (numFolds-1)/numFolds of
   * the data and the second has 1/numFolds of the data
   *
   * 
   * @param data the given data
   * @param numFolds the given number of folds
   * @return the patitioned instances
   */
  public static final Instances[] partition(Instances data, int numFolds){
<span class="fc" id="L902">    Instances[] rt = new Instances[2];</span>
<span class="fc" id="L903">    int splits = data.numInstances() * (numFolds - 1) / numFolds;</span>
    
<span class="fc" id="L905">    rt[0] = new Instances(data, 0, splits);</span>
<span class="fc" id="L906">    rt[1] = new Instances(data, splits, data.numInstances()-splits);</span>
    
<span class="fc" id="L908">    return rt;</span>
  }  
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L917">    return RevisionUtils.extract(&quot;$Revision: 4608 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>