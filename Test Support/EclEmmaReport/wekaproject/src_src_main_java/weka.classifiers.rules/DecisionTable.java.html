<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>DecisionTable.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">DecisionTable.java</span></div><h1>DecisionTable.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    DecisionTable.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.rules;

import weka.attributeSelection.ASSearch;
import weka.attributeSelection.BestFirst;
import weka.attributeSelection.SubsetEvaluator;
import weka.attributeSelection.ASEvaluation;
import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.classifiers.lazy.IBk;
import weka.core.AdditionalMeasureProducer;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Remove;

import java.util.Arrays;
import java.util.BitSet;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Class for building and using a simple decision table majority classifier.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see: &lt;br/&gt;
 * &lt;br/&gt;
 * Ron Kohavi: The Power of Decision Tables. In: 8th European Conference on Machine Learning, 174-189, 1995.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Kohavi1995,
 *    author = {Ron Kohavi},
 *    booktitle = {8th European Conference on Machine Learning},
 *    pages = {174-189},
 *    publisher = {Springer},
 *    title = {The Power of Decision Tables},
 *    year = {1995}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;search method specification&amp;gt;
 *  Full class name of search method, followed
 *  by its options.
 *  eg: &quot;weka.attributeSelection.BestFirst -D 1&quot;
 *  (default weka.attributeSelection.BestFirst)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
 *  Use cross validation to evaluate features.
 *  Use number of folds = 1 for leave one out CV.
 *  (Default = leave one out CV)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;acc | rmse | mae | auc&amp;gt;
 *  Performance evaluation measure to use for selecting attributes.
 *  (Default = accuracy for discrete class and rmse for numeric class)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Use nearest neighbour instead of global table majority.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Display decision table rules.
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to search method weka.attributeSelection.BestFirst:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
 *  Specify a starting set of attributes.
 *  Eg. 1,3,5-7.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D &amp;lt;0 = backward | 1 = forward | 2 = bi-directional&amp;gt;
 *  Direction of search. (default = 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;
 *  Number of non-improving nodes to
 *  consider before terminating search.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Size of lookup cache for evaluated subsets.
 *  Expressed as a multiple of the number of
 *  attributes in the data set. (default = 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Mark Hall (mhall@cs.waikato.ac.nz)
 * @version $Revision: 5981 $ 
 */
<span class="fc" id="L133">public class DecisionTable </span>
  extends Classifier 
  implements OptionHandler, WeightedInstancesHandler, 
             AdditionalMeasureProducer, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = 2888557078165701326L;

  /** The hashtable used to hold training instances */
  protected Hashtable m_entries;

  /** The class priors to use when there is no match in the table */
  protected double [] m_classPriorCounts;
  protected double [] m_classPriors;

  /** Holds the final feature set */
  protected int [] m_decisionFeatures;

  /** Discretization filter */
  protected Filter m_disTransform;

  /** Filter used to remove columns discarded by feature selection */
  protected Remove m_delTransform;

  /** IB1 used to classify non matching instances rather than majority class */
  protected IBk m_ibk;

  /** Holds the original training instances */
  protected Instances m_theInstances;

  /** Holds the final feature selected set of instances */
  protected Instances m_dtInstances;

  /** The number of attributes in the dataset */
  protected int m_numAttributes;

  /** The number of instances in the dataset */
  private int m_numInstances;

  /** Class is nominal */
  protected boolean m_classIsNominal;

  /** Use the IBk classifier rather than majority class */
  protected boolean m_useIBk;

  /** Display Rules */
  protected boolean m_displayRules;

  /** Number of folds for cross validating feature sets */
  private int m_CVFolds;

  /** Random numbers for use in cross validation */
  private Random m_rr;

  /** Holds the majority class */
  protected double m_majority;

  /** The search method to use */
<span class="fc" id="L191">  protected ASSearch m_search = new BestFirst();</span>

  /** Our own internal evaluator */
  protected ASEvaluation m_evaluator;

  /** The evaluation object used to evaluate subsets */
  protected Evaluation m_evaluation;

  /** default is accuracy for discrete class and RMSE for numeric class */
  public static final int EVAL_DEFAULT = 1;
  public static final int EVAL_ACCURACY = 2;
  public static final int EVAL_RMSE = 3;
  public static final int EVAL_MAE = 4;
  public static final int EVAL_AUC = 5;

<span class="fc" id="L206">  public static final Tag [] TAGS_EVALUATION = {</span>
<span class="fc" id="L207">    new Tag(EVAL_DEFAULT, &quot;Default: accuracy (discrete class); RMSE (numeric class)&quot;),</span>
<span class="fc" id="L208">    new Tag(EVAL_ACCURACY, &quot;Accuracy (discrete class only&quot;),</span>
<span class="fc" id="L209">    new Tag(EVAL_RMSE, &quot;RMSE (of the class probabilities for discrete class)&quot;),</span>
<span class="fc" id="L210">    new Tag(EVAL_MAE, &quot;MAE (of the class probabilities for discrete class)&quot;),</span>
<span class="fc" id="L211">    new Tag(EVAL_AUC, &quot;AUC (area under the ROC curve - discrete class only)&quot;)</span>
  };

<span class="fc" id="L214">  protected int m_evaluationMeasure = EVAL_DEFAULT;</span>

  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L223">    return  </span>
<span class="nc" id="L224">    &quot;Class for building and using a simple decision table majority &quot;</span>
    + &quot;classifier.\n\n&quot;
    + &quot;For more information see: \n\n&quot;
<span class="nc" id="L227">    + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;

<span class="nc" id="L240">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L241">    result.setValue(Field.AUTHOR, &quot;Ron Kohavi&quot;);</span>
<span class="nc" id="L242">    result.setValue(Field.TITLE, &quot;The Power of Decision Tables&quot;);</span>
<span class="nc" id="L243">    result.setValue(Field.BOOKTITLE, &quot;8th European Conference on Machine Learning&quot;);</span>
<span class="nc" id="L244">    result.setValue(Field.YEAR, &quot;1995&quot;);</span>
<span class="nc" id="L245">    result.setValue(Field.PAGES, &quot;174-189&quot;);</span>
<span class="nc" id="L246">    result.setValue(Field.PUBLISHER, &quot;Springer&quot;);</span>

<span class="nc" id="L248">    return result;</span>
  }
  
  /**
   * Inserts an instance into the hash table
   *
   * @param inst instance to be inserted
   * @param instA to create the hash key from
   * @throws Exception if the instance can't be inserted
   */
  private void insertIntoTable(Instance inst, double [] instA)
  throws Exception {

    double [] tempClassDist2;
    double [] newDist;
    DecisionTableHashKey thekey;

<span class="fc bfc" id="L265" title="All 2 branches covered.">    if (instA != null) {</span>
<span class="fc" id="L266">      thekey = new DecisionTableHashKey(instA);</span>
    } else {
<span class="fc" id="L268">      thekey = new DecisionTableHashKey(inst, inst.numAttributes(), false);</span>
    }

    // see if this one is already in the table
<span class="fc" id="L272">    tempClassDist2 = (double []) m_entries.get(thekey);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    if (tempClassDist2 == null) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      if (m_classIsNominal) {</span>
<span class="fc" id="L275">	newDist = new double [m_theInstances.classAttribute().numValues()];</span>
	
	//Leplace estimation
<span class="fc bfc" id="L278" title="All 2 branches covered.">	for (int i = 0; i &lt; m_theInstances.classAttribute().numValues(); i++) {</span>
<span class="fc" id="L279">	  newDist[i] = 1.0;</span>
	}
	
<span class="fc" id="L282">	newDist[(int)inst.classValue()] = inst.weight();</span>

	// add to the table
<span class="fc" id="L285">	m_entries.put(thekey, newDist);</span>
      } else {
<span class="fc" id="L287">	newDist = new double [2];</span>
<span class="fc" id="L288">	newDist[0] = inst.classValue() * inst.weight();</span>
<span class="fc" id="L289">	newDist[1] = inst.weight();</span>

	// add to the table
<span class="fc" id="L292">	m_entries.put(thekey, newDist);</span>
      }
    } else { 

      // update the distribution for this instance
<span class="fc bfc" id="L297" title="All 2 branches covered.">      if (m_classIsNominal) {</span>
<span class="fc" id="L298">	tempClassDist2[(int)inst.classValue()]+=inst.weight();</span>

	// update the table
<span class="fc" id="L301">	m_entries.put(thekey, tempClassDist2);</span>
      } else  {
<span class="fc" id="L303">	tempClassDist2[0] += (inst.classValue() * inst.weight());</span>
<span class="fc" id="L304">	tempClassDist2[1] += inst.weight();</span>

	// update the table
<span class="fc" id="L307">	m_entries.put(thekey, tempClassDist2);</span>
      }
    }
<span class="fc" id="L310">  }</span>

  /**
   * Classifies an instance for internal leave one out cross validation
   * of feature sets
   *
   * @param instance instance to be &quot;left out&quot; and classified
   * @param instA feature values of the selected features for the instance
   * @return the classification of the instance
   * @throws Exception if something goes wrong
   */
  double evaluateInstanceLeaveOneOut(Instance instance, double [] instA)
  throws Exception {

    DecisionTableHashKey thekey;
    double [] tempDist;
    double [] normDist;

<span class="fc" id="L328">    thekey = new DecisionTableHashKey(instA);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">    if (m_classIsNominal) {</span>

      // if this one is not in the table
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">      if ((tempDist = (double [])m_entries.get(thekey)) == null) {</span>
<span class="nc" id="L333">	throw new Error(&quot;This should never happen!&quot;);</span>
      } else {
<span class="fc" id="L335">	normDist = new double [tempDist.length];</span>
<span class="fc" id="L336">	System.arraycopy(tempDist,0,normDist,0,tempDist.length);</span>
<span class="fc" id="L337">	normDist[(int)instance.classValue()] -= instance.weight();</span>

	// update the table
	// first check to see if the class counts are all zero now
<span class="fc" id="L341">	boolean ok = false;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">	for (int i=0;i&lt;normDist.length;i++) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">	  if (Utils.gr(normDist[i],1.0)) {</span>
<span class="fc" id="L344">	    ok = true;</span>
<span class="fc" id="L345">	    break;</span>
	  }
	}

//	downdate the class prior counts
<span class="fc" id="L350">	m_classPriorCounts[(int)instance.classValue()] -= </span>
<span class="fc" id="L351">	  instance.weight();</span>
<span class="fc" id="L352">	double [] classPriors = m_classPriorCounts.clone();</span>
<span class="fc" id="L353">	Utils.normalize(classPriors);</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">	if (!ok) { // majority class</span>
<span class="fc" id="L355">	  normDist = classPriors;</span>
	}

<span class="fc" id="L358">	m_classPriorCounts[(int)instance.classValue()] += </span>
<span class="fc" id="L359">	  instance.weight();</span>

	//if (ok) {
<span class="fc" id="L362">	Utils.normalize(normDist);</span>
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">	if (m_evaluationMeasure == EVAL_AUC) {</span>
<span class="nc" id="L364">	  m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, instance);						</span>
	} else {
<span class="fc" id="L366">	  m_evaluation.evaluateModelOnce(normDist, instance);</span>
	}
<span class="fc" id="L368">	return Utils.maxIndex(normDist);</span>
	/*} else {
	  normDist = new double [normDist.length];
	  normDist[(int)m_majority] = 1.0;
	  if (m_evaluationMeasure == EVAL_AUC) {
	    m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, instance);						
	  } else {
	    m_evaluation.evaluateModelOnce(normDist, instance);
	  }
	  return m_majority;
	} */
      }
      //      return Utils.maxIndex(tempDist);
    } else {

      // see if this one is already in the table
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">      if ((tempDist = (double[])m_entries.get(thekey)) != null) {</span>
<span class="fc" id="L385">	normDist = new double [tempDist.length];</span>
<span class="fc" id="L386">	System.arraycopy(tempDist,0,normDist,0,tempDist.length);</span>
<span class="fc" id="L387">	normDist[0] -= (instance.classValue() * instance.weight());</span>
<span class="fc" id="L388">	normDist[1] -= instance.weight();</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">	if (Utils.eq(normDist[1],0.0)) {</span>
<span class="fc" id="L390">	  double [] temp = new double[1];</span>
<span class="fc" id="L391">	  temp[0] = m_majority;</span>
<span class="fc" id="L392">	  m_evaluation.evaluateModelOnce(temp, instance);</span>
<span class="fc" id="L393">	  return m_majority;</span>
	} else {
<span class="fc" id="L395">	  double [] temp = new double[1];</span>
<span class="fc" id="L396">	  temp[0] = normDist[0] / normDist[1];</span>
<span class="fc" id="L397">	  m_evaluation.evaluateModelOnce(temp, instance);</span>
<span class="fc" id="L398">	  return temp[0];</span>
	}
      } else {
<span class="nc" id="L401">	throw new Error(&quot;This should never happen!&quot;);</span>
      }
    }

    // shouldn't get here 
    // return 0.0;
  }

  /**
   * Calculates the accuracy on a test fold for internal cross validation
   * of feature sets
   *
   * @param fold set of instances to be &quot;left out&quot; and classified
   * @param fs currently selected feature set
   * @return the accuracy for the fold
   * @throws Exception if something goes wrong
   */
  double evaluateFoldCV(Instances fold, int [] fs) throws Exception {

    int i;
<span class="nc" id="L421">    int ruleCount = 0;</span>
<span class="nc" id="L422">    int numFold = fold.numInstances();</span>
<span class="nc" id="L423">    int numCl = m_theInstances.classAttribute().numValues();</span>
<span class="nc" id="L424">    double [][] class_distribs = new double [numFold][numCl];</span>
<span class="nc" id="L425">    double [] instA = new double [fs.length];</span>
    double [] normDist;
    DecisionTableHashKey thekey;
<span class="nc" id="L428">    double acc = 0.0;</span>
<span class="nc" id="L429">    int classI = m_theInstances.classIndex();</span>
    Instance inst;

<span class="nc bnc" id="L432" title="All 2 branches missed.">    if (m_classIsNominal) {</span>
<span class="nc" id="L433">      normDist = new double [numCl];</span>
    } else {
<span class="nc" id="L435">      normDist = new double [2];</span>
    }

    // first *remove* instances
<span class="nc bnc" id="L439" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L440">      inst = fold.instance(i);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">      for (int j=0;j&lt;fs.length;j++) {</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">	if (fs[j] == classI) {</span>
<span class="nc" id="L443">	  instA[j] = Double.MAX_VALUE; // missing for the class</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">	} else if (inst.isMissing(fs[j])) {</span>
<span class="nc" id="L445">	  instA[j] = Double.MAX_VALUE;</span>
	} else{
<span class="nc" id="L447">	  instA[j] = inst.value(fs[j]);</span>
	}
      }
<span class="nc" id="L450">      thekey = new DecisionTableHashKey(instA);</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">      if ((class_distribs[i] = (double [])m_entries.get(thekey)) == null) {</span>
<span class="nc" id="L452">	throw new Error(&quot;This should never happen!&quot;);</span>
      } else {
<span class="nc bnc" id="L454" title="All 2 branches missed.">	if (m_classIsNominal) {</span>
<span class="nc" id="L455">	  class_distribs[i][(int)inst.classValue()] -= inst.weight();</span>
	} else {
<span class="nc" id="L457">	  class_distribs[i][0] -= (inst.classValue() * inst.weight());</span>
<span class="nc" id="L458">	  class_distribs[i][1] -= inst.weight();</span>
	}
<span class="nc" id="L460">	ruleCount++;</span>
      }
<span class="nc" id="L462">      m_classPriorCounts[(int)inst.classValue()] -= </span>
<span class="nc" id="L463">	inst.weight();	</span>
    }
<span class="nc" id="L465">    double [] classPriors = m_classPriorCounts.clone();</span>
<span class="nc" id="L466">    Utils.normalize(classPriors);</span>

    // now classify instances
<span class="nc bnc" id="L469" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L470">      inst = fold.instance(i);</span>
<span class="nc" id="L471">      System.arraycopy(class_distribs[i],0,normDist,0,normDist.length);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">      if (m_classIsNominal) {</span>
<span class="nc" id="L473">	boolean ok = false;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">	for (int j=0;j&lt;normDist.length;j++) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">	  if (Utils.gr(normDist[j],1.0)) {</span>
<span class="nc" id="L476">	    ok = true;</span>
<span class="nc" id="L477">	    break;</span>
	  }
	}

<span class="nc bnc" id="L481" title="All 2 branches missed.">	if (!ok) { // majority class</span>
<span class="nc" id="L482">	  normDist = classPriors.clone();</span>
	}

//	if (ok) {
<span class="nc" id="L486">	Utils.normalize(normDist);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">	if (m_evaluationMeasure == EVAL_AUC) {</span>
<span class="nc" id="L488">	  m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, inst);						</span>
	} else {
<span class="nc" id="L490">	  m_evaluation.evaluateModelOnce(normDist, inst);</span>
	}
	/*	} else {					
	  normDist[(int)m_majority] = 1.0;
	  if (m_evaluationMeasure == EVAL_AUC) {
	    m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, inst);						
	  } else {
	    m_evaluation.evaluateModelOnce(normDist, inst);					
	  }
	} */
      } else {
<span class="nc bnc" id="L501" title="All 2 branches missed.">	if (Utils.eq(normDist[1],0.0)) {</span>
<span class="nc" id="L502">	  double [] temp = new double[1];</span>
<span class="nc" id="L503">	  temp[0] = m_majority;</span>
<span class="nc" id="L504">	  m_evaluation.evaluateModelOnce(temp, inst);</span>
	} else {
<span class="nc" id="L506">	  double [] temp = new double[1];</span>
<span class="nc" id="L507">	  temp[0] = normDist[0] / normDist[1];</span>
<span class="nc" id="L508">	  m_evaluation.evaluateModelOnce(temp, inst);</span>
	}
      }
    }

    // now re-insert instances
<span class="nc bnc" id="L514" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L515">      inst = fold.instance(i);</span>

<span class="nc" id="L517">      m_classPriorCounts[(int)inst.classValue()] += </span>
<span class="nc" id="L518">	inst.weight();</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">      if (m_classIsNominal) {</span>
<span class="nc" id="L521">	class_distribs[i][(int)inst.classValue()] += inst.weight();</span>
      } else {
<span class="nc" id="L523">	class_distribs[i][0] += (inst.classValue() * inst.weight());</span>
<span class="nc" id="L524">	class_distribs[i][1] += inst.weight();</span>
      }
    }
<span class="nc" id="L527">    return acc;</span>
  }


  /**
   * Evaluates a feature subset by cross validation
   *
   * @param feature_set the subset to be evaluated
   * @param num_atts the number of attributes in the subset
   * @return the estimated accuracy
   * @throws Exception if subset can't be evaluated
   */
  protected double estimatePerformance(BitSet feature_set, int num_atts)
  throws Exception {

<span class="fc" id="L542">    m_evaluation = new Evaluation(m_theInstances);</span>
    int i;
<span class="fc" id="L544">    int [] fs = new int [num_atts];</span>

<span class="fc" id="L546">    double [] instA = new double [num_atts];</span>
<span class="fc" id="L547">    int classI = m_theInstances.classIndex();</span>

<span class="fc" id="L549">    int index = 0;</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">    for (i=0;i&lt;m_numAttributes;i++) {</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">      if (feature_set.get(i)) {</span>
<span class="fc" id="L552">	fs[index++] = i;</span>
      }
    }

    // create new hash table
<span class="fc" id="L557">    m_entries = new Hashtable((int)(m_theInstances.numInstances() * 1.5));</span>

    // insert instances into the hash table
<span class="fc bfc" id="L560" title="All 2 branches covered.">    for (i=0;i&lt;m_numInstances;i++) {</span>

<span class="fc" id="L562">      Instance inst = m_theInstances.instance(i);</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">      for (int j=0;j&lt;fs.length;j++) {</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">	if (fs[j] == classI) {</span>
<span class="nc" id="L565">	  instA[j] = Double.MAX_VALUE; // missing for the class</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">	} else if (inst.isMissing(fs[j])) {</span>
<span class="fc" id="L567">	  instA[j] = Double.MAX_VALUE;</span>
	} else {
<span class="fc" id="L569">	  instA[j] = inst.value(fs[j]);</span>
	}
      }
<span class="fc" id="L572">      insertIntoTable(inst, instA);</span>
    }


<span class="pc bpc" id="L576" title="1 of 2 branches missed.">    if (m_CVFolds == 1) {</span>

      // calculate leave one out error
<span class="fc bfc" id="L579" title="All 2 branches covered.">      for (i=0;i&lt;m_numInstances;i++) {</span>
<span class="fc" id="L580">	Instance inst = m_theInstances.instance(i);</span>
<span class="fc bfc" id="L581" title="All 2 branches covered.">	for (int j=0;j&lt;fs.length;j++) {</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">	  if (fs[j] == classI) {</span>
<span class="nc" id="L583">	    instA[j] = Double.MAX_VALUE; // missing for the class</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">	  } else if (inst.isMissing(fs[j])) {</span>
<span class="fc" id="L585">	    instA[j] = Double.MAX_VALUE;</span>
	  } else {
<span class="fc" id="L587">	    instA[j] = inst.value(fs[j]);</span>
	  }
	}
<span class="fc" id="L590">	evaluateInstanceLeaveOneOut(inst, instA);				</span>
      }
    } else {
<span class="nc" id="L593">      m_theInstances.randomize(m_rr);</span>
<span class="nc" id="L594">      m_theInstances.stratify(m_CVFolds);</span>

      // calculate 10 fold cross validation error
<span class="nc bnc" id="L597" title="All 2 branches missed.">      for (i=0;i&lt;m_CVFolds;i++) {</span>
<span class="nc" id="L598">	Instances insts = m_theInstances.testCV(m_CVFolds,i);</span>
<span class="nc" id="L599">	evaluateFoldCV(insts, fs);</span>
      }
    }

<span class="pc bpc" id="L603" title="5 of 6 branches missed.">    switch (m_evaluationMeasure) {</span>
    case EVAL_DEFAULT:
<span class="fc bfc" id="L605" title="All 2 branches covered.">      if (m_classIsNominal) {</span>
<span class="fc" id="L606">	return m_evaluation.pctCorrect();</span>
      }
<span class="fc" id="L608">      return -m_evaluation.rootMeanSquaredError();</span>
    case EVAL_ACCURACY:
<span class="nc" id="L610">      return m_evaluation.pctCorrect();</span>
    case EVAL_RMSE:
<span class="nc" id="L612">      return -m_evaluation.rootMeanSquaredError();</span>
    case EVAL_MAE:
<span class="nc" id="L614">      return -m_evaluation.meanAbsoluteError();</span>
    case EVAL_AUC:
<span class="nc" id="L616">      double [] classPriors = m_evaluation.getClassPriors();</span>
<span class="nc" id="L617">      Utils.normalize(classPriors);</span>
<span class="nc" id="L618">      double weightedAUC = 0;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">      for (i = 0; i &lt; m_theInstances.classAttribute().numValues(); i++) {</span>
<span class="nc" id="L620">	double tempAUC = m_evaluation.areaUnderROC(i);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">	if (!Instance.isMissingValue(tempAUC)) {</span>
<span class="nc" id="L622">	  weightedAUC += (classPriors[i] * tempAUC);</span>
	} else {
<span class="nc" id="L624">	  System.err.println(&quot;Undefined AUC!!&quot;);</span>
	}
      }
<span class="nc" id="L627">      return weightedAUC;</span>
    }
    // shouldn't get here
<span class="nc" id="L630">    return 0.0;</span>
  }

  /**
   * Returns a String representation of a feature subset
   *
   * @param sub BitSet representation of a subset
   * @return String containing subset
   */
  private String printSub(BitSet sub) {

<span class="nc" id="L641">    String s=&quot;&quot;;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">    for (int jj=0;jj&lt;m_numAttributes;jj++) {</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">      if (sub.get(jj)) {</span>
<span class="nc" id="L644">	s += &quot; &quot;+(jj+1);</span>
      }
    }
<span class="nc" id="L647">    return s;</span>
  }

  /**
   * Resets the options.
   */
  protected void resetOptions()  {

<span class="fc" id="L655">    m_entries = null;</span>
<span class="fc" id="L656">    m_decisionFeatures = null;</span>
<span class="fc" id="L657">    m_useIBk = false;</span>
<span class="fc" id="L658">    m_CVFolds = 1;</span>
<span class="fc" id="L659">    m_displayRules = false;</span>
<span class="fc" id="L660">    m_evaluationMeasure = EVAL_DEFAULT;</span>
<span class="fc" id="L661">  }</span>

  /**
   * Constructor for a DecisionTable
   */
<span class="fc" id="L666">  public DecisionTable() {</span>

<span class="fc" id="L668">    resetOptions();</span>
<span class="fc" id="L669">  }</span>

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="fc" id="L678">    Vector newVector = new Vector(7);</span>

<span class="fc" id="L680">    newVector.addElement(new Option(</span>
<span class="fc" id="L681">	&quot;\tFull class name of search method, followed\n&quot;</span>
	+ &quot;\tby its options.\n&quot;
	+ &quot;\teg: \&quot;weka.attributeSelection.BestFirst -D 1\&quot;\n&quot;
	+ &quot;\t(default weka.attributeSelection.BestFirst)&quot;,
<span class="fc" id="L685">	&quot;S&quot;, 1, &quot;-S &lt;search method specification&gt;&quot;));</span>

<span class="fc" id="L687">    newVector.addElement(new Option(</span>
<span class="fc" id="L688">	&quot;\tUse cross validation to evaluate features.\n&quot; +</span>
	&quot;\tUse number of folds = 1 for leave one out CV.\n&quot; +
	&quot;\t(Default = leave one out CV)&quot;,
<span class="fc" id="L691">	&quot;X&quot;, 1, &quot;-X &lt;number of folds&gt;&quot;));</span>

<span class="fc" id="L693">    newVector.addElement(new Option(</span>
<span class="fc" id="L694">	&quot;\tPerformance evaluation measure to use for selecting attributes.\n&quot; +</span>
	&quot;\t(Default = accuracy for discrete class and rmse for numeric class)&quot;,
<span class="fc" id="L696">	&quot;E&quot;, 1, &quot;-E &lt;acc | rmse | mae | auc&gt;&quot;));</span>

<span class="fc" id="L698">    newVector.addElement(new Option(</span>
<span class="fc" id="L699">	&quot;\tUse nearest neighbour instead of global table majority.&quot;,</span>
<span class="fc" id="L700">	&quot;I&quot;, 0, &quot;-I&quot;));</span>

<span class="fc" id="L702">    newVector.addElement(new Option(</span>
<span class="fc" id="L703">	&quot;\tDisplay decision table rules.\n&quot;,</span>
<span class="fc" id="L704">	&quot;R&quot;, 0, &quot;-R&quot;)); </span>

<span class="fc" id="L706">    newVector.addElement(new Option(</span>
<span class="fc" id="L707">	&quot;&quot;,</span>
<span class="fc" id="L708">	&quot;&quot;, 0, &quot;\nOptions specific to search method &quot;</span>
<span class="fc" id="L709">	+ m_search.getClass().getName() + &quot;:&quot;));</span>
<span class="fc" id="L710">    Enumeration enu = ((OptionHandler)m_search).listOptions();</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">    while (enu.hasMoreElements()) {</span>
<span class="fc" id="L712">      newVector.addElement(enu.nextElement());</span>
    }
<span class="fc" id="L714">    return newVector.elements();</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String crossValTipText() {
<span class="nc" id="L723">    return &quot;Sets the number of folds for cross validation (1 = leave one out).&quot;;</span>
  }

  /**
   * Sets the number of folds for cross validation (1 = leave one out)
   *
   * @param folds the number of folds
   */
  public void setCrossVal(int folds) {

<span class="fc" id="L733">    m_CVFolds = folds;</span>
<span class="fc" id="L734">  }</span>

  /**
   * Gets the number of folds for cross validation
   *
   * @return the number of cross validation folds
   */
  public int getCrossVal() {

<span class="fc" id="L743">    return m_CVFolds;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useIBkTipText() {
<span class="nc" id="L752">    return &quot;Sets whether IBk should be used instead of the majority class.&quot;;</span>
  }

  /**
   * Sets whether IBk should be used instead of the majority class
   *
   * @param ibk true if IBk is to be used
   */
  public void setUseIBk(boolean ibk) {

<span class="nc" id="L762">    m_useIBk = ibk;</span>
<span class="nc" id="L763">  }</span>

  /**
   * Gets whether IBk is being used instead of the majority class
   *
   * @return true if IBk is being used
   */
  public boolean getUseIBk() {

<span class="nc" id="L772">    return m_useIBk;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String displayRulesTipText() {
<span class="nc" id="L781">    return &quot;Sets whether rules are to be printed.&quot;;</span>
  }

  /**
   * Sets whether rules are to be printed
   *
   * @param rules true if rules are to be printed
   */
  public void setDisplayRules(boolean rules) {

<span class="nc" id="L791">    m_displayRules = rules;</span>
<span class="nc" id="L792">  }</span>

  /**
   * Gets whether rules are being printed
   *
   * @return true if rules are being printed
   */
  public boolean getDisplayRules() {

<span class="nc" id="L801">    return m_displayRules;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String searchTipText() {
<span class="nc" id="L810">    return &quot;The search method used to find good attribute combinations for the &quot;</span>
    + &quot;decision table.&quot;;
  }
  /**
   * Sets the search method to use
   * 
   * @param search
   */
  public void setSearch(ASSearch search) {
<span class="fc" id="L819">    m_search = search;</span>
<span class="fc" id="L820">  }</span>

  /**
   * Gets the current search method
   * 
   * @return the search method used
   */
  public ASSearch getSearch() {
<span class="fc" id="L828">    return m_search;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String evaluationMeasureTipText() {
<span class="nc" id="L837">    return &quot;The measure used to evaluate the performance of attribute combinations &quot;</span>
    + &quot;used in the decision table.&quot;;
  }
  /**
   * Gets the currently set performance evaluation measure used for selecting
   * attributes for the decision table
   * 
   * @return the performance evaluation measure
   */
  public SelectedTag getEvaluationMeasure() {
<span class="nc" id="L847">    return new SelectedTag(m_evaluationMeasure, TAGS_EVALUATION);</span>
  }

  /**
   * Sets the performance evaluation measure to use for selecting attributes
   * for the decision table
   * 
   * @param newMethod the new performance evaluation metric to use
   */
  public void setEvaluationMeasure(SelectedTag newMethod) {
<span class="nc bnc" id="L857" title="All 2 branches missed.">    if (newMethod.getTags() == TAGS_EVALUATION) {</span>
<span class="nc" id="L858">      m_evaluationMeasure = newMethod.getSelectedTag().getID();</span>
    }
<span class="nc" id="L860">  }</span>

  /**
   * Parses the options for this object. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;search method specification&amp;gt;
   *  Full class name of search method, followed
   *  by its options.
   *  eg: &quot;weka.attributeSelection.BestFirst -D 1&quot;
   *  (default weka.attributeSelection.BestFirst)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
   *  Use cross validation to evaluate features.
   *  Use number of folds = 1 for leave one out CV.
   *  (Default = leave one out CV)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E &amp;lt;acc | rmse | mae | auc&amp;gt;
   *  Performance evaluation measure to use for selecting attributes.
   *  (Default = accuracy for discrete class and rmse for numeric class)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I
   *  Use nearest neighbour instead of global table majority.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Display decision table rules.
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to search method weka.attributeSelection.BestFirst:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;start set&amp;gt;
   *  Specify a starting set of attributes.
   *  Eg. 1,3,5-7.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D &amp;lt;0 = backward | 1 = forward | 2 = bi-directional&amp;gt;
   *  Direction of search. (default = 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;
   *  Number of non-improving nodes to
   *  consider before terminating search.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Size of lookup cache for evaluated subsets.
   *  Expressed as a multiple of the number of
   *  attributes in the data set. (default = 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

    String optionString;

<span class="fc" id="L919">    resetOptions();</span>

<span class="fc" id="L921">    optionString = Utils.getOption('X',options);</span>
<span class="fc bfc" id="L922" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L923">      m_CVFolds = Integer.parseInt(optionString);</span>
    }

<span class="fc" id="L926">    m_useIBk = Utils.getFlag('I',options);</span>

<span class="fc" id="L928">    m_displayRules = Utils.getFlag('R',options);</span>

<span class="fc" id="L930">    optionString = Utils.getOption('E', options);</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">      if (optionString.equals(&quot;acc&quot;)) {</span>
<span class="nc" id="L933">	setEvaluationMeasure(new SelectedTag(EVAL_ACCURACY, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">      } else if (optionString.equals(&quot;rmse&quot;)) {</span>
<span class="nc" id="L935">	setEvaluationMeasure(new SelectedTag(EVAL_RMSE, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">      } else if (optionString.equals(&quot;mae&quot;)) {</span>
<span class="nc" id="L937">	setEvaluationMeasure(new SelectedTag(EVAL_MAE, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">      } else if (optionString.equals(&quot;auc&quot;)) {</span>
<span class="nc" id="L939">	setEvaluationMeasure(new SelectedTag(EVAL_AUC, TAGS_EVALUATION));</span>
      } else {
<span class="nc" id="L941">	throw new IllegalArgumentException(&quot;Invalid evaluation measure&quot;);</span>
      }
    }

<span class="fc" id="L945">    String searchString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L946" title="All 2 branches covered.">    if (searchString.length() == 0)</span>
<span class="fc" id="L947">      searchString = weka.attributeSelection.BestFirst.class.getName();</span>
<span class="fc" id="L948">    String [] searchSpec = Utils.splitOptions(searchString);</span>
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">    if (searchSpec.length == 0) {</span>
<span class="nc" id="L950">      throw new IllegalArgumentException(&quot;Invalid search specification string&quot;);</span>
    }
<span class="fc" id="L952">    String searchName = searchSpec[0];</span>
<span class="fc" id="L953">    searchSpec[0] = &quot;&quot;;</span>
<span class="fc" id="L954">    setSearch(ASSearch.forName(searchName, searchSpec));</span>
<span class="fc" id="L955">  }</span>

  /**
   * Gets the current settings of the classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L964">    String [] options = new String [9];</span>
<span class="fc" id="L965">    int current = 0;</span>

<span class="fc" id="L967">    options[current++] = &quot;-X&quot;; options[current++] = &quot;&quot; + m_CVFolds;</span>

<span class="pc bpc" id="L969" title="1 of 2 branches missed.">    if (m_evaluationMeasure != EVAL_DEFAULT) {</span>
<span class="nc" id="L970">      options[current++] = &quot;-E&quot;;</span>
<span class="nc bnc" id="L971" title="All 5 branches missed.">      switch (m_evaluationMeasure) {</span>
      case EVAL_ACCURACY:
<span class="nc" id="L973">	options[current++] = &quot;acc&quot;;</span>
<span class="nc" id="L974">	break;</span>
      case EVAL_RMSE:
<span class="nc" id="L976">	options[current++] = &quot;rmse&quot;;</span>
<span class="nc" id="L977">	break;</span>
      case EVAL_MAE:
<span class="nc" id="L979">	options[current++] = &quot;mae&quot;;</span>
<span class="nc" id="L980">	break;</span>
      case EVAL_AUC:
<span class="nc" id="L982">	options[current++] = &quot;auc&quot;;</span>
	break;
      }
    }
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">    if (m_useIBk) {</span>
<span class="nc" id="L987">      options[current++] = &quot;-I&quot;;</span>
    }
<span class="pc bpc" id="L989" title="1 of 2 branches missed.">    if (m_displayRules) {</span>
<span class="nc" id="L990">      options[current++] = &quot;-R&quot;;</span>
    }

<span class="fc" id="L993">    options[current++] = &quot;-S&quot;;</span>
<span class="fc" id="L994">    options[current++] = &quot;&quot; + getSearchSpec();</span>

<span class="fc bfc" id="L996" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L997">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L999">    return options;</span>
  }

  /**
   * Gets the search specification string, which contains the class name of
   * the search method and any options to it
   *
   * @return the search string.
   */
  protected String getSearchSpec() {

<span class="fc" id="L1010">    ASSearch s = getSearch();</span>
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">    if (s instanceof OptionHandler) {</span>
<span class="fc" id="L1012">      return s.getClass().getName() + &quot; &quot;</span>
<span class="fc" id="L1013">      + Utils.joinOptions(((OptionHandler)s).getOptions());</span>
    }
<span class="nc" id="L1015">    return s.getClass().getName();</span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1024">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1025">    result.disableAll();</span>

    // attributes
<span class="fc" id="L1028">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L1029">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L1030">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L1031">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L1034">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="pc bpc" id="L1035" title="2 of 4 branches missed.">    if (m_evaluationMeasure != EVAL_ACCURACY &amp;&amp; m_evaluationMeasure != EVAL_AUC) {</span>
<span class="fc" id="L1036">      result.enable(Capability.NUMERIC_CLASS);</span>
<span class="fc" id="L1037">      result.enable(Capability.DATE_CLASS);</span>
    }
    
<span class="fc" id="L1040">    result.enable(Capability.MISSING_CLASS_VALUES);</span>

<span class="fc" id="L1042">    return result;</span>
  }
  
<span class="fc" id="L1045">  private class DummySubsetEvaluator extends ASEvaluation implements SubsetEvaluator {</span>
    /** for serialization */
    private static final long serialVersionUID = 3927442457704974150L;
      
    public void buildEvaluator(Instances data) throws Exception {
<span class="nc" id="L1050">    }</span>

    public double evaluateSubset(BitSet subset) throws Exception {

<span class="fc" id="L1054">      int fc = 0;</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">      for (int jj = 0;jj &lt; m_numAttributes; jj++) {</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">        if (subset.get(jj)) {</span>
<span class="fc" id="L1057">          fc++;</span>
        }
      }

<span class="fc" id="L1061">      return estimatePerformance(subset, fc);</span>
    }
  }

  /**
   * Sets up a dummy subset evaluator that basically just delegates
   * evaluation to the estimatePerformance method in DecisionTable
   */
  protected void setUpEvaluator() throws Exception {
<span class="fc" id="L1070">    m_evaluator = new DummySubsetEvaluator();</span>
<span class="fc" id="L1071">  }</span>

<span class="fc" id="L1073">  protected boolean m_saveMemory = true;</span>
  /**
   * Generates the classifier.
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the classifier has not been generated successfully
   */
  public void buildClassifier(Instances data) throws Exception {

    // can classifier handle the data?
<span class="fc" id="L1083">    getCapabilities().testWithFail(data);</span>

    // remove instances with missing class
<span class="fc" id="L1086">    m_theInstances = new Instances(data);</span>
<span class="fc" id="L1087">    m_theInstances.deleteWithMissingClass();</span>

<span class="fc" id="L1089">    m_rr = new Random(1);</span>

<span class="fc bfc" id="L1091" title="All 2 branches covered.">    if (m_theInstances.classAttribute().isNominal())  {//	 Set up class priors</span>
<span class="fc" id="L1092">      m_classPriorCounts = </span>
<span class="fc" id="L1093">	new double [data.classAttribute().numValues()];</span>
<span class="fc" id="L1094">      Arrays.fill(m_classPriorCounts, 1.0);</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">      for (int i = 0; i &lt;data.numInstances(); i++) {</span>
<span class="fc" id="L1096">	Instance curr = data.instance(i);</span>
<span class="fc" id="L1097">	m_classPriorCounts[(int)curr.classValue()] += </span>
<span class="fc" id="L1098">	  curr.weight();</span>
      }
<span class="fc" id="L1100">      m_classPriors = m_classPriorCounts.clone();</span>
<span class="fc" id="L1101">      Utils.normalize(m_classPriors);</span>
    }

<span class="fc" id="L1104">    setUpEvaluator();</span>

<span class="fc bfc" id="L1106" title="All 2 branches covered.">    if (m_theInstances.classAttribute().isNumeric()) {</span>
<span class="fc" id="L1107">      m_disTransform = new weka.filters.unsupervised.attribute.Discretize();</span>
<span class="fc" id="L1108">      m_classIsNominal = false;</span>

      // use binned discretisation if the class is numeric
<span class="fc" id="L1111">      ((weka.filters.unsupervised.attribute.Discretize)m_disTransform).</span>
<span class="fc" id="L1112">      setBins(10);</span>
<span class="fc" id="L1113">      ((weka.filters.unsupervised.attribute.Discretize)m_disTransform).</span>
<span class="fc" id="L1114">      setInvertSelection(true);</span>

      // Discretize all attributes EXCEPT the class 
<span class="fc" id="L1117">      String rangeList = &quot;&quot;;</span>
<span class="fc" id="L1118">      rangeList+=(m_theInstances.classIndex()+1);</span>
      //System.out.println(&quot;The class col: &quot;+m_theInstances.classIndex());

<span class="fc" id="L1121">      ((weka.filters.unsupervised.attribute.Discretize)m_disTransform).</span>
<span class="fc" id="L1122">      setAttributeIndices(rangeList);</span>
    } else {
<span class="fc" id="L1124">      m_disTransform = new weka.filters.supervised.attribute.Discretize();</span>
<span class="fc" id="L1125">      ((weka.filters.supervised.attribute.Discretize)m_disTransform).setUseBetterEncoding(true);</span>
<span class="fc" id="L1126">      m_classIsNominal = true;</span>
    }

<span class="fc" id="L1129">    m_disTransform.setInputFormat(m_theInstances);</span>
<span class="fc" id="L1130">    m_theInstances = Filter.useFilter(m_theInstances, m_disTransform);</span>

<span class="fc" id="L1132">    m_numAttributes = m_theInstances.numAttributes();</span>
<span class="fc" id="L1133">    m_numInstances = m_theInstances.numInstances();</span>
<span class="fc" id="L1134">    m_majority = m_theInstances.meanOrMode(m_theInstances.classAttribute());</span>

    // Perform the search
<span class="fc" id="L1137">    int [] selected = m_search.search(m_evaluator, m_theInstances);</span>

<span class="fc" id="L1139">    m_decisionFeatures = new int [selected.length+1];</span>
<span class="fc" id="L1140">    System.arraycopy(selected, 0, m_decisionFeatures, 0, selected.length);</span>
<span class="fc" id="L1141">    m_decisionFeatures[m_decisionFeatures.length-1] = m_theInstances.classIndex();</span>

    // reduce instances to selected features
<span class="fc" id="L1144">    m_delTransform = new Remove();</span>
<span class="fc" id="L1145">    m_delTransform.setInvertSelection(true);</span>

    // set features to keep
<span class="fc" id="L1148">    m_delTransform.setAttributeIndicesArray(m_decisionFeatures); </span>
<span class="fc" id="L1149">    m_delTransform.setInputFormat(m_theInstances);</span>
<span class="fc" id="L1150">    m_dtInstances = Filter.useFilter(m_theInstances, m_delTransform);</span>

    // reset the number of attributes
<span class="fc" id="L1153">    m_numAttributes = m_dtInstances.numAttributes();</span>

    // create hash table
<span class="fc" id="L1156">    m_entries = new Hashtable((int)(m_dtInstances.numInstances() * 1.5));</span>

    // insert instances into the hash table
<span class="fc bfc" id="L1159" title="All 2 branches covered.">    for (int i = 0; i &lt; m_numInstances; i++) {</span>
<span class="fc" id="L1160">      Instance inst = m_dtInstances.instance(i);</span>
<span class="fc" id="L1161">      insertIntoTable(inst, null);</span>
    }

    // Replace the global table majority with nearest neighbour?
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">    if (m_useIBk) {</span>
<span class="nc" id="L1166">      m_ibk = new IBk();</span>
<span class="nc" id="L1167">      m_ibk.buildClassifier(m_theInstances);</span>
    }

    // Save memory
<span class="fc bfc" id="L1171" title="All 2 branches covered.">    if (m_saveMemory) {</span>
<span class="fc" id="L1172">      m_theInstances = new Instances(m_theInstances, 0);</span>
<span class="fc" id="L1173">      m_dtInstances = new Instances(m_dtInstances, 0);</span>
    }
<span class="fc" id="L1175">    m_evaluation = null;</span>
<span class="fc" id="L1176">  }</span>

  /**
   * Calculates the class membership probabilities for the given 
   * test instance.
   *
   * @param instance the instance to be classified
   * @return predicted class probability distribution
   * @throws Exception if distribution can't be computed
   */
  public double [] distributionForInstance(Instance instance)
  throws Exception {

    DecisionTableHashKey thekey;
    double [] tempDist;
    double [] normDist;

<span class="fc" id="L1193">    m_disTransform.input(instance);</span>
<span class="fc" id="L1194">    m_disTransform.batchFinished();</span>
<span class="fc" id="L1195">    instance = m_disTransform.output();</span>

<span class="fc" id="L1197">    m_delTransform.input(instance);</span>
<span class="fc" id="L1198">    m_delTransform.batchFinished();</span>
<span class="fc" id="L1199">    instance = m_delTransform.output();</span>

<span class="fc" id="L1201">    thekey = new DecisionTableHashKey(instance, instance.numAttributes(), false);</span>

    // if this one is not in the table
<span class="fc bfc" id="L1204" title="All 2 branches covered.">    if ((tempDist = (double [])m_entries.get(thekey)) == null) {</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">      if (m_useIBk) {</span>
<span class="nc" id="L1206">	tempDist = m_ibk.distributionForInstance(instance);</span>
      } else {
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">	if (!m_classIsNominal) {</span>
<span class="fc" id="L1209">	  tempDist = new double[1];</span>
<span class="fc" id="L1210">	  tempDist[0] = m_majority;</span>
	} else {
<span class="nc" id="L1212">	  tempDist = m_classPriors.clone();</span>
	  /*tempDist = new double [m_theInstances.classAttribute().numValues()];
	  tempDist[(int)m_majority] = 1.0; */
	}
      }
    } else {
<span class="fc bfc" id="L1218" title="All 2 branches covered.">      if (!m_classIsNominal) {</span>
<span class="fc" id="L1219">	normDist = new double[1];</span>
<span class="fc" id="L1220">	normDist[0] = (tempDist[0] / tempDist[1]);</span>
<span class="fc" id="L1221">	tempDist = normDist;</span>
      } else {

	// normalise distribution
<span class="fc" id="L1225">	normDist = new double [tempDist.length];</span>
<span class="fc" id="L1226">	System.arraycopy(tempDist,0,normDist,0,tempDist.length);</span>
<span class="fc" id="L1227">	Utils.normalize(normDist);</span>
<span class="fc" id="L1228">	tempDist = normDist;</span>
      }
    }
<span class="fc" id="L1231">    return tempDist;</span>
  }

  /**
   * Returns a string description of the features selected
   *
   * @return a string of features
   */
  public String printFeatures() {

    int i;
<span class="nc" id="L1242">    String s = &quot;&quot;;</span>

<span class="nc bnc" id="L1244" title="All 2 branches missed.">    for (i=0;i&lt;m_decisionFeatures.length;i++) {</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">      if (i==0) {</span>
<span class="nc" id="L1246">	s = &quot;&quot;+(m_decisionFeatures[i]+1);</span>
      } else {
<span class="nc" id="L1248">	s += &quot;,&quot;+(m_decisionFeatures[i]+1);</span>
      }
    }
<span class="nc" id="L1251">    return s;</span>
  }

  /**
   * Returns the number of rules
   * @return the number of rules
   */
  public double measureNumRules() {
<span class="nc" id="L1259">    return m_entries.size();</span>
  }

  /**
   * Returns an enumeration of the additional measure names
   * @return an enumeration of the measure names
   */
  public Enumeration enumerateMeasures() {
<span class="nc" id="L1267">    Vector newVector = new Vector(1);</span>
<span class="nc" id="L1268">    newVector.addElement(&quot;measureNumRules&quot;);</span>
<span class="nc" id="L1269">    return newVector.elements();</span>
  }

  /**
   * Returns the value of the named measure
   * @param additionalMeasureName the name of the measure to query for its value
   * @return the value of the named measure
   * @throws IllegalArgumentException if the named measure is not supported
   */
  public double getMeasure(String additionalMeasureName) {
<span class="nc bnc" id="L1279" title="All 2 branches missed.">    if (additionalMeasureName.compareToIgnoreCase(&quot;measureNumRules&quot;) == 0) {</span>
<span class="nc" id="L1280">      return measureNumRules();</span>
    } else {
<span class="nc" id="L1282">      throw new IllegalArgumentException(additionalMeasureName </span>
<span class="nc" id="L1283">	  + &quot; not supported (DecisionTable)&quot;);</span>
    }
  }

  /**
   * Returns a description of the classifier.
   *
   * @return a description of the classifier as a string.
   */
  public String toString() {

<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">    if (m_entries == null) {</span>
<span class="fc" id="L1295">      return &quot;Decision Table: No model built yet.&quot;;</span>
    } else {
<span class="nc" id="L1297">      StringBuffer text = new StringBuffer();</span>

<span class="nc" id="L1299">      text.append(&quot;Decision Table:&quot;+</span>
<span class="nc" id="L1300">	  &quot;\n\nNumber of training instances: &quot;+m_numInstances+</span>
<span class="nc" id="L1301">	  &quot;\nNumber of Rules : &quot;+m_entries.size()+&quot;\n&quot;);</span>

<span class="nc bnc" id="L1303" title="All 2 branches missed.">      if (m_useIBk) {</span>
<span class="nc" id="L1304">	text.append(&quot;Non matches covered by IB1.\n&quot;);</span>
      } else {
<span class="nc" id="L1306">	text.append(&quot;Non matches covered by Majority class.\n&quot;);</span>
      }

<span class="nc" id="L1309">      text.append(m_search.toString());</span>
      /*text.append(&quot;Best first search for feature set,\nterminated after &quot;+
					m_maxStale+&quot; non improving subsets.\n&quot;); */

<span class="nc" id="L1313">      text.append(&quot;Evaluation (for feature selection): CV &quot;);</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">      if (m_CVFolds &gt; 1) {</span>
<span class="nc" id="L1315">	text.append(&quot;(&quot;+m_CVFolds+&quot; fold) &quot;);</span>
      } else {
<span class="nc" id="L1317">	text.append(&quot;(leave one out) &quot;);</span>
      }
<span class="nc" id="L1319">      text.append(&quot;\nFeature set: &quot;+printFeatures());</span>

<span class="nc bnc" id="L1321" title="All 2 branches missed.">      if (m_displayRules) {</span>

	// find out the max column width
<span class="nc" id="L1324">	int maxColWidth = 0;</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">	for (int i=0;i&lt;m_dtInstances.numAttributes();i++) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">	  if (m_dtInstances.attribute(i).name().length() &gt; maxColWidth) {</span>
<span class="nc" id="L1327">	    maxColWidth = m_dtInstances.attribute(i).name().length();</span>
	  }

<span class="nc bnc" id="L1330" title="All 4 branches missed.">	  if (m_classIsNominal || (i != m_dtInstances.classIndex())) {</span>
<span class="nc" id="L1331">	    Enumeration e = m_dtInstances.attribute(i).enumerateValues();</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">	    while (e.hasMoreElements()) {</span>
<span class="nc" id="L1333">	      String ss = (String)e.nextElement();</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">	      if (ss.length() &gt; maxColWidth) {</span>
<span class="nc" id="L1335">		maxColWidth = ss.length();</span>
	      }
	    }
	  }
	}

<span class="nc" id="L1341">	text.append(&quot;\n\nRules:\n&quot;);</span>
<span class="nc" id="L1342">	StringBuffer tm = new StringBuffer();</span>
<span class="nc bnc" id="L1343" title="All 2 branches missed.">	for (int i=0;i&lt;m_dtInstances.numAttributes();i++) {</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">	  if (m_dtInstances.classIndex() != i) {</span>
<span class="nc" id="L1345">	    int d = maxColWidth - m_dtInstances.attribute(i).name().length();</span>
<span class="nc" id="L1346">	    tm.append(m_dtInstances.attribute(i).name());</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">	    for (int j=0;j&lt;d+1;j++) {</span>
<span class="nc" id="L1348">	      tm.append(&quot; &quot;);</span>
	    }
	  }
	}
<span class="nc" id="L1352">	tm.append(m_dtInstances.attribute(m_dtInstances.classIndex()).name()+&quot;  &quot;);</span>

<span class="nc bnc" id="L1354" title="All 2 branches missed.">	for (int i=0;i&lt;tm.length()+10;i++) {</span>
<span class="nc" id="L1355">	  text.append(&quot;=&quot;);</span>
	}
<span class="nc" id="L1357">	text.append(&quot;\n&quot;);</span>
<span class="nc" id="L1358">	text.append(tm);</span>
<span class="nc" id="L1359">	text.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">	for (int i=0;i&lt;tm.length()+10;i++) {</span>
<span class="nc" id="L1361">	  text.append(&quot;=&quot;);</span>
	}
<span class="nc" id="L1363">	text.append(&quot;\n&quot;);</span>

<span class="nc" id="L1365">	Enumeration e = m_entries.keys();</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">	while (e.hasMoreElements()) {</span>
<span class="nc" id="L1367">	  DecisionTableHashKey tt = (DecisionTableHashKey)e.nextElement();</span>
<span class="nc" id="L1368">	  text.append(tt.toString(m_dtInstances,maxColWidth));</span>
<span class="nc" id="L1369">	  double [] ClassDist = (double []) m_entries.get(tt);</span>

<span class="nc bnc" id="L1371" title="All 2 branches missed.">	  if (m_classIsNominal) {</span>
<span class="nc" id="L1372">	    int m = Utils.maxIndex(ClassDist);</span>
	    try {
<span class="nc" id="L1374">	      text.append(m_dtInstances.classAttribute().value(m)+&quot;\n&quot;);</span>
<span class="nc" id="L1375">	    } catch (Exception ee) {</span>
<span class="nc" id="L1376">	      System.out.println(ee.getMessage());</span>
	    }
	  } else {
<span class="nc" id="L1379">	    text.append((ClassDist[0] / ClassDist[1])+&quot;\n&quot;);</span>
	  }
	}

<span class="nc bnc" id="L1383" title="All 2 branches missed.">	for (int i=0;i&lt;tm.length()+10;i++) {</span>
<span class="nc" id="L1384">	  text.append(&quot;=&quot;);</span>
	}
<span class="nc" id="L1386">	text.append(&quot;\n&quot;);</span>
<span class="nc" id="L1387">	text.append(&quot;\n&quot;);</span>
      }
<span class="nc" id="L1389">      return text.toString();</span>
    }
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1399">    return RevisionUtils.extract(&quot;$Revision: 5981 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv the command-line options
   */
  public static void main(String [] argv) {
<span class="nc" id="L1408">    runClassifier(new DecisionTable(), argv);</span>
<span class="nc" id="L1409">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>