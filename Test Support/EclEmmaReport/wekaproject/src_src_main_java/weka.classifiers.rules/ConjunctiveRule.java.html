<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ConjunctiveRule.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">ConjunctiveRule.java</span></div><h1>ConjunctiveRule.java</h1><pre class="source lang-java linenums">/*
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

/*
 *    ConjunctiveRule.java
 *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.rules;

import weka.classifiers.Classifier;
import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.ContingencyTables;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * This class implements a single conjunctive rule learner that can predict for numeric and nominal class labels.&lt;br/&gt;
 * &lt;br/&gt;
 * A rule consists of antecedents &quot;AND&quot;ed together and the consequent (class value) for the classification/regression.  In this case, the consequent is the distribution of the available classes (or mean for a numeric value) in the dataset. If the test instance is not covered by this rule, then it's predicted using the default class distributions/value of the data not covered by the rule in the training data.This learner selects an antecedent by computing the Information Gain of each antecendent and prunes the generated rule using Reduced Error Prunning (REP) or simple pre-pruning based on the number of antecedents.&lt;br/&gt;
 * &lt;br/&gt;
 * For classification, the Information of one antecedent is the weighted average of the entropies of both the data covered and not covered by the rule.&lt;br/&gt;
 * For regression, the Information is the weighted average of the mean-squared errors of both the data covered and not covered by the rule.&lt;br/&gt;
 * &lt;br/&gt;
 * In pruning, weighted average of the accuracy rates on the pruning data is used for classification while the weighted average of the mean-squared errors on the pruning data is used for regression.&lt;br/&gt;
 * &lt;br/&gt;
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;number of folds&amp;gt;
 *  Set number of folds for REP
 *  One fold is used as pruning set.
 *  (default 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Set if NOT uses randomization
 *  (default:use randomization)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E
 *  Set whether consider the exclusive
 *  expressions for nominal attributes
 *  (default false)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;min. weights&amp;gt;
 *  Set the minimal weights of instances
 *  within a split.
 *  (default 2.0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;number of antecedents&amp;gt;
 *  Set number of antecedents for pre-pruning
 *  if -1, then REP is used
 *  (default -1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
 *  Set the seed of randomization
 *  (default 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Xin XU (xx5@cs.waikato.ac.nz)
 * @version $Revision: 9835 $ 
 */
<span class="fc" id="L94">public class ConjunctiveRule </span>
  extends Classifier 
  implements OptionHandler, WeightedInstancesHandler{
    
  /** for serialization */
  static final long serialVersionUID = -5938309903225087198L;
  
  /** The number of folds to split data into Grow and Prune for REP*/
<span class="fc" id="L102">  private int m_Folds = 3;</span>
    
  /** The class attribute of the data*/
  private Attribute m_ClassAttribute;
    
  /** The vector of antecedents of this rule*/
<span class="fc" id="L108">  protected FastVector m_Antds = null;</span>
    
  /** The default rule distribution of the data not covered*/
<span class="fc" id="L111">  protected double[] m_DefDstr = null;</span>
    
  /** The consequent of this rule */
<span class="fc" id="L114">  protected double[] m_Cnsqt = null;</span>
        
  /** Number of classes in the training data */
<span class="fc" id="L117">  private int m_NumClasses = 0;</span>
    
  /** The seed to perform randomization */
<span class="fc" id="L120">  private long m_Seed = 1;</span>
    
  /** The Random object used for randomization */
<span class="fc" id="L123">  private Random m_Random = null;</span>
    
  /** The predicted classes recorded for each antecedent in the growing data */
  private FastVector m_Targets;

  /** Whether to use exlusive expressions for nominal attributes */
<span class="fc" id="L129">  private boolean m_IsExclude = false;</span>

  /** The minimal number of instance weights within a split*/
<span class="fc" id="L132">  private double m_MinNo = 2.0;</span>
    
  /** The number of antecedents in pre-pruning */
<span class="fc" id="L135">  private int m_NumAntds = -1;</span>

  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L144">    return  &quot;This class implements a single conjunctive rule learner that can predict &quot;</span>
      + &quot;for numeric and nominal class labels.\n\n&quot;
      + &quot;A rule consists of antecedents \&quot;AND\&quot;ed together and the consequent (class value) &quot;
      + &quot;for the classification/regression.  In this case, the consequent is the &quot;
      + &quot;distribution of the available classes (or mean for a numeric value) in the dataset. &quot; 
      + &quot;If the test instance is not covered by this rule, then it's predicted &quot;
      + &quot;using the default class distributions/value of the data not covered by the &quot;
      + &quot;rule in the training data.&quot;
      + &quot;This learner selects an antecedent by computing the Information Gain of each &quot;
      + &quot;antecendent and prunes the generated rule using Reduced Error Prunning (REP) &quot;
      + &quot;or simple pre-pruning based on the number of antecedents.\n\n&quot;
      + &quot;For classification, the Information of one antecedent is the weighted average of &quot;
      + &quot;the entropies of both the data covered and not covered by the rule.\n&quot;
      + &quot;For regression, the Information is the weighted average of the mean-squared errors &quot;
      + &quot;of both the data covered and not covered by the rule.\n\n&quot;
      + &quot;In pruning, weighted average of the accuracy rates on the pruning data is used &quot;
      + &quot;for classification while the weighted average of the mean-squared errors &quot;
      + &quot;on the pruning data is used for regression.\n\n&quot;;
  }

  /** 
   * The single antecedent in the rule, which is composed of an attribute and 
   * the corresponding value.  There are two inherited classes, namely NumericAntd
   * and NominalAntd in which the attributes are numeric and nominal respectively.
   */
  private abstract class Antd
    implements Serializable, RevisionHandler {

    /** for serialization */
    private static final long serialVersionUID = -8729076306737827571L;

    /** The attribute of the antecedent */
    protected Attribute att;
	
    /** The attribute value of the antecedent.  
	For numeric attribute, value is either 0(1st bag) or 1(2nd bag) */
    protected double value; 
	
    /** The maximum infoGain achieved by this antecedent test */
    protected double maxInfoGain;
	
    /** The information of this antecedent test on the growing data */
    protected double inform;
	
    /** The parameter related to the meanSquaredError of the data not covered 
	by the previous antecedents when the class is numeric */
    protected double uncoverWtSq, uncoverWtVl, uncoverSum;
	
    /** The parameters related to the data not covered by the previous
	antecedents when the class is nominal */
    protected double[] uncover;
	
    /** Constructor for nominal class */
<span class="fc" id="L197">    public Antd(Attribute a, double[] unc){</span>
<span class="fc" id="L198">      att=a;</span>
<span class="fc" id="L199">      value=Double.NaN; </span>
<span class="fc" id="L200">      maxInfoGain = 0;</span>
<span class="fc" id="L201">      inform = Double.NaN;</span>
<span class="fc" id="L202">      uncover = unc;	</span>
<span class="fc" id="L203">    }</span>
	
    /** 
     * Constructor for numeric class
     */
<span class="fc" id="L208">    public Antd(Attribute a, double uncoveredWtSq, </span>
		double uncoveredWtVl, double uncoveredWts){
<span class="fc" id="L210">      att=a;</span>
<span class="fc" id="L211">      value=Double.NaN; </span>
<span class="fc" id="L212">      maxInfoGain = 0;</span>
<span class="fc" id="L213">      inform = Double.NaN;</span>
<span class="fc" id="L214">      uncoverWtSq = uncoveredWtSq;</span>
<span class="fc" id="L215">      uncoverWtVl = uncoveredWtVl;</span>
<span class="fc" id="L216">      uncoverSum = uncoveredWts;</span>
<span class="fc" id="L217">    }</span>
	
    /* The abstract members for inheritance */
    public abstract Instances[] splitData(Instances data, double defInfo);
    public abstract boolean isCover(Instance inst);
    public abstract String toString();
	
    /* Get functions of this antecedent */
<span class="fc" id="L225">    public Attribute getAttr(){ return att; }</span>
<span class="fc" id="L226">    public double getAttrValue(){ return value; }</span>
<span class="fc" id="L227">    public double getMaxInfoGain(){ return maxInfoGain; }</span>
<span class="fc" id="L228">    public double getInfo(){ return inform;}</span>
	
    /** 
     * Function used to calculate the weighted mean squared error,
     * i.e., sum[x-avg(x)]^2 based on the given elements of the formula:
     * meanSquaredError = sum(Wi*Xi^2) - (sum(WiXi))^2/sum(Wi)
     * 
     * @param weightedSq sum(Wi*Xi^2)
     * @param weightedValue sum(WiXi)
     * @param sum sum of weights
     * @return the weighted mean-squared error
     */
    protected double wtMeanSqErr(double weightedSq, double weightedValue, double sum){
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if(Utils.smOrEq(sum, 1.0E-6))</span>
<span class="nc" id="L242">	return 0;	    </span>
<span class="fc" id="L243">      return (weightedSq - (weightedValue * weightedValue) / sum);</span>
    }
	
    /**
     * Function used to calculate the entropy of given vector of values
     * entropy = (1/sum)*{-sigma[i=1..P](Xi*log2(Xi)) + sum*log2(sum)}
     * where P is the length of the vector
     *
     * @param value the given vector of values
     * @param sum the sum of the given values.  It's provided just for efficiency.
     * @return the entropy
     */
    protected double entropy(double[] value, double sum){	   
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">      if(Utils.smOrEq(sum, 1.0E-6))</span>
<span class="nc" id="L257">	return 0;</span>

<span class="fc" id="L259">      double entropy = 0;	    </span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">      for(int i=0; i &lt; value.length; i++){</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">	if(!Utils.eq(value[i],0))</span>
<span class="fc" id="L262">	  entropy -= value[i] * Utils.log2(value[i]);</span>
      }
<span class="fc" id="L264">      entropy += sum * Utils.log2(sum);</span>
<span class="fc" id="L265">      entropy /= sum;</span>
<span class="fc" id="L266">      return entropy;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L275">      return RevisionUtils.extract(&quot;$Revision: 9835 $&quot;);</span>
    }
  }
    
  /** 
   * The antecedent with numeric attribute
   */
  private class NumericAntd 
    extends Antd {
    
    /** for serialization */
    static final long serialVersionUID = -7957266498918210436L;
	
    /** The split point for this numeric antecedent */
    private double splitPoint;
	
    /** 
     * Constructor for nominal class
     */
    public NumericAntd(Attribute a, double[] unc){ 
<span class="fc" id="L295">      super(a, unc);</span>
<span class="fc" id="L296">      splitPoint = Double.NaN;</span>
<span class="fc" id="L297">    }    </span>
	
    /** 
     * Constructor for numeric class
     */
    public NumericAntd(Attribute a, double sq, double vl, double wts){ 
<span class="fc" id="L303">      super(a, sq, vl, wts);</span>
<span class="fc" id="L304">      splitPoint = Double.NaN;</span>
<span class="fc" id="L305">    }</span>
	
    /** 
     * Get split point of this numeric antecedent
     * 
     * @return the split point
     */
    public double getSplitPoint(){ 
<span class="nc" id="L313">      return splitPoint; </span>
    }
	
    /**
     * Implements the splitData function.  
     * This procedure is to split the data into two bags according 
     * to the information gain of the numeric attribute value
     * the data with missing values are stored in the last split.
     * The maximum infoGain is also calculated.  
     * 
     * @param insts the data to be split
     * @param defInfo the default information for data
     * @return the array of data after split
     */
    public Instances[] splitData(Instances insts, double defInfo){	
<span class="fc" id="L328">      Instances data = new Instances(insts);</span>
<span class="fc" id="L329">      data.sort(att);</span>
<span class="fc" id="L330">      int total=data.numInstances();// Total number of instances without </span>
      // missing value for att
<span class="fc" id="L332">      maxInfoGain = 0;</span>
<span class="fc" id="L333">      value = 0;	</span>
	    
      // Compute minimum number of Instances required in each split
      double minSplit;
<span class="fc bfc" id="L337" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal()){</span>
<span class="fc" id="L338">	minSplit =  0.1 * (data.sumOfWeights()) /</span>
<span class="fc" id="L339">	  ((double)m_ClassAttribute.numValues());</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">	if (Utils.smOrEq(minSplit,m_MinNo)) </span>
<span class="fc" id="L341">	  minSplit = m_MinNo;</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">	else if (Utils.gr(minSplit,25)) </span>
<span class="nc" id="L343">	  minSplit = 25;</span>
      }
      else
<span class="fc" id="L346">	minSplit = m_MinNo;</span>
 
<span class="fc" id="L348">      double[] fst=null, snd=null, missing=null;</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal()){</span>
<span class="fc" id="L350">	fst = new double[m_NumClasses];</span>
<span class="fc" id="L351">	snd = new double[m_NumClasses];</span>
<span class="fc" id="L352">	missing = new double[m_NumClasses];</span>
		
<span class="fc bfc" id="L354" title="All 2 branches covered.">	for(int v=0; v &lt; m_NumClasses; v++)</span>
<span class="fc" id="L355">	  fst[v]=snd[v]=missing[v]=0.0;</span>
      }
<span class="fc" id="L357">      double fstCover=0, sndCover=0, fstWtSq=0, sndWtSq=0, fstWtVl=0, sndWtVl=0;</span>
	    
<span class="fc" id="L359">      int split=1;                  // Current split position</span>
<span class="fc" id="L360">      int prev=0;                   // Previous split position		    </span>
<span class="fc" id="L361">      int finalSplit=split;         // Final split position</span>
		    
<span class="fc bfc" id="L363" title="All 2 branches covered.">      for(int x=0; x&lt;data.numInstances(); x++){</span>
<span class="fc" id="L364">	Instance inst = data.instance(x);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">	if(inst.isMissing(att)){</span>
<span class="fc" id="L366">	  total = x;</span>
<span class="fc" id="L367">	  break;</span>
	}
		
<span class="fc" id="L370">	sndCover += inst.weight();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">	if(m_ClassAttribute.isNominal()) // Nominal class</span>
<span class="fc" id="L372">	  snd[(int)inst.classValue()] += inst.weight();		</span>
	else{                            // Numeric class
<span class="fc" id="L374">	  sndWtSq += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L375">	  sndWtVl += inst.weight() * inst.classValue();</span>
	}
      }
	    
	    
      // Enough Instances with known values?
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (Utils.sm(sndCover,(2*minSplit)))</span>
<span class="fc" id="L382">	return null;</span>
	    
<span class="fc" id="L384">      double msingWtSq=0, msingWtVl=0;</span>
<span class="fc" id="L385">      Instances missingData = new Instances(data, 0);</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">      for(int y=total; y &lt; data.numInstances(); y++){	    </span>
<span class="fc" id="L387">	Instance inst = data.instance(y);</span>
<span class="fc" id="L388">	missingData.add(inst);</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">	if(m_ClassAttribute.isNominal())</span>
<span class="fc" id="L390">	  missing[(int)inst.classValue()] += inst.weight();</span>
	else{ 
<span class="fc" id="L392">	  msingWtSq += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L393">	  msingWtVl += inst.weight() * inst.classValue();</span>
	}			
      }	    
	    
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">      if(total == 0) return null; // Data all missing for the attribute 	</span>
	    
<span class="fc" id="L399">      splitPoint = data.instance(total-1).value(att);	</span>
	    
<span class="fc bfc" id="L401" title="All 2 branches covered.">      for(; split &lt; total; split++){	</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">	if(!Utils.eq(data.instance(split).value(att), // Can't split </span>
<span class="fc" id="L403">		     data.instance(prev).value(att))){// within same value 	 </span>
		    
	  // Move the split point
<span class="fc bfc" id="L406" title="All 2 branches covered.">	  for(int y=prev; y&lt;split; y++){</span>
<span class="fc" id="L407">	    Instance inst = data.instance(y);</span>
<span class="fc" id="L408">	    fstCover += inst.weight(); sndCover -= inst.weight();</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">	    if(m_ClassAttribute.isNominal()){ // Nominal class</span>
<span class="fc" id="L410">	      fst[(int)inst.classValue()] += inst.weight();</span>
<span class="fc" id="L411">	      snd[(int)inst.classValue()] -= inst.weight();</span>
	    }   
	    else{                             // Numeric class
<span class="fc" id="L414">	      fstWtSq += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L415">	      fstWtVl += inst.weight() * inst.classValue();</span>
<span class="fc" id="L416">	      sndWtSq -= inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L417">	      sndWtVl -= inst.weight() * inst.classValue();</span>
	    }
	  }
		    
<span class="fc bfc" id="L421" title="All 4 branches covered.">	  if(Utils.sm(fstCover, minSplit) || Utils.sm(sndCover, minSplit)){</span>
<span class="fc" id="L422">	    prev=split;  // Cannot split because either</span>
<span class="fc" id="L423">	    continue;    // split has not enough data</span>
	  }
		    
<span class="fc" id="L426">	  double fstEntp = 0, sndEntp = 0;</span>
		    
<span class="fc bfc" id="L428" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){</span>
<span class="fc" id="L429">	    fstEntp = entropy(fst, fstCover);</span>
<span class="fc" id="L430">	    sndEntp = entropy(snd, sndCover);</span>
	  }
	  else{
<span class="fc" id="L433">	    fstEntp = wtMeanSqErr(fstWtSq, fstWtVl, fstCover)/fstCover;</span>
<span class="fc" id="L434">	    sndEntp = wtMeanSqErr(sndWtSq, sndWtVl, sndCover)/sndCover;</span>
	  }
		    
	  /* Which bag has higher information gain? */
	  boolean isFirst; 
	  double fstInfoGain, sndInfoGain;
	  double info, infoGain, fstInfo, sndInfo;
<span class="fc bfc" id="L441" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){</span>
<span class="fc" id="L442">	    double sum = data.sumOfWeights();</span>
<span class="fc" id="L443">	    double otherCover, whole = sum + Utils.sum(uncover), otherEntropy; </span>
<span class="fc" id="L444">	    double[] other = null;</span>
			
	    // InfoGain of first bag			
<span class="fc" id="L447">	    other = new double[m_NumClasses];</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">	    for(int z=0; z &lt; m_NumClasses; z++)</span>
<span class="fc" id="L449">	      other[z] = uncover[z] + snd[z] + missing[z];   </span>
<span class="fc" id="L450">	    otherCover = whole - fstCover;			</span>
<span class="fc" id="L451">	    otherEntropy = entropy(other, otherCover);</span>
	    // Weighted average
<span class="fc" id="L453">	    fstInfo = (fstEntp*fstCover + otherEntropy*otherCover)/whole;</span>
<span class="fc" id="L454">	    fstInfoGain = defInfo - fstInfo;</span>
			
	    // InfoGain of second bag 			
<span class="fc" id="L457">	    other = new double[m_NumClasses];</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">	    for(int z=0; z &lt; m_NumClasses; z++)</span>
<span class="fc" id="L459">	      other[z] = uncover[z] + fst[z] + missing[z]; </span>
<span class="fc" id="L460">	    otherCover = whole - sndCover;			</span>
<span class="fc" id="L461">	    otherEntropy = entropy(other, otherCover);</span>
	    // Weighted average
<span class="fc" id="L463">	    sndInfo = (sndEntp*sndCover + otherEntropy*otherCover)/whole;			    </span>
<span class="fc" id="L464">	    sndInfoGain = defInfo - sndInfo;			</span>
	  }
	  else{
<span class="fc" id="L467">	    double sum = data.sumOfWeights();</span>
<span class="fc" id="L468">	    double otherWtSq = (sndWtSq + msingWtSq + uncoverWtSq), </span>
<span class="fc" id="L469">	      otherWtVl = (sndWtVl + msingWtVl + uncoverWtVl),</span>
<span class="fc" id="L470">	      otherCover = (sum - fstCover + uncoverSum);</span>
			
<span class="pc bpc" id="L472" title="1 of 2 branches missed.">	    fstInfo = Utils.eq(fstCover, 0) ? 0 : (fstEntp * fstCover);</span>
<span class="fc" id="L473">	    fstInfo += wtMeanSqErr(otherWtSq, otherWtVl, otherCover);</span>
<span class="fc" id="L474">	    fstInfoGain = defInfo - fstInfo;</span>
			
<span class="fc" id="L476">	    otherWtSq = (fstWtSq + msingWtSq + uncoverWtSq); </span>
<span class="fc" id="L477">	    otherWtVl = (fstWtVl + msingWtVl + uncoverWtVl);</span>
<span class="fc" id="L478">	    otherCover = sum - sndCover + uncoverSum;</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">	    sndInfo = Utils.eq(sndCover, 0) ? 0 : (sndEntp * sndCover);</span>
<span class="fc" id="L480">	    sndInfo += wtMeanSqErr(otherWtSq, otherWtVl, otherCover);</span>
<span class="fc" id="L481">	    sndInfoGain = defInfo - sndInfo;</span>
	  }
		    
<span class="fc bfc" id="L484" title="All 2 branches covered.">	  if(Utils.gr(fstInfoGain,sndInfoGain) || </span>
<span class="fc bfc" id="L485" title="All 4 branches covered.">	     (Utils.eq(fstInfoGain,sndInfoGain)&amp;&amp;(Utils.sm(fstEntp,sndEntp)))){ </span>
<span class="fc" id="L486">	    isFirst = true;</span>
<span class="fc" id="L487">	    infoGain = fstInfoGain;</span>
<span class="fc" id="L488">	    info = fstInfo;</span>
	  }
	  else{
<span class="fc" id="L491">	    isFirst = false;</span>
<span class="fc" id="L492">	    infoGain = sndInfoGain;</span>
<span class="fc" id="L493">	    info = sndInfo;</span>
	  }
		    
<span class="fc" id="L496">	  boolean isUpdate = Utils.gr(infoGain, maxInfoGain);</span>
		    
	  /* Check whether so far the max infoGain */
<span class="fc bfc" id="L499" title="All 2 branches covered.">	  if(isUpdate){</span>
<span class="fc" id="L500">	    splitPoint = ((data.instance(split).value(att)) + (data.instance(prev).value(att)))/2.0;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">	    value = ((isFirst) ? 0 : 1);</span>
<span class="fc" id="L502">	    inform = info;</span>
<span class="fc" id="L503">	    maxInfoGain = infoGain;</span>
<span class="fc" id="L504">	    finalSplit = split;			</span>
	  }
<span class="fc" id="L506">	  prev=split;</span>
	}
      }
	    
      /* Split the data */
<span class="fc" id="L511">      Instances[] splitData = new Instances[3];</span>
<span class="fc" id="L512">      splitData[0] = new Instances(data, 0, finalSplit);</span>
<span class="fc" id="L513">      splitData[1] = new Instances(data, finalSplit, total-finalSplit);</span>
<span class="fc" id="L514">      splitData[2] = new Instances(missingData);</span>
	    
<span class="fc" id="L516">      return splitData;</span>
    }
	
    /**
     * Whether the instance is covered by this antecedent
     * 
     * @param inst the instance in question
     * @return the boolean value indicating whether the instance is covered 
     *         by this antecedent
     */
    public boolean isCover(Instance inst){
<span class="fc" id="L527">      boolean isCover=false;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">      if(!inst.isMissing(att)){</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">	if(Utils.eq(value, 0)){</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">	  if(Utils.smOrEq(inst.value(att), splitPoint))</span>
<span class="fc" id="L531">	    isCover=true;</span>
	}
<span class="fc bfc" id="L533" title="All 2 branches covered.">	else if(Utils.gr(inst.value(att), splitPoint))</span>
<span class="fc" id="L534">	  isCover=true;</span>
      }
<span class="fc" id="L536">      return isCover;</span>
    }
	
    /**
     * Prints this antecedent
     *
     * @return a textual description of this antecedent
     */
    public String toString() {
<span class="nc bnc" id="L545" title="All 2 branches missed.">      String symbol = Utils.eq(value, 0.0) ? &quot; &lt;= &quot; : &quot; &gt; &quot;;</span>
<span class="nc" id="L546">      return (att.name() + symbol + Utils.doubleToString(splitPoint, 6));</span>
    }   
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L555">      return RevisionUtils.extract(&quot;$Revision: 9835 $&quot;);</span>
    }
  }
    
    
  /** 
   * The antecedent with nominal attribute
   */
  class NominalAntd 
    extends Antd {
	
    /** for serialization */
    static final long serialVersionUID = -5949864163376447424L;
    
    /* The parameters of infoGain calculated for each attribute value */
    private double[][] stats;
    private double[] coverage;
    private boolean isIn;
	
    /** 
     * Constructor for nominal class
     */
    public NominalAntd(Attribute a, double[] unc){ 
<span class="fc" id="L578">      super(a, unc);</span>
<span class="fc" id="L579">      int bag = att.numValues();</span>
<span class="fc" id="L580">      stats = new double[bag][m_NumClasses];</span>
<span class="fc" id="L581">      coverage = new double[bag];</span>
<span class="fc" id="L582">      isIn = true;</span>
<span class="fc" id="L583">    }   </span>
	
    /** 
     * Constructor for numeric class
     */
    public NominalAntd(Attribute a, double sq, double vl, double wts){ 
<span class="fc" id="L589">      super(a, sq, vl, wts);</span>
<span class="fc" id="L590">      int bag = att.numValues();	    </span>
<span class="fc" id="L591">      stats = null;</span>
<span class="fc" id="L592">      coverage = new double[bag];</span>
<span class="fc" id="L593">      isIn = true;</span>
<span class="fc" id="L594">    }</span>
	
    /**
     * Implements the splitData function.  
     * This procedure is to split the data into bags according 
     * to the nominal attribute value
     * the data with missing values are stored in the last bag.
     * The infoGain for each bag is also calculated.  
     * 
     * @param data the data to be split
     * @param defInfo the default information for data
     * @return the array of data after split
     */
    public Instances[] splitData(Instances data, double defInfo){
<span class="fc" id="L608">      int bag = att.numValues();</span>
<span class="fc" id="L609">      Instances[] splitData = new Instances[bag+1];</span>
<span class="fc" id="L610">      double[] wSq = new double[bag];</span>
<span class="fc" id="L611">      double[] wVl = new double[bag];</span>
<span class="fc" id="L612">      double totalWS=0, totalWV=0, msingWS=0, msingWV=0, sum=data.sumOfWeights();</span>
<span class="fc" id="L613">      double[] all = new double[m_NumClasses];</span>
<span class="fc" id="L614">      double[] missing = new double[m_NumClasses];	   </span>
	    
<span class="fc bfc" id="L616" title="All 2 branches covered.">      for(int w=0; w &lt; m_NumClasses; w++)</span>
<span class="fc" id="L617">	all[w] = missing[w] = 0;</span>

<span class="fc bfc" id="L619" title="All 2 branches covered.">      for(int x=0; x&lt;bag; x++){</span>
<span class="fc" id="L620">	coverage[x] = wSq[x] = wVl[x] = 0;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">	if(stats != null)</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">	  for(int y=0; y &lt; m_NumClasses; y++)</span>
<span class="fc" id="L623">	    stats[x][y] = 0;		</span>
<span class="fc" id="L624">	splitData[x] = new Instances(data, data.numInstances());</span>
      }
<span class="fc" id="L626">      splitData[bag] = new Instances(data, data.numInstances());</span>
	    
      // Record the statistics of data
<span class="fc bfc" id="L629" title="All 2 branches covered.">      for(int x=0; x&lt;data.numInstances(); x++){</span>
<span class="fc" id="L630">	Instance inst=data.instance(x);</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">	if(!inst.isMissing(att)){</span>
<span class="fc" id="L632">	  int v = (int)inst.value(att);</span>
<span class="fc" id="L633">	  splitData[v].add(inst);</span>
<span class="fc" id="L634">	  coverage[v] += inst.weight();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){ // Nominal class			</span>
<span class="fc" id="L636">	    stats[v][(int)inst.classValue()] += inst.weight();</span>
<span class="fc" id="L637">	    all[(int)inst.classValue()] += inst.weight();	    </span>
	  }
	  else{                             // Numeric class
<span class="fc" id="L640">	    wSq[v] += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L641">	    wVl[v] += inst.weight() * inst.classValue();</span>
<span class="fc" id="L642">	    totalWS += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L643">	    totalWV += inst.weight() * inst.classValue();</span>
	  }
	}
	else{
<span class="fc" id="L647">	  splitData[bag].add(inst);</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){ // Nominal class</span>
<span class="fc" id="L649">	    all[(int)inst.classValue()] += inst.weight();</span>
<span class="fc" id="L650">	    missing[(int)inst.classValue()] += inst.weight();</span>
	  }
	  else{                            // Numeric class
<span class="fc" id="L653">	    totalWS += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L654">	    totalWV += inst.weight() * inst.classValue();</span>
<span class="fc" id="L655">	    msingWS += inst.weight() * inst.classValue() * inst.classValue();</span>
<span class="fc" id="L656">	    msingWV += inst.weight() * inst.classValue();		 </span>
	  }
	}
      }
	    
      // The total weights of the whole grow data
      double whole;
<span class="fc bfc" id="L663" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal())</span>
<span class="fc" id="L664">	whole = sum + Utils.sum(uncover);</span>
      else
<span class="fc" id="L666">	whole = sum + uncoverSum;</span>
	  
      // Find the split  
<span class="fc" id="L669">      double minEntrp=Double.MAX_VALUE;</span>
<span class="fc" id="L670">      maxInfoGain = 0;</span>
	    
      // Check if &gt;=2 splits have more than the minimal data
<span class="fc" id="L673">      int count=0;</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">      for(int x=0; x&lt;bag; x++)</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">	if(Utils.grOrEq(coverage[x], m_MinNo))		    </span>
<span class="fc" id="L676">	  ++count;</span>
	    
<span class="fc bfc" id="L678" title="All 2 branches covered.">      if(count &lt; 2){ // Don't split</span>
<span class="fc" id="L679">	maxInfoGain = 0;</span>
<span class="fc" id="L680">	inform = defInfo;</span>
<span class="fc" id="L681">	value = Double.NaN;</span>
<span class="fc" id="L682">	return null;</span>
      }
	    
<span class="fc bfc" id="L685" title="All 2 branches covered.">      for(int x=0; x&lt;bag; x++){		</span>
<span class="fc" id="L686">	double t = coverage[x], entrp, infoGain;</span>

<span class="pc bpc" id="L688" title="1 of 2 branches missed.">	if(Utils.sm(t, m_MinNo))</span>
<span class="nc" id="L689">	  continue;</span>
		
<span class="fc bfc" id="L691" title="All 2 branches covered.">	if(m_ClassAttribute.isNominal()){ // Nominal class	   </span>
<span class="fc" id="L692">	  double[] other = new double[m_NumClasses];</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">	  for(int y=0; y &lt; m_NumClasses; y++)</span>
<span class="fc" id="L694">	    other[y] = all[y] - stats[x][y] + uncover[y]; </span>
<span class="fc" id="L695">	  double otherCover = whole - t;	</span>
		    
	  // Entropies of data covered and uncovered 	
<span class="fc" id="L698">	  entrp = entropy(stats[x], t);</span>
<span class="fc" id="L699">	  double uncEntp = entropy(other, otherCover);</span>

<span class="pc bpc" id="L701" title="1 of 2 branches missed.">          if (m_Debug) {</span>
<span class="nc" id="L702">            System.err.println(defInfo + &quot; &quot; + entrp + &quot; &quot; + t + &quot; &quot; + uncEntp +</span>
<span class="nc" id="L703">                               &quot; &quot; + otherCover + &quot; &quot; + whole);</span>
          }
		    
	  // Weighted average
<span class="fc" id="L707">	  infoGain = defInfo - (entrp*t + uncEntp*otherCover)/whole;		   </span>
	}	
	else{                             // Numeric class
<span class="fc" id="L710">	  double weight = (whole - t);</span>
<span class="fc" id="L711">	  entrp = wtMeanSqErr(wSq[x], wVl[x], t)/t;</span>
<span class="fc" id="L712">	  infoGain = defInfo - (entrp * t) - </span>
<span class="fc" id="L713">	    wtMeanSqErr((totalWS-wSq[x]+uncoverWtSq),</span>
<span class="fc" id="L714">			(totalWV-wVl[x]+uncoverWtVl), </span>
<span class="fc" id="L715">			weight);		  </span>
	}   		
		
	// Test the exclusive expression
<span class="fc" id="L719">	boolean isWithin =true;		</span>
<span class="pc bpc" id="L720" title="1 of 2 branches missed.">	if(m_IsExclude){</span>
	  double infoGain2, entrp2;
<span class="nc bnc" id="L722" title="All 2 branches missed.">	  if(m_ClassAttribute.isNominal()){ // Nominal class	</span>
<span class="nc" id="L723">	    double[] other2 = new double[m_NumClasses];</span>
<span class="nc" id="L724">	    double[] notIn = new double[m_NumClasses];</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">	    for(int y=0; y &lt; m_NumClasses; y++){</span>
<span class="nc" id="L726">	      other2[y] = stats[x][y] + missing[y] + uncover[y];</span>
<span class="nc" id="L727">	      notIn[y] = all[y] - stats[x][y] - missing[y];</span>
	    } 
			
<span class="nc" id="L730">	    double msSum = Utils.sum(missing);</span>
<span class="nc" id="L731">	    double otherCover2 = t + msSum + Utils.sum(uncover);</span>
			
<span class="nc" id="L733">	    entrp2 = entropy(notIn, (sum-t-msSum));</span>
<span class="nc" id="L734">	    double uncEntp2 = entropy(other2, otherCover2);</span>
<span class="nc" id="L735">	    infoGain2 = defInfo - </span>
<span class="nc" id="L736">	      (entrp2*(sum-t-msSum) + uncEntp2*otherCover2)/whole;</span>
	  }
	  else{                             // Numeric class
<span class="nc" id="L739">	    double msWts = splitData[bag].sumOfWeights();</span>
<span class="nc" id="L740">	    double weight2 = t + uncoverSum + msWts;</span>
			
<span class="nc" id="L742">	    entrp2 = wtMeanSqErr((totalWS-wSq[x]-msingWS),</span>
<span class="nc" id="L743">				 (totalWV-wVl[x]-msingWV),(sum-t-msWts))</span>
<span class="nc" id="L744">	      /(sum-t-msWts);</span>
<span class="nc" id="L745">	    infoGain2 = defInfo - entrp2 * (sum-t-msWts) -</span>
<span class="nc" id="L746">	      wtMeanSqErr((wSq[x]+uncoverWtSq+msingWS),</span>
<span class="nc" id="L747">			  (wVl[x]+uncoverWtVl+msingWV), </span>
<span class="nc" id="L748">			  weight2);</span>
	  }
		    
	  // Use the exclusive expression?
<span class="nc bnc" id="L752" title="All 2 branches missed.">	  if (Utils.gr(infoGain2, infoGain) ||</span>
<span class="nc bnc" id="L753" title="All 4 branches missed.">	      (Utils.eq(infoGain2, infoGain) &amp;&amp; Utils.sm(entrp2, entrp))){</span>
<span class="nc" id="L754">	    infoGain = infoGain2;</span>
<span class="nc" id="L755">	    entrp = entrp2;</span>
<span class="nc" id="L756">	    isWithin =false;</span>
	  }
	}
		
	// Test this split
<span class="fc bfc" id="L761" title="All 2 branches covered.">	if (Utils.gr(infoGain, maxInfoGain) ||</span>
<span class="fc bfc" id="L762" title="All 4 branches covered.">	    (Utils.eq(infoGain, maxInfoGain) &amp;&amp; Utils.sm(entrp, minEntrp))){</span>
<span class="fc" id="L763">	  value = (double)x;</span>
<span class="fc" id="L764">	  maxInfoGain = infoGain;</span>
<span class="fc" id="L765">	  inform = -(maxInfoGain - defInfo);</span>
<span class="fc" id="L766">	  minEntrp = entrp;</span>
<span class="fc" id="L767">	  isIn = isWithin;</span>
	}		
      }
	    
<span class="fc" id="L771">      return splitData;</span>
    }
	
    /**
     * Whether the instance is covered by this antecedent
     * 
     * @param inst the instance in question
     * @return the boolean value indicating whether the instance is covered 
     *         by this antecedent
     */
    public boolean isCover(Instance inst){	  
<span class="fc" id="L782">      boolean isCover=false;</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">      if(!inst.isMissing(att)){</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">	if(isIn){</span>
<span class="fc bfc" id="L785" title="All 2 branches covered.">	  if(Utils.eq(inst.value(att), value))</span>
<span class="fc" id="L786">	    isCover=true;</span>
	}
<span class="nc bnc" id="L788" title="All 2 branches missed.">	else if(!Utils.eq(inst.value(att), value))</span>
<span class="nc" id="L789">	  isCover=true;</span>
      }
<span class="fc" id="L791">      return isCover;</span>
    }
	
    /**
     * Whether the expression is &quot;att = value&quot; or att != value&quot;
     * for this nominal attribute.  True if in the former expression, 
     * otherwise the latter
     * 
     * @return the boolean value
     */
    public boolean isIn(){	 
<span class="fc" id="L802">      return isIn;</span>
    }
	
    /**
     * Prints this antecedent
     *
     * @return a textual description of this antecedent
     */
    public String toString() {
<span class="nc bnc" id="L811" title="All 2 branches missed.">      String symbol = isIn ? &quot; = &quot; : &quot; != &quot;;	    </span>
<span class="nc" id="L812">      return (att.name() + symbol + att.value((int)value));</span>
    } 
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L821">      return RevisionUtils.extract(&quot;$Revision: 9835 $&quot;);</span>
    }
  }
    
  /**
   * Returns an enumeration describing the available options
   * Valid options are: &lt;p&gt;
   *
   * -N number &lt;br&gt;
   * Set number of folds for REP. One fold is
   * used as the pruning set. (Default: 3) &lt;p&gt;
   *
   * -R &lt;br&gt;
   * Set if NOT randomize the data before split to growing and 
   * pruning data. If NOT set, the seed of randomization is 
   * specified by the -S option. (Default: randomize) &lt;p&gt;
   * 
   * -S &lt;br&gt;
   * Seed of randomization. (Default: 1)&lt;p&gt;
   *
   * -E &lt;br&gt;
   * Set whether consider the exclusive expressions for nominal
   * attribute split. (Default: false) &lt;p&gt;
   *
   * -M number &lt;br&gt;
   * Set the minimal weights of instances within a split.
   * (Default: 2) &lt;p&gt;
   *
   * -P number &lt;br&gt;
   * Set the number of antecedents allowed in the rule if pre-pruning
   * is used.  If this value is other than -1, then pre-pruning will be
   * used, otherwise the rule uses REP. (Default: -1) &lt;p&gt;
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L857">    Vector newVector = new Vector(6);</span>
	
<span class="fc" id="L859">    Enumeration enumer = super.listOptions();</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">    while (enumer.hasMoreElements()) {</span>
<span class="fc" id="L861">      newVector.add(enumer.nextElement());</span>
    }

<span class="fc" id="L864">    newVector.addElement(new Option(&quot;\tSet number of folds for REP\n&quot; +</span>
				    &quot;\tOne fold is used as pruning set.\n&quot; +
<span class="fc" id="L866">				    &quot;\t(default 3)&quot;,&quot;N&quot;, 1, &quot;-N &lt;number of folds&gt;&quot;));</span>
	
<span class="fc" id="L868">    newVector.addElement(new Option(&quot;\tSet if NOT uses randomization\n&quot; +</span>
<span class="fc" id="L869">				    &quot;\t(default:use randomization)&quot;,&quot;R&quot;, 0, &quot;-R&quot;));</span>

<span class="fc" id="L871">    newVector.addElement(new Option(&quot;\tSet whether consider the exclusive\n&quot; +</span>
				    &quot;\texpressions for nominal attributes\n&quot;+
<span class="fc" id="L873">				    &quot;\t(default false)&quot;,&quot;E&quot;, 0, &quot;-E&quot;));</span>
	
<span class="fc" id="L875">    newVector.addElement(new Option(&quot;\tSet the minimal weights of instances\n&quot; +</span>
				    &quot;\twithin a split.\n&quot; +
<span class="fc" id="L877">				    &quot;\t(default 2.0)&quot;,&quot;M&quot;, 1, &quot;-M &lt;min. weights&gt;&quot;));</span>
    
<span class="fc" id="L879">    newVector.addElement(new Option(&quot;\tSet number of antecedents for pre-pruning\n&quot; +</span>
				    &quot;\tif -1, then REP is used\n&quot; +
<span class="fc" id="L881">				    &quot;\t(default -1)&quot;,&quot;P&quot;, 1, &quot;-P &lt;number of antecedents&gt;&quot;));</span>
    
<span class="fc" id="L883">    newVector.addElement(new Option(&quot;\tSet the seed of randomization\n&quot; +</span>
<span class="fc" id="L884">				    &quot;\t(default 1)&quot;,&quot;S&quot;, 1, &quot;-S &lt;seed&gt;&quot;));</span>
    
<span class="fc" id="L886">    return newVector.elements();</span>
  }
    
  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;number of folds&amp;gt;
   *  Set number of folds for REP
   *  One fold is used as pruning set.
   *  (default 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Set if NOT uses randomization
   *  (default:use randomization)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E
   *  Set whether consider the exclusive
   *  expressions for nominal attributes
   *  (default false)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;min. weights&amp;gt;
   *  Set the minimal weights of instances
   *  within a split.
   *  (default 2.0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;number of antecedents&amp;gt;
   *  Set number of antecedents for pre-pruning
   *  if -1, then REP is used
   *  (default -1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
   *  Set the seed of randomization
   *  (default 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
	
<span class="fc" id="L930">    String numFoldsString = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L931" title="All 2 branches covered.">    if (numFoldsString.length() != 0) </span>
<span class="fc" id="L932">      m_Folds = Integer.parseInt(numFoldsString);</span>
    else 
<span class="fc" id="L934">      m_Folds = 3;</span>

<span class="fc" id="L936">    String minNoString = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">    if (minNoString.length() != 0) </span>
<span class="fc" id="L938">      m_MinNo = Double.parseDouble(minNoString);</span>
    else 
<span class="fc" id="L940">      m_MinNo = 2.0;</span>
	
<span class="fc" id="L942">    String seedString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">    if (seedString.length() != 0) </span>
<span class="fc" id="L944">      m_Seed = Integer.parseInt(seedString);</span>
    else 
<span class="fc" id="L946">      m_Seed = 1;</span>
	
<span class="fc" id="L948">    String numAntdsString = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L949" title="All 2 branches covered.">    if (numAntdsString.length() != 0) </span>
<span class="fc" id="L950">      m_NumAntds = Integer.parseInt(numAntdsString);</span>
    else 
<span class="fc" id="L952">      m_NumAntds = -1;</span>
	
<span class="fc" id="L954">    m_IsExclude = Utils.getFlag('E', options);	</span>

<span class="fc" id="L956">    super.setOptions(options);</span>
<span class="fc" id="L957">  }</span>
    
  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {
	
<span class="fc" id="L966">    String[] supersOptions = super.getOptions();</span>
<span class="fc" id="L967">    String [] options = new String [9 + supersOptions.length];</span>
<span class="fc" id="L968">    System.arraycopy(supersOptions, 0, options, 0, supersOptions.length);</span>
<span class="fc" id="L969">    int current = supersOptions.length;</span>
<span class="fc" id="L970">    options[current++] = &quot;-N&quot;; options[current++] = &quot;&quot; + m_Folds;</span>
<span class="fc" id="L971">    options[current++] = &quot;-M&quot;; options[current++] = &quot;&quot; + m_MinNo;</span>
<span class="fc" id="L972">    options[current++] = &quot;-P&quot;; options[current++] = &quot;&quot; + m_NumAntds;</span>
<span class="fc" id="L973">    options[current++] = &quot;-S&quot;; options[current++] = &quot;&quot; + m_Seed;</span>

<span class="pc bpc" id="L975" title="1 of 2 branches missed.">    if(m_IsExclude)</span>
<span class="nc" id="L976">      options[current++] = &quot;-E&quot;;</span>
	
<span class="pc bfc" id="L978" title="All 2 branches covered.">    while (current &lt; options.length) </span>
<span class="fc" id="L979">      options[current++] = &quot;&quot;;</span>
<span class="fc" id="L980">    return options;</span>
  }
    
  /** The access functions for parameters */

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String foldsTipText() {
<span class="nc" id="L991">    return &quot;Determines the amount of data used for pruning. One fold is used for &quot;</span>
      + &quot;pruning, the rest for growing the rules.&quot;;
  }

  /**
   * the number of folds to use
   * 
   * @param folds the number of folds to use
   */
  public void setFolds(int folds) {  
<span class="nc" id="L1001">    m_Folds = folds; </span>
<span class="nc" id="L1002">  }</span>
  
  /**
   * returns the current number of folds
   * 
   * @return the number of folds
   */
  public int getFolds() { 
<span class="nc" id="L1010">    return m_Folds; </span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String seedTipText() {
<span class="nc" id="L1019">    return &quot;The seed used for randomizing the data.&quot;;</span>
  }

  /**
   * sets the seed for randomizing the data
   * 
   * @param s the seed value
   */
  public void setSeed(long s) { 
<span class="nc" id="L1028">    m_Seed = s;</span>
<span class="nc" id="L1029">  }</span>
  
  /**
   * returns the current seed value for randomizing the data
   * 
   * @return the seed value
   */
  public long getSeed() { 
<span class="nc" id="L1037">    return m_Seed; </span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String exclusiveTipText() {
<span class="nc" id="L1046">    return &quot;Set whether to consider exclusive expressions for nominal &quot;</span>
      + &quot;attribute splits.&quot;;
  }

  /**
   * Returns whether exclusive expressions for nominal attributes splits are 
   * considered
   * 
   * @return true if exclusive expressions for nominal attributes splits are
   *         considered
   */
  public boolean getExclusive() { 
<span class="nc" id="L1058">    return m_IsExclude;</span>
  }
  
  /**
   * Sets whether exclusive expressions for nominal attributes splits are 
   * considered
   * 
   * @param e whether to consider exclusive expressions for nominal attribute
   *          splits
   */
  public void setExclusive(boolean e) { 
<span class="nc" id="L1069">    m_IsExclude = e;</span>
<span class="nc" id="L1070">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minNoTipText() {
<span class="nc" id="L1078">    return &quot;The minimum total weight of the instances in a rule.&quot;;</span>
  }

  /**
   * Sets the minimum total weight of the instances in a rule
   * 
   * @param m the minimum total weight of the instances in a rule
   */
  public void setMinNo(double m) {  
<span class="nc" id="L1087">    m_MinNo = m; </span>
<span class="nc" id="L1088">  }</span>
  
  /**
   * Gets the minimum total weight of the instances in a rule
   * 
   * @return the minimum total weight of the instances in a rule
   */
  public double getMinNo(){ 
<span class="nc" id="L1096">    return m_MinNo; </span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numAntdsTipText() {
<span class="nc" id="L1105">    return &quot;Set the number of antecedents allowed in the rule if &quot;</span>
      + &quot;pre-pruning is used.  If this value is other than -1, then &quot;
      + &quot;pre-pruning will be used, otherwise the rule uses reduced-error &quot;
      + &quot;pruning.&quot;;
  }

  /**
   * Sets the number of antecedants
   * 
   * @param n the number of antecedants
   */
  public void setNumAntds(int n) {  
<span class="nc" id="L1117">    m_NumAntds = n; </span>
<span class="nc" id="L1118">  }</span>
  
  /**
   * Gets the number of antecedants
   * 
   * @return the number of antecedants
   */
  public int getNumAntds(){ 
<span class="nc" id="L1126">    return m_NumAntds; </span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1135">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1136">    result.disableAll();</span>

    // attributes
<span class="fc" id="L1139">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L1140">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L1141">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L1142">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L1145">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L1146">    result.enable(Capability.NUMERIC_CLASS);</span>
<span class="fc" id="L1147">    result.enable(Capability.DATE_CLASS);</span>
<span class="fc" id="L1148">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
<span class="fc" id="L1150">    return result;</span>
  }
    
  /**
   * Builds a single rule learner with REP dealing with nominal classes or
   * numeric classes.
   * For nominal classes, this rule learner predicts a distribution on
   * the classes.
   * For numeric classes, this learner predicts a single value.
   *
   * @param instances the training data
   * @throws Exception if classifier can't be built successfully
   */
  public void buildClassifier(Instances instances) throws Exception {
    // can classifier handle the data?
<span class="fc" id="L1165">    getCapabilities().testWithFail(instances);</span>

    // remove instances with missing class
<span class="fc" id="L1168">    Instances data = new Instances(instances);</span>
<span class="fc" id="L1169">    data.deleteWithMissingClass();</span>
    
<span class="pc bpc" id="L1171" title="1 of 2 branches missed.">    if(data.numInstances() &lt; m_Folds)</span>
<span class="nc" id="L1172">      throw new Exception(&quot;Not enough data for REP.&quot;);</span>

<span class="fc" id="L1174">    m_ClassAttribute = data.classAttribute();</span>
<span class="fc bfc" id="L1175" title="All 2 branches covered.">    if(m_ClassAttribute.isNominal())</span>
<span class="fc" id="L1176">      m_NumClasses = m_ClassAttribute.numValues();</span>
    else
<span class="fc" id="L1178">      m_NumClasses = 1;</span>
	
<span class="fc" id="L1180">    m_Antds = new FastVector();</span>
<span class="fc" id="L1181">    m_DefDstr = new double[m_NumClasses];</span>
<span class="fc" id="L1182">    m_Cnsqt = new double[m_NumClasses];</span>
<span class="fc" id="L1183">    m_Targets = new FastVector();	    </span>
<span class="fc" id="L1184">    m_Random = new Random(m_Seed);</span>
    
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">    if(m_NumAntds != -1){</span>
<span class="nc" id="L1187">      grow(data);</span>
    }
    else{

<span class="fc" id="L1191">      data.randomize(m_Random);</span>

      // Split data into Grow and Prune	   
<span class="fc" id="L1194">      data.stratify(m_Folds);</span>
	
<span class="fc" id="L1196">      Instances growData=data.trainCV(m_Folds, m_Folds-1, m_Random);</span>
<span class="fc" id="L1197">      Instances pruneData=data.testCV(m_Folds, m_Folds-1);</span>

<span class="fc" id="L1199">      grow(growData);      // Build this rule  </span>
<span class="fc" id="L1200">      prune(pruneData);    // Prune this rule		  	  </span>
    }
	
<span class="fc bfc" id="L1203" title="All 2 branches covered.">    if(m_ClassAttribute.isNominal()){			   </span>
<span class="fc" id="L1204">      Utils.normalize(m_Cnsqt);</span>
<span class="fc bfc" id="L1205" title="All 2 branches covered.">      if(Utils.gr(Utils.sum(m_DefDstr), 0))</span>
<span class="fc" id="L1206">	Utils.normalize(m_DefDstr);</span>
    }	
<span class="fc" id="L1208">  }</span>
    
  /**
   * Computes class distribution for the given instance.
   *
   * @param instance the instance for which distribution is to be computed
   * @return the class distribution for the given instance
   * @throws Exception if given instance is null
   */
  public double[] distributionForInstance(Instance instance) throws Exception {
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">      if(instance == null)</span>
<span class="nc" id="L1219">	  throw new Exception(&quot;Testing instance is NULL!&quot;);</span>
	
<span class="fc bfc" id="L1221" title="All 2 branches covered.">    if (isCover(instance))		</span>
<span class="fc" id="L1222">      return m_Cnsqt;</span>
    else
<span class="fc" id="L1224">      return m_DefDstr;</span>
  }
 
  /**
   * Whether the instance covered by this rule
   * 
   * @param datum the instance in question
   * @return the boolean value indicating whether the instance is covered by this rule
   */
  public boolean isCover(Instance datum){
<span class="fc" id="L1234">    boolean isCover=true;</span>

<span class="fc bfc" id="L1236" title="All 2 branches covered.">    for(int i=0; i&lt;m_Antds.size(); i++){</span>
<span class="fc" id="L1237">      Antd antd = (Antd)m_Antds.elementAt(i);</span>
<span class="fc bfc" id="L1238" title="All 2 branches covered.">      if(!antd.isCover(datum)){</span>
<span class="fc" id="L1239">	isCover = false;</span>
<span class="fc" id="L1240">	break;</span>
      }
    }
	
<span class="fc" id="L1244">    return isCover;</span>
  }        
    
  /**
   * Whether this rule has antecedents, i.e. whether it is a default rule
   * 
   * @return the boolean value indicating whether the rule has antecedents
   */
  public boolean hasAntds(){
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    if (m_Antds == null)</span>
<span class="nc" id="L1254">      return false;</span>
    else
<span class="nc bnc" id="L1256" title="All 2 branches missed.">      return (m_Antds.size() &gt; 0);</span>
  }      

  /**
   * Build one rule using the growing data
   *
   * @param data the growing data used to build the rule
   */    
  private void grow(Instances data){
<span class="fc" id="L1265">    Instances growData = new Instances(data);	</span>
    double defInfo;	
<span class="fc" id="L1267">    double whole = data.sumOfWeights();</span>

<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">    if(m_NumAntds != 0){</span>
	
      /* Class distribution for data both covered and not covered by one antecedent */
<span class="fc" id="L1272">      double[][] classDstr = new double[2][m_NumClasses];</span>
	    
      /* Compute the default information of the growing data */
<span class="fc bfc" id="L1275" title="All 2 branches covered.">      for(int j=0; j &lt; m_NumClasses; j++){</span>
<span class="fc" id="L1276">	classDstr[0][j] = 0;</span>
<span class="fc" id="L1277">	classDstr[1][j] = 0;</span>
      }	
<span class="fc bfc" id="L1279" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal()){	    </span>
<span class="fc bfc" id="L1280" title="All 2 branches covered.">	for(int i=0; i &lt; growData.numInstances(); i++){</span>
<span class="fc" id="L1281">	  Instance datum = growData.instance(i);</span>
<span class="fc" id="L1282">	  classDstr[0][(int)datum.classValue()] += datum.weight();</span>
	}
<span class="fc" id="L1284">	defInfo = ContingencyTables.entropy(classDstr[0]);    </span>
      }
      else{
<span class="fc bfc" id="L1287" title="All 2 branches covered.">	for(int i=0; i &lt; growData.numInstances(); i++){</span>
<span class="fc" id="L1288">	  Instance datum = growData.instance(i);</span>
<span class="fc" id="L1289">	  classDstr[0][0] += datum.weight() * datum.classValue();</span>
	}
		
	// No need to be divided by the denomitor because
	// it's always the same
<span class="fc" id="L1294">	double defMean = (classDstr[0][0] / whole);</span>
<span class="fc" id="L1295">	defInfo = meanSquaredError(growData, defMean) * growData.sumOfWeights();    </span>
      }
	    
      // Store the default class distribution	
<span class="fc" id="L1299">      double[][] tmp = new double[2][m_NumClasses];</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">      for(int y=0; y &lt; m_NumClasses; y++){</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">	if(m_ClassAttribute.isNominal()){	</span>
<span class="fc" id="L1302">	  tmp[0][y] = classDstr[0][y];</span>
<span class="fc" id="L1303">	  tmp[1][y] = classDstr[1][y];</span>
	}
	else{
<span class="fc" id="L1306">	  tmp[0][y] = classDstr[0][y]/whole;</span>
<span class="fc" id="L1307">	  tmp[1][y] = classDstr[1][y];</span>
	}
      }
<span class="fc" id="L1310">      m_Targets.addElement(tmp); </span>
	    
      /* Keep the record of which attributes have already been used*/    
<span class="fc" id="L1313">      boolean[] used=new boolean[growData.numAttributes()];</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">      for (int k=0; k&lt;used.length; k++)</span>
<span class="fc" id="L1315">	used[k]=false;</span>
<span class="fc" id="L1316">      int numUnused=used.length;	</span>
<span class="fc" id="L1317">      double maxInfoGain, uncoveredWtSq=0, uncoveredWtVl=0, uncoveredWts=0;	</span>
<span class="fc" id="L1318">      boolean isContinue = true; // The stopping criterion of this rule	</span>
	    
<span class="pc bpc" id="L1320" title="1 of 2 branches missed.">      while (isContinue){   </span>
<span class="fc" id="L1321">	maxInfoGain = 0;       // We require that infoGain be positive</span>
		
	/* Build a list of antecedents */
<span class="fc" id="L1324">	Antd oneAntd=null;</span>
<span class="fc" id="L1325">	Instances coverData = null, uncoverData = null;</span>
<span class="fc" id="L1326">	Enumeration enumAttr=growData.enumerateAttributes();	    </span>
<span class="fc" id="L1327">	int index=-1;  </span>

<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1330">          System.out.println(&quot;Growing data: &quot; + growData);</span>
        }
		
	/* Build one condition based on all attributes not used yet*/
<span class="pc bfc" id="L1334" title="All 2 branches covered.">	while (enumAttr.hasMoreElements()){</span>
<span class="fc" id="L1335">	  Attribute att= (Attribute)(enumAttr.nextElement());</span>
<span class="fc" id="L1336">	  index++;</span>
		    
<span class="fc" id="L1338">	  Antd antd =null;	</span>
<span class="fc bfc" id="L1339" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){		    </span>
<span class="fc bfc" id="L1340" title="All 2 branches covered.">	    if(att.isNumeric())</span>
<span class="fc" id="L1341">	      antd = new NumericAntd(att, classDstr[1]);</span>
	    else
<span class="fc" id="L1343">	      antd = new NominalAntd(att, classDstr[1]);</span>
	  }
	  else
<span class="fc bfc" id="L1346" title="All 2 branches covered.">	    if(att.isNumeric())</span>
<span class="fc" id="L1347">	      antd = new NumericAntd(att, uncoveredWtSq, uncoveredWtVl, uncoveredWts);</span>
	    else
<span class="fc" id="L1349">	      antd = new NominalAntd(att, uncoveredWtSq, uncoveredWtVl, uncoveredWts); </span>
		    
<span class="fc bfc" id="L1351" title="All 2 branches covered.">	  if(!used[index]){</span>

	    /* Compute the best information gain for each attribute,
	       it's stored in the antecedent formed by this attribute.
	       This procedure returns the data covered by the antecedent*/
<span class="fc" id="L1356">	    Instances[] coveredData = computeInfoGain(growData, defInfo, antd);	 </span>
			
<span class="fc bfc" id="L1358" title="All 2 branches covered.">	    if(coveredData != null){</span>
<span class="fc" id="L1359">	      double infoGain = antd.getMaxInfoGain();			</span>
<span class="fc" id="L1360">	      boolean isUpdate = Utils.gr(infoGain, maxInfoGain);</span>
		
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">              if (m_Debug) {</span>
<span class="nc" id="L1363">                System.err.println(antd);</span>
<span class="nc" id="L1364">                System.err.println(&quot;Info gain: &quot; + infoGain);</span>
<span class="nc" id="L1365">                System.err.println(&quot;Max info gain: &quot; + maxInfoGain);</span>
              }
	    
<span class="fc bfc" id="L1368" title="All 2 branches covered.">	      if(isUpdate){</span>
<span class="fc" id="L1369">		oneAntd=antd;</span>
<span class="fc" id="L1370">		coverData = coveredData[0]; </span>
<span class="fc" id="L1371">		uncoverData = coveredData[1];  </span>
<span class="fc" id="L1372">		maxInfoGain = infoGain;		    </span>
	      }
	    }
	  }
	}
		
<span class="fc bfc" id="L1378" title="All 2 branches covered.">	if(oneAntd == null) 		</span>
<span class="fc" id="L1379">	  break;	    </span>
		
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1382">          System.err.println(&quot;Adding antecedent: &quot;);</span>
<span class="nc" id="L1383">          System.err.println(oneAntd);</span>
<span class="nc" id="L1384">          System.err.println(&quot;Covered data: &quot;);</span>
<span class="nc" id="L1385">          System.err.println(coverData);</span>
<span class="nc" id="L1386">          System.err.println(&quot;Uncovered data: &quot;);</span>
<span class="nc" id="L1387">          System.err.println(uncoverData);</span>
        }

	//Numeric attributes can be used more than once
<span class="fc bfc" id="L1391" title="All 2 branches covered.">	if(!oneAntd.getAttr().isNumeric()){ </span>
<span class="fc" id="L1392">	  used[oneAntd.getAttr().index()]=true;</span>
<span class="fc" id="L1393">	  numUnused--;</span>
	}
		
<span class="fc" id="L1396">	m_Antds.addElement(oneAntd);</span>
<span class="fc" id="L1397">	growData = coverData;// Grow data size is shrinking 	    </span>
		
<span class="fc bfc" id="L1399" title="All 2 branches covered.">	for(int x=0; x &lt; uncoverData.numInstances(); x++){</span>
<span class="fc" id="L1400">	  Instance datum = uncoverData.instance(x);</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">	  if(m_ClassAttribute.isNumeric()){</span>
<span class="fc" id="L1402">	    uncoveredWtSq += datum.weight() * datum.classValue() * datum.classValue();</span>
<span class="fc" id="L1403">	    uncoveredWtVl += datum.weight() * datum.classValue();</span>
<span class="fc" id="L1404">	    uncoveredWts += datum.weight();</span>
<span class="fc" id="L1405">	    classDstr[0][0] -= datum.weight() * datum.classValue();</span>
<span class="fc" id="L1406">	    classDstr[1][0] += datum.weight() * datum.classValue();</span>
	  }
	  else{
<span class="fc" id="L1409">	    classDstr[0][(int)datum.classValue()] -= datum.weight();</span>
<span class="fc" id="L1410">	    classDstr[1][(int)datum.classValue()] += datum.weight();</span>
	  }
	}	       
		
	// Store class distribution of growing data
<span class="fc" id="L1415">	tmp = new double[2][m_NumClasses];</span>
<span class="fc bfc" id="L1416" title="All 2 branches covered.">	for(int y=0; y &lt; m_NumClasses; y++){</span>
<span class="fc bfc" id="L1417" title="All 2 branches covered.">	  if(m_ClassAttribute.isNominal()){	</span>
<span class="fc" id="L1418">	    tmp[0][y] = classDstr[0][y];</span>
<span class="fc" id="L1419">	    tmp[1][y] = classDstr[1][y];</span>
	  }
	  else{
<span class="fc" id="L1422">	    tmp[0][y] = classDstr[0][y]/(whole-uncoveredWts);</span>
<span class="fc" id="L1423">	    tmp[1][y] = classDstr[1][y]/uncoveredWts;</span>
	  }
	}
<span class="fc" id="L1426">	m_Targets.addElement(tmp);  </span>
		
<span class="fc" id="L1428">	defInfo = oneAntd.getInfo();</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1430">          System.err.println(&quot;Default info: &quot; + defInfo);</span>
        }
<span class="pc bpc" id="L1432" title="1 of 2 branches missed.">	int numAntdsThreshold = (m_NumAntds == -1) ? Integer.MAX_VALUE : m_NumAntds;</span>

<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">	if(Utils.eq(growData.sumOfWeights(), 0.0) || </span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">	   (numUnused == 0) ||</span>
<span class="pc bpc" id="L1436" title="1 of 2 branches missed.">	   (m_Antds.size() &gt;= numAntdsThreshold))</span>
<span class="nc" id="L1437">	  isContinue = false;</span>
      }
    }
	
<span class="fc" id="L1441">    m_Cnsqt = ((double[][])(m_Targets.lastElement()))[0];</span>
<span class="fc" id="L1442">    m_DefDstr = ((double[][])(m_Targets.lastElement()))[1];	</span>
<span class="fc" id="L1443">  }</span>
    
  /** 
   * Compute the best information gain for the specified antecedent
   *  
   * @param instances the data based on which the infoGain is computed
   * @param defInfo the default information of data
   * @param antd the specific antecedent
   * @return the data covered and not covered by the antecedent
   */
  private Instances[] computeInfoGain(Instances instances, double defInfo, Antd antd){	
<span class="fc" id="L1454">    Instances data = new Instances(instances);</span>
	
    /* Split the data into bags.
       The information gain of each bag is also calculated in this procedure */
<span class="fc" id="L1458">    Instances[] splitData = antd.splitData(data, defInfo); </span>
<span class="fc" id="L1459">    Instances[] coveredData = new Instances[2];</span>
	
    /* Get the bag of data to be used for next antecedents */
<span class="fc" id="L1462">    Instances tmp1 = new Instances(data, 0);</span>
<span class="fc" id="L1463">    Instances tmp2 = new Instances(data, 0);</span>
	
<span class="fc bfc" id="L1465" title="All 2 branches covered.">    if(splitData == null)	    </span>
<span class="fc" id="L1466">      return null;</span>
	
<span class="fc bfc" id="L1468" title="All 2 branches covered.">    for(int x=0; x &lt; (splitData.length-1); x++){</span>
<span class="fc bfc" id="L1469" title="All 2 branches covered.">      if(x == ((int)antd.getAttrValue()))</span>
<span class="fc" id="L1470">	tmp1 = splitData[x];</span>
      else{		
<span class="fc bfc" id="L1472" title="All 2 branches covered.">	for(int y=0; y &lt; splitData[x].numInstances(); y++)</span>
<span class="fc" id="L1473">	  tmp2.add(splitData[x].instance(y));		    </span>
      }		
    }
	
<span class="fc bfc" id="L1477" title="All 2 branches covered.">    if(antd.getAttr().isNominal()){ // Nominal attributes</span>
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">      if(((NominalAntd)antd).isIn()){ // Inclusive expression</span>
<span class="fc" id="L1479">	coveredData[0] = new Instances(tmp1);</span>
<span class="fc" id="L1480">	coveredData[1] = new Instances(tmp2);</span>
      }
      else{                           // Exclusive expression
<span class="nc" id="L1483">	coveredData[0] = new Instances(tmp2);</span>
<span class="nc" id="L1484">	coveredData[1] = new Instances(tmp1);</span>
      }	
    }
    else{                           // Numeric attributes
<span class="fc" id="L1488">      coveredData[0] = new Instances(tmp1);</span>
<span class="fc" id="L1489">      coveredData[1] = new Instances(tmp2);</span>
    }
	
    /* Add data with missing value */
<span class="fc bfc" id="L1493" title="All 2 branches covered.">    for(int z=0; z&lt;splitData[splitData.length-1].numInstances(); z++)</span>
<span class="fc" id="L1494">      coveredData[1].add(splitData[splitData.length-1].instance(z));</span>
	
<span class="fc" id="L1496">    return coveredData;</span>
  }
    
  /**
   * Prune the rule using the pruning data.
   * The weighted average of accuracy rate/mean-squared error is 
   * used to prune the rule.
   *
   * @param pruneData the pruning data used to prune the rule
   */    
  private void prune(Instances pruneData){
<span class="fc" id="L1507">    Instances data=new Instances(pruneData);</span>
<span class="fc" id="L1508">    Instances otherData = new Instances(data, 0);</span>
<span class="fc" id="L1509">    double total = data.sumOfWeights();</span>
	
    /* The default accurate# and the the accuracy rate on pruning data */
    double defAccu;
<span class="fc bfc" id="L1513" title="All 2 branches covered.">    if(m_ClassAttribute.isNumeric())</span>
<span class="fc" id="L1514">      defAccu = meanSquaredError(pruneData,</span>
<span class="fc" id="L1515">				 ((double[][])m_Targets.firstElement())[0][0]);</span>
    else{
<span class="fc" id="L1517">      int predict = Utils.maxIndex(((double[][])m_Targets.firstElement())[0]);</span>
<span class="fc" id="L1518">      defAccu = computeAccu(pruneData, predict)/total;</span>
    }
	
<span class="fc" id="L1521">    int size=m_Antds.size();</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">    if(size == 0){</span>
<span class="fc" id="L1523">      m_Cnsqt = ((double[][])m_Targets.lastElement())[0];</span>
<span class="fc" id="L1524">      m_DefDstr = ((double[][])m_Targets.lastElement())[1];</span>
<span class="fc" id="L1525">      return; // Default rule before pruning</span>
    }
	
<span class="fc" id="L1528">    double[] worthValue = new double[size];</span>
	
    /* Calculate accuracy parameters for all the antecedents in this rule */
<span class="fc bfc" id="L1531" title="All 2 branches covered.">    for(int x=0; x&lt;size; x++){</span>
<span class="fc" id="L1532">      Antd antd=(Antd)m_Antds.elementAt(x);</span>
<span class="fc" id="L1533">      Instances newData = new Instances(data);</span>
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">      if(Utils.eq(newData.sumOfWeights(),0.0))</span>
<span class="nc" id="L1535">	break;</span>
	    
<span class="fc" id="L1537">      data = new Instances(newData, newData.numInstances()); // Make data empty</span>
	    
<span class="fc bfc" id="L1539" title="All 2 branches covered.">      for(int y=0; y&lt;newData.numInstances(); y++){</span>
<span class="fc" id="L1540">	Instance ins=newData.instance(y);</span>
<span class="fc bfc" id="L1541" title="All 2 branches covered.">	if(antd.isCover(ins))              // Covered by this antecedent</span>
<span class="fc" id="L1542">	  data.add(ins);                 // Add to data for further 		</span>
	else
<span class="fc" id="L1544">	  otherData.add(ins);            // Not covered by this antecedent</span>
      }
	    
      double covered, other;	    
<span class="fc" id="L1548">      double[][] classes = </span>
<span class="fc" id="L1549">	(double[][])m_Targets.elementAt(x+1); // m_Targets has one more element</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal()){		</span>
<span class="fc" id="L1551">	int coverClass = Utils.maxIndex(classes[0]),</span>
<span class="fc" id="L1552">	  otherClass = Utils.maxIndex(classes[1]);</span>
		
<span class="fc" id="L1554">	covered = computeAccu(data, coverClass); </span>
<span class="fc" id="L1555">	other = computeAccu(otherData, otherClass);		</span>
      }
      else{
<span class="fc" id="L1558">	double coverClass = classes[0][0],</span>
<span class="fc" id="L1559">	  otherClass = classes[1][0];</span>
<span class="fc" id="L1560">	covered = (data.sumOfWeights())*meanSquaredError(data, coverClass); </span>
<span class="fc" id="L1561">	other = (otherData.sumOfWeights())*meanSquaredError(otherData, otherClass);</span>
      }
	    
<span class="fc" id="L1564">      worthValue[x] = (covered + other)/total;</span>
    }
	
    /* Prune the antecedents according to the accuracy parameters */
<span class="pc bfc" id="L1568" title="All 2 branches covered.">    for(int z=(size-1); z &gt; 0; z--){	</span>
      // Treatment to avoid precision problems
      double valueDelta;
<span class="pc bpc" id="L1571" title="1 of 2 branches missed.">      if(m_ClassAttribute.isNominal()){</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">	if(Utils.sm(worthValue[z], 1.0))</span>
<span class="nc" id="L1573">	  valueDelta = (worthValue[z] - worthValue[z-1]) / worthValue[z];</span>
	else
<span class="nc" id="L1575">	  valueDelta = worthValue[z] - worthValue[z-1];</span>
      }
      else{
<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">	if(Utils.sm(worthValue[z], 1.0))</span>
<span class="fc" id="L1579">	  valueDelta = (worthValue[z-1] - worthValue[z]) / worthValue[z];</span>
	else
<span class="nc" id="L1581">	  valueDelta = (worthValue[z-1] - worthValue[z]);</span>
      }
	    
<span class="pc bpc" id="L1584" title="1 of 2 branches missed.">      if(Utils.smOrEq(valueDelta, 0.0)){	</span>
<span class="nc" id="L1585">	m_Antds.removeElementAt(z);</span>
<span class="nc" id="L1586">	m_Targets.removeElementAt(z+1);</span>
      }
      else  break;
    }	
	
    // Check whether this rule is a default rule
<span class="fc bfc" id="L1592" title="All 2 branches covered.">    if(m_Antds.size() == 1){</span>
      double valueDelta;
<span class="fc bfc" id="L1594" title="All 2 branches covered.">      if(m_ClassAttribute.isNominal()){</span>
<span class="fc bfc" id="L1595" title="All 2 branches covered.">	if(Utils.sm(worthValue[0], 1.0))</span>
<span class="fc" id="L1596">	  valueDelta = (worthValue[0] - defAccu) / worthValue[0];</span>
	else
<span class="fc" id="L1598">	  valueDelta = (worthValue[0] - defAccu);</span>
      }
      else{
<span class="fc bfc" id="L1601" title="All 2 branches covered.">	if(Utils.sm(worthValue[0], 1.0))</span>
<span class="fc" id="L1602">	  valueDelta = (defAccu - worthValue[0]) / worthValue[0];</span>
	else
<span class="fc" id="L1604">	  valueDelta = (defAccu - worthValue[0]);</span>
      }
	    
<span class="fc bfc" id="L1607" title="All 2 branches covered.">      if(Utils.smOrEq(valueDelta, 0.0)){</span>
<span class="fc" id="L1608">	m_Antds.removeAllElements();</span>
<span class="fc" id="L1609">	m_Targets.removeElementAt(1);</span>
      }
    }
	
<span class="fc" id="L1613">    m_Cnsqt = ((double[][])(m_Targets.lastElement()))[0];</span>
<span class="fc" id="L1614">    m_DefDstr = ((double[][])(m_Targets.lastElement()))[1];</span>
<span class="fc" id="L1615">  }</span>
    
  /**
   * Private function to compute number of accurate instances
   * based on the specified predicted class
   * 
   * @param data the data in question
   * @param clas the predicted class
   * @return the default accuracy number
   */
  private double computeAccu(Instances data, int clas){ 
<span class="fc" id="L1626">    double accu = 0;</span>
<span class="fc bfc" id="L1627" title="All 2 branches covered.">    for(int i=0; i&lt;data.numInstances(); i++){</span>
<span class="fc" id="L1628">      Instance inst = data.instance(i);</span>
<span class="fc bfc" id="L1629" title="All 2 branches covered.">      if((int)inst.classValue() == clas)</span>
<span class="fc" id="L1630">	accu += inst.weight();</span>
    }
<span class="fc" id="L1632">    return accu;</span>
  }
    

  /**
   * Private function to compute the squared error of
   * the specified data and the specified mean
   * 
   * @param data the data in question
   * @param mean the specified mean
   * @return the default mean-squared error
   */
  private double meanSquaredError(Instances data, double mean){ 
<span class="fc bfc" id="L1645" title="All 2 branches covered.">    if(Utils.eq(data.sumOfWeights(),0.0))</span>
<span class="fc" id="L1646">      return 0;</span>
	
<span class="fc" id="L1648">    double mSqErr=0, sum = data.sumOfWeights();</span>
<span class="fc bfc" id="L1649" title="All 2 branches covered.">    for(int i=0; i &lt; data.numInstances(); i++){</span>
<span class="fc" id="L1650">      Instance datum = data.instance(i);</span>
<span class="fc" id="L1651">      mSqErr += datum.weight()*</span>
<span class="fc" id="L1652">	(datum.classValue() - mean)*</span>
<span class="fc" id="L1653">	(datum.classValue() - mean);</span>
    }	 
	
<span class="fc" id="L1656">    return (mSqErr / sum);</span>
  }
     
  /**
   * Prints this rule with the specified class label
   *
   * @param att the string standing for attribute in the consequent of this rule
   * @param cl the string standing for value in the consequent of this rule
   * @return a textual description of this rule with the specified class label
   */
  public String toString(String att, String cl) {
<span class="nc" id="L1667">    StringBuffer text =  new StringBuffer();</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">    if(m_Antds.size() &gt; 0){</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">      for(int j=0; j&lt; (m_Antds.size()-1); j++)</span>
<span class="nc" id="L1670">	text.append(&quot;(&quot; + ((Antd)(m_Antds.elementAt(j))).toString()+ &quot;) and &quot;);</span>
<span class="nc" id="L1671">      text.append(&quot;(&quot;+((Antd)(m_Antds.lastElement())).toString() + &quot;)&quot;);</span>
    }
<span class="nc" id="L1673">    text.append(&quot; =&gt; &quot; + att + &quot; = &quot; + cl);</span>
	
<span class="nc" id="L1675">    return text.toString();</span>
  }
    
  /**
   * Prints this rule
   *
   * @return a textual description of this rule
   */
  public String toString() {
<span class="fc" id="L1684">    String title = </span>
<span class="fc" id="L1685">      &quot;\n\nSingle conjunctive rule learner:\n&quot;+</span>
<span class="fc" id="L1686">      &quot;--------------------------------\n&quot;, body = null;</span>
<span class="fc" id="L1687">    StringBuffer text =  new StringBuffer();</span>
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">    if(m_ClassAttribute != null){</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">      if(m_ClassAttribute.isNominal()){</span>
<span class="nc" id="L1690">	body = toString(m_ClassAttribute.name(), m_ClassAttribute.value(Utils.maxIndex(m_Cnsqt)));</span>
		
<span class="nc" id="L1692">	text.append(&quot;\n\nClass distributions:\nCovered by the rule:\n&quot;);</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">	for(int k=0; k &lt; m_Cnsqt.length; k++)</span>
<span class="nc" id="L1694">	  text.append(m_ClassAttribute.value(k)+ &quot;\t&quot;);</span>
<span class="nc" id="L1695">	text.append('\n');</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">	for(int l=0; l &lt; m_Cnsqt.length; l++)</span>
<span class="nc" id="L1697">	  text.append(Utils.doubleToString(m_Cnsqt[l], 6)+&quot;\t&quot;);</span>
		
<span class="nc" id="L1699">	text.append(&quot;\n\nNot covered by the rule:\n&quot;);</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">	for(int k=0; k &lt; m_DefDstr.length; k++)</span>
<span class="nc" id="L1701">	  text.append(m_ClassAttribute.value(k)+ &quot;\t&quot;);</span>
<span class="nc" id="L1702">	text.append('\n');</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">	for(int l=0; l &lt; m_DefDstr.length; l++)</span>
<span class="nc" id="L1704">	  text.append(Utils.doubleToString(m_DefDstr[l], 6)+&quot;\t&quot;);	    </span>
      }
      else
<span class="nc" id="L1707">	body = toString(m_ClassAttribute.name(), Utils.doubleToString(m_Cnsqt[0], 6));</span>
    }
<span class="fc" id="L1709">    return (title + body + text.toString());</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1718">    return RevisionUtils.extract(&quot;$Revision: 9835 $&quot;);</span>
  }
    
  /**
   * Main method.
   *
   * @param args the options for the classifier
   */
  public static void main(String[] args) {	
<span class="nc" id="L1727">    runClassifier(new ConjunctiveRule(), args);</span>
<span class="nc" id="L1728">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>