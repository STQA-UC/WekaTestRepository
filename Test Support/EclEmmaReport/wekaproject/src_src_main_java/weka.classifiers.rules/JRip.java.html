<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>JRip.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">JRip.java</span></div><h1>JRip.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    JRip.java
 *    Copyright (C) 2001 University of Waikato, Hamilton, New Zealand
 */

package weka.classifiers.rules;

import weka.classifiers.Classifier;
import weka.core.AdditionalMeasureProducer;
import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.Copyable;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.supervised.attribute.ClassOrder;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * This class implements a propositional rule learner, Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was proposed by William W. Cohen as an optimized version of IREP. &lt;br/&gt;
 * &lt;br/&gt;
 * The algorithm is briefly described as follows: &lt;br/&gt;
 * &lt;br/&gt;
 * Initialize RS = {}, and for each class from the less prevalent one to the more frequent one, DO: &lt;br/&gt;
 * &lt;br/&gt;
 * 1. Building stage:&lt;br/&gt;
 * Repeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and examples is 64 bits greater than the smallest DL met so far, or there are no positive examples, or the error rate &amp;gt;= 50%. &lt;br/&gt;
 * &lt;br/&gt;
 * 1.1. Grow phase:&lt;br/&gt;
 * Grow one rule by greedily adding antecedents (or conditions) to the rule until the rule is perfect (i.e. 100% accurate).  The procedure tries every possible value of each attribute and selects the condition with highest information gain: p(log(p/t)-log(P/T)).&lt;br/&gt;
 * &lt;br/&gt;
 * 1.2. Prune phase:&lt;br/&gt;
 * Incrementally prune each rule and allow the pruning of any final sequences of the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).&lt;br/&gt;
 * &lt;br/&gt;
 * 2. Optimization stage:&lt;br/&gt;
 *  after generating the initial ruleset {Ri}, generate and prune two variants of each rule Ri from randomized data using procedure 1.1 and 1.2. But one variant is generated from an empty rule while the other is generated by greedily adding antecedents to the original rule. Moreover, the pruning metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each variant and the original rule is computed.  The variant with the minimal DL is selected as the final representative of Ri in the ruleset.After all the rules in {Ri} have been examined and if there are still residual positives, more rules are generated based on the residual positives using Building Stage again. &lt;br/&gt;
 * 3. Delete the rules from the ruleset that would increase the DL of the whole ruleset if it were in it. and add resultant ruleset to RS. &lt;br/&gt;
 * ENDDO&lt;br/&gt;
 * &lt;br/&gt;
 * Note that there seem to be 2 bugs in the original ripper program that would affect the ruleset size and accuracy slightly.  This implementation avoids these bugs and thus is a little bit different from Cohen's original implementation. Even after fixing the bugs, since the order of classes with the same frequency is not defined in ripper, there still seems to be some trivial difference between this implementation and the original ripper, especially for audiology data in UCI repository, where there are lots of classes of few instances.&lt;br/&gt;
 * &lt;br/&gt;
 * Details please see:&lt;br/&gt;
 * &lt;br/&gt;
 * William W. Cohen: Fast Effective Rule Induction. In: Twelfth International Conference on Machine Learning, 115-123, 1995.&lt;br/&gt;
 * &lt;br/&gt;
 * PS.  We have compared this implementation with the original ripper implementation in aspects of accuracy, ruleset size and running time on both artificial data &quot;ab+bcd+defg&quot; and UCI datasets.  In all these aspects it seems to be quite comparable to the original ripper implementation.  However, we didn't consider memory consumption optimization in this implementation.&lt;br/&gt;
 * &lt;br/&gt;
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Cohen1995,
 *    author = {William W. Cohen},
 *    booktitle = {Twelfth International Conference on Machine Learning},
 *    pages = {115-123},
 *    publisher = {Morgan Kaufmann},
 *    title = {Fast Effective Rule Induction},
 *    year = {1995}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -F &amp;lt;number of folds&amp;gt;
 *  Set number of folds for REP
 *  One fold is used as pruning set.
 *  (default 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;min. weights&amp;gt;
 *  Set the minimal weights of instances
 *  within a split.
 *  (default 2.0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O &amp;lt;number of runs&amp;gt;
 *  Set the number of runs of
 *  optimizations. (Default: 2)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  Set whether turn on the
 *  debug mode (Default: false)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
 *  The seed of randomization
 *  (Default: 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E
 *  Whether NOT check the error rate&amp;gt;=0.5
 *  in stopping criteria  (default: check)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P
 *  Whether NOT use pruning
 *  (default: use pruning)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Xin Xu (xx5@cs.waikato.ac.nz)
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @version $Revision: 8119 $
 */
<span class="fc" id="L137">public class JRip </span>
  extends Classifier 
  implements AdditionalMeasureProducer, 
	     WeightedInstancesHandler,
	     TechnicalInformationHandler {    

  /** for serialization */
  static final long serialVersionUID = -6589312996832147161L;
  
  /** The limit of description length surplus in ruleset generation */
<span class="fc" id="L147">  private static double MAX_DL_SURPLUS = 64.0;</span>
    
  /** The class attribute of the data*/
  private Attribute m_Class; 
    
  /** The ruleset */
  private FastVector m_Ruleset;
  
  /** The predicted class distribution */
  private FastVector m_Distributions;
  
  /** Runs of optimizations */
<span class="fc" id="L159">  private int m_Optimizations = 2;</span>
    
  /** Random object used in this class */
<span class="fc" id="L162">  private Random m_Random = null;</span>
    
  /** # of all the possible conditions in a rule */
<span class="fc" id="L165">  private double m_Total = 0;</span>

  /** The seed to perform randomization */
<span class="fc" id="L168">  private long m_Seed = 1;</span>

  /** The number of folds to split data into Grow and Prune for IREP */
<span class="fc" id="L171">  private int m_Folds = 3;</span>
    
  /** The minimal number of instance weights within a split*/
<span class="fc" id="L174">  private double m_MinNo = 2.0;</span>

  /** Whether in a debug mode */
<span class="fc" id="L177">  private boolean m_Debug = false;</span>

  /** Whether check the error rate &gt;= 0.5 in stopping criteria */
<span class="fc" id="L180">  private boolean m_CheckErr = true;</span>

  /** Whether use pruning, i.e. the data is clean or not */
<span class="fc" id="L183">  private boolean m_UsePruning = true;</span>

  /** The filter used to randomize the class order */
<span class="fc" id="L186">  private Filter m_Filter = null;</span>

  /** The RuleStats for the ruleset of each class value */
  private FastVector m_RulesetStats;
    
  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L198">    return &quot;This class implements a propositional rule learner, Repeated Incremental &quot;</span>
      + &quot;Pruning to Produce Error Reduction (RIPPER), which was proposed by William &quot;
      + &quot;W. Cohen as an optimized version of IREP. \n\n&quot;
      + &quot;The algorithm is briefly described as follows: \n\n&quot;
      + &quot;Initialize RS = {}, and for each class from the less prevalent one to &quot;
      + &quot;the more frequent one, DO: \n\n&quot;
      + &quot;1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) &quot;
      + &quot;of the ruleset and examples is 64 bits greater than the smallest DL &quot;
      + &quot;met so far, or there are no positive examples, or the error rate &gt;= 50%. &quot;
      + &quot;\n\n&quot;
      + &quot;1.1. Grow phase:\n&quot;
      + &quot;Grow one rule by greedily adding antecedents (or conditions) to &quot;
      + &quot;the rule until the rule is perfect (i.e. 100% accurate).  The &quot;
      + &quot;procedure tries every possible value of each attribute and selects &quot;
      + &quot;the condition with highest information gain: p(log(p/t)-log(P/T)).&quot;
      + &quot;\n\n&quot;
      + &quot;1.2. Prune phase:\n&quot;
      + &quot;Incrementally prune each rule and allow the pruning of any &quot;
      + &quot;final sequences of the antecedents;&quot;
      + &quot;The pruning metric is (p-n)/(p+n) -- but it's actually &quot;
      + &quot;2p/(p+n) -1, so in this implementation we simply use p/(p+n) &quot;
      + &quot;(actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n&quot;
      + &quot;2. Optimization stage:\n after generating the initial ruleset {Ri}, &quot;
      + &quot;generate and prune two variants of each rule Ri from randomized data &quot;
      + &quot;using procedure 1.1 and 1.2. But one variant is generated from an &quot;
      + &quot;empty rule while the other is generated by greedily adding antecedents &quot;
      + &quot;to the original rule. Moreover, the pruning metric used here is &quot;
      + &quot;(TP+TN)/(P+N).&quot;
      + &quot;Then the smallest possible DL for each variant and the original rule &quot;
      + &quot;is computed.  The variant with the minimal DL is selected as the final &quot;
      + &quot;representative of Ri in the ruleset.&quot;
      + &quot;After all the rules in {Ri} have been examined and if there are still &quot;
      + &quot;residual positives, more rules are generated based on the residual &quot;
      + &quot;positives using Building Stage again. \n&quot;
      + &quot;3. Delete the rules from the ruleset that would increase the DL of the &quot;
      + &quot;whole ruleset if it were in it. and add resultant ruleset to RS. \n&quot;
      + &quot;ENDDO\n\n&quot;
      + &quot;Note that there seem to be 2 bugs in the original ripper program that would &quot;
      + &quot;affect the ruleset size and accuracy slightly.  This implementation avoids &quot;
      + &quot;these bugs and thus is a little bit different from Cohen's original &quot;
      + &quot;implementation. Even after fixing the bugs, since the order of classes with &quot;
      + &quot;the same frequency is not defined in ripper, there still seems to be &quot;
      + &quot;some trivial difference between this implementation and the original ripper, &quot;
      + &quot;especially for audiology data in UCI repository, where there are lots of &quot;
      + &quot;classes of few instances.\n\n&quot;
      + &quot;Details please see:\n\n&quot;
<span class="nc" id="L244">      + getTechnicalInformation().toString() + &quot;\n\n&quot;</span>
<span class="nc" id="L245">      + &quot;PS.  We have compared this implementation with the original ripper &quot;</span>
<span class="nc" id="L246">      + &quot;implementation in aspects of accuracy, ruleset size and running time &quot;</span>
<span class="nc" id="L247">      + &quot;on both artificial data \&quot;ab+bcd+defg\&quot; and UCI datasets.  In all these &quot;</span>
<span class="nc" id="L248">      + &quot;aspects it seems to be quite comparable to the original ripper &quot;</span>
<span class="nc" id="L249">      + &quot;implementation.  However, we didn't consider memory consumption &quot;</span>
<span class="nc" id="L250">      + &quot;optimization in this implementation.\n\n&quot;;    </span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L263">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L264">    result.setValue(Field.AUTHOR, &quot;William W. Cohen&quot;);</span>
<span class="nc" id="L265">    result.setValue(Field.TITLE, &quot;Fast Effective Rule Induction&quot;);</span>
<span class="nc" id="L266">    result.setValue(Field.BOOKTITLE, &quot;Twelfth International Conference on Machine Learning&quot;);</span>
<span class="nc" id="L267">    result.setValue(Field.YEAR, &quot;1995&quot;);</span>
<span class="nc" id="L268">    result.setValue(Field.PAGES, &quot;115-123&quot;);</span>
<span class="nc" id="L269">    result.setValue(Field.PUBLISHER, &quot;Morgan Kaufmann&quot;);</span>
    
<span class="nc" id="L271">    return result;</span>
  }
    
  /**
   * Returns an enumeration describing the available options
   * Valid options are: &lt;p&gt;
   *  
   * -F number &lt;br&gt;
   * The number of folds for reduced error pruning. One fold is
   * used as the pruning set. (Default: 3) &lt;p&gt;
   * 
   * -N number &lt;br&gt;
   * The minimal weights of instances within a split.
   * (Default: 2) &lt;p&gt;
   *    
   * -O number &lt;br&gt;
   * Set the number of runs of optimizations. (Default: 2)&lt;p&gt;
   *
   * -D &lt;br&gt;
   * Whether turn on the debug mode
   *
   * -S number &lt;br&gt;
   * The seed of randomization used in Ripper.(Default: 1)&lt;p&gt;
   *
   * -E &lt;br&gt;
   * Whether NOT check the error rate &gt;= 0.5 in stopping criteria.
   * (default: check)&lt;p&gt; 
   *
   * -P &lt;br&gt;
   * Whether NOT use pruning. (default: use pruning)&lt;p&gt;
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L305">    Vector newVector = new Vector(3);</span>
<span class="fc" id="L306">    newVector.addElement(new Option(&quot;\tSet number of folds for REP\n&quot; +</span>
				    &quot;\tOne fold is used as pruning set.\n&quot; +
<span class="fc" id="L308">				    &quot;\t(default 3)&quot;,&quot;F&quot;, 1, &quot;-F &lt;number of folds&gt;&quot;));</span>
<span class="fc" id="L309">    newVector.addElement(new Option(&quot;\tSet the minimal weights of instances\n&quot; +</span>
				    &quot;\twithin a split.\n&quot; +
<span class="fc" id="L311">				    &quot;\t(default 2.0)&quot;,&quot;N&quot;, 1, &quot;-N &lt;min. weights&gt;&quot;));		 </span>
<span class="fc" id="L312">    newVector.addElement(new Option(&quot;\tSet the number of runs of\n&quot;+</span>
<span class="fc" id="L313">				    &quot;\toptimizations. (Default: 2)&quot;, &quot;O&quot;,</span>
<span class="fc" id="L314">				    1,&quot;-O &lt;number of runs&gt;&quot;));</span>
	
<span class="fc" id="L316">    newVector.addElement(new Option(&quot;\tSet whether turn on the\n&quot;+</span>
<span class="fc" id="L317">				    &quot;\tdebug mode (Default: false)&quot;, &quot;D&quot;,</span>
<span class="fc" id="L318">				    0,&quot;-D&quot;));</span>
	
<span class="fc" id="L320">    newVector.addElement(new Option(&quot;\tThe seed of randomization\n&quot;+</span>
<span class="fc" id="L321">				    &quot;\t(Default: 1)&quot;, &quot;S&quot;,</span>
<span class="fc" id="L322">				    1,&quot;-S &lt;seed&gt;&quot;));</span>
	
<span class="fc" id="L324">    newVector.addElement(new Option(&quot;\tWhether NOT check the error rate&gt;=0.5\n&quot;</span>
				    +&quot;\tin stopping criteria &quot;
<span class="fc" id="L326">				    +&quot;\t(default: check)&quot;, &quot;E&quot;, </span>
<span class="fc" id="L327">				    0, &quot;-E&quot;)); </span>
	
<span class="fc" id="L329">    newVector.addElement(new Option(&quot;\tWhether NOT use pruning\n&quot;</span>
<span class="fc" id="L330">				    +&quot;\t(default: use pruning)&quot;, &quot;P&quot;, </span>
<span class="fc" id="L331">				    0, &quot;-P&quot;)); </span>
<span class="fc" id="L332">    return newVector.elements();</span>
  }
    
  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -F &amp;lt;number of folds&amp;gt;
   *  Set number of folds for REP
   *  One fold is used as pruning set.
   *  (default 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;min. weights&amp;gt;
   *  Set the minimal weights of instances
   *  within a split.
   *  (default 2.0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O &amp;lt;number of runs&amp;gt;
   *  Set the number of runs of
   *  optimizations. (Default: 2)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  Set whether turn on the
   *  debug mode (Default: false)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
   *  The seed of randomization
   *  (Default: 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E
   *  Whether NOT check the error rate&amp;gt;=0.5
   *  in stopping criteria  (default: check)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P
   *  Whether NOT use pruning
   *  (default: use pruning)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
<span class="fc" id="L377">    String numFoldsString = Utils.getOption('F', options);</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">    if (numFoldsString.length() != 0) </span>
<span class="fc" id="L379">      m_Folds = Integer.parseInt(numFoldsString);</span>
    else 
<span class="fc" id="L381">      m_Folds = 3;   </span>
	
<span class="fc" id="L383">    String minNoString = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">    if (minNoString.length() != 0) </span>
<span class="fc" id="L385">      m_MinNo = Double.parseDouble(minNoString);</span>
    else 
<span class="fc" id="L387">      m_MinNo = 2.0;</span>
	
<span class="fc" id="L389">    String seedString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">    if (seedString.length() != 0)</span>
<span class="fc" id="L391">      m_Seed = Long.parseLong(seedString);</span>
    else 
<span class="fc" id="L393">      m_Seed = 1;</span>

<span class="fc" id="L395">    String runString = Utils.getOption('O', options);</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">    if (runString.length() != 0)</span>
<span class="fc" id="L397">      m_Optimizations = Integer.parseInt(runString);</span>
    else 
<span class="fc" id="L399">      m_Optimizations = 2;</span>

<span class="fc" id="L401">    m_Debug = Utils.getFlag('D', options);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">    m_CheckErr = !Utils.getFlag('E', options);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">    m_UsePruning = !Utils.getFlag('P', options);</span>
<span class="fc" id="L404">  }</span>
    
  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L413">    String [] options = new String [11];</span>
<span class="fc" id="L414">    int current = 0;</span>
<span class="fc" id="L415">    options[current++] = &quot;-F&quot;; options[current++] = &quot;&quot; + m_Folds;</span>
<span class="fc" id="L416">    options[current++] = &quot;-N&quot;; options[current++] = &quot;&quot; + m_MinNo;</span>
<span class="fc" id="L417">    options[current++] = &quot;-O&quot;; options[current++] = &quot;&quot; + m_Optimizations;</span>
<span class="fc" id="L418">    options[current++] = &quot;-S&quot;; options[current++] = &quot;&quot; + m_Seed;</span>
	
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">    if(m_Debug)</span>
<span class="nc" id="L421">      options[current++] = &quot;-D&quot;;</span>

<span class="pc bpc" id="L423" title="1 of 2 branches missed.">    if(!m_CheckErr)</span>
<span class="nc" id="L424">      options[current++] = &quot;-E&quot;;</span>
	
<span class="pc bpc" id="L426" title="1 of 2 branches missed.">    if(!m_UsePruning)</span>
<span class="nc" id="L427">      options[current++] = &quot;-P&quot;;</span>
	
<span class="pc bfc" id="L429" title="All 2 branches covered.">    while(current &lt; options.length)</span>
<span class="fc" id="L430">      options[current++] = &quot;&quot;;</span>
	
<span class="fc" id="L432">    return options;</span>
  }

  /**
   * Returns an enumeration of the additional measure names
   * @return an enumeration of the measure names
   */
  public Enumeration enumerateMeasures() {
<span class="nc" id="L440">    Vector newVector = new Vector(1);</span>
<span class="nc" id="L441">    newVector.addElement(&quot;measureNumRules&quot;);</span>
<span class="nc" id="L442">    return newVector.elements();</span>
  }
    
  /**
   * Returns the value of the named measure
   * @param additionalMeasureName the name of the measure to query for its value
   * @return the value of the named measure
   * @throws IllegalArgumentException if the named measure is not supported
   */
  public double getMeasure(String additionalMeasureName) {
<span class="nc bnc" id="L452" title="All 2 branches missed.">    if (additionalMeasureName.compareToIgnoreCase(&quot;measureNumRules&quot;) == 0) </span>
<span class="nc" id="L453">      return m_Ruleset.size();</span>
    else 
<span class="nc" id="L455">      throw new IllegalArgumentException(additionalMeasureName+&quot; not supported (RIPPER)&quot;);</span>
  }  

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String foldsTipText() {
<span class="nc" id="L464">    return &quot;Determines the amount of data used for pruning. One fold is used for &quot;</span>
      + &quot;pruning, the rest for growing the rules.&quot;;
  }

  /**
   * Sets the number of folds to use
   * 
   * @param fold the number of folds
   */
  public void setFolds(int fold) { 
<span class="nc" id="L474">    m_Folds = fold; </span>
<span class="nc" id="L475">  }</span>
  
  /**
   * Gets the number of folds
   * 
   * @return the number of folds
   */
  public int getFolds(){ 
<span class="nc" id="L483">    return m_Folds; </span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minNoTipText() {
<span class="nc" id="L492">    return &quot;The minimum total weight of the instances in a rule.&quot;;</span>
  }

  /**
   * Sets the minimum total weight of the instances in a rule
   * 
   * @param m the minimum total weight of the instances in a rule
   */
  public void setMinNo(double m) {
<span class="nc" id="L501">    m_MinNo = m;</span>
<span class="nc" id="L502">  }</span>
  
  /**
   * Gets the minimum total weight of the instances in a rule
   * 
   * @return the minimum total weight of the instances in a rule
   */
  public double getMinNo(){ 
<span class="nc" id="L510">    return m_MinNo;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String seedTipText() {
<span class="nc" id="L519">    return &quot;The seed used for randomizing the data.&quot;;</span>
  }

  /**
   * Sets the seed value to use in randomizing the data
   * 
   * @param s the new seed value
   */
  public void setSeed(long s) {
<span class="nc" id="L528">    m_Seed = s;</span>
<span class="nc" id="L529">  }</span>
  
  /**
   * Gets the current seed value to use in randomizing the data
   * 
   * @return the seed value
   */
  public long getSeed(){
<span class="nc" id="L537">    return m_Seed;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String optimizationsTipText() {
<span class="nc" id="L546">    return &quot;The number of optimization runs.&quot;;</span>
  }

  /**
   * Sets the number of optimization runs
   * 
   * @param run the number of optimization runs
   */
  public void setOptimizations(int run) {
<span class="nc" id="L555">    m_Optimizations = run;</span>
<span class="nc" id="L556">  }</span>
  
  /**
   * Gets the the number of optimization runs
   * 
   * @return the number of optimization runs
   */
  public int getOptimizations() {
<span class="nc" id="L564">    return m_Optimizations;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String debugTipText() {
<span class="nc" id="L573">    return &quot;Whether debug information is output to the console.&quot;;</span>
  }

  /**
   * Sets whether debug information is output to the console
   * 
   * @param d whether debug information is output to the console
   */
  public void setDebug(boolean d) {
<span class="nc" id="L582">    m_Debug = d;</span>
<span class="nc" id="L583">  }</span>
  
  /**
   * Gets whether debug information is output to the console
   * 
   * @return whether debug information is output to the console
   */
  public boolean getDebug(){
<span class="nc" id="L591">    return m_Debug;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String checkErrorRateTipText() {
<span class="nc" id="L600">    return &quot;Whether check for error rate &gt;= 1/2 is included&quot; +</span>
      &quot; in stopping criterion.&quot;;
  }

  /**
   * Sets whether to check for error rate is in stopping criterion
   * 
   * @param d whether to check for error rate is in stopping criterion
   */
  public void setCheckErrorRate(boolean d) { 
<span class="nc" id="L610">    m_CheckErr = d;</span>
<span class="nc" id="L611">  }</span>
  
  /**
   * Gets whether to check for error rate is in stopping criterion
   * 
   * @return true if checking for error rate is in stopping criterion
   */
  public boolean getCheckErrorRate(){ 
<span class="nc" id="L619">    return m_CheckErr; </span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String usePruningTipText() {
<span class="nc" id="L628">    return &quot;Whether pruning is performed.&quot;;</span>
  }

  /**
   * Sets whether pruning is performed
   * 
   * @param d Whether pruning is performed
   */
  public void setUsePruning(boolean d) { 
<span class="nc" id="L637">    m_UsePruning = d;</span>
<span class="nc" id="L638">  }</span>
  
  /**
   * Gets whether pruning is performed
   * 
   * @return true if pruning is performed
   */
  public boolean getUsePruning(){ 
<span class="nc" id="L646">    return m_UsePruning; </span>
  }
    
  /** 
   * Get the ruleset generated by Ripper 
   *
   * @return the ruleset
   */
<span class="nc" id="L654">  public FastVector getRuleset(){ return m_Ruleset; }</span>

  /** 
   * Get the statistics of the ruleset in the given position
   *
   * @param pos the position of the stats, assuming correct
   * @return the statistics of the ruleset in the given position
   */
  public RuleStats getRuleStats(int pos) {
<span class="nc" id="L663">    return (RuleStats)m_RulesetStats.elementAt(pos);</span>
  }
    
  /** 
   * The single antecedent in the rule, which is composed of an attribute and 
   * the corresponding value.  There are two inherited classes, namely NumericAntd
   * and NominalAntd in which the attributes are numeric and nominal respectively.
   */    
  public abstract class Antd 
    implements WeightedInstancesHandler, Copyable, Serializable, RevisionHandler {

    /** for serialization */
    private static final long serialVersionUID = -8929754772994154334L;
	
    /** The attribute of the antecedent */
    protected Attribute att;
	
    /** The attribute value of the antecedent.  
       For numeric attribute, value is either 0(1st bag) or 1(2nd bag) */
    protected double value; 
	
    /** The maximum infoGain achieved by this antecedent test 
     * in the growing data */
    protected double maxInfoGain;
	
    /** The accurate rate of this antecedent test on the growing data */
    protected double accuRate;
	
    /** The coverage of this antecedent in the growing data */
    protected double cover;
	
    /** The accurate data for this antecedent in the growing data */
    protected double accu;
	
    /** 
     * Constructor
     */
<span class="fc" id="L700">    public Antd(Attribute a){</span>
<span class="fc" id="L701">      att=a;</span>
<span class="fc" id="L702">      value=Double.NaN; </span>
<span class="fc" id="L703">      maxInfoGain = 0;</span>
<span class="fc" id="L704">      accuRate = Double.NaN;</span>
<span class="fc" id="L705">      cover = Double.NaN;</span>
<span class="fc" id="L706">      accu = Double.NaN;</span>
<span class="fc" id="L707">    }</span>
	
    /* The abstract members for inheritance */
    public abstract Instances[] splitData(Instances data, double defAcRt, 
					  double cla);
    public abstract boolean covers(Instance inst);
    public abstract String toString();
	
    /** 
     * Implements Copyable
     * 
     * @return a copy of this object
     */
    public abstract Object copy(); 
	   
    /* Get functions of this antecedent */
<span class="fc" id="L723">    public Attribute getAttr(){ return att; }</span>
<span class="fc" id="L724">    public double getAttrValue(){ return value; }</span>
<span class="fc" id="L725">    public double getMaxInfoGain(){ return maxInfoGain; }</span>
<span class="fc" id="L726">    public double getAccuRate(){ return accuRate; } </span>
<span class="fc" id="L727">    public double getAccu(){ return accu; } </span>
<span class="nc" id="L728">    public double getCover(){ return cover; } </span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L736">      return RevisionUtils.extract(&quot;$Revision: 8119 $&quot;);</span>
    }
  }
    
  /** 
   * The antecedent with numeric attribute
   */
  public class 
    NumericAntd extends Antd {
    
    /** for serialization */
    static final long serialVersionUID = 5699457269983735442L;
	
    /** The split point for this numeric antecedent */
    private double splitPoint;
    
    /** 
     * Constructor
     */
    public NumericAntd(Attribute a){ 
<span class="fc" id="L756">      super(a);</span>
<span class="fc" id="L757">      splitPoint = Double.NaN;</span>
<span class="fc" id="L758">    }    </span>
	
    /** 
     * Get split point of this numeric antecedent
     * 
     * @return the split point of this numeric antecedent
     */
    public double getSplitPoint(){ 
<span class="nc" id="L766">      return splitPoint;</span>
    }
	
    /** 
     * Implements Copyable
     * 
     * @return a copy of this object
     */
    public Object copy(){ 
<span class="fc" id="L775">      NumericAntd na = new NumericAntd(getAttr());</span>
<span class="fc" id="L776">      na.value = this.value;</span>
<span class="fc" id="L777">      na.splitPoint = this.splitPoint;</span>
<span class="fc" id="L778">      return na;</span>
    }
	
    /**
     * Implements the splitData function.  
     * This procedure is to split the data into two bags according 
     * to the information gain of the numeric attribute value
     * The maximum infoGain is also calculated.  
     * 
     * @param insts the data to be split
     * @param defAcRt the default accuracy rate for data
     * @param cl the class label to be predicted
     * @return the array of data after split
     */
    public Instances[] splitData(Instances insts, double defAcRt, 
				 double cl){
<span class="fc" id="L794">	Instances data = insts;</span>
<span class="fc" id="L795">      int total=data.numInstances();// Total number of instances without </span>
      // missing value for att
	    
<span class="fc" id="L798">      int split=1;                  // Current split position</span>
<span class="fc" id="L799">      int prev=0;                   // Previous split position</span>
<span class="fc" id="L800">      int finalSplit=split;         // Final split position</span>
<span class="fc" id="L801">      maxInfoGain = 0;</span>
<span class="fc" id="L802">      value = 0;	</span>
	    
<span class="fc" id="L804">      double fstCover=0, sndCover=0, fstAccu=0, sndAccu=0;</span>
	    
<span class="fc" id="L806">      data.sort(att);</span>
      // Find the las instance without missing value 
<span class="fc bfc" id="L808" title="All 2 branches covered.">      for(int x=0; x&lt;data.numInstances(); x++){</span>
<span class="fc" id="L809">	Instance inst = data.instance(x);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">	if(inst.isMissing(att)){</span>
<span class="fc" id="L811">	  total = x;</span>
<span class="fc" id="L812">	  break;</span>
	}
		
<span class="fc" id="L815">	sndCover += inst.weight();</span>
<span class="fc bfc" id="L816" title="All 2 branches covered.">	if(Utils.eq(inst.classValue(), cl))</span>
<span class="fc" id="L817">	  sndAccu += inst.weight();		</span>
      }	    

<span class="fc bfc" id="L820" title="All 2 branches covered.">      if(total == 0) return null; // Data all missing for the attribute</span>
<span class="fc" id="L821">      splitPoint = data.instance(total-1).value(att);	</span>
	    
<span class="fc bfc" id="L823" title="All 2 branches covered.">      for(; split &lt;= total; split++){</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">	if((split == total) ||</span>
<span class="fc" id="L825">	   (data.instance(split).value(att) &gt; // Can't split within</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">	    data.instance(prev).value(att))){ // same value	    </span>
		    
<span class="fc bfc" id="L828" title="All 2 branches covered.">	  for(int y=prev; y&lt;split; y++){</span>
<span class="fc" id="L829">	    Instance inst = data.instance(y);</span>
<span class="fc" id="L830">	    fstCover += inst.weight(); </span>
<span class="fc bfc" id="L831" title="All 2 branches covered.">	    if(Utils.eq(data.instance(y).classValue(), cl)){</span>
<span class="fc" id="L832">	      fstAccu += inst.weight();  // First bag positive# ++</span>
	    }	     		   
	  }
		    
<span class="fc" id="L836">	  double fstAccuRate = (fstAccu+1.0)/(fstCover+1.0),</span>
<span class="fc" id="L837">	    sndAccuRate = (sndAccu+1.0)/(sndCover+1.0);</span>
		    
	  /* Which bag has higher information gain? */
	  boolean isFirst; 
	  double fstInfoGain, sndInfoGain;
	  double accRate, infoGain, coverage, accurate;
		    
<span class="fc" id="L844">	  fstInfoGain = </span>
	    //Utils.eq(defAcRt, 1.0) ? 
	    //fstAccu/(double)numConds : 
<span class="fc" id="L847">	    fstAccu*(Utils.log2(fstAccuRate)-Utils.log2(defAcRt));</span>
		    
<span class="fc" id="L849">	  sndInfoGain = </span>
	    //Utils.eq(defAcRt, 1.0) ? 
	    //sndAccu/(double)numConds : 
<span class="fc" id="L852">	    sndAccu*(Utils.log2(sndAccuRate)-Utils.log2(defAcRt));</span>
		    
<span class="fc bfc" id="L854" title="All 2 branches covered.">	  if(fstInfoGain &gt; sndInfoGain){</span>
<span class="fc" id="L855">	    isFirst = true;</span>
<span class="fc" id="L856">	    infoGain = fstInfoGain;</span>
<span class="fc" id="L857">	    accRate = fstAccuRate;</span>
<span class="fc" id="L858">	    accurate = fstAccu;</span>
<span class="fc" id="L859">	    coverage = fstCover;</span>
	  }
	  else{
<span class="fc" id="L862">	    isFirst = false;</span>
<span class="fc" id="L863">	    infoGain = sndInfoGain;</span>
<span class="fc" id="L864">	    accRate = sndAccuRate;</span>
<span class="fc" id="L865">	    accurate = sndAccu;</span>
<span class="fc" id="L866">	    coverage = sndCover;</span>
	  }
		    
	  /* Check whether so far the max infoGain */
<span class="fc bfc" id="L870" title="All 2 branches covered.">	  if(infoGain &gt; maxInfoGain){</span>
<span class="fc" id="L871">	    splitPoint = data.instance(prev).value(att);</span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">	    value = (isFirst) ? 0 : 1;</span>
<span class="fc" id="L873">	    accuRate = accRate;</span>
<span class="fc" id="L874">	    accu = accurate;</span>
<span class="fc" id="L875">	    cover = coverage;</span>
<span class="fc" id="L876">	    maxInfoGain = infoGain;</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">	    finalSplit = (isFirst) ? split : prev;</span>
	  }
		    
<span class="fc bfc" id="L880" title="All 2 branches covered.">	  for(int y=prev; y&lt;split; y++){</span>
<span class="fc" id="L881">	    Instance inst = data.instance(y);</span>
<span class="fc" id="L882">	    sndCover -= inst.weight(); </span>
<span class="fc bfc" id="L883" title="All 2 branches covered.">	    if(Utils.eq(data.instance(y).classValue(), cl)){</span>
<span class="fc" id="L884">	      sndAccu -= inst.weight();  // Second bag positive# --</span>
	    }	     		   
	  }		    
<span class="fc" id="L887">	  prev=split;</span>
	}
      }
	    
      /* Split the data */
<span class="fc" id="L892">      Instances[] splitData = new Instances[2];</span>
<span class="fc" id="L893">      splitData[0] = new Instances(data, 0, finalSplit);</span>
<span class="fc" id="L894">      splitData[1] = new Instances(data, finalSplit, total-finalSplit);</span>
	    
<span class="fc" id="L896">      return splitData;</span>
    }
	
    /**
     * Whether the instance is covered by this antecedent
     * 
     * @param inst the instance in question
     * @return the boolean value indicating whether the instance is covered
     *         by this antecedent
     */
    public boolean covers(Instance inst){
<span class="fc" id="L907">      boolean isCover=true;</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">      if(!inst.isMissing(att)){</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">	if((int)value == 0){ // First bag</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">	  if(inst.value(att) &gt; splitPoint)</span>
<span class="fc" id="L911">	    isCover=false;</span>
	}
<span class="fc bfc" id="L913" title="All 2 branches covered.">	else if(inst.value(att) &lt; splitPoint) // Second bag</span>
<span class="fc" id="L914">	  isCover=false;</span>
      }
      else
<span class="nc" id="L917">	isCover = false;</span>
	    
<span class="fc" id="L919">      return isCover;</span>
    }
	
    /**
     * Prints this antecedent
     *
     * @return a textual description of this antecedent
     */
    public String toString() {
<span class="nc bnc" id="L928" title="All 2 branches missed.">      String symbol = ((int)value == 0) ? &quot; &lt;= &quot; : &quot; &gt;= &quot;;</span>
<span class="nc" id="L929">      return (att.name() + symbol + Utils.doubleToString(splitPoint, 6));</span>
    }   
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L938">      return RevisionUtils.extract(&quot;$Revision: 8119 $&quot;);</span>
    }
  }
    
    
  /** 
   * The antecedent with nominal attribute
   */
  public class NominalAntd 
    extends Antd {
	
    /** for serialization */
    static final long serialVersionUID = -9102297038837585135L;
    
    /* The parameters of infoGain calculated for each attribute value
     * in the growing data */
    private double[] accurate;
    private double[] coverage;
	
    /** 
     * Constructor
     */
    public NominalAntd(Attribute a){ 
<span class="fc" id="L961">      super(a);    </span>
<span class="fc" id="L962">      int bag = att.numValues();</span>
<span class="fc" id="L963">      accurate = new double[bag];</span>
<span class="fc" id="L964">      coverage = new double[bag];</span>
<span class="fc" id="L965">    }   </span>

    /** 
     * Implements Copyable
     * 
     * @return a copy of this object
     */
    public Object copy(){
<span class="fc" id="L973">      Antd antec = new NominalAntd(getAttr());</span>
<span class="fc" id="L974">      antec.value = this.value;</span>
<span class="fc" id="L975">      return antec;	    </span>
    }
	
    /**
     * Implements the splitData function.  
     * This procedure is to split the data into bags according 
     * to the nominal attribute value
     * The infoGain for each bag is also calculated.  
     * 
     * @param data the data to be split
     * @param defAcRt the default accuracy rate for data
     * @param cl the class label to be predicted
     * @return the array of data after split
     */
    public Instances[] splitData(Instances data, double defAcRt, 
				 double cl){
<span class="fc" id="L991">      int bag = att.numValues();</span>
<span class="fc" id="L992">      Instances[] splitData = new Instances[bag];</span>
	    
<span class="fc bfc" id="L994" title="All 2 branches covered.">      for(int x=0; x&lt;bag; x++){</span>
<span class="fc" id="L995">	splitData[x] = new Instances(data, data.numInstances());</span>
<span class="fc" id="L996">	accurate[x] = 0;</span>
<span class="fc" id="L997">	coverage[x] = 0;</span>
      }
	    
<span class="fc bfc" id="L1000" title="All 2 branches covered.">      for(int x=0; x&lt;data.numInstances(); x++){</span>
<span class="fc" id="L1001">	Instance inst=data.instance(x);</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">	if(!inst.isMissing(att)){</span>
<span class="fc" id="L1003">	  int v = (int)inst.value(att);</span>
<span class="fc" id="L1004">	  splitData[v].add(inst);</span>
<span class="fc" id="L1005">	  coverage[v] += inst.weight();</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">	  if((int)inst.classValue() == (int)cl)</span>
<span class="fc" id="L1007">	    accurate[v] += inst.weight();</span>
	}
      }
	    
<span class="fc bfc" id="L1011" title="All 2 branches covered.">      for(int x=0; x&lt;bag; x++){</span>
<span class="fc" id="L1012">	double t = coverage[x]+1.0;</span>
<span class="fc" id="L1013">	double p = accurate[x] + 1.0;		</span>
<span class="fc" id="L1014">	double infoGain = </span>
	  //Utils.eq(defAcRt, 1.0) ? 
	  //accurate[x]/(double)numConds : 
<span class="fc" id="L1017">	  accurate[x]*(Utils.log2(p/t)-Utils.log2(defAcRt));</span>
		
<span class="fc bfc" id="L1019" title="All 2 branches covered.">	if(infoGain &gt; maxInfoGain){</span>
<span class="fc" id="L1020">	  maxInfoGain = infoGain;</span>
<span class="fc" id="L1021">	  cover = coverage[x];</span>
<span class="fc" id="L1022">	  accu = accurate[x];</span>
<span class="fc" id="L1023">	  accuRate = p/t;</span>
<span class="fc" id="L1024">	  value = (double)x;</span>
	}
      }
	    
<span class="fc" id="L1028">      return splitData;</span>
    }
	
    /**
     * Whether the instance is covered by this antecedent
     * 
     * @param inst the instance in question
     * @return the boolean value indicating whether the instance is
     *         covered by this antecedent
     */
    public boolean covers(Instance inst){
<span class="fc" id="L1039">      boolean isCover=false;</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">      if(!inst.isMissing(att)){</span>
<span class="fc bfc" id="L1041" title="All 2 branches covered.">	if((int)inst.value(att) == (int)value)</span>
<span class="fc" id="L1042">	  isCover=true;	    </span>
      }
<span class="fc" id="L1044">      return isCover;</span>
    }
	
    /**
     * Prints this antecedent
     *
     * @return a textual description of this antecedent
     */
    public String toString() {
<span class="nc" id="L1053">      return (att.name() + &quot; = &quot; +att.value((int)value));</span>
    } 
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1062">      return RevisionUtils.extract(&quot;$Revision: 8119 $&quot;);</span>
    }
  }

    
  /**
   * This class implements a single rule that predicts specified class.  
   *
   * A rule consists of antecedents &quot;AND&quot;ed together and the consequent 
   * (class value) for the classification.  
   * In this class, the Information Gain (p*[log(p/t) - log(P/T)]) is used to
   * select an antecedent and Reduced Error Prunning (REP) with the metric
   * of accuracy rate p/(p+n) or (TP+TN)/(P+N) is used to prune the rule. 
   */    
  public class RipperRule 
    extends Rule {
    
    /** for serialization */
    static final long serialVersionUID = -2410020717305262952L;
	
    /** The internal representation of the class label to be predicted */
<span class="fc" id="L1083">    private double m_Consequent = -1;	</span>
		
    /** The vector of antecedents of this rule*/
<span class="fc" id="L1086">    protected FastVector m_Antds = null;	</span>
	
    /** Constructor */
<span class="fc" id="L1089">    public RipperRule(){    </span>
<span class="fc" id="L1090">      m_Antds = new FastVector();	</span>
<span class="fc" id="L1091">    }</span>
	
    /**
     * Sets the internal representation of the class label to be predicted
     * 
     * @param cl the internal representation of the class label to be predicted
     */
    public void setConsequent(double cl) {
<span class="fc" id="L1099">      m_Consequent = cl; </span>
<span class="fc" id="L1100">    }</span>
    
    /**
     * Gets the internal representation of the class label to be predicted
     * 
     * @return the internal representation of the class label to be predicted
     */
    public double getConsequent() { 
<span class="fc" id="L1108">      return m_Consequent; </span>
    }
	
    /**
     * Get a shallow copy of this rule
     *
     * @return the copy
     */
    public Object copy(){
<span class="fc" id="L1117">      RipperRule copy = new RipperRule();</span>
<span class="fc" id="L1118">      copy.setConsequent(getConsequent());</span>
<span class="fc" id="L1119">      copy.m_Antds = (FastVector)this.m_Antds.copyElements();</span>
<span class="fc" id="L1120">      return copy;</span>
    }
	
    /**
     * Whether the instance covered by this rule
     * 
     * @param datum the instance in question
     * @return the boolean value indicating whether the instance 
     *         is covered by this rule
     */
    public boolean covers(Instance datum){
<span class="fc" id="L1131">      boolean isCover=true;</span>
	    
<span class="fc bfc" id="L1133" title="All 2 branches covered.">      for(int i=0; i&lt;m_Antds.size(); i++){</span>
<span class="fc" id="L1134">	Antd antd = (Antd)m_Antds.elementAt(i);</span>
<span class="fc bfc" id="L1135" title="All 2 branches covered.">	if(!antd.covers(datum)){</span>
<span class="fc" id="L1136">	  isCover = false;</span>
<span class="fc" id="L1137">	  break;</span>
	}
      }
	    
<span class="fc" id="L1141">      return isCover;</span>
    }        
	
    /**
     * Whether this rule has antecedents, i.e. whether it is a default rule
     * 
     * @return the boolean value indicating whether the rule has antecedents
     */
    public boolean hasAntds(){
<span class="nc bnc" id="L1150" title="All 2 branches missed.">      if (m_Antds == null)</span>
<span class="nc" id="L1151">	return false;</span>
      else
<span class="nc bnc" id="L1153" title="All 2 branches missed.">	return (m_Antds.size() &gt; 0);</span>
    }      
    
    /**
     * Return the antecedents
     * 
     * @return the vector of antecedents
     */
    public FastVector getAntds() {
<span class="nc" id="L1162">      return m_Antds;</span>
    }
	
    /** 
     * the number of antecedents of the rule
     *
     * @return the size of this rule
     */
<span class="fc" id="L1170">    public double size(){ return (double)m_Antds.size(); }		</span>

	
    /**
     * Private function to compute default number of accurate instances
     * in the specified data for the consequent of the rule
     * 
     * @param data the data in question
     * @return the default accuracy number
     */
    private double computeDefAccu(Instances data){ 
<span class="fc" id="L1181">      double defAccu=0;</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">      for(int i=0; i&lt;data.numInstances(); i++){</span>
<span class="fc" id="L1183">	Instance inst = data.instance(i);</span>
<span class="fc bfc" id="L1184" title="All 2 branches covered.">	if((int)inst.classValue() == (int)m_Consequent)</span>
<span class="fc" id="L1185">	  defAccu += inst.weight();</span>
      }
<span class="fc" id="L1187">      return defAccu;</span>
    }
	
	
    /**
     * Build one rule using the growing data
     *
     * @param data the growing data used to build the rule
     * @throws Exception if the consequent is not set yet
     */    
      public void grow(Instances data) throws Exception {
<span class="pc bpc" id="L1198" title="1 of 2 branches missed.">      if(m_Consequent == -1)</span>
<span class="nc" id="L1199">	throw new Exception(&quot; Consequent not set yet.&quot;);</span>
	    
<span class="fc" id="L1201">      Instances growData = data;	         </span>
<span class="fc" id="L1202">      double sumOfWeights = growData.sumOfWeights();</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">      if(!Utils.gr(sumOfWeights, 0.0))</span>
<span class="nc" id="L1204">	return;</span>
	    
      /* Compute the default accurate rate of the growing data */
<span class="fc" id="L1207">      double defAccu = computeDefAccu(growData);</span>
<span class="fc" id="L1208">      double defAcRt = (defAccu+1.0)/(sumOfWeights+1.0); </span>
	    
      /* Keep the record of which attributes have already been used*/    
<span class="fc" id="L1211">      boolean[] used=new boolean [growData.numAttributes()];</span>
<span class="fc bfc" id="L1212" title="All 2 branches covered.">      for (int k=0; k&lt;used.length; k++)</span>
<span class="fc" id="L1213">	used[k]=false;</span>
<span class="fc" id="L1214">      int numUnused=used.length;</span>
	    
      // If there are already antecedents existing
<span class="fc bfc" id="L1217" title="All 2 branches covered.">      for(int j=0; j &lt; m_Antds.size(); j++){</span>
<span class="fc" id="L1218">	Antd antdj = (Antd)m_Antds.elementAt(j);</span>
<span class="fc bfc" id="L1219" title="All 2 branches covered.">	if(!antdj.getAttr().isNumeric()){ </span>
<span class="fc" id="L1220">	  used[antdj.getAttr().index()]=true;</span>
<span class="fc" id="L1221">	  numUnused--;</span>
	} 
      }	    
	    
      double maxInfoGain;	    
<span class="pc bpc" id="L1226" title="1 of 4 branches missed.">      while (Utils.gr(growData.numInstances(), 0.0) &amp;&amp; </span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">	     (numUnused &gt; 0) </span>
<span class="fc" id="L1228">	     &amp;&amp; Utils.sm(defAcRt, 1.0)</span>
	     ){   
		
	// We require that infoGain be positive
	/*if(numAntds == originalSize)
	  maxInfoGain = 0.0; // At least one condition allowed
	  else
	  maxInfoGain = Utils.eq(defAcRt, 1.0) ? 
	  defAccu/(double)numAntds : 0.0; */
<span class="fc" id="L1237">	maxInfoGain = 0.0; </span>
		
	/* Build a list of antecedents */
<span class="fc" id="L1240">	Antd oneAntd=null;</span>
<span class="fc" id="L1241">	Instances coverData = null;</span>
<span class="fc" id="L1242">	Enumeration enumAttr=growData.enumerateAttributes();	      </span>
		
	/* Build one condition based on all attributes not used yet*/
<span class="fc bfc" id="L1245" title="All 2 branches covered.">	while (enumAttr.hasMoreElements()){</span>
<span class="fc" id="L1246">	  Attribute att= (Attribute)(enumAttr.nextElement());</span>
	  
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">	  if(m_Debug)</span>
<span class="nc" id="L1249">	    System.err.println(&quot;\nOne condition: size = &quot; </span>
<span class="nc" id="L1250">			       + growData.sumOfWeights());</span>
		   
<span class="fc" id="L1252">	  Antd antd =null;	</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">	  if(att.isNumeric())</span>
<span class="fc" id="L1254">	    antd = new NumericAntd(att);</span>
	  else
<span class="fc" id="L1256">	    antd = new NominalAntd(att);</span>
		    
<span class="fc bfc" id="L1258" title="All 2 branches covered.">	  if(!used[att.index()]){</span>
	    /* Compute the best information gain for each attribute,
	       it's stored in the antecedent formed by this attribute.
	       This procedure returns the data covered by the antecedent*/
<span class="fc" id="L1262">	    Instances coveredData = computeInfoGain(growData, defAcRt,</span>
<span class="fc" id="L1263">						    antd);</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">	    if(coveredData != null){</span>
<span class="fc" id="L1265">	      double infoGain = antd.getMaxInfoGain();      </span>
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">	      if(m_Debug)</span>
<span class="nc" id="L1267">		System.err.println(&quot;Test of \'&quot;+antd.toString()+</span>
<span class="nc" id="L1268">				   &quot;\': infoGain = &quot;+</span>
<span class="nc" id="L1269">				   infoGain + &quot; | Accuracy = &quot; +</span>
<span class="nc" id="L1270">				   antd.getAccuRate()+</span>
<span class="nc" id="L1271">				   &quot;=&quot;+antd.getAccu()</span>
<span class="nc" id="L1272">				   +&quot;/&quot;+antd.getCover()+</span>
<span class="nc" id="L1273">				   &quot; def. accuracy: &quot;+defAcRt);</span>
			    
<span class="fc bfc" id="L1275" title="All 2 branches covered.">	      if(infoGain &gt; maxInfoGain){         </span>
<span class="fc" id="L1276">		oneAntd=antd;</span>
<span class="fc" id="L1277">		coverData = coveredData;  </span>
<span class="fc" id="L1278">		maxInfoGain = infoGain;</span>
	      }		    
	    }
	  }
	}
		
<span class="fc bfc" id="L1284" title="All 2 branches covered.">	if(oneAntd == null) break; // Cannot find antds		</span>
<span class="fc bfc" id="L1285" title="All 2 branches covered.">	if(Utils.sm(oneAntd.getAccu(), m_MinNo)) break;// Too low coverage</span>
		
	//Numeric attributes can be used more than once
<span class="fc bfc" id="L1288" title="All 2 branches covered.">	if(!oneAntd.getAttr().isNumeric()){ </span>
<span class="fc" id="L1289">	  used[oneAntd.getAttr().index()]=true;</span>
<span class="fc" id="L1290">	  numUnused--;</span>
	}
		
<span class="fc" id="L1293">	m_Antds.addElement(oneAntd);</span>
<span class="fc" id="L1294">	growData = coverData;// Grow data size is shrinking 	</span>
<span class="fc" id="L1295">	defAcRt = oneAntd.getAccuRate();</span>
      }
<span class="fc" id="L1297">    }</span>
	
	
    /** 
     * Compute the best information gain for the specified antecedent
     *  
     * @param instances the data based on which the infoGain is computed
     * @param defAcRt the default accuracy rate of data
     * @param antd the specific antecedent
     * @param numConds the number of antecedents in the rule so far
     * @return the data covered by the antecedent
     */
    private Instances computeInfoGain(Instances instances, double defAcRt, 
				      Antd antd){
<span class="fc" id="L1311">	Instances data = instances;</span>
	
      /* Split the data into bags.
	 The information gain of each bag is also calculated in this procedure */
<span class="fc" id="L1315">      Instances[] splitData = antd.splitData(data, defAcRt, </span>
<span class="fc" id="L1316">					     m_Consequent); </span>
	    
      /* Get the bag of data to be used for next antecedents */
<span class="fc bfc" id="L1319" title="All 2 branches covered.">      if(splitData != null)</span>
<span class="fc" id="L1320">	return splitData[(int)antd.getAttrValue()];</span>
<span class="fc" id="L1321">      else return null;</span>
    }
	
    /**
     * Prune all the possible final sequences of the rule using the 
     * pruning data.  The measure used to prune the rule is based on
     * flag given.
     *
     * @param pruneData the pruning data used to prune the rule
     * @param useWhole flag to indicate whether use the error rate of
     *                 the whole pruning data instead of the data covered
     */    
    public void prune(Instances pruneData, boolean useWhole){
<span class="fc" id="L1334">	Instances data = pruneData;</span>
	
<span class="fc" id="L1336">      double total = data.sumOfWeights();</span>
<span class="pc bpc" id="L1337" title="1 of 2 branches missed.">      if(!Utils.gr(total, 0.0))</span>
<span class="nc" id="L1338">	return;</span>
	
      /* The default accurate # and rate on pruning data */
<span class="fc" id="L1341">      double defAccu=computeDefAccu(data);</span>
	    
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">      if(m_Debug)	</span>
<span class="nc" id="L1344">	System.err.println(&quot;Pruning with &quot; + defAccu + </span>
<span class="nc" id="L1345">			   &quot; positive data out of &quot; + total +</span>
<span class="nc" id="L1346">			   &quot; instances&quot;);	</span>
	    
<span class="fc" id="L1348">      int size=m_Antds.size();</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">      if(size == 0) return; // Default rule before pruning</span>
	    
<span class="fc" id="L1351">      double[] worthRt = new double[size];</span>
<span class="fc" id="L1352">      double[] coverage = new double[size];</span>
<span class="fc" id="L1353">      double[] worthValue = new double[size];</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">      for(int w=0; w&lt;size; w++){</span>
<span class="fc" id="L1355">	worthRt[w]=coverage[w]=worthValue[w]=0.0;</span>
      }
	    
      /* Calculate accuracy parameters for all the antecedents in this rule */
<span class="fc" id="L1359">      double tn = 0.0; // True negative if useWhole</span>
<span class="fc bfc" id="L1360" title="All 2 branches covered.">      for(int x=0; x&lt;size; x++){</span>
<span class="fc" id="L1361">	Antd antd=(Antd)m_Antds.elementAt(x);</span>
<span class="fc" id="L1362">	Instances newData = data;</span>
<span class="fc" id="L1363">	data = new Instances(newData, 0); // Make data empty</span>
		
<span class="fc bfc" id="L1365" title="All 2 branches covered.">	for(int y=0; y&lt;newData.numInstances(); y++){</span>
<span class="fc" id="L1366">	  Instance ins=newData.instance(y);</span>
		    
<span class="fc bfc" id="L1368" title="All 2 branches covered.">	  if(antd.covers(ins)){   // Covered by this antecedent</span>
<span class="fc" id="L1369">	    coverage[x] += ins.weight();</span>
<span class="fc" id="L1370">	    data.add(ins);                 // Add to data for further pruning</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">	    if((int)ins.classValue() == (int)m_Consequent) // Accurate prediction</span>
<span class="fc" id="L1372">	      worthValue[x] += ins.weight();</span>
	  }
<span class="fc bfc" id="L1374" title="All 2 branches covered.">	  else if(useWhole){ // Not covered</span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">	    if((int)ins.classValue() != (int)m_Consequent)</span>
<span class="fc" id="L1376">	      tn += ins.weight();</span>
	  }			
	}
		
<span class="fc bfc" id="L1380" title="All 2 branches covered.">	if(useWhole){</span>
<span class="fc" id="L1381">	  worthValue[x] += tn;</span>
<span class="fc" id="L1382">	  worthRt[x] = worthValue[x] / total;</span>
	}
	else // Note if coverage is 0, accuracy is 0.5
<span class="fc" id="L1385">	  worthRt[x] = (worthValue[x]+1.0)/(coverage[x]+2.0);</span>
      }
	    
<span class="fc" id="L1388">      double maxValue = (defAccu+1.0)/(total+2.0);</span>
<span class="fc" id="L1389">      int maxIndex = -1;</span>
<span class="fc bfc" id="L1390" title="All 2 branches covered.">      for(int i=0; i&lt;worthValue.length; i++){</span>
<span class="pc bpc" id="L1391" title="1 of 2 branches missed.">	if(m_Debug){</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">	  double denom = useWhole ? total : coverage[i];</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">	  System.err.println(i+&quot;(useAccuray? &quot;+!useWhole+&quot;): &quot;</span>
<span class="nc" id="L1394">			     + worthRt[i] + </span>
<span class="nc" id="L1395">			     &quot;=&quot;+worthValue[i]+</span>
<span class="nc" id="L1396">			     &quot;/&quot;+denom);</span>
	}
<span class="fc bfc" id="L1398" title="All 2 branches covered.">	if(worthRt[i] &gt; maxValue){ // Prefer to the </span>
<span class="fc" id="L1399">	  maxValue = worthRt[i]; // shorter rule</span>
<span class="fc" id="L1400">	  maxIndex = i;</span>
	}
      }
	    
      /* Prune the antecedents according to the accuracy parameters */
<span class="fc bfc" id="L1405" title="All 2 branches covered.">      for(int z=size-1;z&gt;maxIndex;z--)</span>
<span class="fc" id="L1406">	m_Antds.removeElementAt(z);       </span>
<span class="fc" id="L1407">    }</span>
	
    /**
     * Prints this rule
     *
     * @param classAttr the class attribute in the data
     * @return a textual description of this rule
     */
    public String toString(Attribute classAttr) {
<span class="nc" id="L1416">      StringBuffer text =  new StringBuffer();</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">      if(m_Antds.size() &gt; 0){</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">	for(int j=0; j&lt; (m_Antds.size()-1); j++)</span>
<span class="nc" id="L1419">	  text.append(&quot;(&quot; + ((Antd)(m_Antds.elementAt(j))).toString()+ &quot;) and &quot;);</span>
<span class="nc" id="L1420">	text.append(&quot;(&quot;+((Antd)(m_Antds.lastElement())).toString() + &quot;)&quot;);</span>
      }
<span class="nc" id="L1422">      text.append(&quot; =&gt; &quot; + classAttr.name() +</span>
<span class="nc" id="L1423">		  &quot;=&quot; + classAttr.value((int)m_Consequent));</span>
	    
<span class="nc" id="L1425">      return text.toString();</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1434">      return RevisionUtils.extract(&quot;$Revision: 8119 $&quot;);</span>
    }
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1444">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1445">    result.disableAll();</span>

    // attributes
<span class="fc" id="L1448">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L1449">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L1450">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L1451">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L1454">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L1455">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
   
    // instances
<span class="fc" id="L1458">    result.setMinimumNumberInstances(m_Folds);</span>
    
<span class="fc" id="L1460">    return result;</span>
  }
    
  /**
   * Builds Ripper in the order of class frequencies.  For each class
   * it's built in two stages: building and optimization 
   *
   * @param instances the training data
   * @throws Exception if classifier can't be built successfully
   */
  public void buildClassifier(Instances instances) throws Exception {
    
    // can classifier handle the data?
<span class="fc" id="L1473">    getCapabilities().testWithFail(instances);</span>

    // remove instances with missing class
<span class="fc" id="L1476">    instances = new Instances(instances);</span>
<span class="fc" id="L1477">    instances.deleteWithMissingClass();</span>
    
<span class="fc" id="L1479">    m_Random = instances.getRandomNumberGenerator(m_Seed); </span>
<span class="fc" id="L1480">    m_Total = RuleStats.numAllConditions(instances);</span>
<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">    if(m_Debug)</span>
<span class="nc" id="L1482">      System.err.println(&quot;Number of all possible conditions = &quot;+m_Total);</span>
    
<span class="fc" id="L1484">    Instances data = null;</span>
<span class="fc" id="L1485">    m_Filter = new ClassOrder();</span>
<span class="fc" id="L1486">    ((ClassOrder)m_Filter).setSeed(m_Random.nextInt());	</span>
<span class="fc" id="L1487">    ((ClassOrder)m_Filter).setClassOrder(ClassOrder.FREQ_ASCEND);</span>
<span class="fc" id="L1488">    m_Filter.setInputFormat(instances);</span>
<span class="fc" id="L1489">    data = Filter.useFilter(instances, m_Filter);</span>
	
<span class="pc bpc" id="L1491" title="1 of 2 branches missed.">    if(data == null)</span>
<span class="nc" id="L1492">      throw new Exception(&quot; Unable to randomize the class orders.&quot;);</span>
    
<span class="fc" id="L1494">    m_Class = data.classAttribute();	</span>
<span class="fc" id="L1495">    m_Ruleset = new FastVector();</span>
<span class="fc" id="L1496">    m_RulesetStats = new FastVector();</span>
<span class="fc" id="L1497">    m_Distributions = new FastVector();</span>

    // Sort by classes frequency
<span class="fc" id="L1500">    double[] orderedClasses = ((ClassOrder)m_Filter).getClassCounts();</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">    if(m_Debug){</span>
<span class="nc" id="L1502">      System.err.println(&quot;Sorted classes:&quot;);</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">      for(int x=0; x &lt; m_Class.numValues(); x++)</span>
<span class="nc" id="L1504">	System.err.println(x+&quot;: &quot;+m_Class.value(x) + &quot; has &quot; +</span>
<span class="nc" id="L1505">			   orderedClasses[x] + &quot; instances.&quot;);</span>
    }
    // Iterate from less prevalent class to more frequent one
  oneClass:	
<span class="fc bfc" id="L1509" title="All 2 branches covered.">    for(int y=0; y &lt; data.numClasses()-1; y++){ // For each class	      </span>
	    
<span class="fc" id="L1511">      double classIndex = (double)y;</span>
<span class="pc bpc" id="L1512" title="1 of 2 branches missed.">      if(m_Debug){</span>
<span class="nc" id="L1513">	int ci = (int)classIndex;</span>
<span class="nc" id="L1514">	System.err.println(&quot;\n\nClass &quot;+m_Class.value(ci)+&quot;(&quot;+ci+&quot;): &quot;</span>
<span class="nc" id="L1515">			   + orderedClasses[y] + &quot;instances\n&quot;+</span>
<span class="nc" id="L1516">			   &quot;=====================================\n&quot;);</span>
      }
		
<span class="pc bpc" id="L1519" title="1 of 2 branches missed.">      if(Utils.eq(orderedClasses[y],0.0)) // No data for this class</span>
<span class="nc" id="L1520">	continue oneClass;		</span>
	    
      // The expected FP/err is the proportion of the class
<span class="fc" id="L1523">      double all = 0;</span>
<span class="fc bfc" id="L1524" title="All 2 branches covered.">      for(int i=y; i&lt;orderedClasses.length; i++)</span>
<span class="fc" id="L1525">	all += orderedClasses[i];</span>
<span class="fc" id="L1526">      double expFPRate = orderedClasses[y] / all;	    </span>
		
<span class="fc" id="L1528">      double classYWeights = 0, totalWeights = 0;</span>
<span class="fc bfc" id="L1529" title="All 2 branches covered.">      for(int j=0; j &lt; data.numInstances(); j++){</span>
<span class="fc" id="L1530">	  Instance datum = data.instance(j);</span>
<span class="fc" id="L1531">	  totalWeights += datum.weight();</span>
<span class="fc bfc" id="L1532" title="All 2 branches covered.">	  if((int)datum.classValue() == y){</span>
<span class="fc" id="L1533">	      classYWeights += datum.weight();</span>
	  }	          
      }	
          
      // DL of default rule, no theory DL, only data DL
      double defDL;
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">      if(classYWeights &gt; 0)</span>
<span class="fc" id="L1540">	  defDL = RuleStats.dataDL(expFPRate, </span>
<span class="fc" id="L1541">				   0.0,</span>
<span class="fc" id="L1542">				   totalWeights,</span>
<span class="fc" id="L1543">				   0.0,</span>
<span class="fc" id="L1544">				   classYWeights);	    </span>
      else
	  continue oneClass; // Subsumed by previous rules

<span class="pc bpc" id="L1548" title="2 of 4 branches missed.">      if(Double.isNaN(defDL) || Double.isInfinite(defDL))</span>
<span class="nc" id="L1549">	throw new Exception(&quot;Should never happen: &quot;+</span>
			    &quot;defDL NaN or infinite!&quot;);
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L1552">	System.err.println(&quot;The default DL = &quot;+defDL);</span>
	    
<span class="fc" id="L1554">      data = rulesetForOneClass(expFPRate, data, classIndex, defDL);</span>
    }

    // Set the default rule
<span class="fc" id="L1558">    RipperRule defRule = new RipperRule();</span>
<span class="fc" id="L1559">    defRule.setConsequent((double)(data.numClasses()-1));</span>
<span class="fc" id="L1560">    m_Ruleset.addElement(defRule);</span>
	
<span class="fc" id="L1562">    RuleStats defRuleStat = new RuleStats();</span>
<span class="fc" id="L1563">    defRuleStat.setData(data);</span>
<span class="fc" id="L1564">    defRuleStat.setNumAllConds(m_Total);</span>
<span class="fc" id="L1565">    defRuleStat.addAndUpdate(defRule);</span>
<span class="fc" id="L1566">    m_RulesetStats.addElement(defRuleStat);</span>

<span class="fc bfc" id="L1568" title="All 2 branches covered.">    for(int z=0; z &lt; m_RulesetStats.size(); z++){</span>
<span class="fc" id="L1569">	RuleStats oneClass = (RuleStats)m_RulesetStats.elementAt(z);</span>
<span class="fc bfc" id="L1570" title="All 2 branches covered.">	for(int xyz=0; xyz &lt; oneClass.getRulesetSize(); xyz++){</span>
<span class="fc" id="L1571">	    double[] classDist = oneClass.getDistributions(xyz);</span>
<span class="fc" id="L1572">	    Utils.normalize(classDist);</span>
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">	    if(classDist != null)</span>
<span class="fc" id="L1574">		m_Distributions.addElement(((ClassOrder)m_Filter).distributionsByOriginalIndex(classDist));</span>
	}	
    }    

    // free up memory
<span class="fc bfc" id="L1579" title="All 2 branches covered.">    for (int i = 0; i &lt; m_RulesetStats.size(); i++)</span>
<span class="fc" id="L1580">      ((RuleStats) m_RulesetStats.elementAt(i)).cleanUp();</span>
<span class="fc" id="L1581">  }</span>
    
  /**
   * Classify the test instance with the rule learner and provide
   * the class distributions 
   *
   * @param datum the instance to be classified
   * @return the distribution
   */
    public double[] distributionForInstance(Instance datum){
	try{
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">	    for(int i=0; i &lt; m_Ruleset.size(); i++){</span>
<span class="fc" id="L1593">		RipperRule rule = (RipperRule)m_Ruleset.elementAt(i);</span>
<span class="fc bfc" id="L1594" title="All 2 branches covered.">		if(rule.covers(datum))</span>
<span class="fc" id="L1595">		    return (double[])m_Distributions.elementAt(i); </span>
	    }
<span class="nc" id="L1597">	}catch(Exception e){</span>
<span class="nc" id="L1598">	    System.err.println(e.getMessage());</span>
<span class="nc" id="L1599">	    e.printStackTrace();</span>
	}
	
<span class="nc" id="L1602">	System.err.println(&quot;Should never happen!&quot;);</span>
<span class="nc" id="L1603">	return new double[datum.classAttribute().numValues()];</span>
    }

  /** Build a ruleset for the given class according to the given data
   *
   * @param expFPRate the expected FP/(FP+FN) used in DL calculation
   * @param data the given data
   * @param classIndex the given class index
   * @param defDL the default DL in the data
   * @throws Exception if the ruleset can be built properly
   */
  protected Instances rulesetForOneClass(double expFPRate, 
					 Instances data, 
					 double classIndex,
					 double defDL)
    throws Exception {
	
<span class="fc" id="L1620">    Instances newData = data, growData, pruneData;  	</span>
<span class="fc" id="L1621">    boolean stop = false;</span>
<span class="fc" id="L1622">    FastVector ruleset = new FastVector();		</span>
	
<span class="fc" id="L1624">    double dl = defDL, minDL = defDL;</span>
<span class="fc" id="L1625">    RuleStats rstats = null;</span>
    double[] rst;
	
    // Check whether data have positive examples
<span class="fc" id="L1629">    boolean defHasPositive = true; // No longer used</span>
<span class="fc" id="L1630">    boolean hasPositive = defHasPositive;</span>
	
    /********************** Building stage ***********************/	
<span class="pc bpc" id="L1633" title="1 of 2 branches missed.">    if(m_Debug)</span>
<span class="nc" id="L1634">      System.err.println(&quot;\n*** Building stage ***&quot;);</span>
    
<span class="pc bfc" id="L1636" title="All 4 branches covered.">    while((!stop) &amp;&amp; hasPositive){ // Generate new rules until</span>
      // stopping criteria met
      RipperRule oneRule;
<span class="pc bpc" id="L1639" title="1 of 2 branches missed.">      if(m_UsePruning){		</span>
	/* Split data into Grow and Prune*/

	// We should have stratified the data, but ripper seems
	// to have a bug that makes it not to do so.  In order
	// to simulate it more precisely, we do the same thing.
	//newData.randomize(m_Random);	
<span class="fc" id="L1646">	newData = RuleStats.stratify(newData, m_Folds, m_Random);		</span>
<span class="fc" id="L1647">	Instances[] part = RuleStats.partition(newData, m_Folds);</span>
<span class="fc" id="L1648">	growData=part[0];</span>
<span class="fc" id="L1649">	pruneData=part[1];</span>
	//growData=newData.trainCV(m_Folds, m_Folds-1);
	//pruneData=newData.testCV(m_Folds, m_Folds-1);	
		
<span class="fc" id="L1653">	oneRule = new RipperRule();</span>
<span class="fc" id="L1654">	oneRule.setConsequent(classIndex);  // Must set first</span>
		
<span class="pc bpc" id="L1656" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1657">	  System.err.println(&quot;\nGrowing a rule ...&quot;);  </span>
<span class="fc" id="L1658">	oneRule.grow(growData);             // Build the rule</span>
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1660">	  System.err.println(&quot;One rule found before pruning:&quot;+</span>
<span class="nc" id="L1661">			     oneRule.toString(m_Class));</span>
		
<span class="pc bpc" id="L1663" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1664">	  System.err.println(&quot;\nPruning the rule ...&quot;);  </span>
<span class="fc" id="L1665">	oneRule.prune(pruneData, false);    // Prune the rule</span>
<span class="pc bpc" id="L1666" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1667">	  System.err.println(&quot;One rule found after pruning:&quot;+</span>
<span class="nc" id="L1668">			     oneRule.toString(m_Class));</span>
      }
      else{
<span class="nc" id="L1671">	oneRule = new RipperRule();</span>
<span class="nc" id="L1672">	oneRule.setConsequent(classIndex);  // Must set first</span>
<span class="nc bnc" id="L1673" title="All 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1674">	  System.err.println(&quot;\nNo pruning: growing a rule ...&quot;);</span>
<span class="nc" id="L1675">	oneRule.grow(newData);             // Build the rule</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1677">	  System.err.println(&quot;No pruning: one rule found:\n&quot;+</span>
<span class="nc" id="L1678">			     oneRule.toString(m_Class));</span>
      }
	    
      // Compute the DL of this ruleset
<span class="fc bfc" id="L1682" title="All 2 branches covered.">      if(rstats == null){ // First rule</span>
<span class="fc" id="L1683">	rstats = new RuleStats();</span>
<span class="fc" id="L1684">	rstats.setNumAllConds(m_Total);</span>
<span class="fc" id="L1685">	rstats.setData(newData);</span>
      }
	    
<span class="fc" id="L1688">      rstats.addAndUpdate(oneRule);		    </span>
<span class="fc" id="L1689">      int last = rstats.getRuleset().size()-1; // Index of last rule</span>
<span class="fc" id="L1690">      dl += rstats.relativeDL(last, expFPRate, m_CheckErr);</span>
	    
<span class="pc bpc" id="L1692" title="2 of 4 branches missed.">      if(Double.isNaN(dl) || Double.isInfinite(dl))</span>
<span class="nc" id="L1693">	throw new Exception(&quot;Should never happen: dl in &quot;+</span>
			    &quot;building stage NaN or infinite!&quot;);
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L1696">	System.err.println(&quot;Before optimization(&quot;+last+</span>
<span class="nc" id="L1697">			   &quot;): the dl = &quot;+dl+&quot; | best: &quot;+minDL);</span>
	    
<span class="fc bfc" id="L1699" title="All 2 branches covered.">      if(dl &lt; minDL)</span>
<span class="fc" id="L1700">	minDL = dl;  // The best dl so far	</span>
	    
<span class="fc" id="L1702">      rst = rstats.getSimpleStats(last);	    </span>
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L1704">	System.err.println(&quot;The rule covers: &quot;+rst[0]+</span>
<span class="nc" id="L1705">			   &quot; | pos = &quot; + rst[2] + </span>
<span class="nc" id="L1706">			   &quot; | neg = &quot; + rst[4]+</span>
<span class="nc" id="L1707">			   &quot;\nThe rule doesn't cover: &quot;+rst[1]+</span>
<span class="nc" id="L1708">			   &quot; | pos = &quot; + rst[5]);</span>
	    
<span class="fc" id="L1710">      stop = checkStop(rst, minDL, dl);</span>
	    
<span class="fc bfc" id="L1712" title="All 2 branches covered.">      if(!stop){	  		</span>
<span class="fc" id="L1713">	ruleset.addElement(oneRule);          // Accepted </span>
<span class="fc" id="L1714">	newData = rstats.getFiltered(last)[1];// Data not covered</span>
<span class="fc" id="L1715">	hasPositive = Utils.gr(rst[5], 0.0);  // Positives remaining?</span>
<span class="pc bpc" id="L1716" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1717">	  System.err.println(&quot;One rule added: has positive? &quot;</span>
<span class="nc" id="L1718">			     +hasPositive);</span>
      }
      else{
<span class="pc bpc" id="L1721" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1722">	  System.err.println(&quot;Quit rule&quot;);</span>
<span class="fc" id="L1723">	rstats.removeLast(); // Remove last to be re-used</span>
      }
    }// while !stop	
	
    /******************** Optimization stage *******************/
<span class="fc" id="L1728">    RuleStats finalRulesetStat = null;</span>
<span class="pc bpc" id="L1729" title="1 of 2 branches missed.">    if(m_UsePruning){	 </span>
<span class="fc bfc" id="L1730" title="All 2 branches covered.">      for(int z=0; z &lt; m_Optimizations; z++){</span>
<span class="pc bpc" id="L1731" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1732">	  System.err.println(&quot;\n*** Optimization: run #&quot;</span>
<span class="nc" id="L1733">			     +z+&quot; ***&quot;);</span>
		
<span class="fc" id="L1735">	newData = data;		    </span>
<span class="fc" id="L1736">	finalRulesetStat = new RuleStats();</span>
<span class="fc" id="L1737">	finalRulesetStat.setData(newData);</span>
<span class="fc" id="L1738">	finalRulesetStat.setNumAllConds(m_Total);</span>
<span class="fc" id="L1739">	int position=0;</span>
<span class="fc" id="L1740">	stop = false;</span>
<span class="fc" id="L1741">	boolean isResidual = false;	    </span>
<span class="fc" id="L1742">	hasPositive = defHasPositive;		    </span>
<span class="fc" id="L1743">	dl = minDL = defDL;</span>
		
      oneRule:    
<span class="fc bfc" id="L1746" title="All 4 branches covered.">	while(!stop &amp;&amp; hasPositive){			</span>
		    
<span class="fc bfc" id="L1748" title="All 2 branches covered.">	  isResidual = (position&gt;=ruleset.size()); // Cover residual positive examples  </span>
	  // Re-do shuffling and stratification    
	  //newData.randomize(m_Random);	
<span class="fc" id="L1751">	  newData = RuleStats.stratify(newData, m_Folds, m_Random);</span>
<span class="fc" id="L1752">	  Instances[] part = RuleStats.partition(newData, m_Folds);</span>
<span class="fc" id="L1753">	  growData=part[0];</span>
<span class="fc" id="L1754">	  pruneData=part[1];</span>
	  //growData=newData.trainCV(m_Folds, m_Folds-1);
	  //pruneData=newData.testCV(m_Folds, m_Folds-1);	   
	  RipperRule finalRule;
		    
<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">	  if(m_Debug)</span>
<span class="nc" id="L1760">	    System.err.println(&quot;\nRule #&quot;+position +</span>
<span class="nc" id="L1761">			       &quot;| isResidual?&quot; + isResidual+</span>
<span class="nc" id="L1762">			       &quot;| data size: &quot;+newData.sumOfWeights());</span>
		    
<span class="fc bfc" id="L1764" title="All 2 branches covered.">	  if(isResidual){</span>
<span class="fc" id="L1765">	    RipperRule newRule = new RipperRule();   </span>
<span class="fc" id="L1766">	    newRule.setConsequent(classIndex);</span>
<span class="pc bpc" id="L1767" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1768">	      System.err.println(&quot;\nGrowing and pruning&quot;+</span>
				 &quot; a new rule ...&quot;); 
<span class="fc" id="L1770">	    newRule.grow(growData);</span>
<span class="fc" id="L1771">	    newRule.prune(pruneData, false);</span>
<span class="fc" id="L1772">	    finalRule = newRule;</span>
<span class="pc bpc" id="L1773" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1774">	      System.err.println(&quot;\nNew rule found: &quot;+</span>
<span class="nc" id="L1775">				 newRule.toString(m_Class));</span>
	  }
	  else{
<span class="fc" id="L1778">	    RipperRule oldRule = (RipperRule)ruleset.elementAt(position);</span>
<span class="fc" id="L1779">	    boolean covers = false;</span>
	    // Test coverage of the next old rule
<span class="pc bpc" id="L1781" title="1 of 2 branches missed.">	    for(int i=0; i&lt;newData.numInstances(); i++)</span>
<span class="fc bfc" id="L1782" title="All 2 branches covered.">	      if(oldRule.covers(newData.instance(i))){</span>
<span class="fc" id="L1783">		covers = true;</span>
<span class="fc" id="L1784">		break;</span>
	      }
			
<span class="pc bpc" id="L1787" title="1 of 2 branches missed.">	    if(!covers){// Null coverage, no variants can be generated</span>
<span class="nc" id="L1788">	      finalRulesetStat.addAndUpdate(oldRule);</span>
<span class="nc" id="L1789">	      position++;</span>
<span class="nc" id="L1790">	      continue oneRule;</span>
	    }  
			
	    // 2 variants 
<span class="pc bpc" id="L1794" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1795">	      System.err.println(&quot;\nGrowing and pruning&quot;+</span>
				 &quot; Replace ...&quot;); 
<span class="fc" id="L1797">	    RipperRule replace = new RipperRule();   </span>
<span class="fc" id="L1798">	    replace.setConsequent(classIndex);</span>
<span class="fc" id="L1799">	    replace.grow(growData);</span>
			
	    // Remove the pruning data covered by the following
	    // rules, then simply compute the error rate of the
	    // current rule to prune it.  According to Ripper,
	    // it's equivalent to computing the error of the 
	    // whole ruleset -- is it true?
<span class="fc" id="L1806">	    pruneData = RuleStats.rmCoveredBySuccessives(pruneData,ruleset, position);      	</span>
<span class="fc" id="L1807">	    replace.prune(pruneData, true);</span>
			
<span class="pc bpc" id="L1809" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1810">	      System.err.println(&quot;\nGrowing and pruning&quot;+</span>
				 &quot; Revision ...&quot;); 
<span class="fc" id="L1812">	    RipperRule revision = (RipperRule)oldRule.copy(); </span>
			
	    // For revision, first rm the data covered by the old rule
<span class="fc" id="L1815">	    Instances newGrowData = new Instances(growData, 0);</span>
<span class="fc bfc" id="L1816" title="All 2 branches covered.">	    for(int b=0; b&lt;growData.numInstances(); b++){</span>
<span class="fc" id="L1817">	      Instance inst = growData.instance(b);</span>
<span class="fc bfc" id="L1818" title="All 2 branches covered.">	      if(revision.covers(inst))</span>
<span class="fc" id="L1819">		newGrowData.add(inst);</span>
	    }
<span class="fc" id="L1821">	    revision.grow(newGrowData);	      </span>
<span class="fc" id="L1822">	    revision.prune(pruneData, true);</span>
			
<span class="fc" id="L1824">	    double[][] prevRuleStats = new double[position][6];</span>
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">	    for(int c=0; c &lt; position; c++)</span>
<span class="nc" id="L1826">		prevRuleStats[c] = finalRulesetStat.getSimpleStats(c);</span>

	    // Now compare the relative DL of variants
<span class="fc" id="L1829">	    FastVector tempRules = (FastVector)ruleset.copyElements();</span>
<span class="fc" id="L1830">	    tempRules.setElementAt(replace, position);</span>
			
<span class="fc" id="L1832">	    RuleStats repStat = new RuleStats(data, tempRules);</span>
<span class="fc" id="L1833">	    repStat.setNumAllConds(m_Total);</span>
<span class="fc" id="L1834">	    repStat.countData(position, newData, prevRuleStats);</span>
	    //repStat.countData();
<span class="fc" id="L1836">	    rst = repStat.getSimpleStats(position);	    </span>
<span class="pc bpc" id="L1837" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1838">	      System.err.println(&quot;Replace rule covers: &quot;+rst[0]+</span>
<span class="nc" id="L1839">				 &quot; | pos = &quot; + rst[2] + </span>
<span class="nc" id="L1840">				 &quot; | neg = &quot; + rst[4]+</span>
<span class="nc" id="L1841">				 &quot;\nThe rule doesn't cover: &quot;+rst[1]+</span>
<span class="nc" id="L1842">				 &quot; | pos = &quot; + rst[5]);</span>
			
<span class="fc" id="L1844">	    double repDL = repStat.relativeDL(position, expFPRate,</span>
<span class="fc" id="L1845">					      m_CheckErr);</span>
<span class="pc bpc" id="L1846" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1847">	      System.err.println(&quot;\nReplace: &quot;+</span>
<span class="nc" id="L1848">				 replace.toString(m_Class)</span>
<span class="nc" id="L1849">				 +&quot; |dl = &quot;+repDL); </span>
			
<span class="pc bpc" id="L1851" title="2 of 4 branches missed.">	    if(Double.isNaN(repDL) || Double.isInfinite(repDL))</span>
<span class="nc" id="L1852">	      throw new Exception(&quot;Should never happen: repDL&quot;+</span>
				  &quot;in optmz. stage NaN or &quot;+
				  &quot;infinite!&quot;);
			
<span class="fc" id="L1856">	    tempRules.setElementAt(revision, position);</span>
<span class="fc" id="L1857">	    RuleStats revStat = new RuleStats(data, tempRules);</span>
<span class="fc" id="L1858">	    revStat.setNumAllConds(m_Total);</span>
<span class="fc" id="L1859">	    revStat.countData(position, newData, prevRuleStats);</span>
	    //revStat.countData();
<span class="fc" id="L1861">	    double revDL = revStat.relativeDL(position, expFPRate,</span>
<span class="fc" id="L1862">					      m_CheckErr);</span>
			
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1865">	      System.err.println(&quot;Revision: &quot;</span>
<span class="nc" id="L1866">				 + revision.toString(m_Class)</span>
<span class="nc" id="L1867">				 +&quot; |dl = &quot;+revDL);</span>
			
<span class="pc bpc" id="L1869" title="2 of 4 branches missed.">	    if(Double.isNaN(revDL) || Double.isInfinite(revDL))</span>
<span class="nc" id="L1870">	      throw new Exception(&quot;Should never happen: revDL&quot;+</span>
				  &quot;in optmz. stage NaN or &quot;+
				  &quot;infinite!&quot;);
			
<span class="fc" id="L1874">	    rstats = new RuleStats(data, ruleset);</span>
<span class="fc" id="L1875">	    rstats.setNumAllConds(m_Total);</span>
<span class="fc" id="L1876">	    rstats.countData(position, newData, prevRuleStats);</span>
	    //rstats.countData();
<span class="fc" id="L1878">	    double oldDL = rstats.relativeDL(position, expFPRate,</span>
<span class="fc" id="L1879">					     m_CheckErr);</span>
			
<span class="pc bpc" id="L1881" title="2 of 4 branches missed.">	    if(Double.isNaN(oldDL) || Double.isInfinite(oldDL))</span>
<span class="nc" id="L1882">	      throw new Exception(&quot;Should never happen: oldDL&quot;+</span>
				  &quot;in optmz. stage NaN or &quot;+
				  &quot;infinite!&quot;);
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1886">	      System.err.println(&quot;Old rule: &quot;+</span>
<span class="nc" id="L1887">				 oldRule.toString(m_Class)</span>
<span class="nc" id="L1888">				 +&quot; |dl = &quot;+oldDL); </span>
			
<span class="pc bpc" id="L1890" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1891">	      System.err.println(&quot;\nrepDL: &quot;+repDL+ </span>
<span class="nc" id="L1892">				 &quot;\nrevDL: &quot;+revDL+</span>
<span class="nc" id="L1893">				 &quot;\noldDL: &quot;+oldDL);</span>
			
<span class="pc bpc" id="L1895" title="1 of 4 branches missed.">	    if((oldDL &lt;= revDL) &amp;&amp; (oldDL &lt;= repDL))</span>
<span class="fc" id="L1896">	      finalRule = oldRule; // Old the best</span>
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">	    else if(revDL &lt;= repDL)</span>
<span class="nc" id="L1898">	      finalRule = revision; // Revision the best</span>
	    else
<span class="fc" id="L1900">	      finalRule = replace; // Replace the best  </span>
	  }		
		    
<span class="fc" id="L1903">	  finalRulesetStat.addAndUpdate(finalRule);  	 </span>
<span class="fc" id="L1904">	  rst = finalRulesetStat.getSimpleStats(position);</span>
		    
<span class="fc bfc" id="L1906" title="All 2 branches covered.">	  if(isResidual){</span>
			
<span class="fc" id="L1908">	    dl += finalRulesetStat.relativeDL(position, </span>
<span class="fc" id="L1909">					      expFPRate,</span>
<span class="fc" id="L1910">					      m_CheckErr);</span>
<span class="pc bpc" id="L1911" title="1 of 2 branches missed.">	    if(m_Debug)</span>
<span class="nc" id="L1912">	      System.err.println(&quot;After optimization: the dl&quot;</span>
<span class="nc" id="L1913">				 +&quot;=&quot;+dl+&quot; | best: &quot;+minDL);</span>
			
<span class="fc bfc" id="L1915" title="All 2 branches covered.">	    if(dl &lt; minDL)</span>
<span class="fc" id="L1916">	      minDL = dl;  // The best dl so far</span>
			
<span class="fc" id="L1918">	    stop = checkStop(rst, minDL, dl);</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">	    if(!stop)</span>
<span class="fc" id="L1920">	      ruleset.addElement(finalRule); // Accepted </span>
	    else{
<span class="fc" id="L1922">	      finalRulesetStat.removeLast(); // Remove last to be re-used</span>
<span class="fc" id="L1923">	      position--;</span>
	    }
	  }
	  else
<span class="fc" id="L1927">	    ruleset.setElementAt(finalRule, position); // Accepted </span>

<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">	  if(m_Debug){</span>
<span class="nc" id="L1930">	    System.err.println(&quot;The rule covers: &quot;+rst[0]+</span>
<span class="nc" id="L1931">			       &quot; | pos = &quot; + rst[2] + </span>
<span class="nc" id="L1932">			       &quot; | neg = &quot; + rst[4]+</span>
<span class="nc" id="L1933">			       &quot;\nThe rule doesn't cover: &quot;+rst[1]+</span>
<span class="nc" id="L1934">			       &quot; | pos = &quot; + rst[5]);		</span>
<span class="nc" id="L1935">	    System.err.println(&quot;\nRuleset so far: &quot;);</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">	    for(int x=0; x&lt;ruleset.size(); x++)</span>
<span class="nc" id="L1937">	      System.err.println(x+&quot;: &quot;+((RipperRule)ruleset.elementAt(x)).toString(m_Class));</span>
<span class="nc" id="L1938">	    System.err.println();</span>
	  }
		    
	  //Data not covered	
<span class="fc bfc" id="L1942" title="All 2 branches covered.">	  if(finalRulesetStat.getRulesetSize() &gt; 0)// If any rules	</span>
<span class="fc" id="L1943">	    newData = finalRulesetStat.getFiltered(position)[1]; </span>
<span class="fc" id="L1944">	  hasPositive = Utils.gr(rst[5], 0.0); //Positives remaining? </span>
<span class="fc" id="L1945">	  position++;</span>
	} // while !stop &amp;&amp; hasPositive
		
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">	if(ruleset.size() &gt; (position+1)){ // Hasn't gone through yet</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">	  for(int k=position+1; k&lt;ruleset.size(); k++)</span>
<span class="nc" id="L1950">	    finalRulesetStat.addAndUpdate((Rule)ruleset.elementAt(k));</span>
	}
<span class="pc bpc" id="L1952" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L1953">	  System.err.println(&quot;\nDeleting rules to decrease&quot;+</span>
			     &quot; DL of the whole ruleset ...&quot;); 
<span class="fc" id="L1955">	finalRulesetStat.reduceDL(expFPRate, m_CheckErr);</span>
<span class="pc bpc" id="L1956" title="1 of 2 branches missed.">	if(m_Debug){</span>
<span class="nc" id="L1957">	  int del = ruleset.size() -</span>
<span class="nc" id="L1958">	    finalRulesetStat.getRulesetSize(); </span>
<span class="nc" id="L1959">	  System.err.println(del+&quot; rules are deleted&quot;+</span>
<span class="nc" id="L1960">			     &quot; after DL reduction procedure&quot;);</span>
	}
<span class="fc" id="L1962">	ruleset = finalRulesetStat.getRuleset();</span>
<span class="fc" id="L1963">	rstats = finalRulesetStat;	      	    </span>
		
      } // For each run of optimization
    } // if pruning is used
	
    // Concatenate the ruleset for this class to the whole ruleset
<span class="pc bpc" id="L1969" title="1 of 2 branches missed.">    if(m_Debug){</span>
<span class="nc" id="L1970">      System.err.println(&quot;\nFinal ruleset: &quot;);</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">      for(int x=0; x&lt;ruleset.size(); x++)</span>
<span class="nc" id="L1972">	System.err.println(x+&quot;: &quot;+((RipperRule)ruleset.elementAt(x)).toString(m_Class));</span>
<span class="nc" id="L1973">      System.err.println();</span>
    }
	
<span class="fc" id="L1976">    m_Ruleset.appendElements(ruleset);</span>
<span class="fc" id="L1977">    m_RulesetStats.addElement(rstats);</span>
	
<span class="fc bfc" id="L1979" title="All 2 branches covered.">    if(ruleset.size() &gt; 0)// If any rules for this class</span>
<span class="fc" id="L1980">      return rstats.getFiltered(ruleset.size()-1)[1]; // Data not </span>
    else                                                // covered
<span class="fc" id="L1982">      return data; </span>
  }   
    
  /**
   * Check whether the stopping criterion meets
   *
   * @param rst the statistic of the ruleset
   * @param minDL the min description length so far
   * @param dl the current description length of the ruleset
   * @return true if stop criterion meets, false otherwise
   */
  private boolean checkStop(double[] rst, double minDL, double dl){
	
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">    if(dl &gt; minDL+MAX_DL_SURPLUS){</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L1997">	System.err.println(&quot;DL too large: &quot;+dl+&quot; | &quot;+minDL);</span>
<span class="nc" id="L1998">      return true;</span>
    }
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">    else if(!Utils.gr(rst[2], 0.0)){// Covered positives</span>
<span class="nc bnc" id="L2001" title="All 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L2002">	System.err.println(&quot;Too few positives.&quot;);</span>
<span class="nc" id="L2003">      return true;</span>
    }	
<span class="fc bfc" id="L2005" title="All 2 branches covered.">    else if((rst[4]/rst[0]) &gt;= 0.5){// Err rate</span>
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">      if(m_CheckErr){</span>
<span class="pc bpc" id="L2007" title="1 of 2 branches missed.">	if(m_Debug)</span>
<span class="nc" id="L2008">	  System.err.println(&quot;Error too large: &quot;+</span>
<span class="nc" id="L2009">			     rst[4] + &quot;/&quot; + rst[0]);</span>
<span class="fc" id="L2010">	return  true;</span>
      }
      else
<span class="nc" id="L2013">	return false;</span>
    }		
    else{// Not stops
<span class="pc bpc" id="L2016" title="1 of 2 branches missed.">      if(m_Debug)</span>
<span class="nc" id="L2017">	System.err.println(&quot;Continue.&quot;);</span>
<span class="fc" id="L2018">      return  false;</span>
    }				
  }
 
  /**
   * Prints the all the rules of the rule learner.
   *
   * @return a textual description of the classifier
   */
  public String toString() {
<span class="pc bpc" id="L2028" title="1 of 2 branches missed.">    if (m_Ruleset == null) </span>
<span class="fc" id="L2029">      return &quot;JRIP: No model built yet.&quot;;</span>
	
<span class="nc" id="L2031">    StringBuffer sb = new StringBuffer(&quot;JRIP rules:\n&quot;+</span>
				       &quot;===========\n\n&quot;); 
<span class="nc bnc" id="L2033" title="All 2 branches missed.">    for(int j=0; j&lt;m_RulesetStats.size(); j++){</span>
<span class="nc" id="L2034">      RuleStats rs = (RuleStats)m_RulesetStats.elementAt(j);</span>
<span class="nc" id="L2035">      FastVector rules = rs.getRuleset();</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">      for(int k=0; k&lt;rules.size(); k++){</span>
<span class="nc" id="L2037">	double[] simStats = rs.getSimpleStats(k);</span>
<span class="nc" id="L2038">	sb.append(((RipperRule)rules.elementAt(k)).toString(m_Class)</span>
<span class="nc" id="L2039">		  + &quot; (&quot;+simStats[0]+&quot;/&quot;+simStats[4]+&quot;)\n&quot;);</span>
      }			    
    }
<span class="nc bnc" id="L2042" title="All 2 branches missed.">    if(m_Debug){</span>
<span class="nc" id="L2043">      System.err.println(&quot;Inside m_Ruleset&quot;);</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">      for(int i=0; i&lt;m_Ruleset.size(); i++)</span>
<span class="nc" id="L2045">	System.err.println(((RipperRule)m_Ruleset.elementAt(i)).toString(m_Class));</span>
    }
<span class="nc" id="L2047">    sb.append(&quot;\nNumber of Rules : &quot; </span>
<span class="nc" id="L2048">	      + m_Ruleset.size() + &quot;\n&quot;);</span>
<span class="nc" id="L2049">    return sb.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L2058">    return RevisionUtils.extract(&quot;$Revision: 8119 $&quot;);</span>
  }
    
  /**
   * Main method.
   *
   * @param args the options for the classifier
   */
  public static void main(String[] args) {	
<span class="nc" id="L2067">    runClassifier(new JRip(), args);</span>
<span class="nc" id="L2068">  } </span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>