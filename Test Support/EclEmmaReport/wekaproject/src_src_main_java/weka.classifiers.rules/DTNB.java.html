<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>DTNB.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">DTNB.java</span></div><h1>DTNB.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    DecisionTable.java
 *    Copyright (C) 2008 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.rules;

import weka.attributeSelection.ASEvaluation;
import weka.attributeSelection.ASSearch;
import weka.attributeSelection.SubsetEvaluator;
import weka.classifiers.bayes.NaiveBayes;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.TechnicalInformation;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.BitSet;
import java.util.Enumeration;
import java.util.Vector;

/**
 *
 &lt;!-- globalinfo-start --&gt;
 * Class for building and using a decision table/naive bayes hybrid classifier. At each point in the search, the algorithm evaluates the merit of dividing the attributes into two disjoint subsets: one for the decision table, the other for naive Bayes. A forward selection search is used, where at each step, selected attributes are modeled by naive Bayes and the remainder by the decision table, and all attributes are modelled by the decision table initially. At each step, the algorithm also considers dropping an attribute entirely from the model.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information, see: &lt;br/&gt;
 * &lt;br/&gt;
 * Mark Hall, Eibe Frank: Combining Naive Bayes and Decision Tables. In: Proceedings of the 21st Florida Artificial Intelligence Society Conference (FLAIRS), ???-???, 2008.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Hall2008,
 *    author = {Mark Hall and Eibe Frank},
 *    booktitle = {Proceedings of the 21st Florida Artificial Intelligence Society Conference (FLAIRS)},
 *    pages = {318-319},
 *    publisher = {AAAI press},
 *    title = {Combining Naive Bayes and Decision Tables},
 *    year = {2008}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
 *  Use cross validation to evaluate features.
 *  Use number of folds = 1 for leave one out CV.
 *  (Default = leave one out CV)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;acc | rmse | mae | auc&amp;gt;
 *  Performance evaluation measure to use for selecting attributes.
 *  (Default = accuracy for discrete class and rmse for numeric class)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Use nearest neighbour instead of global table majority.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Display decision table rules.
 * &lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Mark Hall (mhall{[at]}pentaho{[dot]}org)
 * @author Eibe Frank (eibe{[at]}cs{[dot]}waikato{[dot]}ac{[dot]}nz)
 *
 * @version $Revision: 6269 $
 *
 */
<span class="fc" id="L98">public class DTNB extends DecisionTable {</span>

  /**
   * The naive Bayes half of the hybrid
   */
  protected NaiveBayes m_NB;

  /**
   * The features used by naive Bayes
   */
  private int [] m_nbFeatures;

  /**
   * Percentage of the total number of features used by the decision table
   */
  private double m_percentUsedByDT;
  
  /**
   * Percentage of the features features that were dropped entirely
   */
  private double m_percentDeleted;

  static final long serialVersionUID = 2999557077765701326L;

  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L129">    return  </span>
<span class="nc" id="L130">      &quot;Class for building and using a decision table/naive bayes hybrid classifier. At each point &quot;</span>
      + &quot;in the search, the algorithm evaluates the merit of dividing the attributes into two disjoint &quot;
      + &quot;subsets: one for the decision table, the other for naive Bayes. A forward selection search is &quot;
      + &quot;used, where at each step, selected attributes are modeled by naive Bayes and the remainder &quot;
      + &quot;by the decision table, and all attributes are modelled by the decision table initially. At each &quot;
      + &quot;step, the algorithm also considers dropping an attribute entirely from the model.\n\n&quot;
      + &quot;For more information, see: \n\n&quot;
<span class="nc" id="L137">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;

<span class="nc" id="L150">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L151">    result.setValue(Field.AUTHOR, &quot;Mark Hall and Eibe Frank&quot;);</span>
<span class="nc" id="L152">    result.setValue(Field.TITLE, &quot;Combining Naive Bayes and Decision Tables&quot;);</span>
<span class="nc" id="L153">    result.setValue(Field.BOOKTITLE, &quot;Proceedings of the 21st Florida Artificial Intelligence &quot;</span>
                    + &quot;Society Conference (FLAIRS)&quot;);
<span class="nc" id="L155">    result.setValue(Field.YEAR, &quot;2008&quot;);</span>
<span class="nc" id="L156">    result.setValue(Field.PAGES, &quot;318-319&quot;);</span>
<span class="nc" id="L157">    result.setValue(Field.PUBLISHER, &quot;AAAI press&quot;);</span>

<span class="nc" id="L159">    return result;</span>
  }

  /**
   * Calculates the accuracy on a test fold for internal cross validation
   * of feature sets
   *
   * @param fold set of instances to be &quot;left out&quot; and classified
   * @param fs currently selected feature set
   * @return the accuracy for the fold
   * @throws Exception if something goes wrong
   */
  double evaluateFoldCV(Instances fold, int [] fs) throws Exception {

    int i;
<span class="nc" id="L174">    int ruleCount = 0;</span>
<span class="nc" id="L175">    int numFold = fold.numInstances();</span>
<span class="nc" id="L176">    int numCl = m_theInstances.classAttribute().numValues();</span>
<span class="nc" id="L177">    double [][] class_distribs = new double [numFold][numCl];</span>
<span class="nc" id="L178">    double [] instA = new double [fs.length];</span>
    double [] normDist;
    DecisionTableHashKey thekey;
<span class="nc" id="L181">    double acc = 0.0;</span>
<span class="nc" id="L182">    int classI = m_theInstances.classIndex();</span>
    Instance inst;

<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (m_classIsNominal) {</span>
<span class="nc" id="L186">      normDist = new double [numCl];</span>
    } else {
<span class="nc" id="L188">      normDist = new double [2];</span>
    }

    // first *remove* instances
<span class="nc bnc" id="L192" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L193">      inst = fold.instance(i);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">      for (int j=0;j&lt;fs.length;j++) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">	if (fs[j] == classI) {</span>
<span class="nc" id="L196">	  instA[j] = Double.MAX_VALUE; // missing for the class</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">	} else if (inst.isMissing(fs[j])) {</span>
<span class="nc" id="L198">	  instA[j] = Double.MAX_VALUE;</span>
	} else{
<span class="nc" id="L200">	  instA[j] = inst.value(fs[j]);</span>
	}
      }
<span class="nc" id="L203">      thekey = new DecisionTableHashKey(instA);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">      if ((class_distribs[i] = (double [])m_entries.get(thekey)) == null) {</span>
<span class="nc" id="L205">	throw new Error(&quot;This should never happen!&quot;);</span>
      } else {
<span class="nc bnc" id="L207" title="All 2 branches missed.">	if (m_classIsNominal) {</span>
<span class="nc" id="L208">	  class_distribs[i][(int)inst.classValue()] -= inst.weight();</span>
<span class="nc" id="L209">	  inst.setWeight(-inst.weight());</span>
<span class="nc" id="L210">	  m_NB.updateClassifier(inst);</span>
<span class="nc" id="L211">	  inst.setWeight(-inst.weight());</span>
	} else {
<span class="nc" id="L213">	  class_distribs[i][0] -= (inst.classValue() * inst.weight());</span>
<span class="nc" id="L214">	  class_distribs[i][1] -= inst.weight();</span>
	}
<span class="nc" id="L216">	ruleCount++;</span>
      }
<span class="nc" id="L218">      m_classPriorCounts[(int)inst.classValue()] -= </span>
<span class="nc" id="L219">	inst.weight();	</span>
    }
<span class="nc" id="L221">    double [] classPriors = m_classPriorCounts.clone();</span>
<span class="nc" id="L222">    Utils.normalize(classPriors);</span>

    // now classify instances
<span class="nc bnc" id="L225" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L226">      inst = fold.instance(i);</span>
<span class="nc" id="L227">      System.arraycopy(class_distribs[i],0,normDist,0,normDist.length);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      if (m_classIsNominal) {</span>
<span class="nc" id="L229">	boolean ok = false;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">	for (int j=0;j&lt;normDist.length;j++) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">	  if (Utils.gr(normDist[j],1.0)) {</span>
<span class="nc" id="L232">	    ok = true;</span>
<span class="nc" id="L233">	    break;</span>
	  }
	}

<span class="nc bnc" id="L237" title="All 2 branches missed.">	if (!ok) { // majority class</span>
<span class="nc" id="L238">	  normDist = classPriors.clone();</span>
	} else {
<span class="nc" id="L240">	  Utils.normalize(normDist);</span>
	}

<span class="nc" id="L243">	double [] nbDist = m_NB.distributionForInstance(inst);</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">	for (int l = 0; l &lt; normDist.length; l++) {</span>
<span class="nc" id="L246">	  normDist[l] = (Math.log(normDist[l]) - Math.log(classPriors[l]));</span>
<span class="nc" id="L247">	  normDist[l] += Math.log(nbDist[l]);</span>
	}
<span class="nc" id="L249">	normDist = Utils.logs2probs(normDist);</span>
	// Utils.normalize(normDist);

	//	System.out.println(normDist[0] + &quot; &quot; + normDist[1] + &quot; &quot; + inst.classValue());

<span class="nc bnc" id="L254" title="All 2 branches missed.">	if (m_evaluationMeasure == EVAL_AUC) {</span>
<span class="nc" id="L255">	  m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, inst);</span>
	} else {
<span class="nc" id="L257">	  m_evaluation.evaluateModelOnce(normDist, inst);</span>
	}
	/*	} else {					
	  normDist[(int)m_majority] = 1.0;
	  if (m_evaluationMeasure == EVAL_AUC) {
	    m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, inst);						
	  } else {
	    m_evaluation.evaluateModelOnce(normDist, inst);					
	  }
	} */
      } else {
<span class="nc bnc" id="L268" title="All 2 branches missed.">	if (Utils.eq(normDist[1],0.0)) {</span>
<span class="nc" id="L269">	  double [] temp = new double[1];</span>
<span class="nc" id="L270">	  temp[0] = m_majority;</span>
<span class="nc" id="L271">	  m_evaluation.evaluateModelOnce(temp, inst);</span>
	} else {
<span class="nc" id="L273">	  double [] temp = new double[1];</span>
<span class="nc" id="L274">	  temp[0] = normDist[0] / normDist[1];</span>
<span class="nc" id="L275">	  m_evaluation.evaluateModelOnce(temp, inst);</span>
	}
      }
    }

    // now re-insert instances
<span class="nc bnc" id="L281" title="All 2 branches missed.">    for (i=0;i&lt;numFold;i++) {</span>
<span class="nc" id="L282">      inst = fold.instance(i);</span>

<span class="nc" id="L284">      m_classPriorCounts[(int)inst.classValue()] += </span>
<span class="nc" id="L285">	inst.weight();</span>

<span class="nc bnc" id="L287" title="All 2 branches missed.">      if (m_classIsNominal) {</span>
<span class="nc" id="L288">	class_distribs[i][(int)inst.classValue()] += inst.weight();</span>
<span class="nc" id="L289">	m_NB.updateClassifier(inst);</span>
      } else {
<span class="nc" id="L291">	class_distribs[i][0] += (inst.classValue() * inst.weight());</span>
<span class="nc" id="L292">	class_distribs[i][1] += inst.weight();</span>
      }
    }
<span class="nc" id="L295">    return acc;</span>
  }

  /**
   * Classifies an instance for internal leave one out cross validation
   * of feature sets
   *
   * @param instance instance to be &quot;left out&quot; and classified
   * @param instA feature values of the selected features for the instance
   * @return the classification of the instance
   * @throws Exception if something goes wrong
   */
  double evaluateInstanceLeaveOneOut(Instance instance, double [] instA)
  throws Exception {

    DecisionTableHashKey thekey;
    double [] tempDist;
    double [] normDist;

<span class="fc" id="L314">    thekey = new DecisionTableHashKey(instA);</span>

    // if this one is not in the table
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">    if ((tempDist = (double [])m_entries.get(thekey)) == null) {</span>
<span class="nc" id="L318">      throw new Error(&quot;This should never happen!&quot;);</span>
    } else {
<span class="fc" id="L320">      normDist = new double [tempDist.length];</span>
<span class="fc" id="L321">      System.arraycopy(tempDist,0,normDist,0,tempDist.length);</span>
<span class="fc" id="L322">      normDist[(int)instance.classValue()] -= instance.weight();</span>

      // update the table
      // first check to see if the class counts are all zero now
<span class="fc" id="L326">      boolean ok = false;</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">      for (int i=0;i&lt;normDist.length;i++) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">	if (Utils.gr(normDist[i],1.0)) {</span>
<span class="fc" id="L329">	  ok = true;</span>
<span class="fc" id="L330">	  break;</span>
	}
      }

      // downdate the class prior counts
<span class="fc" id="L335">      m_classPriorCounts[(int)instance.classValue()] -= </span>
<span class="fc" id="L336">	instance.weight(); </span>
<span class="fc" id="L337">      double [] classPriors = m_classPriorCounts.clone();</span>
<span class="fc" id="L338">      Utils.normalize(classPriors);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">      if (!ok) { // majority class	</span>
<span class="fc" id="L340">	normDist = classPriors;</span>
      } else {
<span class="fc" id="L342">	Utils.normalize(normDist);</span>
      }

<span class="fc" id="L345">      m_classPriorCounts[(int)instance.classValue()] += </span>
<span class="fc" id="L346">      instance.weight();</span>

<span class="pc bpc" id="L348" title="1 of 2 branches missed.">      if (m_NB != null){</span>
	// downdate NaiveBayes

<span class="fc" id="L351">	instance.setWeight(-instance.weight());</span>
<span class="fc" id="L352">	m_NB.updateClassifier(instance);</span>
<span class="fc" id="L353">	double [] nbDist = m_NB.distributionForInstance(instance);</span>
<span class="fc" id="L354">	instance.setWeight(-instance.weight());</span>
<span class="fc" id="L355">	m_NB.updateClassifier(instance);</span>

<span class="fc bfc" id="L357" title="All 2 branches covered.">	for (int i = 0; i &lt; normDist.length; i++) {</span>
<span class="fc" id="L358">	  normDist[i] = (Math.log(normDist[i]) - Math.log(classPriors[i]));</span>
<span class="fc" id="L359">	  normDist[i] += Math.log(nbDist[i]);</span>
	}
<span class="fc" id="L361">	normDist = Utils.logs2probs(normDist);</span>
	// Utils.normalize(normDist);
      }

<span class="pc bpc" id="L365" title="1 of 2 branches missed.">      if (m_evaluationMeasure == EVAL_AUC) {</span>
<span class="nc" id="L366">	m_evaluation.evaluateModelOnceAndRecordPrediction(normDist, instance);						</span>
      } else {
<span class="fc" id="L368">	m_evaluation.evaluateModelOnce(normDist, instance);</span>
      }
<span class="fc" id="L370">      return Utils.maxIndex(normDist);</span>
    }
  }

  /**
   * Sets up a dummy subset evaluator that basically just delegates
   * evaluation to the estimatePerformance method in DecisionTable
   */
  protected void setUpEvaluator() throws Exception {
<span class="fc" id="L379">    m_evaluator = new EvalWithDelete();</span>
<span class="fc" id="L380">    m_evaluator.buildEvaluator(m_theInstances);</span>
<span class="fc" id="L381">  }</span>
  
<span class="fc" id="L383">  protected class EvalWithDelete extends ASEvaluation implements SubsetEvaluator {</span>
    
    // holds the list of attributes that are no longer in the model at all
    private BitSet m_deletedFromDTNB;
    
    public void buildEvaluator(Instances data) throws Exception {
<span class="fc" id="L389">      m_NB = null;</span>
<span class="fc" id="L390">      m_deletedFromDTNB = new BitSet(data.numAttributes());</span>
      // System.err.println(&quot;Here&quot;);
<span class="fc" id="L392">    }</span>
    
   private int setUpForEval(BitSet subset) throws Exception {
     
<span class="fc" id="L396">     int fc = 0;</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">     for (int jj = 0;jj &lt; m_numAttributes; jj++) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">	if (subset.get(jj)) {</span>
<span class="fc" id="L399">	  fc++;</span>
	}
     }

     //int [] nbFs = new int [fc];
     //int count = 0;

<span class="fc bfc" id="L406" title="All 2 branches covered.">     for (int j = 0; j &lt; m_numAttributes; j++) {</span>
<span class="fc" id="L407">	m_theInstances.attribute(j).setWeight(1.0); // reset weight</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">	if (j != m_theInstances.classIndex()) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">	  if (subset.get(j)) {</span>
	//    nbFs[count++] = j;
<span class="fc" id="L411">	    m_theInstances.attribute(j).setWeight(0.0); // no influence for NB</span>
	  }
	}
     }
     
     // process delete set
<span class="fc bfc" id="L417" title="All 2 branches covered.">     for (int i = 0; i &lt; m_numAttributes; i++) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">	if (m_deletedFromDTNB.get(i)) {</span>
<span class="fc" id="L419">	   m_theInstances.attribute(i).setWeight(0.0); // no influence for NB</span>
	}
     }
     
<span class="fc bfc" id="L423" title="All 2 branches covered.">     if (m_NB == null) {</span>
	// construct naive bayes for the first time
<span class="fc" id="L425">	m_NB = new NaiveBayes();</span>
<span class="fc" id="L426">	m_NB.buildClassifier(m_theInstances);</span>
     }
<span class="fc" id="L428">     return fc;</span>
   }

    public double evaluateSubset(BitSet subset) throws Exception {
<span class="fc" id="L432">      int fc = setUpForEval(subset);</span>
      
<span class="fc" id="L434">      return estimatePerformance(subset, fc);</span>
    }
    
    public double evaluateSubsetDelete(BitSet subset, int potentialDelete) throws Exception {
      
<span class="fc" id="L439">      int fc = setUpForEval(subset);</span>
      
      // clear potentail delete for naive Bayes
<span class="fc" id="L442">      m_theInstances.attribute(potentialDelete).setWeight(0.0);</span>
      //copy.clear(potentialDelete);
      //fc--;
<span class="fc" id="L445">      return estimatePerformance(subset, fc);</span>
    }
    
    public BitSet getDeletedList() {
<span class="fc" id="L449">      return m_deletedFromDTNB;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L458">      return RevisionUtils.extract(&quot;$Revision: 6269 $&quot;);</span>
    }
  }

  protected ASSearch m_backwardWithDelete;

  /**
   * Inner class implementing a special forwards search that looks for a good
   * split of attributes between naive Bayes and the decision table. It also
   * considers dropping attributes entirely from the model.
   */
<span class="fc" id="L469">  protected class BackwardsWithDelete extends ASSearch {</span>

    public String globalInfo() {
<span class="nc" id="L472">      return &quot;Specialized search that performs a forward selection (naive Bayes)/&quot;</span>
        + &quot;backward elimination (decision table). Also considers dropping attributes &quot;
        + &quot;entirely from the combined model.&quot;;
    }

    public String toString() {
<span class="nc" id="L478">      return &quot;&quot;;</span>
    }

    public int [] search(ASEvaluation eval, Instances data)
      	throws Exception {
	int i;
<span class="fc" id="L484">	double best_merit = -Double.MAX_VALUE;</span>
<span class="fc" id="L485">	double temp_best = 0, temp_merit = 0, temp_merit_delete = 0;</span>
<span class="fc" id="L486">	int temp_index=0;</span>
	BitSet temp_group;
<span class="fc" id="L488">	BitSet best_group = null;</span>

<span class="fc" id="L490">	int numAttribs = data.numAttributes();</span>

	if (best_group == null) {
<span class="fc" id="L493">	  best_group = new BitSet(numAttribs);</span>
	}

	
<span class="fc" id="L497">	int classIndex = data.classIndex();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">	for (i = 0; i &lt; numAttribs; i++) {</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">	  if (i != classIndex) {</span>
<span class="fc" id="L500">	    best_group.set(i);</span>
	  }
	}

	//System.err.println(best_group);
	
	// Evaluate the initial subset
        //	best_merit = m_evaluator.evaluateSubset(best_group);
<span class="fc" id="L508">        best_merit = ((SubsetEvaluator)eval).evaluateSubset(best_group);</span>

	//System.err.println(best_merit);

	// main search loop
<span class="fc" id="L513">	boolean done = false;</span>
<span class="fc" id="L514">	boolean addone = false;</span>
	boolean z;
<span class="fc" id="L516">	boolean deleted = false;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">	while (!done) {</span>
<span class="fc" id="L518">	  temp_group = (BitSet)best_group.clone();</span>
<span class="fc" id="L519">	  temp_best = best_merit;</span>
	  
<span class="fc" id="L521">	  done = true;</span>
<span class="fc" id="L522">	  addone = false;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">	  for (i = 0; i &lt; numAttribs;i++) {</span>
<span class="fc bfc" id="L524" title="All 4 branches covered.">	    z = ((i != classIndex) &amp;&amp; (temp_group.get(i)));</span>

<span class="fc bfc" id="L526" title="All 2 branches covered.">	    if (z) {</span>
	      // set/unset the bit
<span class="fc" id="L528">	      temp_group.clear(i);</span>

              //	      temp_merit = m_evaluator.evaluateSubset(temp_group);
<span class="fc" id="L531">	      temp_merit = ((SubsetEvaluator)eval).evaluateSubset(temp_group);</span>
              //	      temp_merit_delete = ((EvalWithDelete)m_evaluator).evaluateSubsetDelete(temp_group, i);
<span class="fc" id="L533">	      temp_merit_delete = ((EvalWithDelete)eval).evaluateSubsetDelete(temp_group, i);</span>
<span class="fc" id="L534">	      boolean deleteBetter = false;</span>
	      //System.out.println(&quot;Merit: &quot; + temp_merit + &quot;\t&quot; + &quot;Delete merit: &quot; + temp_merit_delete);
<span class="fc bfc" id="L536" title="All 2 branches covered.">	      if (temp_merit_delete &gt;= temp_merit) {</span>
<span class="fc" id="L537">		temp_merit = temp_merit_delete;</span>
<span class="fc" id="L538">		deleteBetter = true;</span>
	      }
	      
<span class="fc bfc" id="L541" title="All 2 branches covered.">	      z = (temp_merit &gt;= temp_best);</span>

<span class="fc bfc" id="L543" title="All 2 branches covered.">	      if (z) {</span>
<span class="fc" id="L544">		temp_best = temp_merit;</span>
<span class="fc" id="L545">		temp_index = i;</span>
<span class="fc" id="L546">		addone = true;</span>
<span class="fc" id="L547">		done = false;</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">		if (deleteBetter) {</span>
<span class="fc" id="L549">		  deleted = true;</span>
		} else {
<span class="fc" id="L551">		  deleted = false;</span>
		}
	      }

	      // unset this addition/deletion
<span class="fc" id="L556">		temp_group.set(i);</span>
	    }
	  }
<span class="fc bfc" id="L559" title="All 2 branches covered.">	  if (addone) {</span>
<span class="fc" id="L560">	    best_group.clear(temp_index);</span>
<span class="fc" id="L561">	    best_merit = temp_best;</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">	    if (deleted) {</span>
              //	      ((EvalWithDelete)m_evaluator).getDeletedList().set(temp_index);
<span class="fc" id="L564">	      ((EvalWithDelete)eval).getDeletedList().set(temp_index);</span>
	    }
	    //System.err.println(&quot;----------------------&quot;);
	    //System.err.println(&quot;Best subset: (dec table)&quot; + best_group);
	    //System.err.println(&quot;Best subset: (deleted)&quot; + ((EvalWithDelete)m_evaluator).getDeletedList());
	    //System.err.println(best_merit);
	  }
	}
<span class="fc" id="L572">	return attributeList(best_group);</span>
      }
      
      /**
       * converts a BitSet into a list of attribute indexes 
       * @param group the BitSet to convert
       * @return an array of attribute indexes
       **/
      protected int[] attributeList (BitSet group) {
<span class="fc" id="L581">	int count = 0;</span>
<span class="fc" id="L582">	BitSet copy = (BitSet)group.clone();</span>
	
	/* remove any that have been completely deleted from DTNB
	BitSet deleted = ((EvalWithDelete)m_evaluator).getDeletedList();
	for (int i = 0; i &lt; m_numAttributes; i++) {
	  if (deleted.get(i)) {
	    copy.clear(i);
	  }
	} */
	
	// count how many were selected
<span class="fc bfc" id="L593" title="All 2 branches covered.">	for (int i = 0; i &lt; m_numAttributes; i++) {</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">	  if (copy.get(i)) {</span>
<span class="nc" id="L595">	    count++;</span>
	  }
	}

<span class="fc" id="L599">	int[] list = new int[count];</span>
<span class="fc" id="L600">	count = 0;</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">	for (int i = 0; i &lt; m_numAttributes; i++) {</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">	  if (copy.get(i)) {</span>
<span class="nc" id="L604">	    list[count++] = i;</span>
	  }
	}

<span class="fc" id="L608">	return  list;</span>
      }
      
      /**
       * Returns the revision string.
       * 
       * @return		the revision
       */
      public String getRevision() {
<span class="nc" id="L617">        return RevisionUtils.extract(&quot;$Revision: 6269 $&quot;);</span>
      }
  }

  private void setUpSearch() {
<span class="fc" id="L622">    m_backwardWithDelete = new BackwardsWithDelete();</span>
<span class="fc" id="L623">  }</span>
  
  /**
   * Generates the classifier.
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the classifier has not been generated successfully
   */
  public void buildClassifier(Instances data) throws Exception {

<span class="fc" id="L633">    m_saveMemory = false;</span>

<span class="fc bfc" id="L635" title="All 2 branches covered.">    if (data.classAttribute().isNumeric()) {</span>
<span class="fc" id="L636">      throw new Exception(&quot;Can only handle nominal class!&quot;);</span>
    }

<span class="fc bfc" id="L639" title="All 2 branches covered.">    if (m_backwardWithDelete == null) {</span>
<span class="fc" id="L640">      setUpSearch();</span>
<span class="fc" id="L641">      m_search = m_backwardWithDelete;</span>
    }

    /*    if (m_search != m_backwardWithDelete) {
      m_search = m_backwardWithDelete;
      } */
<span class="fc" id="L647">    super.buildClassifier(data);</span>

    // new NB stuff

    // delete the features used by the decision table (not the class!!)
<span class="fc bfc" id="L652" title="All 2 branches covered.">    for (int i = 0; i &lt; m_theInstances.numAttributes(); i++) {</span>
<span class="fc" id="L653">      m_theInstances.attribute(i).setWeight(1.0); // reset all weights</span>
    }
    // m_nbFeatures = new int [m_decisionFeatures.length - 1];
<span class="fc" id="L656">     int count = 0;</span>

<span class="fc bfc" id="L658" title="All 2 branches covered.">    for (int i = 0; i &lt; m_decisionFeatures.length; i++) {</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">      if (m_decisionFeatures[i] != m_theInstances.classIndex()) {</span>
<span class="nc" id="L660">	count++;</span>
//	m_nbFeatures[count++] = m_decisionFeatures[i];
<span class="nc" id="L662">	m_theInstances.attribute(m_decisionFeatures[i]).setWeight(0.0); // No influence for NB</span>
      }
    }
    
<span class="fc" id="L666">    double numDeleted = 0;</span>
    // remove any attributes that have been deleted completely from the DTNB
<span class="fc" id="L668">    BitSet deleted = ((EvalWithDelete)m_evaluator).getDeletedList();</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">    for (int i = 0; i &lt; m_theInstances.numAttributes(); i++) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">      if (deleted.get(i)) {</span>
<span class="fc" id="L671">	m_theInstances.attribute(i).setWeight(0.0);</span>
	// count--;
<span class="fc" id="L673">	numDeleted++;</span>
	// System.err.println(&quot;Attribute &quot;+i+&quot; was eliminated completely&quot;);
      }
    }
    
<span class="fc" id="L678">    m_percentUsedByDT = (double)count / (m_theInstances.numAttributes() - 1);</span>
<span class="fc" id="L679">    m_percentDeleted = numDeleted / (m_theInstances.numAttributes() -1);</span>

<span class="fc" id="L681">    m_NB = new NaiveBayes();</span>
<span class="fc" id="L682">    m_NB.buildClassifier(m_theInstances);</span>

<span class="fc" id="L684">    m_dtInstances = new Instances(m_dtInstances, 0);</span>
<span class="fc" id="L685">    m_theInstances = new Instances(m_theInstances, 0);</span>
<span class="fc" id="L686">  }</span>

  /**
   * Calculates the class membership probabilities for the given 
   * test instance.
   *
   * @param instance the instance to be classified
   * @return predicted class probability distribution
   * @exception Exception if distribution can't be computed
   */
  public double [] distributionForInstance(Instance instance)
  throws Exception {

    DecisionTableHashKey thekey;
    double [] tempDist;
    double [] normDist;

<span class="fc" id="L703">    m_disTransform.input(instance);</span>
<span class="fc" id="L704">    m_disTransform.batchFinished();</span>
<span class="fc" id="L705">    instance = m_disTransform.output();</span>

<span class="fc" id="L707">    m_delTransform.input(instance);</span>
<span class="fc" id="L708">    m_delTransform.batchFinished();</span>
<span class="fc" id="L709">    Instance dtInstance = m_delTransform.output();</span>

<span class="fc" id="L711">    thekey = new DecisionTableHashKey(dtInstance, dtInstance.numAttributes(), false);</span>

    // if this one is not in the table
<span class="pc bpc" id="L714" title="1 of 2 branches missed.">    if ((tempDist = (double [])m_entries.get(thekey)) == null) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">      if (m_useIBk) {</span>
<span class="nc" id="L716">	tempDist = m_ibk.distributionForInstance(dtInstance);</span>
      } else {  
	// tempDist = new double [m_theInstances.classAttribute().numValues()];
//	tempDist[(int)m_majority] = 1.0;
	
<span class="nc" id="L721">	tempDist = m_classPriors.clone();</span>
	// return tempDist; ??????
      }
    } else {
      // normalise distribution
<span class="fc" id="L726">      normDist = new double [tempDist.length];</span>
<span class="fc" id="L727">      System.arraycopy(tempDist,0,normDist,0,tempDist.length);</span>
<span class="fc" id="L728">      Utils.normalize(normDist);</span>
<span class="fc" id="L729">      tempDist = normDist;			</span>
    }

<span class="fc" id="L732">    double [] nbDist = m_NB.distributionForInstance(instance);</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">    for (int i = 0; i &lt; nbDist.length; i++) {</span>
<span class="fc" id="L734">      tempDist[i] = (Math.log(tempDist[i]) - Math.log(m_classPriors[i]));</span>
<span class="fc" id="L735">      tempDist[i] += Math.log(nbDist[i]);</span>

      /*tempDist[i] *= nbDist[i];
      tempDist[i] /= m_classPriors[i];*/
    }
<span class="fc" id="L740">    tempDist = Utils.logs2probs(tempDist);</span>
<span class="fc" id="L741">    Utils.normalize(tempDist);</span>

<span class="fc" id="L743">    return tempDist;</span>
  }

  public String toString() {

<span class="fc" id="L748">    String sS = super.toString();</span>
<span class="pc bpc" id="L749" title="3 of 4 branches missed.">    if (m_displayRules &amp;&amp; m_NB != null) {</span>
<span class="nc" id="L750">      sS += m_NB.toString();			</span>
    }
<span class="fc" id="L752">    return sS;</span>
  }
  
  /**
   * Returns the number of rules
   * @return the number of rules
   */
  public double measurePercentAttsUsedByDT() {
<span class="nc" id="L760">    return m_percentUsedByDT;</span>
  }
  
  /**
   * Returns an enumeration of the additional measure names
   * @return an enumeration of the measure names
   */
  public Enumeration enumerateMeasures() {
<span class="nc" id="L768">    Vector newVector = new Vector(2);</span>
<span class="nc" id="L769">    newVector.addElement(&quot;measureNumRules&quot;);</span>
<span class="nc" id="L770">    newVector.addElement(&quot;measurePercentAttsUsedByDT&quot;);</span>
<span class="nc" id="L771">    return newVector.elements();</span>
  }

  /**
   * Returns the value of the named measure
   * @param additionalMeasureName the name of the measure to query for its value
   * @return the value of the named measure
   * @throws IllegalArgumentException if the named measure is not supported
   */
  public double getMeasure(String additionalMeasureName) {
<span class="nc bnc" id="L781" title="All 2 branches missed.">    if (additionalMeasureName.compareToIgnoreCase(&quot;measureNumRules&quot;) == 0) {</span>
<span class="nc" id="L782">      return measureNumRules();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">    } else if (additionalMeasureName.compareToIgnoreCase(&quot;measurePercentAttsUsedByDT&quot;) == 0) {</span>
<span class="nc" id="L784">      return measurePercentAttsUsedByDT();</span>
    } else {
<span class="nc" id="L786">      throw new IllegalArgumentException(additionalMeasureName </span>
<span class="nc" id="L787">	  + &quot; not supported (DecisionTable)&quot;);</span>
    }
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L797">    Capabilities result = super.getCapabilities();</span>

<span class="fc" id="L799">    result.disable(Capability.NUMERIC_CLASS);</span>
<span class="fc" id="L800">    result.disable(Capability.DATE_CLASS);</span>

<span class="fc" id="L802">    return result;</span>
  }

  /**
   * Sets the search method to use
   * 
   * @param search
   */
  public void setSearch(ASSearch search) {
    // Search method cannot be changed.
    // Must be BackwardsWithDelete
<span class="nc" id="L813">    return;</span>
  }

  /**
   * Gets the current search method
   * 
   * @return the search method used
   */
  public ASSearch getSearch() {
<span class="nc bnc" id="L822" title="All 2 branches missed.">    if (m_backwardWithDelete == null) {</span>
<span class="nc" id="L823">      setUpSearch();</span>
      //      setSearch(m_backwardWithDelete);
<span class="nc" id="L825">      m_search = m_backwardWithDelete;</span>
    }
<span class="nc" id="L827">    return m_search;</span>
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="fc" id="L837">    Vector newVector = new Vector(7);</span>

<span class="fc" id="L839">    newVector.addElement(new Option(</span>
<span class="fc" id="L840">	&quot;\tUse cross validation to evaluate features.\n&quot; +</span>
	&quot;\tUse number of folds = 1 for leave one out CV.\n&quot; +
	&quot;\t(Default = leave one out CV)&quot;,
<span class="fc" id="L843">	&quot;X&quot;, 1, &quot;-X &lt;number of folds&gt;&quot;));</span>

<span class="fc" id="L845">    newVector.addElement(new Option(</span>
<span class="fc" id="L846">	&quot;\tPerformance evaluation measure to use for selecting attributes.\n&quot; +</span>
	&quot;\t(Default = accuracy for discrete class and rmse for numeric class)&quot;,
<span class="fc" id="L848">	&quot;E&quot;, 1, &quot;-E &lt;acc | rmse | mae | auc&gt;&quot;));</span>

<span class="fc" id="L850">    newVector.addElement(new Option(</span>
<span class="fc" id="L851">	&quot;\tUse nearest neighbour instead of global table majority.&quot;,</span>
<span class="fc" id="L852">	&quot;I&quot;, 0, &quot;-I&quot;));</span>

<span class="fc" id="L854">    newVector.addElement(new Option(</span>
<span class="fc" id="L855">	&quot;\tDisplay decision table rules.\n&quot;,</span>
<span class="fc" id="L856">	&quot;R&quot;, 0, &quot;-R&quot;)); </span>

<span class="fc" id="L858">    return newVector.elements();</span>
  }

  /**
   * Parses the options for this object. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
   *  Use cross validation to evaluate features.
   *  Use number of folds = 1 for leave one out CV.
   *  (Default = leave one out CV)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E &amp;lt;acc | rmse | mae | auc&amp;gt;
   *  Performance evaluation measure to use for selecting attributes.
   *  (Default = accuracy for discrete class and rmse for numeric class)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I
   *  Use nearest neighbour instead of global table majority.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Display decision table rules.
   * &lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

    String optionString;

<span class="fc" id="L892">    resetOptions();</span>

<span class="fc" id="L894">    optionString = Utils.getOption('X',options);</span>
<span class="fc bfc" id="L895" title="All 2 branches covered.">    if (optionString.length() != 0) {</span>
<span class="fc" id="L896">      setCrossVal(Integer.parseInt(optionString));</span>
    }

<span class="fc" id="L899">    m_useIBk = Utils.getFlag('I',options);</span>

<span class="fc" id="L901">    m_displayRules = Utils.getFlag('R',options);</span>

<span class="fc" id="L903">    optionString = Utils.getOption('E', options);</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">      if (optionString.equals(&quot;acc&quot;)) {</span>
<span class="nc" id="L906">	setEvaluationMeasure(new SelectedTag(EVAL_ACCURACY, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">      } else if (optionString.equals(&quot;rmse&quot;)) {</span>
<span class="nc" id="L908">	setEvaluationMeasure(new SelectedTag(EVAL_RMSE, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">      } else if (optionString.equals(&quot;mae&quot;)) {</span>
<span class="nc" id="L910">	setEvaluationMeasure(new SelectedTag(EVAL_MAE, TAGS_EVALUATION));</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">      } else if (optionString.equals(&quot;auc&quot;)) {</span>
<span class="nc" id="L912">	setEvaluationMeasure(new SelectedTag(EVAL_AUC, TAGS_EVALUATION));</span>
      } else {
<span class="nc" id="L914">	throw new IllegalArgumentException(&quot;Invalid evaluation measure&quot;);</span>
      }
    }
<span class="fc" id="L917">  }</span>

  /**
   * Gets the current settings of the classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L926">    String [] options = new String [9];</span>
<span class="fc" id="L927">    int current = 0;</span>

<span class="fc" id="L929">    options[current++] = &quot;-X&quot;; options[current++] = &quot;&quot; + getCrossVal();</span>

<span class="pc bpc" id="L931" title="1 of 2 branches missed.">    if (m_evaluationMeasure != EVAL_DEFAULT) {</span>
<span class="nc" id="L932">      options[current++] = &quot;-E&quot;;</span>
<span class="nc bnc" id="L933" title="All 5 branches missed.">      switch (m_evaluationMeasure) {</span>
      case EVAL_ACCURACY:
<span class="nc" id="L935">	options[current++] = &quot;acc&quot;;</span>
<span class="nc" id="L936">	break;</span>
      case EVAL_RMSE:
<span class="nc" id="L938">	options[current++] = &quot;rmse&quot;;</span>
<span class="nc" id="L939">	break;</span>
      case EVAL_MAE:
<span class="nc" id="L941">	options[current++] = &quot;mae&quot;;</span>
<span class="nc" id="L942">	break;</span>
      case EVAL_AUC:
<span class="nc" id="L944">	options[current++] = &quot;auc&quot;;</span>
	break;
      }
    }
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">    if (m_useIBk) {</span>
<span class="nc" id="L949">      options[current++] = &quot;-I&quot;;</span>
    }
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">    if (m_displayRules) {</span>
<span class="nc" id="L952">      options[current++] = &quot;-R&quot;;</span>
    }

<span class="pc bfc" id="L955" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L956">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L958">    return options;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L967">    return RevisionUtils.extract(&quot;$Revision: 6269 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv the command-line options
   */
  public static void main(String [] argv) {
<span class="nc" id="L976">    runClassifier(new DTNB(), argv);</span>
<span class="nc" id="L977">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>