<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>NNge.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.rules</a> &gt; <span class="el_source">NNge.java</span></div><h1>NNge.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    NNge.java
 *    Copyright (C) 2002 Brent Martin
 *
 */

package weka.classifiers.rules;

import weka.classifiers.Classifier;
import weka.classifiers.UpdateableClassifier;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.Enumeration;
import java.util.LinkedList;
import java.util.Vector;


/**
 &lt;!-- globalinfo-start --&gt;
 * Nearest-neighbor-like algorithm using non-nested generalized exemplars (which are hyperrectangles that can be viewed as if-then rules). For more information, see &lt;br/&gt;
 * &lt;br/&gt;
 * Brent Martin (1995). Instance-Based learning: Nearest Neighbor With Generalization. Hamilton, New Zealand.&lt;br/&gt;
 * &lt;br/&gt;
 * Sylvain Roy (2002). Nearest Neighbor With Generalization. Christchurch, New Zealand.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;mastersthesis{Martin1995,
 *    address = {Hamilton, New Zealand},
 *    author = {Brent Martin},
 *    school = {University of Waikato},
 *    title = {Instance-Based learning: Nearest Neighbor With Generalization},
 *    year = {1995}
 * }
 * 
 * &amp;#64;unpublished{Roy2002,
 *    address = {Christchurch, New Zealand},
 *    author = {Sylvain Roy},
 *    school = {University of Canterbury},
 *    title = {Nearest Neighbor With Generalization},
 *    year = {2002}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -G &amp;lt;value&amp;gt;
 *  Number of attempts of generalisation.
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;value&amp;gt;
 *  Number of folder for computing the mutual information.
 * &lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Brent Martin (bim20@cosc.canterbury.ac.nz)
 * @author Sylvain Roy (sro33@student.canterbury.ac.nz)
 * @version $Revision: 5529 $
 */
<span class="fc" id="L94">public class NNge </span>
  extends Classifier 
  implements UpdateableClassifier, OptionHandler, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = 4084742275553788972L;
  
  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L108">    return &quot;Nearest-neighbor-like algorithm using non-nested generalized exemplars &quot;</span>
      + &quot;(which are hyperrectangles that can be viewed as if-then rules). For more &quot;
      + &quot;information, see \n\n&quot;
<span class="nc" id="L111">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    TechnicalInformation 	additional;
    
<span class="nc" id="L125">    result = new TechnicalInformation(Type.MASTERSTHESIS);</span>
<span class="nc" id="L126">    result.setValue(Field.AUTHOR, &quot;Brent Martin&quot;);</span>
<span class="nc" id="L127">    result.setValue(Field.YEAR, &quot;1995&quot;);</span>
<span class="nc" id="L128">    result.setValue(Field.TITLE, &quot;Instance-Based learning: Nearest Neighbor With Generalization&quot;);</span>
<span class="nc" id="L129">    result.setValue(Field.SCHOOL, &quot;University of Waikato&quot;);</span>
<span class="nc" id="L130">    result.setValue(Field.ADDRESS, &quot;Hamilton, New Zealand&quot;);</span>
    
<span class="nc" id="L132">    additional = result.add(Type.UNPUBLISHED);</span>
<span class="nc" id="L133">    additional.setValue(Field.AUTHOR, &quot;Sylvain Roy&quot;);</span>
<span class="nc" id="L134">    additional.setValue(Field.YEAR, &quot;2002&quot;);</span>
<span class="nc" id="L135">    additional.setValue(Field.TITLE, &quot;Nearest Neighbor With Generalization&quot;);</span>
<span class="nc" id="L136">    additional.setValue(Field.SCHOOL, &quot;University of Canterbury&quot;);</span>
<span class="nc" id="L137">    additional.setValue(Field.ADDRESS, &quot;Christchurch, New Zealand&quot;);</span>
    
<span class="nc" id="L139">    return result;</span>
  }

  /**
   * Implements Exemplar as used by NNge : parallel axis hyperrectangle.
   */
  private class Exemplar 
    extends Instances {
    
    /** for serialization */
    static final long serialVersionUID = 3960180128928697216L;
    
    /** List of all the Exemplar */
<span class="fc" id="L152">    private Exemplar previous = null;</span>
<span class="fc" id="L153">    private Exemplar next = null;</span>
	
    /** List of all the Exemplar with the same class */
<span class="fc" id="L156">    private Exemplar previousWithClass = null;</span>
<span class="fc" id="L157">    private Exemplar nextWithClass = null;</span>

    /** The NNge which owns this Exemplar */
    private NNge m_NNge;

    /** class of the Exemplar */
    private double m_ClassValue;

    /** Number of correct prediction for this examplar */
<span class="fc" id="L166">    private int m_PositiveCount = 1;</span>
    
    /** Number of incorrect prediction for this examplar */
<span class="fc" id="L169">    private int m_NegativeCount = 0;</span>

    /** The max borders of the rectangle for numeric attributes */
    private double[] m_MaxBorder;
	                     
    /** The min borders of the rectangle for numeric attributes */
    private double[] m_MinBorder;
	                     
    /** The ranges of the hyperrectangle for nominal attributes */
    private boolean[][] m_Range;
	                     
    /** the arrays used by preGeneralise */
<span class="fc" id="L181">    private double[] m_PreMaxBorder = null;</span>
<span class="fc" id="L182">    private double[] m_PreMinBorder = null;</span>
<span class="fc" id="L183">    private boolean[][] m_PreRange = null;</span>
<span class="fc" id="L184">    private Instance m_PreInst = null;</span>


    /**
     * Build a new empty Exemplar
     *
     * @param nnge the classifier which owns this Exemplar
     * @param inst the instances from which the header information is to be taken
     * @param size the capacity of the Exemplar
     * @param classV the class of the Exemplar
     */
    private Exemplar (NNge nnge, Instances inst, int size, double classV){

<span class="fc" id="L197">      super(inst, size);</span>
<span class="fc" id="L198">      m_NNge = nnge;</span>
<span class="fc" id="L199">      m_ClassValue = classV;</span>
<span class="fc" id="L200">      m_MinBorder = new double[numAttributes()];</span>
<span class="fc" id="L201">      m_MaxBorder = new double[numAttributes()];</span>
<span class="fc" id="L202">      m_Range = new boolean[numAttributes()][];</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">	if(attribute(i).isNumeric()){</span>
<span class="fc" id="L205">	  m_MinBorder[i] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L206">	  m_MaxBorder[i] = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L207">	  m_Range[i] = null;</span>
	} else {
<span class="fc" id="L209">	  m_MinBorder[i] = Double.NaN;</span>
<span class="fc" id="L210">	  m_MaxBorder[i] = Double.NaN;</span>
<span class="fc" id="L211">	  m_Range[i] = new boolean[attribute(i).numValues() + 1];</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">	  for(int j = 0; j &lt; attribute(i).numValues() + 1; j++){</span>
<span class="fc" id="L213">	    m_Range[i][j] = false;</span>
	  }
	}
      }
<span class="fc" id="L217">    }</span>


    /**
     * Generalise the Exemplar with inst
     *
     * @param inst the new example used for the generalisation
     * @throws Exception if either the class of inst is not equal to the class of the Exemplar or inst misses a value.
     */
    private void generalise(Instance inst) throws Exception {

<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      if(m_ClassValue != inst.classValue())</span>
<span class="nc" id="L229">	throw new Exception(&quot;Exemplar.generalise : Incompatible instance's class.&quot;);</span>

<span class="fc" id="L231">      add(inst);</span>

      /* extends each range in order to cover inst */
<span class="fc bfc" id="L234" title="All 2 branches covered.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
	 
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">	if(inst.isMissing(i))</span>
<span class="nc" id="L237">	  throw new Exception(&quot;Exemplar.generalise : Generalisation with missing feature impossible.&quot;);</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">	if(i == classIndex())</span>
<span class="fc" id="L240">	  continue;</span>
	    
<span class="fc bfc" id="L242" title="All 2 branches covered.">	if(attribute(i).isNumeric()){</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">	  if(m_MaxBorder[i] &lt; inst.value(i)) </span>
<span class="fc" id="L244">	    m_MaxBorder[i] = inst.value(i);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">	  if(inst.value(i) &lt; m_MinBorder[i]) </span>
<span class="fc" id="L246">	    m_MinBorder[i] = inst.value(i);  </span>
		
	} else {
<span class="fc" id="L249">	  m_Range[i][(int) inst.value(i)] = true;</span>
	}
      }
<span class="fc" id="L252">    } </span>


    /**
     * pre-generalise the Exemplar with inst
     * i.e. the boundaries of the Exemplar include inst but the Exemplar still doesn't 'own' inst.
     * To be complete, the generalisation must be validated with validateGeneralisation.
     * the generalisation can be canceled with cancelGeneralisation.
     * @param inst the new example used for the generalisation
     * @throws Exception if either the class of inst is not equal to the class of the Exemplar or inst misses a value.
     */
    private void preGeneralise(Instance inst) throws Exception {
	
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">      if(m_ClassValue != inst.classValue())</span>
<span class="nc" id="L266">	throw new Exception(&quot;Exemplar.preGeneralise : Incompatible instance's class.&quot;);</span>

<span class="fc" id="L268">      m_PreInst = inst;</span>

      /* save the current state */
<span class="fc" id="L271">      m_PreRange = new boolean[numAttributes()][];</span>
<span class="fc" id="L272">      m_PreMinBorder = new double[numAttributes()];</span>
<span class="fc" id="L273">      m_PreMaxBorder = new double[numAttributes()];</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">	if(attribute(i).isNumeric()){</span>
<span class="fc" id="L276">	  m_PreMinBorder[i] = m_MinBorder[i];</span>
<span class="fc" id="L277">	  m_PreMaxBorder[i] = m_MaxBorder[i];</span>
	} else {
<span class="fc" id="L279">	  m_PreRange[i] = new boolean[attribute(i).numValues() + 1];</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">	  for(int j = 0; j &lt; attribute(i).numValues() + 1; j++){</span>
<span class="fc" id="L281">	    m_PreRange[i][j] = m_Range[i][j];</span>
	  }
	}
      }

      /* perform the pre-generalisation */
<span class="fc bfc" id="L287" title="All 2 branches covered.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">	if(inst.isMissing(i))</span>
<span class="nc" id="L289">	  throw new Exception(&quot;Exemplar.preGeneralise : Generalisation with missing feature impossible.&quot;);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">	if(i == classIndex())</span>
<span class="fc" id="L291">	  continue;</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">	if(attribute(i).isNumeric()){</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">	  if(m_MaxBorder[i] &lt; inst.value(i)) </span>
<span class="fc" id="L294">	    m_MaxBorder[i] = inst.value(i);</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">	  if(inst.value(i) &lt; m_MinBorder[i]) </span>
<span class="fc" id="L296">	    m_MinBorder[i] = inst.value(i);  </span>
	} else {
<span class="fc" id="L298">	  m_Range[i][(int) inst.value(i)] = true;</span>
	}
      }
<span class="fc" id="L301">    }</span>


    /**
     * Validates a generalisation started with preGeneralise.
     * Watch out, preGeneralise must have been called before.
     *
     * @throws Exception is thrown if preGeneralise hasn't been called before
     */
    private void validateGeneralisation() throws Exception {
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">      if(m_PreInst == null){</span>
<span class="nc" id="L312">	throw new Exception(&quot;Exemplar.validateGeneralisation : validateGeneralisation called without previous call to preGeneralise!&quot;);</span>
      }
<span class="fc" id="L314">      add(m_PreInst);</span>
<span class="fc" id="L315">      m_PreRange = null;</span>
<span class="fc" id="L316">      m_PreMinBorder = null;</span>
<span class="fc" id="L317">      m_PreMaxBorder = null;</span>
<span class="fc" id="L318">    }</span>

    
    /**
     * Cancels a generalisation started with preGeneralise.
     * Watch out, preGeneralise must have been called before.
     *
     * @throws Exception is thrown if preGeneralise hasn't been called before
     */
    private void cancelGeneralisation() throws Exception {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">      if(m_PreInst == null){</span>
<span class="nc" id="L329">	throw new Exception(&quot;Exemplar.cancelGeneralisation : cancelGeneralisation called without previous call to preGeneralise!&quot;);</span>
      }
<span class="fc" id="L331">      m_PreInst = null;</span>
<span class="fc" id="L332">      m_Range = m_PreRange;</span>
<span class="fc" id="L333">      m_MinBorder = m_PreMinBorder;</span>
<span class="fc" id="L334">      m_MaxBorder = m_PreMaxBorder;</span>
<span class="fc" id="L335">      m_PreRange = null;</span>
<span class="fc" id="L336">      m_PreMinBorder = null;</span>
<span class="fc" id="L337">      m_PreMaxBorder = null;</span>
<span class="fc" id="L338">    }</span>


    /**
     * return true if inst is held by this Exemplar, false otherwise
     *
     * @param inst an Instance
     * @return true if inst is held by this hyperrectangle, false otherwise
     */
    private boolean holds(Instance inst) {
	
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">      if(numInstances() == 0)</span>
<span class="nc" id="L350">	return false;</span>

<span class="fc bfc" id="L352" title="All 2 branches covered.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
<span class="fc bfc" id="L353" title="All 4 branches covered.">	if(i != classIndex() &amp;&amp; !holds(i, inst.value(i)))</span>
<span class="fc" id="L354">	  return false;</span>
      }
<span class="fc" id="L356">      return true;</span>
    }


    /**
     * return true if value is inside the Exemplar along the attrIndex attribute.
     *
     * @param attrIndex the index of an attribute 
     * @param value a value along the attrIndexth attribute
     * @return true if value is inside the Exemplar along the attrIndex attribute.
     */
    private boolean holds(int attrIndex, double value) {
	
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">      if (numAttributes() == 0)</span>
<span class="nc" id="L370">	return false;</span>
	
<span class="fc bfc" id="L372" title="All 2 branches covered.">      if(attribute(attrIndex).isNumeric())</span>
<span class="fc bfc" id="L373" title="All 4 branches covered.">	return(m_MinBorder[attrIndex] &lt;= value &amp;&amp; value &lt;= m_MaxBorder[attrIndex]);</span>
      else
<span class="fc" id="L375">	return m_Range[attrIndex][(int) value];</span>
    }


    /**
     * Check if the Examplar overlaps ex
     *
     * @param ex an Exemplar
     * @return true if ex is overlapped by the Exemplar
     * @throws Exception
     */
    private boolean overlaps(Exemplar ex) {

<span class="pc bpc" id="L388" title="2 of 4 branches missed.">      if(ex.isEmpty() || isEmpty())</span>
<span class="nc" id="L389">	return false;</span>

<span class="fc bfc" id="L391" title="All 2 branches covered.">      for (int i = 0; i &lt; numAttributes(); i++){</span>
	    
<span class="fc bfc" id="L393" title="All 2 branches covered.">	if(i == classIndex()){</span>
<span class="fc" id="L394">	  continue;</span>
	}
<span class="fc bfc" id="L396" title="All 2 branches covered.">	if (attribute(i).isNumeric() &amp;&amp; </span>
<span class="fc bfc" id="L397" title="All 4 branches covered.">	    (ex.m_MaxBorder[i] &lt; m_MinBorder[i] || ex.m_MinBorder[i] &gt; m_MaxBorder[i])){</span>
<span class="fc" id="L398">	  return false;</span>
	}
<span class="fc bfc" id="L400" title="All 2 branches covered.">	if (attribute(i).isNominal()) {</span>
<span class="fc" id="L401">	  boolean in = false;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">	  for (int j = 0; j &lt; attribute(i).numValues() + 1; j++){</span>
<span class="fc bfc" id="L403" title="All 4 branches covered.">	    if(m_Range[i][j] &amp;&amp; ex.m_Range[i][j]){</span>
<span class="fc" id="L404">	      in = true;</span>
<span class="fc" id="L405">	      break;</span>
	    }
	  }
<span class="fc bfc" id="L408" title="All 2 branches covered.">	  if(!in) return false;</span>
	}
      }
<span class="fc" id="L411">      return true;</span>
    }


    /** 
     * Compute the distance between the projection of inst and this Exemplar along the attribute attrIndex.
     * If inst misses its value along the attribute, the function returns 0.
     *
     * @param inst an instance
     * @param attrIndex the index of the attribute 
     * @return the distance between the projection of inst and this Exemplar along the attribute attrIndex.
     */
    private double attrDistance(Instance inst, int attrIndex) {

<span class="fc bfc" id="L425" title="All 2 branches covered.">      if(inst.isMissing(attrIndex))</span>
<span class="fc" id="L426">	return 0;</span>

      /* numeric attribute */
<span class="fc bfc" id="L429" title="All 2 branches covered.">      if(attribute(attrIndex).isNumeric()){</span>

<span class="fc" id="L431">	double norm = m_NNge.m_MaxArray[attrIndex] - m_NNge.m_MinArray[attrIndex];</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">	if(norm &lt;= 0)</span>
<span class="fc" id="L433">	  norm = 1;</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">	if (m_MaxBorder[attrIndex] &lt; inst.value(attrIndex)) {</span>
<span class="fc" id="L436">	  return (inst.value(attrIndex) - m_MaxBorder[attrIndex]) / norm;</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">	} else if (inst.value(attrIndex) &lt; m_MinBorder[attrIndex]) {</span>
<span class="fc" id="L438">	  return (m_MinBorder[attrIndex] - inst.value(attrIndex)) / norm;</span>
	} else {
<span class="fc" id="L440">	  return 0;</span>
	}

	/* nominal attribute */
      } else {
<span class="fc bfc" id="L445" title="All 2 branches covered.">	if(holds(attrIndex, inst.value(attrIndex))){</span>
<span class="fc" id="L446">	  return 0;</span>
	} else {
<span class="fc" id="L448">	  return 1;</span>
	}
      }
    }


    /**
     * Returns the square of the distance between inst and the Exemplar. 
     * 
     * @param inst an instance
     * @return the squared distance between inst and the Exemplar.
     */
    private double squaredDistance(Instance inst) {
	
<span class="fc" id="L462">      double sum = 0, term;</span>
<span class="fc" id="L463">      int numNotMissingAttr = 0;</span>
<span class="fc bfc" id="L464" title="All 2 branches covered.">      for(int i = 0; i &lt; inst.numAttributes(); i++){</span>
	    
<span class="fc bfc" id="L466" title="All 2 branches covered.">	if(i == classIndex())</span>
<span class="fc" id="L467">	  continue;</span>
	    
<span class="fc" id="L469">	term = m_NNge.attrWeight(i) * attrDistance(inst, i);</span>
<span class="fc" id="L470">	term = term * term;</span>
<span class="fc" id="L471">	sum += term;</span>

<span class="fc bfc" id="L473" title="All 2 branches covered.">	if (!inst.isMissing(i))</span>
<span class="fc" id="L474">	  numNotMissingAttr++;</span>

      }
	
<span class="fc bfc" id="L478" title="All 2 branches covered.">      if(numNotMissingAttr == 0){</span>
<span class="fc" id="L479">	return 0;</span>
      } else {
<span class="fc" id="L481">	return sum / (double) (numNotMissingAttr * numNotMissingAttr);</span>
      }
    }


    /**
     * Return the weight of the Examplar
     *
     * @return the weight of the Examplar.
     */
    private double weight(){
<span class="nc" id="L492">      return ((double) (m_PositiveCount + m_NegativeCount)) / ((double) m_PositiveCount);</span>
    }


    /**
     * Return the class of the Exemplar
     *
     * @return the class of this exemplar as a double (weka format)
     */
    private double classValue(){
<span class="fc" id="L502">      return m_ClassValue;</span>
    }


    /**
     * Returns the value of the inf border of the Exemplar. 
     *
     * @param attrIndex the index of the attribute
     * @return the value of the inf border for this attribute
     * @throws Exception is thrown either if the attribute is nominal or if the Exemplar is empty
     */
    private double getMinBorder(int attrIndex) throws Exception {
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">      if(!attribute(attrIndex).isNumeric())</span>
<span class="nc" id="L515">	throw new Exception(&quot;Exception.getMinBorder : not numeric attribute !&quot;);</span>
<span class="pc bpc" id="L516" title="1 of 2 branches missed.">      if(numInstances() == 0)</span>
<span class="nc" id="L517">	throw new Exception(&quot;Exception.getMinBorder : empty Exemplar !&quot;);</span>
<span class="fc" id="L518">      return m_MinBorder[attrIndex];</span>
    }


    /**
     * Returns the value of the sup border of the hyperrectangle
     * Returns NaN if the HyperRectangle doesn't have any border for this attribute 
     *
     * @param attrIndex the index of the attribute
     * @return the value of the sup border for this attribute
     * @throws Exception is thrown either if the attribute is nominal or if the Exemplar is empty
     */
    private double getMaxBorder(int attrIndex) throws Exception {
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">      if(!attribute(attrIndex).isNumeric())</span>
<span class="nc" id="L532">	throw new Exception(&quot;Exception.getMaxBorder : not numeric attribute !&quot;);</span>
<span class="pc bpc" id="L533" title="1 of 2 branches missed.">      if(numInstances() == 0)</span>
<span class="nc" id="L534">	throw new Exception(&quot;Exception.getMaxBorder : empty Exemplar !&quot;);</span>
<span class="fc" id="L535">      return m_MaxBorder[attrIndex];</span>
    }


    /**
     * Returns the number of positive classifications
     *
     * @return the number of positive classifications
     */
    private int getPositiveCount(){
<span class="fc" id="L545">      return m_PositiveCount;</span>
    }


    /**
     * Returns the number of negative classifications
     *
     * @return the number of negative classifications
     */
    private int getNegativeCount(){
<span class="fc" id="L555">      return m_NegativeCount;</span>
    }


    /**
     * Set the number of positive classifications
     *
     * @param value an integer value (greater than 0 is wise...)
     */
    private void setPositiveCount(int value) {
<span class="fc" id="L565">      m_PositiveCount = value;</span>
<span class="fc" id="L566">    }</span>


    /**
     * Set the number of negative classifications
     *
     * @param value an integer value
     */
    private void setNegativeCount(int value) {
<span class="fc" id="L575">      m_NegativeCount = value;</span>
<span class="fc" id="L576">    }</span>


    /**
     * Increment the number of positive Classifications
     */
    private void incrPositiveCount(){
<span class="fc" id="L583">      m_PositiveCount++;</span>
<span class="fc" id="L584">    }</span>


    /**
     * Increment the number of negative Classifications
     */
    private void incrNegativeCount(){
<span class="fc" id="L591">      m_NegativeCount++;</span>
<span class="fc" id="L592">    }</span>


    /**
     * Returns true if the Exemplar is empty (i.e. doesn't yield any Instance)
     *
     * @return true if the Exemplar is empty, false otherwise
     */
    private boolean isEmpty(){
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">      return (numInstances() == 0);</span>
    }

    
    /**
     * Returns a description of this Exemplar
     *
     * @return A string that describes this Exemplar
     */
    private String toString2(){
      String s;
<span class="nc" id="L612">      Enumeration enu = null;</span>
<span class="nc" id="L613">      s = &quot;Exemplar[&quot;;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">      if (numInstances() == 0) {</span>
<span class="nc" id="L615">	return s + &quot;Empty]&quot;;</span>
      }
<span class="nc" id="L617">      s += &quot;{&quot;;</span>
<span class="nc" id="L618">      enu = enumerateInstances();</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">      while(enu.hasMoreElements()){</span>
<span class="nc" id="L620">	s = s + &quot;&lt;&quot; + enu.nextElement().toString() + &quot;&gt; &quot;;</span>
      }
<span class="nc" id="L622">      s = s.substring(0, s.length()-1);</span>
<span class="nc" id="L623">      s = s + &quot;} {&quot; + toRules() + &quot;} p=&quot; + m_PositiveCount + &quot; n=&quot; + m_NegativeCount + &quot;]&quot;;</span>
<span class="nc" id="L624">      return s;</span>
    }


    /**
     * Returns a string of the rules induced by this examplar
     *
     * @return a string of the rules induced by this examplar
     */
    private String toRules(){

<span class="nc bnc" id="L635" title="All 2 branches missed.">      if (numInstances() == 0)</span>
<span class="nc" id="L636">	return &quot;No Rules (Empty Exemplar)&quot;;</span>

<span class="nc" id="L638">      String s = &quot;&quot;, sep = &quot;&quot;;</span>
	
<span class="nc bnc" id="L640" title="All 2 branches missed.">      for(int i = 0; i &lt; numAttributes(); i++){</span>
	    
<span class="nc bnc" id="L642" title="All 2 branches missed.">	if(i == classIndex())</span>
<span class="nc" id="L643">	  continue;</span>
	    
<span class="nc bnc" id="L645" title="All 2 branches missed.">	if(attribute(i).isNumeric()){</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">	  if(m_MaxBorder[i] != m_MinBorder[i]){</span>
<span class="nc" id="L647">	    s += sep + m_MinBorder[i] + &quot;&lt;=&quot; + attribute(i).name() + &quot;&lt;=&quot; + m_MaxBorder[i];</span>
	  } else {
<span class="nc" id="L649">	    s += sep + attribute(i).name() + &quot;=&quot; + m_MaxBorder[i];</span>
	  }
<span class="nc" id="L651">	  sep = &quot; ^ &quot;;</span>
	    
	} else {
<span class="nc" id="L654">	  s += sep + attribute(i).name() + &quot; in {&quot;;</span>
<span class="nc" id="L655">	  String virg = &quot;&quot;;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">	  for(int j = 0; j &lt; attribute(i).numValues() + 1; j++){</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">	    if(m_Range[i][j]){</span>
<span class="nc" id="L658">	      s+= virg;</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">	      if(j == attribute(i).numValues())</span>
<span class="nc" id="L660">		s += &quot;?&quot;;</span>
	      else
<span class="nc" id="L662">		s += attribute(i).value(j);</span>
<span class="nc" id="L663">	      virg = &quot;,&quot;;</span>
	    }
	  }
<span class="nc" id="L666">	  s+=&quot;}&quot;;</span>
<span class="nc" id="L667">	  sep = &quot; ^ &quot;;</span>
	}	    
      }
<span class="nc" id="L670">      s += &quot;  (&quot;+numInstances() +&quot;)&quot;;</span>
<span class="nc" id="L671">      return s;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L680">      return RevisionUtils.extract(&quot;$Revision: 5529 $&quot;);</span>
    }
  }



  /** An empty instances to keep the headers, the classIndex, etc... */
  private Instances m_Train;

  /** The list of Exemplars */
  private Exemplar m_Exemplars;

  /** The lists of Exemplars by class */
  private Exemplar m_ExemplarsByClass[];

  /** The minimum values for numeric attributes. */
  double [] m_MinArray;

  /** The maximum values for numeric attributes. */
  double [] m_MaxArray;

  /** The number of try for generalisation */
<span class="fc" id="L702">  private int m_NumAttemptsOfGene = 5;</span>

  /** The number of folder for the Mutual Information */
<span class="fc" id="L705">  private int m_NumFoldersMI = 5;</span>

  /** Values to use for missing value */
  private double [] m_MissingVector;

  /** MUTUAL INFORMATION'S DATAS */
  /* numeric attributes */
  private int [][][] m_MI_NumAttrClassInter;
  private int [][] m_MI_NumAttrInter;
  private double [] m_MI_MaxArray;
  private double [] m_MI_MinArray;
  /* nominal attributes */
  private int [][][] m_MI_NumAttrClassValue;
  private int [][] m_MI_NumAttrValue;
  /* both */
  private int [] m_MI_NumClass;
  private int m_MI_NumInst;
  private double [] m_MI;



  /** MAIN FUNCTIONS OF THE CLASSIFIER */


  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L735">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L736">    result.disableAll();</span>

    // attributes
<span class="fc" id="L739">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L740">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L741">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L742">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L745">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L746">    result.enable(Capability.MISSING_CLASS_VALUES);</span>

    // instances
<span class="fc" id="L749">    result.setMinimumNumberInstances(0);</span>
    
<span class="fc" id="L751">    return result;</span>
  }

  /**
   * Generates a classifier. Must initialize all fields of the classifier
   * that are not being set via options (ie. multiple calls of buildClassifier
   * must always lead to the same result). Must not change the dataset
   * in any way.
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the classifier has not been 
   * generated successfully
   */
  public void buildClassifier(Instances data) throws Exception {

    // can classifier handle the data?
<span class="fc" id="L767">    getCapabilities().testWithFail(data);</span>

    // remove instances with missing class
<span class="fc" id="L770">    data = new Instances(data);</span>
<span class="fc" id="L771">    data.deleteWithMissingClass();</span>
    
    /* initialize the classifier */

<span class="fc" id="L775">    m_Train = new Instances(data, 0);</span>
<span class="fc" id="L776">    m_Exemplars = null;</span>
<span class="fc" id="L777">    m_ExemplarsByClass = new Exemplar[m_Train.numClasses()];</span>
<span class="fc bfc" id="L778" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Train.numClasses(); i++){</span>
<span class="fc" id="L779">      m_ExemplarsByClass[i] = null;</span>
    }
<span class="fc" id="L781">    m_MaxArray = new double[m_Train.numAttributes()];</span>
<span class="fc" id="L782">    m_MinArray = new double[m_Train.numAttributes()];</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Train.numAttributes(); i++){</span>
<span class="fc" id="L784">      m_MinArray[i] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L785">      m_MaxArray[i] = Double.NEGATIVE_INFINITY;</span>
    }

<span class="fc" id="L788">    m_MI_MinArray = new double [data.numAttributes()];</span>
<span class="fc" id="L789">    m_MI_MaxArray = new double [data.numAttributes()];</span>
<span class="fc" id="L790">    m_MI_NumAttrClassInter = new int[data.numAttributes()][][];</span>
<span class="fc" id="L791">    m_MI_NumAttrInter = new int[data.numAttributes()][];</span>
<span class="fc" id="L792">    m_MI_NumAttrClassValue = new int[data.numAttributes()][][];</span>
<span class="fc" id="L793">    m_MI_NumAttrValue = new int[data.numAttributes()][];</span>
<span class="fc" id="L794">    m_MI_NumClass = new int[data.numClasses()];</span>
<span class="fc" id="L795">    m_MI = new double[data.numAttributes()];</span>
<span class="fc" id="L796">    m_MI_NumInst = 0;</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">    for(int cclass = 0; cclass &lt; data.numClasses(); cclass++)</span>
<span class="fc" id="L798">      m_MI_NumClass[cclass] = 0;</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">    for (int attrIndex = 0; attrIndex &lt; data.numAttributes(); attrIndex++) {</span>
	    
<span class="fc bfc" id="L801" title="All 2 branches covered.">      if(attrIndex == data.classIndex())</span>
<span class="fc" id="L802">	continue;</span>
	    
<span class="fc" id="L804">      m_MI_MaxArray[attrIndex] = m_MI_MinArray[attrIndex] = Double.NaN;</span>
<span class="fc" id="L805">      m_MI[attrIndex] = Double.NaN;</span>
	    
<span class="fc bfc" id="L807" title="All 2 branches covered.">      if(data.attribute(attrIndex).isNumeric()){</span>
<span class="fc" id="L808">	m_MI_NumAttrInter[attrIndex] = new int[m_NumFoldersMI];</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">	for(int inter = 0; inter &lt; m_NumFoldersMI; inter++){</span>
<span class="fc" id="L810">	  m_MI_NumAttrInter[attrIndex][inter] = 0;</span>
	}
      } else {
<span class="fc" id="L813">	m_MI_NumAttrValue[attrIndex] = new int[data.attribute(attrIndex).numValues() + 1];</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">	for(int attrValue = 0; attrValue &lt; data.attribute(attrIndex).numValues() + 1; attrValue++){</span>
<span class="fc" id="L815">	  m_MI_NumAttrValue[attrIndex][attrValue] = 0;</span>
	}
      }
	    
<span class="fc" id="L819">      m_MI_NumAttrClassInter[attrIndex] = new int[data.numClasses()][];</span>
<span class="fc" id="L820">      m_MI_NumAttrClassValue[attrIndex] = new int[data.numClasses()][];</span>

<span class="fc bfc" id="L822" title="All 2 branches covered.">      for(int cclass = 0; cclass &lt; data.numClasses(); cclass++){</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">	if(data.attribute(attrIndex).isNumeric()){</span>
<span class="fc" id="L824">	  m_MI_NumAttrClassInter[attrIndex][cclass] = new int[m_NumFoldersMI];</span>
<span class="fc bfc" id="L825" title="All 2 branches covered.">	  for(int inter = 0; inter &lt; m_NumFoldersMI; inter++){</span>
<span class="fc" id="L826">	    m_MI_NumAttrClassInter[attrIndex][cclass][inter] = 0;</span>
	  }
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">	} else if(data.attribute(attrIndex).isNominal()){</span>
<span class="fc" id="L829">	  m_MI_NumAttrClassValue[attrIndex][cclass] = new int[data.attribute(attrIndex).numValues() + 1];		</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">	  for(int attrValue = 0; attrValue &lt; data.attribute(attrIndex).numValues() + 1; attrValue++){</span>
<span class="fc" id="L831">	    m_MI_NumAttrClassValue[attrIndex][cclass][attrValue] = 0;</span>
	  }
	}
      }
    }
<span class="fc" id="L836">    m_MissingVector = new double[data.numAttributes()];</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">    for(int i = 0; i &lt; data.numAttributes(); i++){</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">      if(i == data.classIndex()){</span>
<span class="fc" id="L839">	m_MissingVector[i] = Double.NaN;</span>
      } else {
<span class="fc" id="L841">	m_MissingVector[i] = data.attribute(i).numValues();</span>
      }
    }

    /* update the classifier with data */
<span class="fc" id="L846">    Enumeration enu = data.enumerateInstances();</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">    while(enu.hasMoreElements()){</span>
<span class="fc" id="L848">      update((Instance) enu.nextElement());</span>
    }	
<span class="fc" id="L850">  }</span>

    
  /**
   * Classifies a given instance.
   *
   * @param instance the instance to be classified
   * @return index of the predicted class as a double
   * @throws Exception if instance could not be classified
   * successfully
   */
  public double classifyInstance(Instance instance) throws Exception {

    /* check the instance */
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">    if (m_Train.equalHeaders(instance.dataset()) == false){</span>
<span class="nc" id="L865">      throw new Exception(&quot;NNge.classifyInstance : Incompatible instance types !&quot;);</span>
    }
	
<span class="fc" id="L868">    Exemplar matched = nearestExemplar(instance); </span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">    if(matched == null){</span>
<span class="fc" id="L870">      throw new Exception(&quot;NNge.classifyInstance : NNge hasn't been trained !&quot;);</span>
    }
<span class="fc" id="L872">    return matched.classValue();</span>
  }


  /**
   * Updates the classifier using the given instance.
   *
   * @param instance the instance to include
   * @throws Exception if instance could not be incorporated
   * successfully
   */
  public void updateClassifier(Instance instance) throws Exception {

<span class="pc bpc" id="L885" title="1 of 2 branches missed.">    if (m_Train.equalHeaders(instance.dataset()) == false) {</span>
<span class="nc" id="L886">      throw new Exception(&quot;Incompatible instance types&quot;);</span>
    }	
<span class="fc" id="L888">    update(instance);	</span>
<span class="fc" id="L889">  }</span>



  /** HIGH LEVEL SUB-FUNCTIONS */
    


  /**
   * Performs the update of the classifier
   *
   * @param instance the new instance
   * @throws Exception if the update fails
   */
  private void update(Instance instance) throws Exception {

<span class="pc bpc" id="L905" title="1 of 2 branches missed.">    if (instance.classIsMissing()) {</span>
<span class="nc" id="L906">      return;</span>
    }

<span class="fc" id="L909">    instance.replaceMissingValues(m_MissingVector);</span>
<span class="fc" id="L910">    m_Train.add(instance);</span>

    /* Update the minimum and maximum for all the attributes */
<span class="fc" id="L913">    updateMinMax(instance);</span>

    /* update the mutual information datas */
<span class="fc" id="L916">    updateMI(instance);</span>

    /* Nearest Exemplar */
<span class="fc" id="L919">    Exemplar nearest = nearestExemplar(instance);</span>
	
    /* Adjust */
<span class="fc bfc" id="L922" title="All 2 branches covered.">    if(nearest == null){</span>
<span class="fc" id="L923">      Exemplar newEx = new Exemplar(this, m_Train, 10, instance.classValue());</span>
<span class="fc" id="L924">      newEx.generalise(instance);</span>
<span class="fc" id="L925">      initWeight(newEx);</span>
<span class="fc" id="L926">      addExemplar(newEx);</span>
<span class="fc" id="L927">      return;</span>
    }
<span class="fc" id="L929">    adjust(instance, nearest);</span>

    /* Generalise */
<span class="fc" id="L932">    generalise(instance);</span>
<span class="fc" id="L933">  }</span>


  /**
   * Returns the nearest Exemplar
   *
   * @param inst an Instance
   * @return the nearest Exemplar to inst, null if no exemplar are found.
   */
  private Exemplar nearestExemplar(Instance inst){

<span class="fc bfc" id="L944" title="All 2 branches covered.">    if (m_Exemplars == null)</span>
<span class="fc" id="L945">      return null;</span>
<span class="fc" id="L946">    Exemplar cur = m_Exemplars, nearest = m_Exemplars;</span>
<span class="fc" id="L947">    double dist, smallestDist = cur.squaredDistance(inst);</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">    while (cur.next != null){</span>
<span class="fc" id="L949">      cur = cur.next;</span>
<span class="fc" id="L950">      dist = cur.squaredDistance(inst);</span>
<span class="fc bfc" id="L951" title="All 2 branches covered.">      if (dist &lt; smallestDist){</span>
<span class="fc" id="L952">	smallestDist = dist;</span>
<span class="fc" id="L953">	nearest = cur;</span>
      }
    }
<span class="fc" id="L956">    return nearest;</span>
  }

    
  /**
   * Returns the nearest Exemplar with class c
   *
   * @param inst an Instance
   * @param c the class of the Exemplar to return
   * @return the nearest Exemplar to inst with class c, null if no exemplar with class c are found.
   */
  private Exemplar nearestExemplar(Instance inst, double c){

<span class="nc bnc" id="L969" title="All 2 branches missed.">    if (m_ExemplarsByClass[(int) c] == null)</span>
<span class="nc" id="L970">      return null;</span>
<span class="nc" id="L971">    Exemplar cur = m_ExemplarsByClass[(int) c], nearest = m_ExemplarsByClass[(int) c];</span>
<span class="nc" id="L972">    double dist, smallestDist = cur.squaredDistance(inst);</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">    while (cur.nextWithClass != null){</span>
<span class="nc" id="L974">      cur = cur.nextWithClass;</span>
<span class="nc" id="L975">      dist = cur.squaredDistance(inst);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">      if (dist &lt; smallestDist){</span>
<span class="nc" id="L977">	smallestDist = dist;</span>
<span class="nc" id="L978">	nearest = cur;</span>
      }
    }
<span class="nc" id="L981">    return nearest;</span>
  }

    
  /**
   * Generalise an Exemplar (not necessarily predictedExemplar) to match instance.
   * predictedExemplar must be in NNge's lists
   *
   * @param newInst the new instance
   * @throws Exception in case of inconsitent situation
   */
  private void generalise(Instance newInst) throws Exception {

<span class="fc" id="L994">    Exemplar first = m_ExemplarsByClass[(int) newInst.classValue()];</span>
<span class="fc" id="L995">    int n = 0;</span>

    /* try to generalise with the n first exemplars */
<span class="fc bfc" id="L998" title="All 4 branches covered.">    while(n &lt; m_NumAttemptsOfGene &amp;&amp; first != null){</span>
	    
      /* find the nearest one starting from first */
<span class="fc" id="L1001">      Exemplar closest = first, cur = first;</span>
<span class="fc" id="L1002">      double smallestDist = first.squaredDistance(newInst), dist;</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">      while(cur.nextWithClass != null){</span>
<span class="fc" id="L1004">	cur = cur.nextWithClass;</span>
<span class="fc" id="L1005">	dist = cur.squaredDistance(newInst);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">	if(dist &lt; smallestDist){</span>
<span class="fc" id="L1007">	  smallestDist = dist;</span>
<span class="fc" id="L1008">	  closest = cur;</span>
	}
      }

      /* remove the Examplar from NNge's lists */
<span class="fc bfc" id="L1013" title="All 2 branches covered.">      if(closest == first)</span>
<span class="fc" id="L1014">	first = first.nextWithClass;</span>
<span class="fc" id="L1015">      removeExemplar(closest); </span>

      /* try to generalise */
<span class="fc" id="L1018">      closest.preGeneralise(newInst);</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">      if(!detectOverlapping(closest)){</span>
<span class="fc" id="L1020">	closest.validateGeneralisation();</span>
<span class="fc" id="L1021">	addExemplar(closest);</span>
<span class="fc" id="L1022">	return;</span>
      }

      /* it didn't work, put ungeneralised exemplar on the top of the lists */
<span class="fc" id="L1026">      closest.cancelGeneralisation();</span>
<span class="fc" id="L1027">      addExemplar(closest);			</span>

<span class="fc" id="L1029">      n++;</span>
    }

    /* generalisation failled : add newInst as a new Examplar */
<span class="fc" id="L1033">    Exemplar newEx = new Exemplar(this, m_Train, 5, newInst.classValue());</span>
<span class="fc" id="L1034">    newEx.generalise(newInst);</span>
<span class="fc" id="L1035">    initWeight(newEx);</span>
<span class="fc" id="L1036">    addExemplar(newEx);</span>
<span class="fc" id="L1037">  }</span>


  /**
   * Adjust the NNge.
   *
   * @param newInst the instance to classify
   * @param predictedExemplar the Exemplar that matches newInst
   * @throws Exception in case of inconsistent situation
   */
  private void adjust(Instance newInst, Exemplar predictedExemplar) throws Exception {

    /* correct prediction */
<span class="fc bfc" id="L1050" title="All 2 branches covered.">    if(newInst.classValue() == predictedExemplar.classValue()){</span>
<span class="fc" id="L1051">      predictedExemplar.incrPositiveCount();</span>
      /* incorrect prediction */
    } else {
<span class="fc" id="L1054">      predictedExemplar.incrNegativeCount();</span>

      /* new instance falls inside */
<span class="fc bfc" id="L1057" title="All 2 branches covered.">      if(predictedExemplar.holds(newInst)){</span>
<span class="fc" id="L1058">	prune(predictedExemplar, newInst);</span>
      }
    }    
<span class="fc" id="L1061">  }</span>


  /**
   * Prunes an Exemplar that matches an Instance
   *
   * @param predictedExemplar an Exemplar
   * @param newInst an Instance matched by predictedExemplar
   * @throws Exception in case of inconsistent situation. (shouldn't happen.)
   */
  private void prune(Exemplar predictedExemplar, Instance newInst) throws Exception {

    /* remove the Exemplar */
<span class="fc" id="L1074">    removeExemplar(predictedExemplar);</span>

    /* look for the best nominal feature and the best numeric feature to cut */
<span class="fc" id="L1077">    int numAttr = -1, nomAttr = -1;</span>
<span class="fc" id="L1078">    double smallestDelta = Double.POSITIVE_INFINITY, delta;</span>
<span class="fc" id="L1079">    int biggest_N_Nom = -1, biggest_N_Num = -1, n, m;</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Train.numAttributes(); i++){</span>

<span class="fc bfc" id="L1082" title="All 2 branches covered.">      if(i == m_Train.classIndex())</span>
<span class="fc" id="L1083">	continue;</span>

      /* numeric attribute */
<span class="fc bfc" id="L1086" title="All 2 branches covered.">      if(m_Train.attribute(i).isNumeric()){</span>

	/* compute the distance 'delta' to the closest boundary */
<span class="fc" id="L1089">	double norm = m_MaxArray[i] - m_MinArray[i];</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">	if(norm != 0){</span>
<span class="fc" id="L1091">	  delta = Math.min((predictedExemplar.getMaxBorder(i) - newInst.value(i)), </span>
<span class="fc" id="L1092">			   (newInst.value(i) - predictedExemplar.getMinBorder(i))) / norm;</span>
	} else {
<span class="fc" id="L1094">	  delta = Double.POSITIVE_INFINITY;</span>
	}

	/* compute the size of the biggest Exemplar which would be created */
<span class="fc" id="L1098">	n = m = 0;</span>
<span class="fc" id="L1099">	Enumeration enu = predictedExemplar.enumerateInstances();</span>
<span class="fc bfc" id="L1100" title="All 2 branches covered.">	while(enu.hasMoreElements()){</span>
<span class="fc" id="L1101">	  Instance ins = (Instance) enu.nextElement();</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">	  if(ins.value(i) &lt; newInst.value(i))</span>
<span class="fc" id="L1103">	    n++;</span>
<span class="fc bfc" id="L1104" title="All 2 branches covered.">	  else if(ins.value(i) &gt; newInst.value(i))</span>
<span class="fc" id="L1105">	    m++;</span>
	}
<span class="fc" id="L1107">	n = Math.max(n, m);</span>

<span class="fc bfc" id="L1109" title="All 2 branches covered.">	if(delta &lt; smallestDelta){</span>
<span class="fc" id="L1110">	  smallestDelta = delta;</span>
<span class="fc" id="L1111">	  biggest_N_Num = n;</span>
<span class="fc" id="L1112">	  numAttr = i;</span>
<span class="pc bpc" id="L1113" title="1 of 4 branches missed.">	} else if(delta == smallestDelta &amp;&amp; n &gt; biggest_N_Num){</span>
<span class="fc" id="L1114">	  biggest_N_Num = n;</span>
<span class="fc" id="L1115">	  numAttr = i;</span>
	}

	/* nominal attribute */
      } else {

	/* compute the size of the Exemplar which would be created */
<span class="fc" id="L1122">	Enumeration enu = predictedExemplar.enumerateInstances();</span>
<span class="fc" id="L1123">	n = 0;</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">	while(enu.hasMoreElements()){</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">	  if(((Instance) enu.nextElement()).value(i) != newInst.value(i))</span>
<span class="fc" id="L1126">	    n++;</span>
	}
<span class="fc bfc" id="L1128" title="All 2 branches covered.">	if(n &gt; biggest_N_Nom){</span>
<span class="fc" id="L1129">	  biggest_N_Nom = n;</span>
<span class="fc" id="L1130">	  nomAttr = i;</span>
	} 
      }
    }

    /* selection of the feature to cut between the best nominal and the best numeric */
    int attrToCut;
<span class="fc bfc" id="L1137" title="All 4 branches covered.">    if(numAttr == -1 &amp;&amp; nomAttr == -1){</span>
<span class="fc" id="L1138">      attrToCut = 0;</span>
<span class="fc bfc" id="L1139" title="All 2 branches covered.">    } else if (numAttr == -1){</span>
<span class="fc" id="L1140">      attrToCut = nomAttr;</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">    } else if(nomAttr == -1){</span>
<span class="fc" id="L1142">      attrToCut = numAttr;</span>
    } else {
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">      if(biggest_N_Nom &gt; biggest_N_Num)</span>
<span class="nc" id="L1145">	attrToCut = nomAttr;</span>
      else
<span class="fc" id="L1147">	attrToCut = numAttr;</span>
    }

    /* split the Exemplar */
    Instance curInst;
    Exemplar a, b;
<span class="fc" id="L1153">    a = new Exemplar(this, m_Train, 10, predictedExemplar.classValue());</span>
<span class="fc" id="L1154">    b = new Exemplar(this, m_Train, 10, predictedExemplar.classValue());</span>
<span class="fc" id="L1155">    LinkedList leftAlone = new LinkedList();</span>
<span class="fc" id="L1156">    Enumeration enu = predictedExemplar.enumerateInstances();</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">    if(m_Train.attribute(attrToCut).isNumeric()){</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">      while(enu.hasMoreElements()){</span>
<span class="fc" id="L1159">	curInst = (Instance) enu.nextElement();</span>
<span class="fc bfc" id="L1160" title="All 2 branches covered.">	if(curInst.value(attrToCut) &gt; newInst.value(attrToCut)){</span>
<span class="fc" id="L1161">	  a.generalise(curInst);</span>
<span class="fc bfc" id="L1162" title="All 2 branches covered.">	} else if (curInst.value(attrToCut) &lt; newInst.value(attrToCut)){</span>
<span class="fc" id="L1163">	  b.generalise(curInst);</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">	} else if (notEqualFeatures(curInst, newInst)) {</span>
<span class="nc" id="L1165">	  leftAlone.add(curInst);</span>
	}
      }
    } else {
<span class="fc bfc" id="L1169" title="All 2 branches covered.">      while(enu.hasMoreElements()){</span>
<span class="fc" id="L1170">	curInst = (Instance) enu.nextElement();</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">	if(curInst.value(attrToCut) != newInst.value(attrToCut)){</span>
<span class="fc" id="L1172">	  a.generalise(curInst);</span>
<span class="pc bpc" id="L1173" title="1 of 2 branches missed.">	} else if (notEqualFeatures(curInst, newInst)){</span>
<span class="nc" id="L1174">	  leftAlone.add(curInst);</span>
	}
      }
    }
	
    /* treat the left alone Instances */
<span class="pc bpc" id="L1180" title="1 of 2 branches missed.">    while(leftAlone.size() != 0){</span>

<span class="nc" id="L1182">      Instance alone = (Instance) leftAlone.removeFirst();</span>
<span class="nc" id="L1183">      a.preGeneralise(alone);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">      if(!a.holds(newInst)){</span>
<span class="nc" id="L1185">	a.validateGeneralisation();</span>
<span class="nc" id="L1186">	continue;</span>
      }
<span class="nc" id="L1188">      a.cancelGeneralisation();</span>
<span class="nc" id="L1189">      b.preGeneralise(alone);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">      if(!b.holds(newInst)){</span>
<span class="nc" id="L1191">	b.validateGeneralisation();</span>
<span class="nc" id="L1192">	continue;</span>
      }
<span class="nc" id="L1194">      b.cancelGeneralisation();</span>
<span class="nc" id="L1195">      Exemplar exem = new Exemplar(this, m_Train, 3, alone.classValue());</span>
<span class="nc" id="L1196">      exem.generalise(alone);</span>
<span class="nc" id="L1197">      initWeight(exem);</span>
<span class="nc" id="L1198">      addExemplar(exem);</span>
    }

    /* add (or not) the new Exemplars */
<span class="fc bfc" id="L1202" title="All 2 branches covered.">    if(a.numInstances() != 0){</span>
<span class="fc" id="L1203">      initWeight(a);</span>
<span class="fc" id="L1204">      addExemplar(a);</span>
    }
<span class="fc bfc" id="L1206" title="All 2 branches covered.">    if(b.numInstances() != 0){</span>
<span class="fc" id="L1207">      initWeight(b);</span>
<span class="fc" id="L1208">      addExemplar(b);	    </span>
    }
<span class="fc" id="L1210">  }</span>


  /**
   * Returns true if the instance don't have the same feature values
   * 
   * @param inst1 an instance
   * @param inst2 an instance
   * @return true if the instance don't have the same feature values
   */
  private boolean notEqualFeatures(Instance inst1, Instance inst2) {

<span class="fc bfc" id="L1222" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Train.numAttributes(); i++){</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">      if(i == m_Train.classIndex())</span>
<span class="fc" id="L1224">	continue;</span>
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">      if(inst1.value(i) != inst2.value(i))</span>
<span class="nc" id="L1226">	return true;</span>
    }
<span class="fc" id="L1228">    return false;</span>
  }


  /**
   * Returns true if ex overlaps any of the Exemplars in NNge's lists
   *
   * @param ex an Exemplars
   * @return true if ex overlaps any of the Exemplars in NNge's lists
   */
  private boolean detectOverlapping(Exemplar ex){
<span class="fc" id="L1239">    Exemplar cur = m_Exemplars;</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">    while(cur != null){</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">      if(ex.overlaps(cur)){</span>
<span class="fc" id="L1242">	return true;</span>
      }
<span class="fc" id="L1244">      cur = cur.next;</span>
    }
<span class="fc" id="L1246">    return false;</span>
  }


  /**
   * Updates the minimum, maximum, sum, sumSquare values for all the attributes 
   * 
   * @param instance the new instance
   */
  private void updateMinMax(Instance instance){

<span class="fc bfc" id="L1257" title="All 2 branches covered.">    for (int j = 0; j &lt; m_Train.numAttributes(); j++) {</span>
<span class="fc bfc" id="L1258" title="All 4 branches covered.">      if(m_Train.classIndex() == j || m_Train.attribute(j).isNominal())</span>
<span class="fc" id="L1259">	continue;</span>
<span class="fc bfc" id="L1260" title="All 2 branches covered.">      if (instance.value(j) &lt; m_MinArray[j]) </span>
<span class="fc" id="L1261">	m_MinArray[j] = instance.value(j);</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">      if (instance.value(j) &gt; m_MaxArray[j])</span>
<span class="fc" id="L1263">	m_MaxArray[j] = instance.value(j);</span>
    }    
<span class="fc" id="L1265">  }</span>


  /**
   * Updates the data for computing the mutual information
   *
   * MUST be called AFTER adding inst in m_Train 
   *
   * @param inst the new instance
   * @throws Exception is thrown if an inconsistent situation is met
   */
  private void updateMI(Instance inst) throws Exception {

<span class="pc bpc" id="L1278" title="1 of 2 branches missed.">    if(m_NumFoldersMI &lt; 1){</span>
<span class="nc" id="L1279">      throw new Exception(&quot;NNge.updateMI : incorrect number of folders ! Option I must be greater than 1.&quot;);</span>
    }

<span class="fc" id="L1282">    m_MI_NumClass[(int) inst.classValue()]++;</span>
<span class="fc" id="L1283">    m_MI_NumInst++;</span>

    /* for each attribute */
<span class="fc bfc" id="L1286" title="All 2 branches covered.">    for(int attrIndex = 0; attrIndex &lt; m_Train.numAttributes(); attrIndex++){</span>

      /* which is the class attribute */
<span class="fc bfc" id="L1289" title="All 2 branches covered.">      if(m_Train.classIndex() == attrIndex)</span>
<span class="fc" id="L1290">	continue;</span>

      /* which is a numeric attribute */
<span class="fc bfc" id="L1293" title="All 2 branches covered.">      else if(m_Train.attribute(attrIndex).isNumeric()){</span>
		
	/* if max-min have to be updated */
<span class="fc bfc" id="L1296" title="All 2 branches covered.">	if(Double.isNaN(m_MI_MaxArray[attrIndex]) ||</span>
<span class="pc bpc" id="L1297" title="1 of 2 branches missed.">	   Double.isNaN(m_MI_MinArray[attrIndex]) ||</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">	   m_MI_MaxArray[attrIndex] &lt; inst.value(attrIndex) || </span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">	   inst.value(attrIndex) &lt; m_MI_MinArray[attrIndex]){</span>

	  /* then update them */
<span class="fc bfc" id="L1302" title="All 2 branches covered.">	  if(Double.isNaN(m_MI_MaxArray[attrIndex])) m_MI_MaxArray[attrIndex] = inst.value(attrIndex);</span>
<span class="fc bfc" id="L1303" title="All 2 branches covered.">	  if(Double.isNaN(m_MI_MinArray[attrIndex])) m_MI_MinArray[attrIndex] = inst.value(attrIndex);</span>
<span class="fc bfc" id="L1304" title="All 2 branches covered.">	  if(m_MI_MaxArray[attrIndex] &lt; inst.value(attrIndex)) m_MI_MaxArray[attrIndex] = inst.value(attrIndex);</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">	  if(m_MI_MinArray[attrIndex] &gt; inst.value(attrIndex)) m_MI_MinArray[attrIndex] = inst.value(attrIndex);</span>
		    
	  /* and re-compute everything from scratch... (just for this attribute) */
<span class="fc" id="L1308">	  double delta = (m_MI_MaxArray[attrIndex] - m_MI_MinArray[attrIndex]) / (double) m_NumFoldersMI;</span>

	  /* for each interval */
<span class="fc bfc" id="L1311" title="All 2 branches covered.">	  for(int inter = 0; inter &lt; m_NumFoldersMI; inter++){</span>

<span class="fc" id="L1313">	    m_MI_NumAttrInter[attrIndex][inter] = 0;</span>

	    /* for each class */
<span class="fc bfc" id="L1316" title="All 2 branches covered.">	    for(int cclass = 0; cclass &lt; m_Train.numClasses(); cclass++){</span>
			    
<span class="fc" id="L1318">	      m_MI_NumAttrClassInter[attrIndex][cclass][inter] = 0;</span>

	      /* count */
<span class="fc" id="L1321">	      Enumeration enu = m_Train.enumerateInstances();</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">	      while(enu.hasMoreElements()){</span>
<span class="fc" id="L1323">		Instance cur = (Instance) enu.nextElement();</span>
<span class="fc bfc" id="L1324" title="All 2 branches covered.">		if(( (m_MI_MinArray[attrIndex] + inter * delta) &lt;= cur.value(attrIndex)       ) &amp;&amp;</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">		   ( cur.value(attrIndex) &lt;= (m_MI_MinArray[attrIndex] + (inter + 1) * delta) ) &amp;&amp;</span>
<span class="fc bfc" id="L1326" title="All 2 branches covered.">		   ( cur.classValue() == cclass ) ){</span>
<span class="fc" id="L1327">		  m_MI_NumAttrInter[attrIndex][inter]++;</span>
<span class="fc" id="L1328">		  m_MI_NumAttrClassInter[attrIndex][cclass][inter]++;</span>
		}
	      }
	    }
	  }
		
	  /* max-min don't have to be updated */
	} else {

	  /* still have to incr the card of the correct interval */
<span class="fc" id="L1338">	  double delta = (m_MI_MaxArray[attrIndex] - m_MI_MinArray[attrIndex]) / (double) m_NumFoldersMI;</span>
		    
	  /* for each interval */
<span class="fc bfc" id="L1341" title="All 2 branches covered.">	  for(int inter = 0; inter &lt; m_NumFoldersMI; inter++){</span>
	    /* which contains inst*/
<span class="fc bfc" id="L1343" title="All 2 branches covered.">	    if(( (m_MI_MinArray[attrIndex] + inter * delta) &lt;= inst.value(attrIndex)       ) &amp;&amp;</span>
<span class="fc bfc" id="L1344" title="All 2 branches covered.">	       ( inst.value(attrIndex) &lt;= (m_MI_MinArray[attrIndex] + (inter + 1) * delta) )){</span>
<span class="fc" id="L1345">	      m_MI_NumAttrInter[attrIndex][inter]++;</span>
<span class="fc" id="L1346">	      m_MI_NumAttrClassInter[attrIndex][(int) inst.classValue()][inter]++;</span>
	    }
	  }
	}
		
	/* update the mutual information of this attribute... */
<span class="fc" id="L1352">	m_MI[attrIndex] = 0;</span>
		
	/* for each interval, for each class */
<span class="fc bfc" id="L1355" title="All 2 branches covered.">	for(int inter = 0; inter &lt; m_NumFoldersMI; inter++){</span>
<span class="fc bfc" id="L1356" title="All 2 branches covered.">	  for(int cclass = 0; cclass &lt; m_Train.numClasses(); cclass++){</span>
<span class="fc" id="L1357">	    double pXY = ((double) m_MI_NumAttrClassInter[attrIndex][cclass][inter]) / ((double) m_MI_NumInst);</span>
<span class="fc" id="L1358">	    double pX = ((double) m_MI_NumClass[cclass]) / ((double) m_MI_NumInst);</span>
<span class="fc" id="L1359">	    double pY = ((double) m_MI_NumAttrInter[attrIndex][inter]) / ((double) m_MI_NumInst);</span>

<span class="fc bfc" id="L1361" title="All 2 branches covered.">	    if(pXY != 0)</span>
<span class="fc" id="L1362">	      m_MI[attrIndex] += pXY * Utils.log2(pXY / (pX * pY));</span>
	  }
	}
		
	/* which is a nominal attribute */
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">      } else if (m_Train.attribute(attrIndex).isNominal()){</span>
		
	/*incr the card of the correct 'values' */
<span class="fc" id="L1370">	m_MI_NumAttrValue[attrIndex][(int) inst.value(attrIndex)]++;</span>
<span class="fc" id="L1371">	m_MI_NumAttrClassValue[attrIndex][(int) inst.classValue()][(int) inst.value(attrIndex)]++;</span>
		
	/* update the mutual information of this attribute... */
<span class="fc" id="L1374">	m_MI[attrIndex] = 0;</span>
		
	/* for each nominal value, for each class */
<span class="fc bfc" id="L1377" title="All 2 branches covered.">	for(int attrValue = 0; attrValue &lt; m_Train.attribute(attrIndex).numValues() + 1; attrValue++){</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">	  for(int cclass = 0; cclass &lt; m_Train.numClasses(); cclass++){</span>
<span class="fc" id="L1379">	    double pXY = ((double) m_MI_NumAttrClassValue[attrIndex][cclass][attrValue]) / ((double) m_MI_NumInst);</span>
<span class="fc" id="L1380">	    double pX = ((double) m_MI_NumClass[cclass]) / ((double) m_MI_NumInst);</span>
<span class="fc" id="L1381">	    double pY = ((double) m_MI_NumAttrValue[attrIndex][attrValue]) / ((double) m_MI_NumInst);</span>
<span class="fc bfc" id="L1382" title="All 2 branches covered.">	    if(pXY != 0)</span>
<span class="fc" id="L1383">	      m_MI[attrIndex] += pXY * Utils.log2(pXY / (pX * pY));</span>
	  }
	}

	/* not a nominal attribute, not a numeric attribute */
      } else {
<span class="nc" id="L1389">	throw new Exception(&quot;NNge.updateMI : Cannot deal with 'string attribute'.&quot;);</span>
      }
    }	
<span class="fc" id="L1392">  }</span>


  /**
   * Init the weight of ex
   * Watch out ! ex shouldn't be in NNge's lists when initialized
   *
   * @param ex the Exemplar to initialise
   */
  private void initWeight(Exemplar ex) {	
<span class="fc" id="L1402">    int pos = 0, neg = 0, n = 0;</span>
<span class="fc" id="L1403">    Exemplar cur = m_Exemplars;</span>
<span class="fc bfc" id="L1404" title="All 2 branches covered.">    if (cur == null){</span>
<span class="fc" id="L1405">      ex.setPositiveCount(1);</span>
<span class="fc" id="L1406">      ex.setNegativeCount(0);</span>
<span class="fc" id="L1407">      return;</span>
    }
<span class="fc bfc" id="L1409" title="All 2 branches covered.">    while(cur != null){</span>
<span class="fc" id="L1410">      pos += cur.getPositiveCount();</span>
<span class="fc" id="L1411">      neg += cur.getNegativeCount();</span>
<span class="fc" id="L1412">      n++;</span>
<span class="fc" id="L1413">      cur = cur.next;</span>
    }
<span class="fc" id="L1415">    ex.setPositiveCount(pos / n);</span>
<span class="fc" id="L1416">    ex.setNegativeCount(neg / n);</span>
<span class="fc" id="L1417">  }</span>


  /**
   * Adds an Exemplar in NNge's lists
   * Ensure that the exemplar is not already in a list : the links would be broken...
   *
   * @param ex a new Exemplar to add
   */
  private void addExemplar(Exemplar ex) {
	
    /* add ex at the top of the general list */
<span class="fc" id="L1429">    ex.next = m_Exemplars;</span>
<span class="fc bfc" id="L1430" title="All 2 branches covered.">    if(m_Exemplars != null)</span>
<span class="fc" id="L1431">      m_Exemplars.previous = ex;</span>
<span class="fc" id="L1432">    ex.previous = null;</span>
<span class="fc" id="L1433">    m_Exemplars = ex;</span>

    /* add ex at the top of the corresponding class list */
<span class="fc" id="L1436">    ex.nextWithClass = m_ExemplarsByClass[(int) ex.classValue()];</span>
<span class="fc bfc" id="L1437" title="All 2 branches covered.">    if(m_ExemplarsByClass[(int) ex.classValue()] != null)</span>
<span class="fc" id="L1438">      m_ExemplarsByClass[(int) ex.classValue()].previousWithClass = ex;</span>
<span class="fc" id="L1439">    ex.previousWithClass = null;</span>
<span class="fc" id="L1440">    m_ExemplarsByClass[(int) ex.classValue()] = ex;</span>
<span class="fc" id="L1441">  }</span>


  /**
   * Removes an Exemplar from NNge's lists
   * Ensure that the Exemplar is actually in NNge's lists. 
   *   Likely to do something wrong if this condition is not respected.
   * Due to the list implementation, the Exemplar can appear only once in the lists : 
   *   once removed, the exemplar is not in the lists anymore.
   *
   * @param ex a new Exemplar to add
   */
  private void removeExemplar(Exemplar ex){

    /* remove from the general list */
<span class="fc bfc" id="L1456" title="All 2 branches covered.">    if(m_Exemplars == ex){</span>
<span class="fc" id="L1457">      m_Exemplars = ex.next;</span>
<span class="fc bfc" id="L1458" title="All 2 branches covered.">      if(m_Exemplars != null)</span>
<span class="fc" id="L1459">	m_Exemplars.previous = null;</span>
	
    } else {
<span class="fc" id="L1462">      ex.previous.next = ex.next;</span>
<span class="fc bfc" id="L1463" title="All 2 branches covered.">      if(ex.next != null){</span>
<span class="fc" id="L1464">	ex.next.previous = ex.previous;</span>
      }
    }
<span class="fc" id="L1467">    ex.next = ex.previous = null;</span>

    /* remove from the class list */
<span class="fc bfc" id="L1470" title="All 2 branches covered.">    if(m_ExemplarsByClass[(int) ex.classValue()] == ex){</span>
<span class="fc" id="L1471">      m_ExemplarsByClass[(int) ex.classValue()] = ex.nextWithClass;</span>
<span class="fc bfc" id="L1472" title="All 2 branches covered.">      if(m_ExemplarsByClass[(int) ex.classValue()] != null)</span>
<span class="fc" id="L1473">	m_ExemplarsByClass[(int) ex.classValue()].previousWithClass = null;</span>
	
    } else {
<span class="fc" id="L1476">      ex.previousWithClass.nextWithClass = ex.nextWithClass;</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">      if(ex.nextWithClass != null){</span>
<span class="fc" id="L1478">	ex.nextWithClass.previousWithClass = ex.previousWithClass;</span>
      }
    }
<span class="fc" id="L1481">    ex.nextWithClass = ex.previousWithClass = null;</span>
<span class="fc" id="L1482">  }</span>


  /**
   * returns the weight of indexth attribute
   *
   * @param index attribute's index
   * @return the weight of indexth attribute
   */
  private double attrWeight (int index) {
<span class="fc" id="L1492">    return m_MI[index];</span>
  }

    
  /**
   * Returns a description of this classifier.
   *
   * @return a description of this classifier as a string.
   */
  public String toString(){

    String s;
<span class="fc" id="L1504">    Exemplar cur = m_Exemplars;</span>
    int i;	

<span class="pc bpc" id="L1507" title="1 of 2 branches missed.">   if (m_MinArray == null) {</span>
<span class="fc" id="L1508">      return &quot;No classifier built&quot;;</span>
    }
<span class="nc" id="L1510">     int[] nbHypClass = new int[m_Train.numClasses()];</span>
<span class="nc" id="L1511">    int[] nbSingleClass = new int[m_Train.numClasses()];</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">    for(i = 0; i&lt;nbHypClass.length; i++){</span>
<span class="nc" id="L1513">      nbHypClass[i] = 0;</span>
<span class="nc" id="L1514">      nbSingleClass[i] = 0;</span>
    }
<span class="nc" id="L1516">    int nbHyp = 0, nbSingle = 0;</span>

<span class="nc" id="L1518">    s = &quot;\nNNGE classifier\n\nRules generated :\n&quot;;</span>

<span class="nc bnc" id="L1520" title="All 2 branches missed.">    while(cur != null){</span>
<span class="nc" id="L1521">      s += &quot;\tclass &quot; + m_Train.attribute(m_Train.classIndex()).value((int) cur.classValue()) + &quot; IF : &quot;;</span>
<span class="nc" id="L1522">      s += cur.toRules() + &quot;\n&quot;;</span>
<span class="nc" id="L1523">      nbHyp++;</span>
<span class="nc" id="L1524">      nbHypClass[(int) cur.classValue()]++;	    </span>
<span class="nc bnc" id="L1525" title="All 2 branches missed.">      if (cur.numInstances() == 1){</span>
<span class="nc" id="L1526">	nbSingle++;</span>
<span class="nc" id="L1527">	nbSingleClass[(int) cur.classValue()]++;</span>
      }
<span class="nc" id="L1529">      cur = cur.next;</span>
    }
<span class="nc" id="L1531">    s += &quot;\nStat :\n&quot;;</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">    for(i = 0; i&lt;nbHypClass.length; i++){</span>
<span class="nc" id="L1533">      s += &quot;\tclass &quot; + m_Train.attribute(m_Train.classIndex()).value(i) + </span>
<span class="nc" id="L1534">	&quot; : &quot; + Integer.toString(nbHypClass[i]) + &quot; exemplar(s) including &quot; + </span>
<span class="nc" id="L1535">	Integer.toString(nbHypClass[i] - nbSingleClass[i]) + &quot; Hyperrectangle(s) and &quot; +</span>
<span class="nc" id="L1536">	Integer.toString(nbSingleClass[i]) + &quot; Single(s).\n&quot;;</span>
    }
<span class="nc" id="L1538">    s += &quot;\n\tTotal : &quot; + Integer.toString(nbHyp) + &quot; exemplars(s) including &quot; + </span>
<span class="nc" id="L1539">      Integer.toString(nbHyp - nbSingle) + &quot; Hyperrectangle(s) and &quot; +</span>
<span class="nc" id="L1540">      Integer.toString(nbSingle) + &quot; Single(s).\n&quot;;</span>
	
<span class="nc" id="L1542">    s += &quot;\n&quot;;</span>
	
<span class="nc" id="L1544">    s += &quot;\tFeature weights : &quot;;</span>

<span class="nc" id="L1546">    String space = &quot;[&quot;;</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">    for(int ii = 0; ii &lt; m_Train.numAttributes(); ii++){</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">      if(ii != m_Train.classIndex()){</span>
<span class="nc" id="L1549">	s += space + Double.toString(attrWeight(ii));</span>
<span class="nc" id="L1550">	space = &quot; &quot;;</span>
      }
    }
<span class="nc" id="L1553">    s += &quot;]&quot;;</span>
<span class="nc" id="L1554">    s += &quot;\n\n&quot;;</span>
<span class="nc" id="L1555">    return s;</span>
  }



  /** OPTION HANDLER FUNCTION */
    

  /**
   * Returns an enumeration of all the available options..
   *
   * @return an enumeration of all available options.
   */
  public Enumeration listOptions(){

<span class="fc" id="L1570">    Vector newVector = new Vector(2);</span>

<span class="fc" id="L1572">    newVector.addElement(new Option(</span>
<span class="fc" id="L1573">				    &quot;\tNumber of attempts of generalisation.\n&quot;,</span>
<span class="fc" id="L1574">				    &quot;G&quot;, </span>
<span class="fc" id="L1575">				    1, </span>
<span class="fc" id="L1576">				    &quot;-G &lt;value&gt;&quot;));</span>
<span class="fc" id="L1577">    newVector.addElement(new Option(</span>
<span class="fc" id="L1578">				    &quot;\tNumber of folder for computing the mutual information.\n&quot;,</span>
<span class="fc" id="L1579">				    &quot;I&quot;, </span>
<span class="fc" id="L1580">				    1, </span>
<span class="fc" id="L1581">				    &quot;-I &lt;value&gt;&quot;));</span>

<span class="fc" id="L1583">    return newVector.elements();</span>
  }

    
  /**
   * Sets the OptionHandler's options using the given list. All options
   * will be set (or reset) during this call (i.e. incremental setting
   * of options is not possible). &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -G &amp;lt;value&amp;gt;
   *  Number of attempts of generalisation.
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;value&amp;gt;
   *  Number of folder for computing the mutual information.
   * &lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

    String str;

    /* Number max of attempts of generalisation */
<span class="fc" id="L1613">    str = Utils.getOption('G', options);</span>
<span class="fc bfc" id="L1614" title="All 2 branches covered.">    if(str.length() != 0){</span>
<span class="fc" id="L1615">      m_NumAttemptsOfGene = Integer.parseInt(str);</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">      if(m_NumAttemptsOfGene &lt; 1)</span>
<span class="nc" id="L1617">	throw new Exception(&quot;NNge.setOptions : G option's value must be greater than 1.&quot;);</span>
    } else {
<span class="fc" id="L1619">      m_NumAttemptsOfGene = 5;</span>
    }

    /* Number of folder for computing the mutual information */
<span class="fc" id="L1623">    str = Utils.getOption('I', options);</span>
<span class="fc bfc" id="L1624" title="All 2 branches covered.">    if(str.length() != 0){</span>
<span class="fc" id="L1625">      m_NumFoldersMI = Integer.parseInt(str);</span>
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">      if(m_NumFoldersMI &lt; 1)</span>
<span class="nc" id="L1627">	throw new Exception(&quot;NNge.setOptions : I option's value must be greater than 1.&quot;);</span>
    } else {
<span class="fc" id="L1629">      m_NumFoldersMI = 5;</span>
    }
<span class="fc" id="L1631">  }</span>

    
  /**
   * Gets the current option settings for the OptionHandler.
   *
   * @return the list of current option settings as an array of strings
   */
  public String[] getOptions(){

<span class="fc" id="L1641">    String[] options = new String[5];</span>
<span class="fc" id="L1642">    int current = 0;</span>

<span class="fc" id="L1644">    options[current++] = &quot;-G&quot;; options[current++] = &quot;&quot; + m_NumAttemptsOfGene;</span>
<span class="fc" id="L1645">    options[current++] = &quot;-I&quot;; options[current++] = &quot;&quot; + m_NumFoldersMI;</span>

<span class="fc bfc" id="L1647" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L1648">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L1650">    return options;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numAttemptsOfGeneOptionTipText() {
<span class="nc" id="L1659">    return &quot;Sets the number of attempts for generalization.&quot;;</span>
  }

  /**
   * Gets the number of attempts for generalisation.
   *
   * @return the value of the option G
   */
  public int getNumAttemptsOfGeneOption() {
<span class="nc" id="L1668">    return m_NumAttemptsOfGene;</span>
  }


  /**
   * Sets the number of attempts for generalisation.
   *
   * @param newIntParameter the new value.
   */
  public void setNumAttemptsOfGeneOption(int newIntParameter) {
<span class="nc" id="L1678">    m_NumAttemptsOfGene = newIntParameter;</span>
<span class="nc" id="L1679">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numFoldersMIOptionTipText() {
<span class="nc" id="L1687">    return &quot;Sets the number of folder for mutual information.&quot;;</span>
  }

  /**
   * Gets the number of folder for mutual information.
   *
   * @return the value of the option I
   */
  public int getNumFoldersMIOption() {
<span class="nc" id="L1696">    return m_NumFoldersMI;</span>
  }

  /**
   * Sets the number of folder for mutual information.
   *
   * @param newIntParameter the new value.
   */
  public void setNumFoldersMIOption(int newIntParameter) {
<span class="nc" id="L1705">    m_NumFoldersMI = newIntParameter;</span>
<span class="nc" id="L1706">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1714">    return RevisionUtils.extract(&quot;$Revision: 5529 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv should contain command line arguments for evaluation
   * (see Evaluation).
   */
  public static void main(String [] argv) {
<span class="nc" id="L1724">    runClassifier(new NNge(), argv);</span>
<span class="nc" id="L1725">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>