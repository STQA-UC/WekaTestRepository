<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>AveragingResultProducer.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.experiment</a> &gt; <span class="el_source">AveragingResultProducer.java</span></div><h1>AveragingResultProducer.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    AveragingResultProducer.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */


package weka.experiment;

import weka.core.AdditionalMeasureProducer;
import weka.core.FastVector;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Takes the results from a ResultProducer and submits the average to the result listener. Normally used with a CrossValidationResultProducer to perform n x m fold cross validation. For non-numeric result fields, the first value is used.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -F &amp;lt;field name&amp;gt;
 *  The name of the field to average over.
 *  (default &quot;Fold&quot;)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -X &amp;lt;num results&amp;gt;
 *  The number of results expected per average.
 *  (default 10)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Calculate standard deviations.
 *  (default only averages)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
 *  The full class name of a ResultProducer.
 *  eg: weka.experiment.CrossValidationResultProducer&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to result producer weka.experiment.CrossValidationResultProducer:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
 *  The number of folds to use for the cross-validation.
 *  (default 10)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 * Save raw split evaluator output.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O &amp;lt;file/directory name/path&amp;gt;
 *  The filename where raw output will be stored.
 *  If a directory name is specified then then individual
 *  outputs will be gzipped, otherwise all output will be
 *  zipped to the named file. Use in conjuction with -D. (default splitEvalutorOut.zip)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
 *  The full class name of a SplitEvaluator.
 *  eg: weka.experiment.ClassifierSplitEvaluator&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to split evaluator weka.experiment.ClassifierSplitEvaluator:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
 *  The full class name of the classifier.
 *  eg: weka.classifiers.bayes.NaiveBayes&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;index&amp;gt;
 *  The index of the class for which IR statistics
 *  are to be output. (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;index&amp;gt;
 *  The index of an attribute to output in the
 *  results. This attribute should identify an
 *  instance in order to know which instances are
 *  in the test set of a cross validation. if 0
 *  no output (default 0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P
 *  Add target and prediction columns to the result
 *  for each fold.&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to classifier weka.classifiers.rules.ZeroR:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * All options after -- will be passed to the result producer.
 * 
 * @author Len Trigg (trigg@cs.waikato.ac.nz)
 * @version $Revision: 6419 $
 */
<span class="nc" id="L123">public class AveragingResultProducer </span>
  implements ResultListener, ResultProducer, OptionHandler,
	     AdditionalMeasureProducer, RevisionHandler {

  /** for serialization */
  static final long serialVersionUID = 2551284958501991352L;
  
  /** The dataset of interest */
  protected Instances m_Instances;

  /** The ResultListener to send results to */
<span class="nc" id="L134">  protected ResultListener m_ResultListener = new CSVResultListener();</span>

  /** The ResultProducer used to generate results */
<span class="nc" id="L137">  protected ResultProducer m_ResultProducer</span>
<span class="nc" id="L138">    = new CrossValidationResultProducer();</span>

  /** The names of any additional measures to look for in SplitEvaluators */
<span class="nc" id="L141">  protected String [] m_AdditionalMeasures = null;</span>
  
  /** The number of results expected to average over for each run */
<span class="nc" id="L144">  protected int m_ExpectedResultsPerAverage = 10;</span>

  /** True if standard deviation fields should be produced */
  protected boolean m_CalculateStdDevs;
    
  /**
   * The name of the field that will contain the number of results
   * averaged over.
   */
<span class="nc" id="L153">  protected String m_CountFieldName = &quot;Num_&quot; + CrossValidationResultProducer</span>
<span class="nc" id="L154">    .FOLD_FIELD_NAME;</span>

  /** The name of the key field to average over */
<span class="nc" id="L157">  protected String m_KeyFieldName = CrossValidationResultProducer</span>
<span class="nc" id="L158">    .FOLD_FIELD_NAME;</span>

  /** The index of the field to average over in the resultproducers key */
<span class="nc" id="L161">  protected int m_KeyIndex = -1;</span>

  /** Collects the keys from a single run */
<span class="nc" id="L164">  protected FastVector m_Keys = new FastVector();</span>
  
  /** Collects the results from a single run */
<span class="nc" id="L167">  protected FastVector m_Results = new FastVector();</span>

  /**
   * Returns a string describing this result producer
   * @return a description of the result producer suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L175">    return &quot;Takes the results from a ResultProducer &quot;</span>
      +&quot;and submits the average to the result listener. Normally used with &quot;
      +&quot;a CrossValidationResultProducer to perform n x m fold cross &quot;
      +&quot;validation. For non-numeric result fields, the first value is used.&quot;;
  }

  /**
   * Scans through the key field names of the result producer to find
   * the index of the key field to average over. Sets the value of
   * m_KeyIndex to the index, or -1 if no matching key field was found.
   *
   * @return the index of the key field to average over
   */
  protected int findKeyIndex() {

<span class="nc" id="L190">    m_KeyIndex = -1;</span>
    try {
<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (m_ResultProducer != null) {</span>
<span class="nc" id="L193">	String [] keyNames = m_ResultProducer.getKeyNames();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">	for (int i = 0; i &lt; keyNames.length; i++) {</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">	  if (keyNames[i].equals(m_KeyFieldName)) {</span>
<span class="nc" id="L196">	    m_KeyIndex = i;</span>
<span class="nc" id="L197">	    break;</span>
	  }
	}
      }
<span class="nc" id="L201">    } catch (Exception ex) {</span>
    }
<span class="nc" id="L203">    return m_KeyIndex;</span>
  }

  /**
   * Determines if there are any constraints (imposed by the
   * destination) on the result columns to be produced by
   * resultProducers. Null should be returned if there are NO
   * constraints, otherwise a list of column names should be
   * returned as an array of Strings.
   * @param rp the ResultProducer to which the constraints will apply
   * @return an array of column names to which resutltProducer's
   * results will be restricted.
   * @throws Exception if constraints can't be determined
   */
  public String [] determineColumnConstraints(ResultProducer rp) 
    throws Exception {
<span class="nc" id="L219">    return null;</span>
  }

  /**
   * Simulates a run to collect the keys the sub-resultproducer could
   * generate. Does some checking on the keys and determines the 
   * template key.
   *
   * @param run the run number
   * @return a template key (null for the field being averaged)
   * @throws Exception if an error occurs
   */
  protected Object [] determineTemplate(int run) throws Exception {

<span class="nc bnc" id="L233" title="All 2 branches missed.">    if (m_Instances == null) {</span>
<span class="nc" id="L234">      throw new Exception(&quot;No Instances set&quot;);</span>
    }
<span class="nc" id="L236">    m_ResultProducer.setInstances(m_Instances);</span>

    // Clear the collected results
<span class="nc" id="L239">    m_Keys.removeAllElements();</span>
<span class="nc" id="L240">    m_Results.removeAllElements();</span>
    
<span class="nc" id="L242">    m_ResultProducer.doRunKeys(run);</span>
<span class="nc" id="L243">    checkForMultipleDifferences();</span>

<span class="nc" id="L245">    Object [] template = (Object [])((Object [])m_Keys.elementAt(0)).clone();</span>
<span class="nc" id="L246">    template[m_KeyIndex] = null;</span>
    // Check for duplicate keys
<span class="nc" id="L248">    checkForDuplicateKeys(template);</span>

<span class="nc" id="L250">    return template;</span>
  }

  /**
   * Gets the keys for a specified run number. Different run
   * numbers correspond to different randomizations of the data. Keys
   * produced should be sent to the current ResultListener
   *
   * @param run the run number to get keys for.
   * @throws Exception if a problem occurs while getting the keys
   */
  public void doRunKeys(int run) throws Exception {

    // Generate the template
<span class="nc" id="L264">    Object [] template = determineTemplate(run);</span>
<span class="nc" id="L265">    String [] newKey = new String [template.length - 1];</span>
<span class="nc" id="L266">    System.arraycopy(template, 0, newKey, 0, m_KeyIndex);</span>
<span class="nc" id="L267">    System.arraycopy(template, m_KeyIndex + 1,</span>
<span class="nc" id="L268">		     newKey, m_KeyIndex,</span>
<span class="nc" id="L269">		     template.length - m_KeyIndex - 1);</span>
<span class="nc" id="L270">    m_ResultListener.acceptResult(this, newKey, null);      </span>
<span class="nc" id="L271">  }</span>

  /**
   * Gets the results for a specified run number. Different run
   * numbers correspond to different randomizations of the data. Results
   * produced should be sent to the current ResultListener
   *
   * @param run the run number to get results for.
   * @throws Exception if a problem occurs while getting the results
   */
  public void doRun(int run) throws Exception {

    // Generate the key and ask whether the result is required
<span class="nc" id="L284">    Object [] template = determineTemplate(run);</span>
<span class="nc" id="L285">    String [] newKey = new String [template.length - 1];</span>
<span class="nc" id="L286">    System.arraycopy(template, 0, newKey, 0, m_KeyIndex);</span>
<span class="nc" id="L287">    System.arraycopy(template, m_KeyIndex + 1,</span>
<span class="nc" id="L288">		     newKey, m_KeyIndex,</span>
<span class="nc" id="L289">		     template.length - m_KeyIndex - 1);</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">    if (m_ResultListener.isResultRequired(this, newKey)) {</span>
      // Clear the collected keys
<span class="nc" id="L293">      m_Keys.removeAllElements();</span>
<span class="nc" id="L294">      m_Results.removeAllElements();</span>
      
<span class="nc" id="L296">      m_ResultProducer.doRun(run);</span>
      
      // Average the results collected
      //System.err.println(&quot;Number of results collected: &quot; + m_Keys.size());
      
      // Check that the keys only differ on the selected key field
<span class="nc" id="L302">      checkForMultipleDifferences();</span>
      
<span class="nc" id="L304">      template = (Object [])((Object [])m_Keys.elementAt(0)).clone();</span>
<span class="nc" id="L305">      template[m_KeyIndex] = null;</span>
      // Check for duplicate keys
<span class="nc" id="L307">      checkForDuplicateKeys(template);</span>
      // Calculate the average and submit it if necessary
<span class="nc" id="L309">      doAverageResult(template);</span>
    }
<span class="nc" id="L311">  }</span>

  
  /**
   * Compares a key to a template to see whether they match. Null
   * fields in the template are ignored in the matching.
   *
   * @param template the template to match against
   * @param test the key to test
   * @return true if the test key matches the template on all non-null template
   * fields
   */
  protected boolean matchesTemplate(Object [] template, Object [] test) {
    
<span class="nc bnc" id="L325" title="All 2 branches missed.">    if (template.length != test.length) {</span>
<span class="nc" id="L326">      return false;</span>
    }
<span class="nc bnc" id="L328" title="All 2 branches missed.">    for (int i = 0; i &lt; test.length; i++) {</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">      if ((template[i] != null) &amp;&amp; (!template[i].equals(test[i]))) {</span>
<span class="nc" id="L330">	return false;</span>
      }
    }
<span class="nc" id="L333">    return true;</span>
  }
  
  /**
   * Asks the resultlistener whether an average result is required, and
   * if so, calculates it.
   *
   * @param template the template to match keys against when calculating the
   * average
   * @throws Exception if an error occurs
   */
  protected void doAverageResult(Object [] template) throws Exception {

    // Generate the key and ask whether the result is required
<span class="nc" id="L347">    String [] newKey = new String [template.length - 1];</span>
<span class="nc" id="L348">    System.arraycopy(template, 0, newKey, 0, m_KeyIndex);</span>
<span class="nc" id="L349">    System.arraycopy(template, m_KeyIndex + 1,</span>
<span class="nc" id="L350">		     newKey, m_KeyIndex,</span>
<span class="nc" id="L351">		     template.length - m_KeyIndex - 1);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">    if (m_ResultListener.isResultRequired(this, newKey)) {</span>
<span class="nc" id="L353">      Object [] resultTypes = m_ResultProducer.getResultTypes();</span>
<span class="nc" id="L354">      Stats [] stats = new Stats [resultTypes.length];</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">      for (int i = 0; i &lt; stats.length; i++) {</span>
<span class="nc" id="L356">	stats[i] = new Stats();</span>
      }
<span class="nc" id="L358">      Object [] result = getResultTypes();</span>
<span class="nc" id="L359">      int numMatches = 0;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">      for (int i = 0; i &lt; m_Keys.size(); i++) {</span>
<span class="nc" id="L361">	Object [] currentKey = (Object [])m_Keys.elementAt(i);</span>
	// Skip non-matching keys
<span class="nc bnc" id="L363" title="All 2 branches missed.">	if (!matchesTemplate(template, currentKey)) {</span>
<span class="nc" id="L364">	  continue;</span>
	}
	// Add the results to the stats accumulator
<span class="nc" id="L367">	Object [] currentResult = (Object [])m_Results.elementAt(i);</span>
<span class="nc" id="L368">	numMatches++;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">	for (int j = 0; j &lt; resultTypes.length; j++) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">	  if (resultTypes[j] instanceof Double) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">	    if (currentResult[j] == null) {</span>

	      // set the stats object for this result to null---
	      // more than likely this is an additional measure field
	      // not supported by the low level split evaluator
<span class="nc bnc" id="L376" title="All 2 branches missed.">	      if (stats[j] != null) {</span>
<span class="nc" id="L377">		stats[j] = null;</span>
	      }
	      
	      /* throw new Exception(&quot;Null numeric result field found:\n&quot;
		 + DatabaseUtils.arrayToString(currentKey)
		 + &quot; -- &quot;
		 + DatabaseUtils
		 .arrayToString(currentResult)); */
	    }
<span class="nc bnc" id="L386" title="All 2 branches missed.">	    if (stats[j] != null) {</span>
<span class="nc" id="L387">	      double currentVal = ((Double)currentResult[j]).doubleValue();</span>
<span class="nc" id="L388">	      stats[j].add(currentVal);</span>
	    }
	  }
	}
      }
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (numMatches != m_ExpectedResultsPerAverage) {</span>
<span class="nc" id="L394">	throw new Exception(&quot;Expected &quot; + m_ExpectedResultsPerAverage</span>
<span class="nc" id="L395">			    + &quot; results matching key \&quot;&quot;</span>
<span class="nc" id="L396">			    + DatabaseUtils.arrayToString(template)</span>
<span class="nc" id="L397">			    + &quot;\&quot; but got &quot;</span>
<span class="nc" id="L398">			    + numMatches);</span>
      }
<span class="nc" id="L400">      result[0] = new Double(numMatches);</span>
<span class="nc" id="L401">      Object [] currentResult = (Object [])m_Results.elementAt(0);</span>
<span class="nc" id="L402">      int k = 1;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">      for (int j = 0; j &lt; resultTypes.length; j++) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">	if (resultTypes[j] instanceof Double) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">	  if (stats[j] != null) {</span>
<span class="nc" id="L406">	    stats[j].calculateDerived();</span>
<span class="nc" id="L407">	    result[k++] = new Double(stats[j].mean);</span>
	  } else {
<span class="nc" id="L409">	    result[k++] = null;</span>
	  }
<span class="nc bnc" id="L411" title="All 2 branches missed.">	  if (getCalculateStdDevs()) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">	    if (stats[j] != null) {</span>
<span class="nc" id="L413">	      result[k++] = new Double(stats[j].stdDev);</span>
	    } else {
<span class="nc" id="L415">	      result[k++] = null;</span>
	    }
	  }
	} else {
<span class="nc" id="L419">	  result[k++] = currentResult[j];</span>
	}
      }
<span class="nc" id="L422">      m_ResultListener.acceptResult(this, newKey, result);      </span>
    }
<span class="nc" id="L424">  }</span>
  
  /**
   * Checks whether any duplicate results (with respect to a key template)
   * were received.
   *
   * @param template the template key.
   * @throws Exception if duplicate results are detected
   */
  protected void checkForDuplicateKeys(Object [] template) throws Exception {

<span class="nc" id="L435">    Hashtable hash = new Hashtable();</span>
<span class="nc" id="L436">    int numMatches = 0;</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">    for (int i = 0; i &lt; m_Keys.size(); i++) {</span>
<span class="nc" id="L438">      Object [] current = (Object [])m_Keys.elementAt(i);</span>
      // Skip non-matching keys
<span class="nc bnc" id="L440" title="All 2 branches missed.">      if (!matchesTemplate(template, current)) {</span>
<span class="nc" id="L441">	continue;</span>
      }
<span class="nc bnc" id="L443" title="All 2 branches missed.">      if (hash.containsKey(current[m_KeyIndex])) {</span>
<span class="nc" id="L444">	throw new Exception(&quot;Duplicate result received:&quot;</span>
<span class="nc" id="L445">			    + DatabaseUtils.arrayToString(current));</span>
      }
<span class="nc" id="L447">      numMatches++;</span>
<span class="nc" id="L448">      hash.put(current[m_KeyIndex], current[m_KeyIndex]);</span>
    }
<span class="nc bnc" id="L450" title="All 2 branches missed.">    if (numMatches != m_ExpectedResultsPerAverage) {</span>
<span class="nc" id="L451">      throw new Exception(&quot;Expected &quot; + m_ExpectedResultsPerAverage</span>
<span class="nc" id="L452">			  + &quot; results matching key \&quot;&quot;</span>
<span class="nc" id="L453">			  + DatabaseUtils.arrayToString(template)</span>
<span class="nc" id="L454">			  + &quot;\&quot; but got &quot;</span>
<span class="nc" id="L455">			  + numMatches);</span>
    }
<span class="nc" id="L457">  }</span>
  
  /**
   * Checks that the keys for a run only differ in one key field. If they
   * differ in more than one field, a more sophisticated averager will submit
   * multiple results - for now an exception is thrown. Currently assumes that
   * the most differences will be shown between the first and last
   * result received.
   *
   * @throws Exception if the keys differ on fields other than the
   * key averaging field
   */
  protected void checkForMultipleDifferences() throws Exception {
    
<span class="nc" id="L471">    Object [] firstKey = (Object [])m_Keys.elementAt(0);</span>
<span class="nc" id="L472">    Object [] lastKey = (Object [])m_Keys.elementAt(m_Keys.size() - 1);</span>
    /*
    System.err.println(&quot;First key:&quot; +  DatabaseUtils.arrayToString(firstKey));
    System.err.println(&quot;Last key :&quot; + DatabaseUtils.arrayToString(lastKey));
    */
<span class="nc bnc" id="L477" title="All 2 branches missed.">    for (int i = 0; i &lt; firstKey.length; i++) {</span>
<span class="nc bnc" id="L478" title="All 4 branches missed.">      if ((i != m_KeyIndex) &amp;&amp; !firstKey[i].equals(lastKey[i])) {</span>
<span class="nc" id="L479">	throw new Exception(&quot;Keys differ on fields other than \&quot;&quot;</span>
<span class="nc" id="L480">			    + m_KeyFieldName</span>
<span class="nc" id="L481">			    + &quot;\&quot; -- time to implement multiple averaging&quot;);</span>
      }
    }
<span class="nc" id="L484">  }</span>
  
  /**
   * Prepare for the results to be received.
   *
   * @param rp the ResultProducer that will generate the results
   * @throws Exception if an error occurs during preprocessing.
   */
  public void preProcess(ResultProducer rp) throws Exception {

<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (m_ResultListener == null) {</span>
<span class="nc" id="L495">      throw new Exception(&quot;No ResultListener set&quot;);</span>
    }
<span class="nc" id="L497">    m_ResultListener.preProcess(this);</span>
<span class="nc" id="L498">  }</span>

  /**
   * Prepare to generate results. The ResultProducer should call
   * preProcess(this) on the ResultListener it is to send results to.
   *
   * @throws Exception if an error occurs during preprocessing.
   */
  public void preProcess() throws Exception {
    
<span class="nc bnc" id="L508" title="All 2 branches missed.">    if (m_ResultProducer == null) {</span>
<span class="nc" id="L509">      throw new Exception(&quot;No ResultProducer set&quot;);</span>
    }
    // Tell the resultproducer to send results to us
<span class="nc" id="L512">    m_ResultProducer.setResultListener(this);</span>
<span class="nc" id="L513">    findKeyIndex();</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">    if (m_KeyIndex == -1) {</span>
<span class="nc" id="L515">      throw new Exception(&quot;No key field called &quot; + m_KeyFieldName</span>
<span class="nc" id="L516">			  + &quot; produced by &quot;</span>
<span class="nc" id="L517">			  + m_ResultProducer.getClass().getName());</span>
    }
<span class="nc" id="L519">    m_ResultProducer.preProcess();</span>
<span class="nc" id="L520">  }</span>
  
  /**
   * When this method is called, it indicates that no more results
   * will be sent that need to be grouped together in any way.
   *
   * @param rp the ResultProducer that generated the results
   * @throws Exception if an error occurs
   */
  public void postProcess(ResultProducer rp) throws Exception {

<span class="nc" id="L531">    m_ResultListener.postProcess(this);</span>
<span class="nc" id="L532">  }</span>

  /**
   * When this method is called, it indicates that no more requests to
   * generate results for the current experiment will be sent. The
   * ResultProducer should call preProcess(this) on the
   * ResultListener it is to send results to.
   *
   * @throws Exception if an error occurs
   */
  public void postProcess() throws Exception {

<span class="nc" id="L544">    m_ResultProducer.postProcess();</span>
<span class="nc" id="L545">  }</span>
  
  /**
   * Accepts results from a ResultProducer.
   *
   * @param rp the ResultProducer that generated the results
   * @param key an array of Objects (Strings or Doubles) that uniquely
   * identify a result for a given ResultProducer with given compatibilityState
   * @param result the results stored in an array. The objects stored in
   * the array may be Strings, Doubles, or null (for the missing value).
   * @throws Exception if the result could not be accepted.
   */
  public void acceptResult(ResultProducer rp, Object [] key, Object [] result)
    throws Exception {

<span class="nc bnc" id="L560" title="All 2 branches missed.">    if (m_ResultProducer != rp) {</span>
<span class="nc" id="L561">      throw new Error(&quot;Unrecognized ResultProducer sending results!!&quot;);</span>
    }
<span class="nc" id="L563">    m_Keys.addElement(key);</span>
<span class="nc" id="L564">    m_Results.addElement(result);</span>
<span class="nc" id="L565">  }</span>

  /**
   * Determines whether the results for a specified key must be
   * generated.
   *
   * @param rp the ResultProducer wanting to generate the results
   * @param key an array of Objects (Strings or Doubles) that uniquely
   * identify a result for a given ResultProducer with given compatibilityState
   * @return true if the result should be generated
   * @throws Exception if it could not be determined if the result 
   * is needed.
   */
  public boolean isResultRequired(ResultProducer rp, Object [] key) 
    throws Exception {

<span class="nc bnc" id="L581" title="All 2 branches missed.">    if (m_ResultProducer != rp) {</span>
<span class="nc" id="L582">      throw new Error(&quot;Unrecognized ResultProducer sending results!!&quot;);</span>
    }
<span class="nc" id="L584">    return true;</span>
  }

  /**
   * Gets the names of each of the columns produced for a single run.
   *
   * @return an array containing the name of each column
   * @throws Exception if key names cannot be generated
   */
  public String [] getKeyNames() throws Exception {

<span class="nc bnc" id="L595" title="All 2 branches missed.">    if (m_KeyIndex == -1) {</span>
<span class="nc" id="L596">      throw new Exception(&quot;No key field called &quot; + m_KeyFieldName</span>
<span class="nc" id="L597">			  + &quot; produced by &quot;</span>
<span class="nc" id="L598">			  + m_ResultProducer.getClass().getName());</span>
    }
<span class="nc" id="L600">    String [] keyNames = m_ResultProducer.getKeyNames();</span>
<span class="nc" id="L601">    String [] newKeyNames = new String [keyNames.length - 1];</span>
<span class="nc" id="L602">    System.arraycopy(keyNames, 0, newKeyNames, 0, m_KeyIndex);</span>
<span class="nc" id="L603">    System.arraycopy(keyNames, m_KeyIndex + 1,</span>
<span class="nc" id="L604">		     newKeyNames, m_KeyIndex,</span>
<span class="nc" id="L605">		     keyNames.length - m_KeyIndex - 1);</span>
<span class="nc" id="L606">    return newKeyNames;</span>
  }

  /**
   * Gets the data types of each of the columns produced for a single run.
   * This method should really be static.
   *
   * @return an array containing objects of the type of each column. The 
   * objects should be Strings, or Doubles.
   * @throws Exception if the key types could not be determined (perhaps
   * because of a problem from a nested sub-resultproducer)
   */
  public Object [] getKeyTypes() throws Exception {

<span class="nc bnc" id="L620" title="All 2 branches missed.">    if (m_KeyIndex == -1) {</span>
<span class="nc" id="L621">      throw new Exception(&quot;No key field called &quot; + m_KeyFieldName</span>
<span class="nc" id="L622">			  + &quot; produced by &quot;</span>
<span class="nc" id="L623">			  + m_ResultProducer.getClass().getName());</span>
    }
<span class="nc" id="L625">    Object [] keyTypes = m_ResultProducer.getKeyTypes();</span>
    // Find and remove the key field that is being averaged over
<span class="nc" id="L627">    Object [] newKeyTypes = new String [keyTypes.length - 1];</span>
<span class="nc" id="L628">    System.arraycopy(keyTypes, 0, newKeyTypes, 0, m_KeyIndex);</span>
<span class="nc" id="L629">    System.arraycopy(keyTypes, m_KeyIndex + 1,</span>
<span class="nc" id="L630">		     newKeyTypes, m_KeyIndex,</span>
<span class="nc" id="L631">		     keyTypes.length - m_KeyIndex - 1);</span>
<span class="nc" id="L632">    return newKeyTypes;</span>
  }

  /**
   * Gets the names of each of the columns produced for a single run.
   * A new result field is added for the number of results used to
   * produce each average.
   * If only averages are being produced the names are not altered, if
   * standard deviations are produced then &quot;Dev_&quot; and &quot;Avg_&quot; are prepended
   * to each result deviation and average field respectively.
   *
   * @return an array containing the name of each column
   * @throws Exception if the result names could not be determined (perhaps
   * because of a problem from a nested sub-resultproducer)
   */
  public String [] getResultNames() throws Exception {

<span class="nc" id="L649">    String [] resultNames = m_ResultProducer.getResultNames();</span>
    // Add in the names of our extra Result fields
<span class="nc bnc" id="L651" title="All 2 branches missed.">    if (getCalculateStdDevs()) {</span>
<span class="nc" id="L652">      Object [] resultTypes = m_ResultProducer.getResultTypes();</span>
<span class="nc" id="L653">      int numNumeric = 0;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">      for (int i = 0; i &lt; resultTypes.length; i++) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">	if (resultTypes[i] instanceof Double) {</span>
<span class="nc" id="L656">	  numNumeric++;</span>
	}
      }
<span class="nc" id="L659">      String [] newResultNames = new String [resultNames.length +</span>
<span class="nc" id="L660">					    1 + numNumeric];</span>
<span class="nc" id="L661">      newResultNames[0] = m_CountFieldName;</span>
<span class="nc" id="L662">      int j = 1;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">      for (int i = 0; i &lt; resultNames.length; i++) {</span>
<span class="nc" id="L664">	newResultNames[j++] = &quot;Avg_&quot; + resultNames[i];</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">	if (resultTypes[i] instanceof Double) {</span>
<span class="nc" id="L666">	  newResultNames[j++] = &quot;Dev_&quot; + resultNames[i];</span>
	}
      }
<span class="nc" id="L669">      return newResultNames;</span>
    } else {
<span class="nc" id="L671">      String [] newResultNames = new String [resultNames.length + 1];</span>
<span class="nc" id="L672">      newResultNames[0] = m_CountFieldName;</span>
<span class="nc" id="L673">      System.arraycopy(resultNames, 0, newResultNames, 1, resultNames.length);</span>
<span class="nc" id="L674">      return newResultNames;</span>
    }
  }

  /**
   * Gets the data types of each of the columns produced for a single run.
   *
   * @return an array containing objects of the type of each column. The 
   * objects should be Strings, or Doubles.
   * @throws Exception if the result types could not be determined (perhaps
   * because of a problem from a nested sub-resultproducer)
   */
  public Object [] getResultTypes() throws Exception {

<span class="nc" id="L688">    Object [] resultTypes = m_ResultProducer.getResultTypes();</span>
    // Add in the types of our extra Result fields
<span class="nc bnc" id="L690" title="All 2 branches missed.">    if (getCalculateStdDevs()) {</span>
<span class="nc" id="L691">      int numNumeric = 0;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">      for (int i = 0; i &lt; resultTypes.length; i++) {</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">	if (resultTypes[i] instanceof Double) {</span>
<span class="nc" id="L694">	  numNumeric++;</span>
	}
      }
<span class="nc" id="L697">      Object [] newResultTypes = new Object [resultTypes.length +</span>
<span class="nc" id="L698">					    1 + numNumeric];</span>
<span class="nc" id="L699">      newResultTypes[0] = new Double(0);</span>
<span class="nc" id="L700">      int j = 1;</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">      for (int i = 0; i &lt; resultTypes.length; i++) {</span>
<span class="nc" id="L702">	newResultTypes[j++] = resultTypes[i];</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">	if (resultTypes[i] instanceof Double) {</span>
<span class="nc" id="L704">	  newResultTypes[j++] = new Double(0);</span>
	}
      }
<span class="nc" id="L707">      return newResultTypes;</span>
    } else {
<span class="nc" id="L709">      Object [] newResultTypes = new Object [resultTypes.length + 1];</span>
<span class="nc" id="L710">      newResultTypes[0] = new Double(0);</span>
<span class="nc" id="L711">      System.arraycopy(resultTypes, 0, newResultTypes, 1, resultTypes.length);</span>
<span class="nc" id="L712">      return newResultTypes;</span>
    }
  }

  /**
   * Gets a description of the internal settings of the result
   * producer, sufficient for distinguishing a ResultProducer
   * instance from another with different settings (ignoring
   * those settings set through this interface). For example,
   * a cross-validation ResultProducer may have a setting for the
   * number of folds. For a given state, the results produced should
   * be compatible. Typically if a ResultProducer is an OptionHandler,
   * this string will represent the command line arguments required
   * to set the ResultProducer to that state.
   *
   * @return the description of the ResultProducer state, or null
   * if no state is defined
   */
  public String getCompatibilityState() {

<span class="nc" id="L732">    String result = // &quot;-F &quot; + Utils.quote(getKeyFieldName())</span>
<span class="nc" id="L733">      &quot; -X &quot; + getExpectedResultsPerAverage() + &quot; &quot;;</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">    if (getCalculateStdDevs()) {</span>
<span class="nc" id="L735">      result += &quot;-S &quot;;</span>
    }
<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (m_ResultProducer == null) {</span>
<span class="nc" id="L738">      result += &quot;&lt;null ResultProducer&gt;&quot;;</span>
    } else {
<span class="nc" id="L740">      result += &quot;-W &quot; + m_ResultProducer.getClass().getName();</span>
<span class="nc" id="L741">      result  += &quot; -- &quot; + m_ResultProducer.getCompatibilityState();</span>
    }

<span class="nc" id="L744">    return result.trim();</span>
  }


  /**
   * Returns an enumeration describing the available options..
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="nc" id="L755">    Vector newVector = new Vector(2);</span>

<span class="nc" id="L757">    newVector.addElement(new Option(</span>
<span class="nc" id="L758">	     &quot;\tThe name of the field to average over.\n&quot;</span>
	      +&quot;\t(default \&quot;Fold\&quot;)&quot;, 
<span class="nc" id="L760">	     &quot;F&quot;, 1, </span>
<span class="nc" id="L761">	     &quot;-F &lt;field name&gt;&quot;));</span>
<span class="nc" id="L762">    newVector.addElement(new Option(</span>
<span class="nc" id="L763">	     &quot;\tThe number of results expected per average.\n&quot;</span>
	      +&quot;\t(default 10)&quot;, 
<span class="nc" id="L765">	     &quot;X&quot;, 1, </span>
<span class="nc" id="L766">	     &quot;-X &lt;num results&gt;&quot;));</span>
<span class="nc" id="L767">    newVector.addElement(new Option(</span>
<span class="nc" id="L768">	     &quot;\tCalculate standard deviations.\n&quot;</span>
	      +&quot;\t(default only averages)&quot;, 
<span class="nc" id="L770">	     &quot;S&quot;, 0, </span>
<span class="nc" id="L771">	     &quot;-S&quot;));</span>
<span class="nc" id="L772">    newVector.addElement(new Option(</span>
<span class="nc" id="L773">	     &quot;\tThe full class name of a ResultProducer.\n&quot;</span>
	      +&quot;\teg: weka.experiment.CrossValidationResultProducer&quot;, 
<span class="nc" id="L775">	     &quot;W&quot;, 1, </span>
<span class="nc" id="L776">	     &quot;-W &lt;class name&gt;&quot;));</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">    if ((m_ResultProducer != null) &amp;&amp;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">	(m_ResultProducer instanceof OptionHandler)) {</span>
<span class="nc" id="L780">      newVector.addElement(new Option(</span>
<span class="nc" id="L781">	     &quot;&quot;,</span>
<span class="nc" id="L782">	     &quot;&quot;, 0, &quot;\nOptions specific to result producer &quot;</span>
<span class="nc" id="L783">	     + m_ResultProducer.getClass().getName() + &quot;:&quot;));</span>
<span class="nc" id="L784">      Enumeration enu = ((OptionHandler)m_ResultProducer).listOptions();</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">      while (enu.hasMoreElements()) {</span>
<span class="nc" id="L786">	newVector.addElement(enu.nextElement());</span>
      }
    }
<span class="nc" id="L789">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -F &amp;lt;field name&amp;gt;
   *  The name of the field to average over.
   *  (default &quot;Fold&quot;)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -X &amp;lt;num results&amp;gt;
   *  The number of results expected per average.
   *  (default 10)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Calculate standard deviations.
   *  (default only averages)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
   *  The full class name of a ResultProducer.
   *  eg: weka.experiment.CrossValidationResultProducer&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to result producer weka.experiment.CrossValidationResultProducer:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
   *  The number of folds to use for the cross-validation.
   *  (default 10)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   * Save raw split evaluator output.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O &amp;lt;file/directory name/path&amp;gt;
   *  The filename where raw output will be stored.
   *  If a directory name is specified then then individual
   *  outputs will be gzipped, otherwise all output will be
   *  zipped to the named file. Use in conjuction with -D. (default splitEvalutorOut.zip)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
   *  The full class name of a SplitEvaluator.
   *  eg: weka.experiment.ClassifierSplitEvaluator&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to split evaluator weka.experiment.ClassifierSplitEvaluator:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -W &amp;lt;class name&amp;gt;
   *  The full class name of the classifier.
   *  eg: weka.classifiers.bayes.NaiveBayes&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;index&amp;gt;
   *  The index of the class for which IR statistics
   *  are to be output. (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;index&amp;gt;
   *  The index of an attribute to output in the
   *  results. This attribute should identify an
   *  instance in order to know which instances are
   *  in the test set of a cross validation. if 0
   *  no output (default 0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P
   *  Add target and prediction columns to the result
   *  for each fold.&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to classifier weka.classifiers.rules.ZeroR:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * All options after -- will be passed to the result producer.
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    
<span class="nc" id="L875">    String keyFieldName = Utils.getOption('F', options);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if (keyFieldName.length() != 0) {</span>
<span class="nc" id="L877">      setKeyFieldName(keyFieldName);</span>
    } else {
<span class="nc" id="L879">      setKeyFieldName(CrossValidationResultProducer.FOLD_FIELD_NAME);</span>
    }

<span class="nc" id="L882">    String numResults = Utils.getOption('X', options);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">    if (numResults.length() != 0) {</span>
<span class="nc" id="L884">      setExpectedResultsPerAverage(Integer.parseInt(numResults));</span>
    } else {
<span class="nc" id="L886">      setExpectedResultsPerAverage(10);</span>
    }

<span class="nc" id="L889">    setCalculateStdDevs(Utils.getFlag('S', options));</span>
    
<span class="nc" id="L891">    String rpName = Utils.getOption('W', options);</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">    if (rpName.length() == 0) {</span>
<span class="nc" id="L893">      throw new Exception(&quot;A ResultProducer must be specified with&quot;</span>
			  + &quot; the -W option.&quot;);
    }
    // Do it first without options, so if an exception is thrown during
    // the option setting, listOptions will contain options for the actual
    // RP.
<span class="nc" id="L899">    setResultProducer((ResultProducer)Utils.forName(</span>
<span class="nc" id="L900">		      ResultProducer.class,</span>
<span class="nc" id="L901">		      rpName,</span>
<span class="nc" id="L902">		      null));</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">    if (getResultProducer() instanceof OptionHandler) {</span>
<span class="nc" id="L904">      ((OptionHandler) getResultProducer())</span>
<span class="nc" id="L905">	.setOptions(Utils.partitionOptions(options));</span>
    }
<span class="nc" id="L907">  }</span>

  /**
   * Gets the current settings of the result producer.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="nc" id="L916">    String [] seOptions = new String [0];</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">    if ((m_ResultProducer != null) &amp;&amp; </span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">	(m_ResultProducer instanceof OptionHandler)) {</span>
<span class="nc" id="L919">      seOptions = ((OptionHandler)m_ResultProducer).getOptions();</span>
    }
    
<span class="nc" id="L922">    String [] options = new String [seOptions.length + 8];</span>
<span class="nc" id="L923">    int current = 0;</span>

<span class="nc" id="L925">    options[current++] = &quot;-F&quot;;</span>
<span class="nc" id="L926">    options[current++] = &quot;&quot; + getKeyFieldName();</span>
<span class="nc" id="L927">    options[current++] = &quot;-X&quot;;</span>
<span class="nc" id="L928">    options[current++] = &quot;&quot; + getExpectedResultsPerAverage();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">    if (getCalculateStdDevs()) {</span>
<span class="nc" id="L930">      options[current++] = &quot;-S&quot;;</span>
    }
<span class="nc bnc" id="L932" title="All 2 branches missed.">    if (getResultProducer() != null) {</span>
<span class="nc" id="L933">      options[current++] = &quot;-W&quot;;</span>
<span class="nc" id="L934">      options[current++] = getResultProducer().getClass().getName();</span>
    }
<span class="nc" id="L936">    options[current++] = &quot;--&quot;;</span>

<span class="nc" id="L938">    System.arraycopy(seOptions, 0, options, current, </span>
<span class="nc" id="L939">		     seOptions.length);</span>
<span class="nc" id="L940">    current += seOptions.length;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">    while (current &lt; options.length) {</span>
<span class="nc" id="L942">      options[current++] = &quot;&quot;;</span>
    }
<span class="nc" id="L944">    return options;</span>
  }

  /**
   * Set a list of method names for additional measures to look for
   * in SplitEvaluators. This could contain many measures (of which only a
   * subset may be produceable by the current resultProducer) if an experiment
   * is the type that iterates over a set of properties.
   * @param additionalMeasures an array of measure names, null if none
   */
  public void setAdditionalMeasures(String [] additionalMeasures) {
<span class="nc" id="L955">    m_AdditionalMeasures = additionalMeasures;</span>

<span class="nc bnc" id="L957" title="All 2 branches missed.">    if (m_ResultProducer != null) {</span>
<span class="nc" id="L958">      System.err.println(&quot;AveragingResultProducer: setting additional &quot;</span>
			 +&quot;measures for &quot;
			 +&quot;ResultProducer&quot;);
<span class="nc" id="L961">      m_ResultProducer.setAdditionalMeasures(m_AdditionalMeasures);</span>
    }
<span class="nc" id="L963">  }</span>

  /**
   * Returns an enumeration of any additional measure names that might be
   * in the result producer
   * @return an enumeration of the measure names
   */
  public Enumeration enumerateMeasures() {
<span class="nc" id="L971">    Vector newVector = new Vector();</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">    if (m_ResultProducer instanceof AdditionalMeasureProducer) {</span>
<span class="nc" id="L973">      Enumeration en = ((AdditionalMeasureProducer)m_ResultProducer).</span>
<span class="nc" id="L974">	enumerateMeasures();</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">      while (en.hasMoreElements()) {</span>
<span class="nc" id="L976">	String mname = (String)en.nextElement();</span>
<span class="nc" id="L977">	newVector.addElement(mname);</span>
      }
    }
<span class="nc" id="L980">    return newVector.elements();</span>
  }

  /**
   * Returns the value of the named measure
   * @param additionalMeasureName the name of the measure to query for its value
   * @return the value of the named measure
   * @throws IllegalArgumentException if the named measure is not supported
   */
  public double getMeasure(String additionalMeasureName) {
<span class="nc bnc" id="L990" title="All 2 branches missed.">    if (m_ResultProducer instanceof AdditionalMeasureProducer) {</span>
<span class="nc" id="L991">      return ((AdditionalMeasureProducer)m_ResultProducer).</span>
<span class="nc" id="L992">	getMeasure(additionalMeasureName);</span>
    } else {
<span class="nc" id="L994">      throw new IllegalArgumentException(&quot;AveragingResultProducer: &quot;</span>
<span class="nc" id="L995">			  +&quot;Can't return value for : &quot;+additionalMeasureName</span>
<span class="nc" id="L996">			  +&quot;. &quot;+m_ResultProducer.getClass().getName()+&quot; &quot;</span>
<span class="nc" id="L997">			  +&quot;is not an AdditionalMeasureProducer&quot;);</span>
    }
  }

  /**
   * Sets the dataset that results will be obtained for.
   *
   * @param instances a value of type 'Instances'.
   */
  public void setInstances(Instances instances) {
    
<span class="nc" id="L1008">    m_Instances = instances;</span>
<span class="nc" id="L1009">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String calculateStdDevsTipText() {
<span class="nc" id="L1017">    return &quot;Record standard deviations for each run.&quot;;</span>
  }

  /**
   * Get the value of CalculateStdDevs.
   *
   * @return Value of CalculateStdDevs.
   */
  public boolean getCalculateStdDevs() {
    
<span class="nc" id="L1027">    return m_CalculateStdDevs;</span>
  }
  
  /**
   * Set the value of CalculateStdDevs.
   *
   * @param newCalculateStdDevs Value to assign to CalculateStdDevs.
   */
  public void setCalculateStdDevs(boolean newCalculateStdDevs) {
    
<span class="nc" id="L1037">    m_CalculateStdDevs = newCalculateStdDevs;</span>
<span class="nc" id="L1038">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String expectedResultsPerAverageTipText() {
<span class="nc" id="L1046">    return &quot;Set the expected number of results to average per run. &quot;</span>
      +&quot;For example if a CrossValidationResultProducer is being used &quot;
      +&quot;(with the number of folds set to 10), then the expected number &quot;
      +&quot;of results per run is 10.&quot;;
  }

  /**
   * Get the value of ExpectedResultsPerAverage.
   *
   * @return Value of ExpectedResultsPerAverage.
   */
  public int getExpectedResultsPerAverage() {
    
<span class="nc" id="L1059">    return m_ExpectedResultsPerAverage;</span>
  }
  
  /**
   * Set the value of ExpectedResultsPerAverage.
   *
   * @param newExpectedResultsPerAverage Value to assign to
   * ExpectedResultsPerAverage.
   */
  public void setExpectedResultsPerAverage(int newExpectedResultsPerAverage) {
    
<span class="nc" id="L1070">    m_ExpectedResultsPerAverage = newExpectedResultsPerAverage;</span>
<span class="nc" id="L1071">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String keyFieldNameTipText() {
<span class="nc" id="L1079">    return &quot;Set the field name that will be unique for a run.&quot;;</span>
  }

  /**
   * Get the value of KeyFieldName.
   *
   * @return Value of KeyFieldName.
   */
  public String getKeyFieldName() {
    
<span class="nc" id="L1089">    return m_KeyFieldName;</span>
  }
  
  /**
   * Set the value of KeyFieldName.
   *
   * @param newKeyFieldName Value to assign to KeyFieldName.
   */
  public void setKeyFieldName(String newKeyFieldName) {
    
<span class="nc" id="L1099">    m_KeyFieldName = newKeyFieldName;</span>
<span class="nc" id="L1100">    m_CountFieldName = &quot;Num_&quot; + m_KeyFieldName;</span>
<span class="nc" id="L1101">    findKeyIndex();</span>
<span class="nc" id="L1102">  }</span>
  
  /**
   * Sets the object to send results of each run to.
   *
   * @param listener a value of type 'ResultListener'
   */
  public void setResultListener(ResultListener listener) {

<span class="nc" id="L1111">    m_ResultListener = listener;</span>
<span class="nc" id="L1112">  }</span>
  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String resultProducerTipText() {
<span class="nc" id="L1120">    return &quot;Set the resultProducer for which results are to be averaged.&quot;;</span>
  }

  /**
   * Get the ResultProducer.
   *
   * @return the ResultProducer.
   */
  public ResultProducer getResultProducer() {
    
<span class="nc" id="L1130">    return m_ResultProducer;</span>
  }
  
  /**
   * Set the ResultProducer.
   *
   * @param newResultProducer new ResultProducer to use.
   */
  public void setResultProducer(ResultProducer newResultProducer) {

<span class="nc" id="L1140">    m_ResultProducer = newResultProducer;</span>
<span class="nc" id="L1141">    m_ResultProducer.setResultListener(this);</span>
<span class="nc" id="L1142">    findKeyIndex();</span>
<span class="nc" id="L1143">  }</span>

  /**
   * Gets a text descrption of the result producer.
   *
   * @return a text description of the result producer.
   */
  public String toString() {

<span class="nc" id="L1152">    String result = &quot;AveragingResultProducer: &quot;;</span>
<span class="nc" id="L1153">    result += getCompatibilityState();</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">    if (m_Instances == null) {</span>
<span class="nc" id="L1155">      result += &quot;: &lt;null Instances&gt;&quot;;</span>
    } else {
<span class="nc" id="L1157">      result += &quot;: &quot; + Utils.backQuoteChars(m_Instances.relationName());</span>
    }
<span class="nc" id="L1159">    return result;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1168">    return RevisionUtils.extract(&quot;$Revision: 6419 $&quot;);</span>
  }
} // AveragingResultProducer
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>