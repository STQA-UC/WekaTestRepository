<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>RotationForest.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.meta</a> &gt; <span class="el_source">RotationForest.java</span></div><h1>RotationForest.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    RotationForest.java
 *    Copyright (C) 2008 Juan Jose Rodriguez
 *    Copyright (C) 2008 University of Waikato, Hamilton, New Zealand
 *
 */


package weka.classifiers.meta;

import weka.classifiers.RandomizableIteratedSingleClassifierEnhancer;
import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Randomizable;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.core.TechnicalInformationHandler;
import weka.core.WeightedInstancesHandler;
import weka.core.Utils;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Normalize;
import weka.filters.unsupervised.attribute.PrincipalComponents;
import weka.filters.unsupervised.attribute.RemoveUseless;
import weka.filters.unsupervised.instance.RemovePercentage;

import java.util.Enumeration;
import java.util.LinkedList;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Class for construction a Rotation Forest. Can do classification and regression depending on the base learner. &lt;br/&gt;
 * &lt;br/&gt;
 * For more information, see&lt;br/&gt;
 * &lt;br/&gt;
 * Juan J. Rodriguez, Ludmila I. Kuncheva, Carlos J. Alonso (2006). Rotation Forest: A new classifier ensemble method. IEEE Transactions on Pattern Analysis and Machine Intelligence. 28(10):1619-1630. URL http://doi.ieeecomputersociety.org/10.1109/TPAMI.2006.211.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;article{Rodriguez2006,
 *    author = {Juan J. Rodriguez and Ludmila I. Kuncheva and Carlos J. Alonso},
 *    journal = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
 *    number = {10},
 *    pages = {1619-1630},
 *    title = {Rotation Forest: A new classifier ensemble method},
 *    volume = {28},
 *    year = {2006},
 *    ISSN = {0162-8828},
 *    URL = {http://doi.ieeecomputersociety.org/10.1109/TPAMI.2006.211}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -N
 *  Whether minGroup (-G) and maxGroup (-H) refer to
 *  the number of groups or their size.
 *  (default: false)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G &amp;lt;num&amp;gt;
 *  Minimum size of a group of attributes:
 *   if numberOfGroups is true, the minimum number
 *   of groups.
 *   (default: 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H &amp;lt;num&amp;gt;
 *  Maximum size of a group of attributes:
 *   if numberOfGroups is true, the maximum number
 *   of groups.
 *   (default: 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;num&amp;gt;
 *  Percentage of instances to be removed.
 *   (default: 50)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -F &amp;lt;filter specification&amp;gt;
 *  Full class name of filter to use, followed
 *  by filter options.
 *  eg: &quot;weka.filters.unsupervised.attribute.PrincipalComponents-R 1.0&quot;&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Random number seed.
 *  (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;num&amp;gt;
 *  Number of iterations.
 *  (default 10)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W
 *  Full name of base classifier.
 *  (default: weka.classifiers.trees.J48)&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to classifier weka.classifiers.trees.J48:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -U
 *  Use unpruned tree.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;pruning confidence&amp;gt;
 *  Set confidence threshold for pruning.
 *  (default 0.25)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;minimum number of instances&amp;gt;
 *  Set minimum number of instances per leaf.
 *  (default 2)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Use reduced error pruning.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;number of folds&amp;gt;
 *  Set number of folds for reduced error
 *  pruning. One fold is used as pruning set.
 *  (default 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -B
 *  Use binary splits only.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Don't perform subtree raising.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L
 *  Do not clean up after the tree has been built.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -A
 *  Laplace smoothing for predicted probabilities.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -Q &amp;lt;seed&amp;gt;
 *  Seed for random data shuffling (default 1).&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Juan Jose Rodriguez (jjrodriguez@ubu.es)
 * @version $Revision: 7012 $
 */
public class RotationForest 
  extends RandomizableIteratedSingleClassifierEnhancer
  implements WeightedInstancesHandler, TechnicalInformationHandler {
  // It implements WeightedInstancesHandler because the base classifier 
  // can implement this interface, but in this method the weights are
  // not used

  /** for serialization */
  static final long serialVersionUID = -3255631880798499936L;

  /** The minimum size of a group */
<span class="fc" id="L180">  protected int m_MinGroup = 3;</span>

  /** The maximum size of a group */
<span class="fc" id="L183">  protected int m_MaxGroup = 3;</span>

  /** 
   * Whether minGroup and maxGroup refer to the number of groups or their 
   * size */
<span class="fc" id="L188">  protected boolean m_NumberOfGroups = false;</span>

  /** The percentage of instances to be removed */
<span class="fc" id="L191">  protected int m_RemovedPercentage = 50;</span>

  /** The attributes of each group */
<span class="fc" id="L194">  protected int [][][] m_Groups = null;</span>

  /** The type of projection filter */
<span class="fc" id="L197">  protected Filter m_ProjectionFilter = null;</span>

  /** The projection filters */
<span class="fc" id="L200">  protected Filter [][] m_ProjectionFilters = null;</span>

  /** Headers of the transformed dataset */
<span class="fc" id="L203">  protected Instances [] m_Headers = null;</span>

  /** Headers of the reduced datasets */
<span class="fc" id="L206">  protected Instances [][] m_ReducedHeaders = null;</span>

  /** Filter that remove useless attributes */
<span class="fc" id="L209">  protected RemoveUseless m_RemoveUseless = null;</span>

  /** Filter that normalized the attributes */
<span class="fc" id="L212">  protected Normalize m_Normalize = null;</span>

  /**
   * Constructor.
   */
<span class="fc" id="L217">  public RotationForest() {</span>
    
<span class="fc" id="L219">    m_Classifier = new weka.classifiers.trees.J48();</span>
<span class="fc" id="L220">    m_ProjectionFilter = defaultFilter();</span>
<span class="fc" id="L221">  }</span>

  /**
   * Default projection method.
   */
  protected Filter defaultFilter() {
<span class="fc" id="L227">    PrincipalComponents filter = new PrincipalComponents();</span>
    //filter.setNormalize(false);
<span class="fc" id="L229">    filter.setVarianceCovered(1.0);</span>
<span class="fc" id="L230">    return filter;</span>
  }
  
  /**
   * Returns a string describing classifier
   * @return a description suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
 
<span class="nc" id="L240">    return &quot;Class for construction a Rotation Forest. Can do classification &quot;</span>
      + &quot;and regression depending on the base learner. \n\n&quot;
      + &quot;For more information, see\n\n&quot;
<span class="nc" id="L243">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L256">    result = new TechnicalInformation(Type.ARTICLE);</span>
<span class="nc" id="L257">    result.setValue(Field.AUTHOR, &quot;Juan J. Rodriguez and Ludmila I. Kuncheva and Carlos J. Alonso&quot;);</span>
<span class="nc" id="L258">    result.setValue(Field.YEAR, &quot;2006&quot;);</span>
<span class="nc" id="L259">    result.setValue(Field.TITLE, &quot;Rotation Forest: A new classifier ensemble method&quot;);</span>
<span class="nc" id="L260">    result.setValue(Field.JOURNAL, &quot;IEEE Transactions on Pattern Analysis and Machine Intelligence&quot;);</span>
<span class="nc" id="L261">    result.setValue(Field.VOLUME, &quot;28&quot;);</span>
<span class="nc" id="L262">    result.setValue(Field.NUMBER, &quot;10&quot;);</span>
<span class="nc" id="L263">    result.setValue(Field.PAGES, &quot;1619-1630&quot;);</span>
<span class="nc" id="L264">    result.setValue(Field.ISSN, &quot;0162-8828&quot;);</span>
<span class="nc" id="L265">    result.setValue(Field.URL, &quot;http://doi.ieeecomputersociety.org/10.1109/TPAMI.2006.211&quot;);</span>
    
<span class="nc" id="L267">    return result;</span>
  }

  /**
   * String describing default classifier.
   * 
   * @return the default classifier classname
   */
  protected String defaultClassifierString() {
    
<span class="fc" id="L277">    return &quot;weka.classifiers.trees.J48&quot;;</span>
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="fc" id="L287">    Vector newVector = new Vector(5);</span>

<span class="fc" id="L289">    newVector.addElement(new Option(</span>
<span class="fc" id="L290">              &quot;\tWhether minGroup (-G) and maxGroup (-H) refer to&quot;</span>
              + &quot;\n\tthe number of groups or their size.&quot;
              + &quot;\n\t(default: false)&quot;,
<span class="fc" id="L293">              &quot;N&quot;, 0, &quot;-N&quot;));</span>

<span class="fc" id="L295">    newVector.addElement(new Option(</span>
<span class="fc" id="L296">              &quot;\tMinimum size of a group of attributes:&quot;</span>
              + &quot;\n\t\tif numberOfGroups is true, the minimum number&quot;
              + &quot;\n\t\tof groups.&quot;
              + &quot;\n\t\t(default: 3)&quot;,
<span class="fc" id="L300">              &quot;G&quot;, 1, &quot;-G &lt;num&gt;&quot;));</span>

<span class="fc" id="L302">    newVector.addElement(new Option(</span>
<span class="fc" id="L303">              &quot;\tMaximum size of a group of attributes:&quot;</span>
              + &quot;\n\t\tif numberOfGroups is true, the maximum number&quot; 
              + &quot;\n\t\tof groups.&quot;
              + &quot;\n\t\t(default: 3)&quot;,
<span class="fc" id="L307">              &quot;H&quot;, 1, &quot;-H &lt;num&gt;&quot;));</span>

<span class="fc" id="L309">    newVector.addElement(new Option(</span>
<span class="fc" id="L310">              &quot;\tPercentage of instances to be removed.&quot;</span>
              + &quot;\n\t\t(default: 50)&quot;,
<span class="fc" id="L312">              &quot;P&quot;, 1, &quot;-P &lt;num&gt;&quot;));</span>

<span class="fc" id="L314">    newVector.addElement(new Option(</span>
<span class="fc" id="L315">	      &quot;\tFull class name of filter to use, followed\n&quot;</span>
	      + &quot;\tby filter options.\n&quot;
	      + &quot;\teg: \&quot;weka.filters.unsupervised.attribute.PrincipalComponents-R 1.0\&quot;&quot;,
<span class="fc" id="L318">	      &quot;F&quot;, 1, &quot;-F &lt;filter specification&gt;&quot;));</span>

<span class="fc" id="L320">    Enumeration enu = super.listOptions();</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">    while (enu.hasMoreElements()) {</span>
<span class="fc" id="L322">      newVector.addElement(enu.nextElement());</span>
    }
<span class="fc" id="L324">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -N
   *  Whether minGroup (-G) and maxGroup (-H) refer to
   *  the number of groups or their size.
   *  (default: false)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G &amp;lt;num&amp;gt;
   *  Minimum size of a group of attributes:
   *   if numberOfGroups is true, the minimum number
   *   of groups.
   *   (default: 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -H &amp;lt;num&amp;gt;
   *  Maximum size of a group of attributes:
   *   if numberOfGroups is true, the maximum number
   *   of groups.
   *   (default: 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;num&amp;gt;
   *  Percentage of instances to be removed.
   *   (default: 50)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -F &amp;lt;filter specification&amp;gt;
   *  Full class name of filter to use, followed
   *  by filter options.
   *  eg: &quot;weka.filters.unsupervised.attribute.PrincipalComponents-R 1.0&quot;&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Random number seed.
   *  (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;num&amp;gt;
   *  Number of iterations.
   *  (default 10)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W
   *  Full name of base classifier.
   *  (default: weka.classifiers.trees.J48)&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to classifier weka.classifiers.trees.J48:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -U
   *  Use unpruned tree.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;pruning confidence&amp;gt;
   *  Set confidence threshold for pruning.
   *  (default 0.25)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;minimum number of instances&amp;gt;
   *  Set minimum number of instances per leaf.
   *  (default 2)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Use reduced error pruning.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;number of folds&amp;gt;
   *  Set number of folds for reduced error
   *  pruning. One fold is used as pruning set.
   *  (default 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -B
   *  Use binary splits only.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Don't perform subtree raising.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L
   *  Do not clean up after the tree has been built.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -A
   *  Laplace smoothing for predicted probabilities.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -Q &amp;lt;seed&amp;gt;
   *  Seed for random data shuffling (default 1).&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

    /* Taken from FilteredClassifier */
<span class="fc" id="L421">    String filterString = Utils.getOption('F', options);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">    if (filterString.length() &gt; 0) {</span>
<span class="fc" id="L423">      String [] filterSpec = Utils.splitOptions(filterString);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">      if (filterSpec.length == 0) {</span>
<span class="nc" id="L425">	throw new IllegalArgumentException(&quot;Invalid filter specification string&quot;);</span>
      }
<span class="fc" id="L427">      String filterName = filterSpec[0];</span>
<span class="fc" id="L428">      filterSpec[0] = &quot;&quot;;</span>
<span class="fc" id="L429">      setProjectionFilter((Filter) Utils.forName(Filter.class, filterName, filterSpec));</span>
    } else {
<span class="fc" id="L431">      setProjectionFilter(defaultFilter());</span>
    }

    String tmpStr;
    
<span class="fc" id="L436">    tmpStr = Utils.getOption('G', options);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L438">      setMinGroup(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L440">      setMinGroup(3);</span>

<span class="fc" id="L442">    tmpStr = Utils.getOption('H', options);</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L444">      setMaxGroup(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L446">      setMaxGroup(3);</span>

<span class="fc" id="L448">    tmpStr = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L450">      setRemovedPercentage(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L452">      setRemovedPercentage(50);</span>

<span class="fc" id="L454">    setNumberOfGroups(Utils.getFlag('N', options));</span>

<span class="fc" id="L456">    super.setOptions(options);</span>
<span class="fc" id="L457">  }</span>

  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L466">    String [] superOptions = super.getOptions();</span>
<span class="fc" id="L467">    String [] options = new String [superOptions.length + 9];</span>

<span class="fc" id="L469">    int current = 0;</span>

<span class="pc bpc" id="L471" title="1 of 2 branches missed.">    if (getNumberOfGroups()) { </span>
<span class="nc" id="L472">      options[current++] = &quot;-N&quot;;</span>
    }

<span class="fc" id="L475">    options[current++] = &quot;-G&quot;; </span>
<span class="fc" id="L476">    options[current++] = &quot;&quot; + getMinGroup();</span>

<span class="fc" id="L478">    options[current++] = &quot;-H&quot;; </span>
<span class="fc" id="L479">    options[current++] = &quot;&quot; + getMaxGroup();</span>

<span class="fc" id="L481">    options[current++] = &quot;-P&quot;; </span>
<span class="fc" id="L482">    options[current++] = &quot;&quot; + getRemovedPercentage();</span>

<span class="fc" id="L484">    options[current++] = &quot;-F&quot;;</span>
<span class="fc" id="L485">    options[current++] = getProjectionFilterSpec();</span>

<span class="fc" id="L487">    System.arraycopy(superOptions, 0, options, current, </span>
<span class="fc" id="L488">		     superOptions.length);</span>

<span class="fc" id="L490">    current += superOptions.length;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L492">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L494">    return options;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numberOfGroupsTipText() {
<span class="nc" id="L503">    return &quot;Whether minGroup and maxGroup refer to the number of groups or their size.&quot;;</span>
  }

  /**
   * Set whether minGroup and maxGroup refer to the number of groups or their 
   * size
   *
   * @param numberOfGroups whether minGroup and maxGroup refer to the number 
   * of groups or their size
   */
  public void setNumberOfGroups(boolean numberOfGroups) {

<span class="fc" id="L515">    m_NumberOfGroups = numberOfGroups;</span>
<span class="fc" id="L516">  }</span>

  /**
   * Get whether minGroup and maxGroup refer to the number of groups or their 
   * size
   *
   * @return whether minGroup and maxGroup refer to the number of groups or 
   * their size
   */
  public boolean getNumberOfGroups() {

<span class="fc" id="L527">    return m_NumberOfGroups;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for displaying in the 
   * explorer/experimenter gui
   */
  public String minGroupTipText() {
<span class="nc" id="L536">    return &quot;Minimum size of a group (if numberOfGrups is true, the minimum number of groups.&quot;;</span>
  }

  /**
   * Sets the minimum size of a group.
   *
   * @param minGroup the minimum value.
   * of attributes.
   */
  public void setMinGroup( int minGroup ) throws IllegalArgumentException {

<span class="pc bpc" id="L547" title="1 of 2 branches missed.">    if( minGroup &lt;= 0 )</span>
<span class="nc" id="L548">      throw new IllegalArgumentException( &quot;MinGroup has to be positive.&quot; );</span>
<span class="fc" id="L549">    m_MinGroup = minGroup;</span>
<span class="fc" id="L550">  }</span>

  /**
   * Gets the minimum size of a group.
   *
   * @return 		the minimum value.
   */
  public int getMinGroup() {
<span class="fc" id="L558">    return m_MinGroup;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String maxGroupTipText() {
<span class="nc" id="L567">    return &quot;Maximum size of a group (if numberOfGrups is true, the maximum number of groups.&quot;;</span>
  }

  /**
   * Sets the maximum size of a group.
   *
   * @param maxGroup the maximum value.
   * of attributes.
   */
  public void setMaxGroup( int maxGroup ) throws IllegalArgumentException {
 
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">    if( maxGroup &lt;= 0 )</span>
<span class="nc" id="L579">      throw new IllegalArgumentException( &quot;MaxGroup has to be positive.&quot; );</span>
<span class="fc" id="L580">    m_MaxGroup = maxGroup;</span>
<span class="fc" id="L581">  }</span>

  /**
   * Gets the maximum size of a group.
   *
   * @return 		the maximum value.
   */
  public int getMaxGroup() {
<span class="fc" id="L589">    return m_MaxGroup;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String removedPercentageTipText() {
<span class="nc" id="L598">    return &quot;The percentage of instances to be removed.&quot;;</span>
  }

  /**
   * Sets the percentage of instance to be removed
   *
   * @param removedPercentage the percentage.
   */
  public void setRemovedPercentage( int removedPercentage ) throws IllegalArgumentException {

<span class="pc bpc" id="L608" title="1 of 2 branches missed.">    if( removedPercentage &lt; 0 )</span>
<span class="nc" id="L609">      throw new IllegalArgumentException( &quot;RemovedPercentage has to be &gt;=0.&quot; );</span>
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">    if( removedPercentage &gt;= 100 )</span>
<span class="nc" id="L611">      throw new IllegalArgumentException( &quot;RemovedPercentage has to be &lt;100.&quot; );</span>
 
<span class="fc" id="L613">    m_RemovedPercentage = removedPercentage;</span>
<span class="fc" id="L614">  }</span>

  /**
   * Gets the percentage of instances to be removed
   *
   * @return 		the percentage.
   */
  public int getRemovedPercentage() {
<span class="fc" id="L622">    return m_RemovedPercentage;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String projectionFilterTipText() {
<span class="nc" id="L631">    return &quot;The filter used to project the data (e.g., PrincipalComponents).&quot;;</span>
  }

  /**
   * Sets the filter used to project the data.
   *
   * @param projectionFilter the filter.
   */
  public void setProjectionFilter( Filter projectionFilter ) {

<span class="fc" id="L641">    m_ProjectionFilter = projectionFilter;</span>
<span class="fc" id="L642">  }</span>

  /**
   * Gets the filter used to project the data.
   *
   * @return 		the filter.
   */
  public Filter getProjectionFilter() {
<span class="fc" id="L650">    return m_ProjectionFilter;</span>
  }

  /**
   * Gets the filter specification string, which contains the class name of
   * the filter and any options to the filter
   *
   * @return the filter string.
   */
  /* Taken from FilteredClassifier */
  protected String getProjectionFilterSpec() {
    
<span class="fc" id="L662">    Filter c = getProjectionFilter();</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">    if (c instanceof OptionHandler) {</span>
<span class="fc" id="L664">      return c.getClass().getName() + &quot; &quot;</span>
<span class="fc" id="L665">	+ Utils.joinOptions(((OptionHandler)c).getOptions());</span>
    }
<span class="nc" id="L667">    return c.getClass().getName();</span>
  }

  /**
   * Returns description of the Rotation Forest classifier.
   *
   * @return description of the Rotation Forest classifier as a string
   */
  public String toString() {
    
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">    if (m_Classifiers == null) {</span>
<span class="fc" id="L678">      return &quot;RotationForest: No model built yet.&quot;;</span>
    }
<span class="nc" id="L680">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L681">    text.append(&quot;All the base classifiers: \n\n&quot;);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">    for (int i = 0; i &lt; m_Classifiers.length; i++)</span>
<span class="nc" id="L683">      text.append(m_Classifiers[i].toString() + &quot;\n\n&quot;);</span>
    
<span class="nc" id="L685">    return text.toString();</span>
  }

  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L694">    return RevisionUtils.extract(&quot;$Revision: 7012 $&quot;);</span>
  }

  /**
   * builds the classifier.
   *
   * @param data 	the training data to be used for generating the
   * 			classifier.
   * @throws Exception 	if the classifier could not be built successfully
   */
  public void buildClassifier(Instances data) throws Exception {

    // can classifier handle the data?
<span class="fc" id="L707">    getCapabilities().testWithFail(data);</span>

<span class="fc" id="L709">    data = new Instances( data );</span>
<span class="fc" id="L710">    super.buildClassifier(data);</span>

<span class="fc" id="L712">    checkMinMax(data);</span>

    Random random;
<span class="fc bfc" id="L715" title="All 2 branches covered.">    if( data.numInstances() &gt; 0 ) {</span>
      // This function fails if there are 0 instances
<span class="fc" id="L717">      random = data.getRandomNumberGenerator(m_Seed);</span>
    }
    else {
<span class="fc" id="L720">      random = new Random(m_Seed);</span>
    }

<span class="fc" id="L723">    m_RemoveUseless = new RemoveUseless();</span>
<span class="fc" id="L724">    m_RemoveUseless.setInputFormat(data);</span>
<span class="fc" id="L725">    data = Filter.useFilter(data, m_RemoveUseless);</span>

<span class="fc" id="L727">    m_Normalize = new Normalize();</span>
<span class="fc" id="L728">    m_Normalize.setInputFormat(data);</span>
<span class="fc" id="L729">    data = Filter.useFilter(data, m_Normalize);</span>

<span class="pc bpc" id="L731" title="1 of 2 branches missed.">    if(m_NumberOfGroups) {</span>
<span class="nc" id="L732">      generateGroupsFromNumbers(data, random);</span>
    }
    else {
<span class="fc" id="L735">      generateGroupsFromSizes(data, random);</span>
    }

<span class="fc" id="L738">    m_ProjectionFilters = new Filter[m_Groups.length][];</span>
<span class="fc bfc" id="L739" title="All 2 branches covered.">    for(int i = 0; i &lt; m_ProjectionFilters.length; i++ ) {</span>
<span class="fc" id="L740">      m_ProjectionFilters[i] = Filter.makeCopies( m_ProjectionFilter, </span>
<span class="fc" id="L741">          m_Groups[i].length );</span>
    }

<span class="fc" id="L744">    int numClasses = data.numClasses();</span>

    // Split the instances according to their class
<span class="fc" id="L747">    Instances [] instancesOfClass = new Instances[numClasses + 1]; </span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">    if( data.classAttribute().isNumeric() ) {</span>
<span class="nc" id="L749">      instancesOfClass = new Instances[numClasses]; </span>
<span class="nc" id="L750">      instancesOfClass[0] = data;</span>
    }
    else {
<span class="fc" id="L753">      instancesOfClass = new Instances[numClasses+1]; </span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">      for( int i = 0; i &lt; instancesOfClass.length; i++ ) {</span>
<span class="fc" id="L755">        instancesOfClass[ i ] = new Instances( data, 0 );</span>
      }
<span class="fc" id="L757">      Enumeration enu = data.enumerateInstances();</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">      while( enu.hasMoreElements() ) {</span>
<span class="fc" id="L759">        Instance instance = (Instance)enu.nextElement();</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">        if( instance.classIsMissing() ) {</span>
<span class="fc" id="L761">          instancesOfClass[numClasses].add( instance );</span>
	}
	else {
<span class="fc" id="L764">          int c = (int)instance.classValue();</span>
<span class="fc" id="L765">          instancesOfClass[c].add( instance );</span>
        }
      }
      // If there are not instances with a missing class, we do not need to
      // consider them
<span class="fc bfc" id="L770" title="All 2 branches covered.">      if( instancesOfClass[numClasses].numInstances() == 0 ) {</span>
<span class="fc" id="L771">        Instances [] tmp = instancesOfClass;</span>
<span class="fc" id="L772">        instancesOfClass =  new Instances[ numClasses ];</span>
<span class="fc" id="L773">        System.arraycopy( tmp, 0, instancesOfClass, 0, numClasses );</span>
      }
    }

    // These arrays keep the information of the transformed data set
<span class="fc" id="L778">    m_Headers = new Instances[ m_Classifiers.length ];</span>
<span class="fc" id="L779">    m_ReducedHeaders = new Instances[ m_Classifiers.length ][];</span>

    // Construction of the base classifiers
<span class="fc bfc" id="L782" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Classifiers.length; i++) {</span>
<span class="fc" id="L783">      m_ReducedHeaders[i] = new Instances[ m_Groups[i].length ];</span>
<span class="fc" id="L784">      FastVector transformedAttributes = new FastVector( data.numAttributes() );</span>

      // Construction of the dataset for each group of attributes
<span class="fc bfc" id="L787" title="All 2 branches covered.">      for( int j = 0; j &lt; m_Groups[ i ].length; j++ ) {</span>
<span class="fc" id="L788">        FastVector fv = new FastVector( m_Groups[i][j].length + 1 );</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        for( int k = 0; k &lt; m_Groups[i][j].length; k++ ) {</span>
<span class="fc" id="L790">          String newName = data.attribute( m_Groups[i][j][k] ).name()</span>
<span class="fc" id="L791">            + &quot;_&quot; + k;</span>
<span class="fc" id="L792">          fv.addElement( data.attribute( m_Groups[i][j][k] ).copy(newName) );</span>
        }
<span class="fc" id="L794">        fv.addElement( data.classAttribute( ).copy() );</span>
<span class="fc" id="L795">        Instances dataSubSet = new Instances( &quot;rotated-&quot; + i + &quot;-&quot; + j + &quot;-&quot;, </span>
<span class="fc" id="L796">	    fv, 0);</span>
<span class="fc" id="L797">        dataSubSet.setClassIndex( dataSubSet.numAttributes() - 1 );</span>

        // Select instances for the dataset
<span class="fc" id="L800">        m_ReducedHeaders[i][j] = new Instances( dataSubSet, 0 );</span>
<span class="fc" id="L801">        boolean [] selectedClasses = selectClasses( instancesOfClass.length, </span>
<span class="fc" id="L802">	      random );</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        for( int c = 0; c &lt; selectedClasses.length; c++ ) {</span>
<span class="fc bfc" id="L804" title="All 2 branches covered.">          if( !selectedClasses[c] )</span>
<span class="fc" id="L805">            continue;</span>
<span class="fc" id="L806">          Enumeration enu = instancesOfClass[c].enumerateInstances();</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">          while( enu.hasMoreElements() ) {</span>
<span class="fc" id="L808">            Instance instance = (Instance)enu.nextElement();</span>
<span class="fc" id="L809">            Instance newInstance = new Instance(dataSubSet.numAttributes());</span>
<span class="fc" id="L810">            newInstance.setDataset( dataSubSet );</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            for( int k = 0; k &lt; m_Groups[i][j].length; k++ ) {</span>
<span class="fc" id="L812">              newInstance.setValue( k, instance.value( m_Groups[i][j][k] ) );</span>
            }
<span class="fc" id="L814">            newInstance.setClassValue( instance.classValue( ) );</span>
<span class="fc" id="L815">            dataSubSet.add( newInstance );</span>
          }
        }

<span class="fc" id="L819">        dataSubSet.randomize(random);</span>
        // Remove a percentage of the instances
<span class="fc" id="L821">	Instances originalDataSubSet = dataSubSet;</span>
<span class="fc" id="L822">	dataSubSet.randomize(random);</span>
<span class="fc" id="L823">        RemovePercentage rp = new RemovePercentage();</span>
<span class="fc" id="L824">        rp.setPercentage( m_RemovedPercentage );</span>
<span class="fc" id="L825">        rp.setInputFormat( dataSubSet );</span>
<span class="fc" id="L826">        dataSubSet = Filter.useFilter( dataSubSet, rp );</span>
<span class="fc bfc" id="L827" title="All 2 branches covered.">	if( dataSubSet.numInstances() &lt; 2 ) {</span>
<span class="fc" id="L828">	  dataSubSet = originalDataSubSet;</span>
	}

        // Project de data
<span class="fc" id="L832">        m_ProjectionFilters[i][j].setInputFormat( dataSubSet );</span>
<span class="fc" id="L833">	Instances projectedData = null;</span>
	do {
	  try {
<span class="fc" id="L836">            projectedData = Filter.useFilter( dataSubSet, </span>
<span class="fc" id="L837">	        m_ProjectionFilters[i][j] );</span>
<span class="fc" id="L838">	  } catch ( Exception e ) {</span>
	    // The data could not be projected, we add some random instances
<span class="fc" id="L840">	    addRandomInstances( dataSubSet, 10, random );</span>
	  }
<span class="fc bfc" id="L842" title="All 2 branches covered.">	} while( projectedData == null );</span>

	// Include the projected attributes in the attributes of the 
	// transformed dataset
<span class="fc bfc" id="L846" title="All 2 branches covered.">        for( int a = 0; a &lt; projectedData.numAttributes() - 1; a++ ) {</span>
<span class="fc" id="L847">          String newName = projectedData.attribute(a).name() + &quot;_&quot; + j;</span>
<span class="fc" id="L848">          transformedAttributes.addElement( projectedData.attribute(a).copy(newName));</span>
        }
      }
      
<span class="fc" id="L852">      transformedAttributes.addElement( data.classAttribute().copy() );</span>
<span class="fc" id="L853">      Instances transformedData = new Instances( &quot;rotated-&quot; + i + &quot;-&quot;, </span>
<span class="fc" id="L854">        transformedAttributes, 0 );</span>
<span class="fc" id="L855">      transformedData.setClassIndex( transformedData.numAttributes() - 1 );</span>
<span class="fc" id="L856">      m_Headers[ i ] = new Instances( transformedData, 0 );</span>

      // Project all the training data
<span class="fc" id="L859">      Enumeration enu = data.enumerateInstances();</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">      while( enu.hasMoreElements() ) {</span>
<span class="fc" id="L861">        Instance instance = (Instance)enu.nextElement();</span>
<span class="fc" id="L862">        Instance newInstance = convertInstance( instance, i );</span>
<span class="fc" id="L863">        transformedData.add( newInstance );</span>
      }

      // Build the base classifier
<span class="pc bpc" id="L867" title="1 of 2 branches missed.">      if (m_Classifier instanceof Randomizable) {</span>
<span class="nc" id="L868">	((Randomizable) m_Classifiers[i]).setSeed(random.nextInt());</span>
      }
<span class="fc" id="L870">      m_Classifiers[i].buildClassifier( transformedData );</span>
    }

<span class="pc bpc" id="L873" title="1 of 2 branches missed.">    if(m_Debug){</span>
<span class="nc" id="L874">      printGroups();</span>
    }
<span class="fc" id="L876">  }</span>

  /** 
   * Adds random instances to the dataset.
   * 
   * @param dataset the dataset
   * @param numInstances the number of instances
   * @param random a random number generator
   */
  protected void addRandomInstances( Instances dataset, int numInstances, 
                                  Random random ) {
<span class="fc" id="L887">    int n = dataset.numAttributes();				</span>
<span class="fc" id="L888">    double [] v = new double[ n ];</span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">    for( int i = 0; i &lt; numInstances; i++ ) {</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">      for( int j = 0; j &lt; n; j++ ) {</span>
<span class="fc" id="L891">        Attribute att = dataset.attribute( j );</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        if( att.isNumeric() ) {</span>
<span class="fc" id="L893">	  v[ j ] = random.nextDouble();</span>
	}
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">	else if ( att.isNominal() ) { </span>
<span class="fc" id="L896">	  v[ j ] = random.nextInt( att.numValues() );</span>
	}
      }
<span class="fc" id="L899">      dataset.add( new Instance( 1, v ) );</span>
    }
<span class="fc" id="L901">  }</span>

  /** 
   * Checks m_MinGroup and m_MaxGroup
   * 
   * @param data the dataset
   */
  protected void checkMinMax(Instances data) {
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">    if( m_MinGroup &gt; m_MaxGroup ) {</span>
<span class="nc" id="L910">      int tmp = m_MaxGroup;</span>
<span class="nc" id="L911">      m_MaxGroup = m_MinGroup;</span>
<span class="nc" id="L912">      m_MinGroup = tmp;</span>
    }
    
<span class="fc" id="L915">    int n = data.numAttributes();</span>
<span class="fc bfc" id="L916" title="All 2 branches covered.">    if( m_MaxGroup &gt;= n )</span>
<span class="fc" id="L917">      m_MaxGroup = n - 1;</span>
<span class="fc bfc" id="L918" title="All 2 branches covered.">    if( m_MinGroup &gt;= n )</span>
<span class="fc" id="L919">      m_MinGroup = n - 1;</span>
<span class="fc" id="L920">  }</span>

  /** 
   * Selects a non-empty subset of the classes
   * 
   * @param numClasses         the number of classes
   * @param random 	       the random number generator.
   * @return a random subset of classes
   */
  protected boolean [] selectClasses( int numClasses, Random random ) {

<span class="fc" id="L931">    int numSelected = 0;</span>
<span class="fc" id="L932">    boolean selected[] = new boolean[ numClasses ];</span>

<span class="fc bfc" id="L934" title="All 2 branches covered.">    for( int i = 0; i &lt; selected.length; i++ ) {</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">      if(random.nextBoolean()) {</span>
<span class="fc" id="L936">        selected[i] = true;</span>
<span class="fc" id="L937">        numSelected++;</span>
      }
    }
<span class="fc bfc" id="L940" title="All 2 branches covered.">    if( numSelected == 0 ) {</span>
<span class="fc" id="L941">      selected[random.nextInt( selected.length )] = true;</span>
    }
<span class="fc" id="L943">    return selected;</span>
  }

  /**
   * generates the groups of attributes, given their minimum and maximum
   * sizes.
   *
   * @param data 	the training data to be used for generating the
   * 			groups.
   * @param random 	the random number generator.
   */
  protected void generateGroupsFromSizes(Instances data, Random random) {
<span class="fc" id="L955">    m_Groups = new int[m_Classifiers.length][][];</span>
<span class="fc bfc" id="L956" title="All 2 branches covered.">    for( int i = 0; i &lt; m_Classifiers.length; i++ ) {</span>
<span class="fc" id="L957">      int [] permutation = attributesPermutation(data.numAttributes(), </span>
<span class="fc" id="L958">                           data.classIndex(), random);</span>

      // The number of groups that have a given size 
<span class="fc" id="L961">      int [] numGroupsOfSize = new int[m_MaxGroup - m_MinGroup + 1];</span>

<span class="fc" id="L963">      int numAttributes = 0;</span>
      int numGroups;

      // Select the size of each group
<span class="fc bfc" id="L967" title="All 2 branches covered.">      for( numGroups = 0; numAttributes &lt; permutation.length; numGroups++ ) {</span>
<span class="fc" id="L968">        int n = random.nextInt( numGroupsOfSize.length );</span>
<span class="fc" id="L969">        numGroupsOfSize[n]++;</span>
<span class="fc" id="L970">        numAttributes += m_MinGroup + n;</span>
      }

<span class="fc" id="L973">      m_Groups[i] = new int[numGroups][];</span>
<span class="fc" id="L974">      int currentAttribute = 0;</span>
<span class="fc" id="L975">      int currentSize = 0;</span>
<span class="fc bfc" id="L976" title="All 2 branches covered.">      for( int j = 0; j &lt; numGroups; j++ ) {</span>
<span class="pc bpc" id="L977" title="1 of 2 branches missed.">        while( numGroupsOfSize[ currentSize ] == 0 )</span>
<span class="nc" id="L978">          currentSize++;</span>
<span class="fc" id="L979">        numGroupsOfSize[ currentSize ]--;</span>
<span class="fc" id="L980">        int n = m_MinGroup + currentSize;</span>
<span class="fc" id="L981">        m_Groups[i][j] = new int[n];</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">        for( int k = 0; k &lt; n; k++ ) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">          if( currentAttribute &lt; permutation.length )</span>
<span class="fc" id="L984">            m_Groups[i][j][k] = permutation[ currentAttribute ];</span>
          else
	    // For the last group, it can be necessary to reuse some attributes
<span class="fc" id="L987">            m_Groups[i][j][k] = permutation[ random.nextInt( </span>
<span class="fc" id="L988">	        permutation.length ) ];</span>
<span class="fc" id="L989">          currentAttribute++;</span>
        }
      }
    }
<span class="fc" id="L993">  }</span>

  /**
   * generates the groups of attributes, given their minimum and maximum
   * numbers.
   *
   * @param data 	the training data to be used for generating the
   * 			groups.
   * @param random 	the random number generator.
   */
  protected void generateGroupsFromNumbers(Instances data, Random random) {
<span class="nc" id="L1004">    m_Groups = new int[m_Classifiers.length][][];</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">    for( int i = 0; i &lt; m_Classifiers.length; i++ ) {</span>
<span class="nc" id="L1006">      int [] permutation = attributesPermutation(data.numAttributes(), </span>
<span class="nc" id="L1007">                           data.classIndex(), random);</span>
<span class="nc" id="L1008">      int numGroups = m_MinGroup + random.nextInt(m_MaxGroup - m_MinGroup + 1);</span>
<span class="nc" id="L1009">      m_Groups[i] = new int[numGroups][];</span>
<span class="nc" id="L1010">      int groupSize = permutation.length / numGroups;</span>

      // Some groups will have an additional attribute
<span class="nc" id="L1013">      int numBiggerGroups = permutation.length % numGroups;</span>

      // Distribute the attributes in the groups
<span class="nc" id="L1016">      int currentAttribute = 0;</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">      for( int j = 0; j &lt; numGroups; j++ ) {</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if( j &lt; numBiggerGroups ) {</span>
<span class="nc" id="L1019">          m_Groups[i][j] = new int[groupSize + 1];</span>
        }
        else {
<span class="nc" id="L1022">          m_Groups[i][j] = new int[groupSize];</span>
        }
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        for( int k = 0; k &lt; m_Groups[i][j].length; k++ ) {</span>
<span class="nc" id="L1025">          m_Groups[i][j][k] = permutation[currentAttribute++];</span>
        }
      }
    }
<span class="nc" id="L1029">  }</span>

  /**
   * generates a permutation of the attributes.
   *
   * @param numAttributes       the number of attributes.
   * @param classAttributes     the index of the class attribute.
   * @param random 	        the random number generator.
   * @return a permutation of the attributes
   */
  protected int [] attributesPermutation(int numAttributes, int classAttribute,
                                         Random random) {
<span class="fc" id="L1041">    int [] permutation = new int[numAttributes-1];</span>
<span class="fc" id="L1042">    int i = 0;</span>
<span class="fc bfc" id="L1043" title="All 2 branches covered.">    for(; i &lt; classAttribute; i++){</span>
<span class="fc" id="L1044">      permutation[i] = i;</span>
    }
<span class="fc bfc" id="L1046" title="All 2 branches covered.">    for(; i &lt; permutation.length; i++){</span>
<span class="fc" id="L1047">      permutation[i] = i + 1;</span>
    }

<span class="fc" id="L1050">    permute( permutation, random );</span>

<span class="fc" id="L1052">    return permutation;</span>
  }

  /**
   * permutes the elements of a given array.
   *
   * @param v       the array to permute
   * @param random  the random number generator.
   */
  protected void permute( int v[], Random random ) {

<span class="fc bfc" id="L1063" title="All 2 branches covered.">    for(int i = v.length - 1; i &gt; 0; i-- ) {</span>
<span class="fc" id="L1064">      int j = random.nextInt( i + 1 );</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">      if( i != j ) {</span>
<span class="fc" id="L1066">        int tmp = v[i];</span>
<span class="fc" id="L1067">        v[i] = v[j];</span>
<span class="fc" id="L1068">        v[j] = tmp;</span>
      }
    }
<span class="fc" id="L1071">  }</span>

  /**
   * prints the groups.
   */
  protected void printGroups( ) {
<span class="nc bnc" id="L1077" title="All 2 branches missed.">    for( int i = 0; i &lt; m_Groups.length; i++ ) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">      for( int j = 0; j &lt; m_Groups[i].length; j++ ) {</span>
<span class="nc" id="L1079">        System.err.print( &quot;( &quot; );</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">        for( int k = 0; k &lt; m_Groups[i][j].length; k++ ) {</span>
<span class="nc" id="L1081">          System.err.print( m_Groups[i][j][k] );</span>
<span class="nc" id="L1082">          System.err.print( &quot; &quot; );</span>
        }
<span class="nc" id="L1084">        System.err.print( &quot;) &quot; );</span>
      }
<span class="nc" id="L1086">      System.err.println( );</span>
    }
<span class="nc" id="L1088">  }</span>

  /** 
   * Transforms an instance for the i-th classifier.
   *
   * @param instance the instance to be transformed
   * @param i the base classifier number
   * @return the transformed instance
   * @throws Exception if the instance can't be converted successfully 
   */
  protected Instance convertInstance( Instance instance, int i ) 
  throws Exception {
<span class="fc" id="L1100">    Instance newInstance = new Instance( m_Headers[ i ].numAttributes( ) );</span>
<span class="fc" id="L1101">    newInstance.setWeight(instance.weight());</span>
<span class="fc" id="L1102">    newInstance.setDataset( m_Headers[ i ] );</span>
<span class="fc" id="L1103">    int currentAttribute = 0;</span>

    // Project the data for each group
<span class="fc bfc" id="L1106" title="All 2 branches covered.">    for( int j = 0; j &lt; m_Groups[i].length; j++ ) {</span>
<span class="fc" id="L1107">      Instance auxInstance = new Instance( m_Groups[i][j].length + 1 );</span>
      int k;
<span class="fc bfc" id="L1109" title="All 2 branches covered.">      for( k = 0; k &lt; m_Groups[i][j].length; k++ ) {</span>
<span class="fc" id="L1110">        auxInstance.setValue( k, instance.value( m_Groups[i][j][k] ) );</span>
      }
<span class="fc" id="L1112">      auxInstance.setValue( k, instance.classValue( ) );</span>
<span class="fc" id="L1113">      auxInstance.setDataset( m_ReducedHeaders[ i ][ j ] );</span>
<span class="fc" id="L1114">      m_ProjectionFilters[i][j].input( auxInstance );</span>
<span class="fc" id="L1115">      auxInstance = m_ProjectionFilters[i][j].output( );</span>
<span class="fc" id="L1116">      m_ProjectionFilters[i][j].batchFinished();</span>
<span class="fc bfc" id="L1117" title="All 2 branches covered.">      for( int a = 0; a &lt; auxInstance.numAttributes() - 1; a++ ) {</span>
<span class="fc" id="L1118">        newInstance.setValue( currentAttribute++, auxInstance.value( a ) );</span>
      }
    }

<span class="fc" id="L1122">    newInstance.setClassValue( instance.classValue() );</span>
<span class="fc" id="L1123">    return newInstance;</span>
  }

  /**
   * Calculates the class membership probabilities for the given test
   * instance.
   *
   * @param instance the instance to be classified
   * @return preedicted class probability distribution
   * @throws Exception if distribution can't be computed successfully 
   */
  public double[] distributionForInstance(Instance instance) throws Exception {

<span class="fc" id="L1136">    m_RemoveUseless.input(instance);</span>
<span class="fc" id="L1137">    instance =m_RemoveUseless.output();</span>
<span class="fc" id="L1138">    m_RemoveUseless.batchFinished();</span>

<span class="fc" id="L1140">    m_Normalize.input(instance);</span>
<span class="fc" id="L1141">    instance =m_Normalize.output();</span>
<span class="fc" id="L1142">    m_Normalize.batchFinished();</span>

<span class="fc" id="L1144">    double [] sums = new double [instance.numClasses()], newProbs; </span>
    
<span class="fc bfc" id="L1146" title="All 2 branches covered.">    for (int i = 0; i &lt; m_Classifiers.length; i++) {</span>
<span class="fc" id="L1147">      Instance convertedInstance = convertInstance(instance, i);</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">      if (instance.classAttribute().isNumeric() == true) {</span>
<span class="nc" id="L1149">	sums[0] += m_Classifiers[i].classifyInstance(convertedInstance);</span>
      } else {
<span class="fc" id="L1151">	newProbs = m_Classifiers[i].distributionForInstance(convertedInstance);</span>
<span class="fc bfc" id="L1152" title="All 2 branches covered.">	for (int j = 0; j &lt; newProbs.length; j++)</span>
<span class="fc" id="L1153">	  sums[j] += newProbs[j];</span>
      }
    }
<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">    if (instance.classAttribute().isNumeric() == true) {</span>
<span class="nc" id="L1157">      sums[0] /= (double)m_NumIterations;</span>
<span class="nc" id="L1158">      return sums;</span>
<span class="fc bfc" id="L1159" title="All 2 branches covered.">    } else if (Utils.eq(Utils.sum(sums), 0)) {</span>
<span class="fc" id="L1160">      return sums;</span>
    } else {
<span class="fc" id="L1162">      Utils.normalize(sums);</span>
<span class="fc" id="L1163">      return sums;</span>
    }
  }

  /**
   * Main method for testing this class.
   *
   * @param argv the options
   */
  public static void main(String [] argv) {
<span class="nc" id="L1173">    runClassifier(new RotationForest(), argv);</span>
<span class="nc" id="L1174">  }</span>

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>