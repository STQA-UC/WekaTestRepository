<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>RacedIncrementalLogitBoost.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.meta</a> &gt; <span class="el_source">RacedIncrementalLogitBoost.java</span></div><h1>RacedIncrementalLogitBoost.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    RacedIncrementalLogitBoost.java
 *    Copyright (C) 2002 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.meta;

import weka.classifiers.Classifier;
import weka.classifiers.RandomizableSingleClassifierEnhancer;
import weka.classifiers.UpdateableClassifier;
import weka.classifiers.rules.ZeroR;
import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Classifier for incremental learning of large datasets by way of racing logit-boosted committees.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Eibe Frank, Geoffrey Holmes, Richard Kirkby, Mark Hall:  Racing committees for large datasets. In: Proceedings of the 5th International Conferenceon Discovery Science, 153-164, 2002.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Frank2002,
 *    author = {Eibe Frank and Geoffrey Holmes and Richard Kirkby and Mark Hall},
 *    booktitle = {Proceedings of the 5th International Conferenceon Discovery Science},
 *    pages = {153-164},
 *    publisher = {Springer},
 *    title = { Racing committees for large datasets},
 *    year = {2002}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;num&amp;gt;
 *  Minimum size of chunks.
 *  (default 500)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;num&amp;gt;
 *  Maximum size of chunks.
 *  (default 2000)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V &amp;lt;num&amp;gt;
 *  Size of validation set.
 *  (default 1000)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;pruning type&amp;gt;
 *  Committee pruning to perform.
 *  0=none, 1=log likelihood (default)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -Q
 *  Use resampling for boosting.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Random number seed.
 *  (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W
 *  Full name of base classifier.
 *  (default: weka.classifiers.trees.DecisionStump)&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to classifier weka.classifiers.trees.DecisionStump:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * Options after -- are passed to the designated learner.&lt;p&gt;
 *
 * @author Richard Kirkby (rkirkby@cs.waikato.ac.nz)
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @version $Revision: 6477 $ 
 */
<span class="fc" id="L127">public class RacedIncrementalLogitBoost </span>
  extends RandomizableSingleClassifierEnhancer
  implements UpdateableClassifier, TechnicalInformationHandler {
  
  /** for serialization */
  static final long serialVersionUID = 908598343772170052L;

  /** no pruning */
  public static final int PRUNETYPE_NONE = 0;
  /** log likelihood pruning */
  public static final int PRUNETYPE_LOGLIKELIHOOD = 1;
  /** The pruning types */
<span class="fc" id="L139">  public static final Tag [] TAGS_PRUNETYPE = {</span>
<span class="fc" id="L140">    new Tag(PRUNETYPE_NONE, &quot;No pruning&quot;),</span>
<span class="fc" id="L141">    new Tag(PRUNETYPE_LOGLIKELIHOOD, &quot;Log likelihood pruning&quot;)</span>
  };

  /** The committees */   
  protected FastVector m_committees;

  /** The pruning type used */
<span class="fc" id="L148">  protected int m_PruningType = PRUNETYPE_LOGLIKELIHOOD;</span>

  /** Whether to use resampling */
<span class="fc" id="L151">  protected boolean m_UseResampling = false;</span>

  /** The number of classes */
  protected int m_NumClasses;

  /** A threshold for responses (Friedman suggests between 2 and 4) */
  protected static final double Z_MAX = 4;

  /** Dummy dataset with a numeric class */
  protected Instances m_NumericClassData;

  /** The actual class attribute (for getting class names) */
  protected Attribute m_ClassAttribute;  

  /** The minimum chunk size used for training */
<span class="fc" id="L166">  protected int m_minChunkSize = 500;</span>

  /** The maimum chunk size used for training */
<span class="fc" id="L169">  protected int m_maxChunkSize = 2000;</span>

  /** The size of the validation set */
<span class="fc" id="L172">  protected int m_validationChunkSize = 1000;</span>

  /** The number of instances consumed */  
  protected int m_numInstancesConsumed;

  /** The instances used for validation */    
  protected Instances m_validationSet;

  /** The instances currently in memory for training */   
  protected Instances m_currentSet;

  /** The current best committee */   
  protected Committee m_bestCommittee;

  /** The default scheme used when committees aren't ready */    
<span class="fc" id="L187">  protected ZeroR m_zeroR = null;</span>

  /** Whether the validation set has recently been changed */ 
  protected boolean m_validationSetChanged;

  /** The maximum number of instances required for processing */   
  protected int m_maxBatchSizeRequired;

  /** The random number generator used */
<span class="fc" id="L196">  protected Random m_RandomInstance = null;</span>

    
  /**
   * Constructor.
   */
<span class="fc" id="L202">  public RacedIncrementalLogitBoost() {</span>
    
<span class="fc" id="L204">    m_Classifier = new weka.classifiers.trees.DecisionStump();</span>
<span class="fc" id="L205">  }</span>

  /**
   * String describing default classifier.
   * 
   * @return the default classifier classname
   */
  protected String defaultClassifierString() {
    
<span class="fc" id="L214">    return &quot;weka.classifiers.trees.DecisionStump&quot;;</span>
  }


  /** 
   * Class representing a committee of LogitBoosted models
   */
  protected class Committee 
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = 5559880306684082199L;

    protected int m_chunkSize;
    
    /** number eaten from m_currentSet */
    protected int m_instancesConsumed; 
    
    protected FastVector m_models;
    protected double m_lastValidationError;
    protected double m_lastLogLikelihood;
    protected boolean m_modelHasChanged;
    protected boolean m_modelHasChangedLL;
    protected double[][] m_validationFs;
    protected double[][] m_newValidationFs;

    /** 
     * constructor 
     * 
     * @param chunkSize the size of the chunk
     */
<span class="fc" id="L245">    public Committee(int chunkSize) {</span>

<span class="fc" id="L247">      m_chunkSize = chunkSize;</span>
<span class="fc" id="L248">      m_instancesConsumed = 0;</span>
<span class="fc" id="L249">      m_models = new FastVector();</span>
<span class="fc" id="L250">      m_lastValidationError = 1.0;</span>
<span class="fc" id="L251">      m_lastLogLikelihood = Double.MAX_VALUE;</span>
<span class="fc" id="L252">      m_modelHasChanged = true;</span>
<span class="fc" id="L253">      m_modelHasChangedLL = true;</span>
<span class="fc" id="L254">      m_validationFs = new double[m_validationChunkSize][m_NumClasses];</span>
<span class="fc" id="L255">      m_newValidationFs = new double[m_validationChunkSize][m_NumClasses];</span>
<span class="fc" id="L256">    } </span>

    /** 
     * update the committee 
     * 
     * @return true if the committee has changed
     * @throws Exception if anything goes wrong
     */
    public boolean update() throws Exception {

<span class="nc" id="L266">      boolean hasChanged = false;</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">      while (m_currentSet.numInstances() - m_instancesConsumed &gt;= m_chunkSize) {</span>
<span class="nc" id="L268">	Classifier[] newModel = boost(new Instances(m_currentSet, m_instancesConsumed, m_chunkSize));</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">	for (int i=0; i&lt;m_validationSet.numInstances(); i++) {</span>
<span class="nc" id="L270">	  m_newValidationFs[i] = updateFS(m_validationSet.instance(i), newModel, m_validationFs[i]);</span>
	}
<span class="nc" id="L272">	m_models.addElement(newModel);</span>
<span class="nc" id="L273">	m_instancesConsumed += m_chunkSize;</span>
<span class="nc" id="L274">	hasChanged = true;</span>
      }
<span class="nc bnc" id="L276" title="All 2 branches missed.">      if (hasChanged) {</span>
<span class="nc" id="L277">	m_modelHasChanged = true;</span>
<span class="nc" id="L278">	m_modelHasChangedLL = true;</span>
      }
<span class="nc" id="L280">      return hasChanged;</span>
    }

    /** reset consumation counts */
    public void resetConsumed() {

<span class="nc" id="L286">      m_instancesConsumed = 0;</span>
<span class="nc" id="L287">    }</span>

    /** remove the last model from the committee */
    public void pruneLastModel() {

<span class="nc bnc" id="L292" title="All 2 branches missed.">      if (m_models.size() &gt; 0) {</span>
<span class="nc" id="L293">	m_models.removeElementAt(m_models.size()-1);</span>
<span class="nc" id="L294">	m_modelHasChanged = true;</span>
<span class="nc" id="L295">	m_modelHasChangedLL = true;</span>
      }
<span class="nc" id="L297">    }</span>

    /** 
     * decide to keep the last model in the committee 
     * @throws Exception if anything goes wrong
     */
    public void keepLastModel() throws Exception {

<span class="nc" id="L305">      m_validationFs = m_newValidationFs;</span>
<span class="nc" id="L306">      m_newValidationFs = new double[m_validationChunkSize][m_NumClasses];</span>
<span class="nc" id="L307">      m_modelHasChanged = true;</span>
<span class="nc" id="L308">      m_modelHasChangedLL = true;</span>
<span class="nc" id="L309">    }</span>

    /** 
     * calculate the log likelihood on the validation data 
     * @return the log likelihood
     * @throws Exception if computation fails
     */        
    public double logLikelihood() throws Exception {

<span class="nc bnc" id="L318" title="All 2 branches missed.">      if (m_modelHasChangedLL) {</span>

	Instance inst;
<span class="nc" id="L321">	double llsum = 0.0;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">	for (int i=0; i&lt;m_validationSet.numInstances(); i++) {</span>
<span class="nc" id="L323">	  inst = m_validationSet.instance(i);</span>
<span class="nc" id="L324">	  llsum += (logLikelihood(m_validationFs[i],(int) inst.classValue()));</span>
	}
<span class="nc" id="L326">	m_lastLogLikelihood = llsum / (double) m_validationSet.numInstances();</span>
<span class="nc" id="L327">	m_modelHasChangedLL = false;</span>
      }
<span class="nc" id="L329">      return m_lastLogLikelihood;</span>
    }

    /** 
     * calculate the log likelihood on the validation data after adding the last model 
     * @return the log likelihood
     * @throws Exception if computation fails
     */
    public double logLikelihoodAfter() throws Exception {

	Instance inst;
<span class="nc" id="L340">	double llsum = 0.0;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">	for (int i=0; i&lt;m_validationSet.numInstances(); i++) {</span>
<span class="nc" id="L342">	  inst = m_validationSet.instance(i);</span>
<span class="nc" id="L343">	  llsum += (logLikelihood(m_newValidationFs[i],(int) inst.classValue()));</span>
	}
<span class="nc" id="L345">	return llsum / (double) m_validationSet.numInstances();</span>
    }

    
    /** 
     * calculates the log likelihood of an instance 
     * @param Fs the Fs values
     * @param classIndex the class index
     * @return the log likelihood
     * @throws Exception if computation fails
     */
    private double logLikelihood(double[] Fs, int classIndex) throws Exception {

<span class="nc" id="L358">      return -Math.log(distributionForInstance(Fs)[classIndex]);</span>
    }

    /** 
     * calculates the validation error of the committee 
     * @return the validation error
     * @throws Exception if computation fails
     */
    public double validationError() throws Exception {

<span class="nc bnc" id="L368" title="All 2 branches missed.">      if (m_modelHasChanged) {</span>

	Instance inst;
<span class="nc" id="L371">	int numIncorrect = 0;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">	for (int i=0; i&lt;m_validationSet.numInstances(); i++) {</span>
<span class="nc" id="L373">	  inst = m_validationSet.instance(i);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">	  if (classifyInstance(m_validationFs[i]) != inst.classValue())</span>
<span class="nc" id="L375">	    numIncorrect++;</span>
	}
<span class="nc" id="L377">	m_lastValidationError = (double) numIncorrect / (double) m_validationSet.numInstances();</span>
<span class="nc" id="L378">	m_modelHasChanged = false;</span>
      }
<span class="nc" id="L380">      return m_lastValidationError;</span>
    }

    /** 
     * returns the chunk size used by the committee 
     * 
     * @return the chunk size
     */
    public int chunkSize() {

<span class="nc" id="L390">      return m_chunkSize;</span>
    }

    /** 
     * returns the number of models in the committee 
     * 
     * @return the committee size
     */
    public int committeeSize() {

<span class="nc" id="L400">      return m_models.size();</span>
    }

    
    /** 
     * classifies an instance (given Fs values) with the committee 
     * 
     * @param Fs the Fs values
     * @return the classification
     * @throws Exception if anything goes wrong
     */
    public double classifyInstance(double[] Fs) throws Exception {
      
<span class="nc" id="L413">      double [] dist = distributionForInstance(Fs);</span>

<span class="nc" id="L415">      double max = 0;</span>
<span class="nc" id="L416">      int maxIndex = 0;</span>
      
<span class="nc bnc" id="L418" title="All 2 branches missed.">      for (int i = 0; i &lt; dist.length; i++) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">	if (dist[i] &gt; max) {</span>
<span class="nc" id="L420">	  maxIndex = i;</span>
<span class="nc" id="L421">	  max = dist[i];</span>
	}
      }
<span class="nc bnc" id="L424" title="All 2 branches missed.">      if (max &gt; 0) {</span>
<span class="nc" id="L425">	return maxIndex;</span>
      } else {
<span class="nc" id="L427">	return Instance.missingValue();</span>
      }
    }

    /** 
     * classifies an instance with the committee 
     * 
     * @param instance the instance to classify
     * @return the classification
     * @throws Exception if anything goes wrong
     */
    public double classifyInstance(Instance instance) throws Exception {
      
<span class="nc" id="L440">      double [] dist = distributionForInstance(instance);</span>
<span class="nc bnc" id="L441" title="All 3 branches missed.">      switch (instance.classAttribute().type()) {</span>
      case Attribute.NOMINAL:
<span class="nc" id="L443">	double max = 0;</span>
<span class="nc" id="L444">	int maxIndex = 0;</span>
	
<span class="nc bnc" id="L446" title="All 2 branches missed.">	for (int i = 0; i &lt; dist.length; i++) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">	  if (dist[i] &gt; max) {</span>
<span class="nc" id="L448">	    maxIndex = i;</span>
<span class="nc" id="L449">	    max = dist[i];</span>
	  }
	}
<span class="nc bnc" id="L452" title="All 2 branches missed.">	if (max &gt; 0) {</span>
<span class="nc" id="L453">	  return maxIndex;</span>
	} else {
<span class="nc" id="L455">	  return Instance.missingValue();</span>
	}
      case Attribute.NUMERIC:
<span class="nc" id="L458">	return dist[0];</span>
      default:
<span class="nc" id="L460">	return Instance.missingValue();</span>
      }
    }

    /** 
     * returns the distribution the committee generates for an instance (given Fs values) 
     * 
     * @param Fs the Fs values
     * @return the distribution
     * @throws Exception if anything goes wrong
     */
    public double[] distributionForInstance(double[] Fs) throws Exception {
      
<span class="nc" id="L473">      double [] distribution = new double [m_NumClasses];</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L475">	distribution[j] = RtoP(Fs, j);</span>
      }
<span class="nc" id="L477">      return distribution;</span>
    }
    
    /** 
     * updates the Fs values given a new model in the committee 
     * 
     * @param instance the instance to use
     * @param newModel the new model
     * @param Fs the Fs values to update
     * @return the updated Fs values
     * @throws Exception if anything goes wrong
     */
    public double[] updateFS(Instance instance, Classifier[] newModel, double[] Fs) throws Exception {
      
<span class="nc" id="L491">      instance = (Instance)instance.copy();</span>
<span class="nc" id="L492">      instance.setDataset(m_NumericClassData);</span>
      
<span class="nc" id="L494">      double [] Fi = new double [m_NumClasses];</span>
<span class="nc" id="L495">      double Fsum = 0;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L497">	Fi[j] = newModel[j].classifyInstance(instance);</span>
<span class="nc" id="L498">	Fsum += Fi[j];</span>
      }
<span class="nc" id="L500">      Fsum /= m_NumClasses;</span>
      
<span class="nc" id="L502">      double[] newFs = new double[Fs.length];</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L504">	newFs[j] = Fs[j] + ((Fi[j] - Fsum) * (m_NumClasses - 1) / m_NumClasses);</span>
      }
<span class="nc" id="L506">      return newFs;</span>
    }

    /** 
     * returns the distribution the committee generates for an instance
     * 
     * @param instance the instance to get the distribution for
     * @return the distribution
     * @throws Exception if anything goes wrong
     */
    public double[] distributionForInstance(Instance instance) throws Exception {

<span class="nc" id="L518">      instance = (Instance)instance.copy();</span>
<span class="nc" id="L519">      instance.setDataset(m_NumericClassData);</span>
<span class="nc" id="L520">      double [] Fs = new double [m_NumClasses]; </span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">      for (int i = 0; i &lt; m_models.size(); i++) {</span>
<span class="nc" id="L522">	double [] Fi = new double [m_NumClasses];</span>
<span class="nc" id="L523">	double Fsum = 0;</span>
<span class="nc" id="L524">	Classifier[] model = (Classifier[]) m_models.elementAt(i);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">	for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L526">	  Fi[j] = model[j].classifyInstance(instance);</span>
<span class="nc" id="L527">	  Fsum += Fi[j];</span>
	}
<span class="nc" id="L529">	Fsum /= m_NumClasses;</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">	for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L531">	  Fs[j] += (Fi[j] - Fsum) * (m_NumClasses - 1) / m_NumClasses;</span>
	}
      }
<span class="nc" id="L534">      double [] distribution = new double [m_NumClasses];</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L536">	distribution[j] = RtoP(Fs, j);</span>
      }
<span class="nc" id="L538">      return distribution;</span>
    }

    /** 
     * performs a boosting iteration, returning a new model for the committee
     * 
     * @param data the data to boost on
     * @return the new model
     * @throws Exception if anything goes wrong
     */
    protected Classifier[] boost(Instances data) throws Exception {
      
<span class="nc" id="L550">      Classifier[] newModel = Classifier.makeCopies(m_Classifier, m_NumClasses);</span>
      
      // Create a copy of the data with the class transformed into numeric
<span class="nc" id="L553">      Instances boostData = new Instances(data);</span>
<span class="nc" id="L554">      boostData.deleteWithMissingClass();</span>
<span class="nc" id="L555">      int numInstances = boostData.numInstances();</span>
      
      // Temporarily unset the class index
<span class="nc" id="L558">      int classIndex = data.classIndex();</span>
<span class="nc" id="L559">      boostData.setClassIndex(-1);</span>
<span class="nc" id="L560">      boostData.deleteAttributeAt(classIndex);</span>
<span class="nc" id="L561">      boostData.insertAttributeAt(new Attribute(&quot;'pseudo class'&quot;), classIndex);</span>
<span class="nc" id="L562">      boostData.setClassIndex(classIndex);</span>
<span class="nc" id="L563">      double [][] trainFs = new double [numInstances][m_NumClasses];</span>
<span class="nc" id="L564">      double [][] trainYs = new double [numInstances][m_NumClasses];</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">	for (int i = 0, k = 0; i &lt; numInstances; i++, k++) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">	  while (data.instance(k).classIsMissing()) k++;</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">	  trainYs[i][j] = (data.instance(k).classValue() == j) ? 1 : 0;</span>
	}
      }
      
      // Evaluate / increment trainFs from the classifiers
<span class="nc bnc" id="L573" title="All 2 branches missed.">      for (int x = 0; x &lt; m_models.size(); x++) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">	for (int i = 0; i &lt; numInstances; i++) {</span>
<span class="nc" id="L575">	  double [] pred = new double [m_NumClasses];</span>
<span class="nc" id="L576">	  double predSum = 0;</span>
<span class="nc" id="L577">	  Classifier[] model = (Classifier[]) m_models.elementAt(x);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">	  for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L579">	    pred[j] = model[j].classifyInstance(boostData.instance(i));</span>
<span class="nc" id="L580">	    predSum += pred[j];</span>
	  }
<span class="nc" id="L582">	  predSum /= m_NumClasses;</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">	  for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L584">	    trainFs[i][j] += (pred[j] - predSum) * (m_NumClasses-1) </span>
<span class="nc" id="L585">	      / m_NumClasses;</span>
	  }
	}
      }

<span class="nc bnc" id="L590" title="All 2 branches missed.">      for (int j = 0; j &lt; m_NumClasses; j++) {</span>
	
	// Set instance pseudoclass and weights
<span class="nc bnc" id="L593" title="All 2 branches missed.">	for (int i = 0; i &lt; numInstances; i++) {</span>
<span class="nc" id="L594">	  double p = RtoP(trainFs[i], j);</span>
<span class="nc" id="L595">	  Instance current = boostData.instance(i);</span>
<span class="nc" id="L596">	  double z, actual = trainYs[i][j];</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">	  if (actual == 1) {</span>
<span class="nc" id="L598">	    z = 1.0 / p;</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">	    if (z &gt; Z_MAX) { // threshold</span>
<span class="nc" id="L600">	      z = Z_MAX;</span>
	    }
<span class="nc bnc" id="L602" title="All 2 branches missed.">	  } else if (actual == 0) {</span>
<span class="nc" id="L603">	    z = -1.0 / (1.0 - p);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">	    if (z &lt; -Z_MAX) { // threshold</span>
<span class="nc" id="L605">	      z = -Z_MAX;</span>
	    }
	  } else {
<span class="nc" id="L608">	    z = (actual - p) / (p * (1 - p));</span>
	  }

<span class="nc" id="L611">	  double w = (actual - p) / z;</span>
<span class="nc" id="L612">	  current.setValue(classIndex, z);</span>
<span class="nc" id="L613">	  current.setWeight(numInstances * w);</span>
	}
	
<span class="nc" id="L616">	Instances trainData = boostData;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">	if (m_UseResampling) {</span>
<span class="nc" id="L618">	  double[] weights = new double[boostData.numInstances()];</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">	  for (int kk = 0; kk &lt; weights.length; kk++) {</span>
<span class="nc" id="L620">	    weights[kk] = boostData.instance(kk).weight();</span>
	  }
<span class="nc" id="L622">	  trainData = boostData.resampleWithWeights(m_RandomInstance, </span>
<span class="nc" id="L623">						    weights);</span>
	}
	
	// Build the classifier
<span class="nc" id="L627">	newModel[j].buildClassifier(trainData);</span>
      }      
      
<span class="nc" id="L630">      return newModel;</span>
    }

    /** 
     * outputs description of the committee
     * 
     * @return a string representation of the classifier
     */
    public String toString() {
      
<span class="nc" id="L640">      StringBuffer text = new StringBuffer();</span>
      
<span class="nc" id="L642">      text.append(&quot;RacedIncrementalLogitBoost: Best committee on validation data\n&quot;);</span>
<span class="nc" id="L643">      text.append(&quot;Base classifiers: \n&quot;);</span>
      
<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (int i = 0; i &lt; m_models.size(); i++) {</span>
<span class="nc" id="L646">	text.append(&quot;\nModel &quot;+(i+1));</span>
<span class="nc" id="L647">	Classifier[] cModels = (Classifier[]) m_models.elementAt(i);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">	for (int j = 0; j &lt; m_NumClasses; j++) {</span>
<span class="nc" id="L649">	  text.append(&quot;\n\tClass &quot; + (j + 1) </span>
<span class="nc" id="L650">		      + &quot; (&quot; + m_ClassAttribute.name() </span>
<span class="nc" id="L651">		      + &quot;=&quot; + m_ClassAttribute.value(j) + &quot;)\n\n&quot;</span>
<span class="nc" id="L652">		      + cModels[j].toString() + &quot;\n&quot;);</span>
	}
      }
<span class="nc" id="L655">      text.append(&quot;Number of models: &quot; +</span>
<span class="nc" id="L656">		  m_models.size() + &quot;\n&quot;);      </span>
<span class="nc" id="L657">      text.append(&quot;Chunk size per model: &quot; + m_chunkSize + &quot;\n&quot;);</span>
      
<span class="nc" id="L659">      return text.toString();</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L668">      return RevisionUtils.extract(&quot;$Revision: 6477 $&quot;);</span>
    }
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L678">    Capabilities result = super.getCapabilities();</span>

    // class
<span class="fc" id="L681">    result.disableAllClasses();</span>
<span class="fc" id="L682">    result.disableAllClassDependencies();</span>
<span class="fc" id="L683">    result.enable(Capability.NOMINAL_CLASS);</span>

    // instances
<span class="fc" id="L686">    result.setMinimumNumberInstances(0);</span>
    
<span class="fc" id="L688">    return result;</span>
  }

 /**
   * Builds the classifier.
   *
   * @param data the instances to train the classifier with
   * @throws Exception if something goes wrong
   */
  public void buildClassifier(Instances data) throws Exception {

<span class="fc" id="L699">    m_RandomInstance = new Random(m_Seed);</span>

    Instances boostData;
<span class="fc" id="L702">    int classIndex = data.classIndex();</span>

    // can classifier handle the data?
<span class="fc" id="L705">    getCapabilities().testWithFail(data);</span>

    // remove instances with missing class
<span class="fc" id="L708">    data = new Instances(data);</span>
<span class="fc" id="L709">    data.deleteWithMissingClass();</span>
    
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">    if (m_Classifier == null) {</span>
<span class="nc" id="L712">      throw new Exception(&quot;A base classifier has not been specified!&quot;);</span>
    }

<span class="pc bpc" id="L715" title="1 of 2 branches missed.">    if (!(m_Classifier instanceof WeightedInstancesHandler) &amp;&amp;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">	!m_UseResampling) {</span>
<span class="nc" id="L717">      m_UseResampling = true;</span>
    }

<span class="fc" id="L720">    m_NumClasses = data.numClasses();</span>
<span class="fc" id="L721">    m_ClassAttribute = data.classAttribute();</span>

    // Create a copy of the data with the class transformed into numeric
<span class="fc" id="L724">    boostData = new Instances(data);</span>

    // Temporarily unset the class index
<span class="fc" id="L727">    boostData.setClassIndex(-1);</span>
<span class="fc" id="L728">    boostData.deleteAttributeAt(classIndex);</span>
<span class="fc" id="L729">    boostData.insertAttributeAt(new Attribute(&quot;'pseudo class'&quot;), classIndex);</span>
<span class="fc" id="L730">    boostData.setClassIndex(classIndex);</span>
<span class="fc" id="L731">    m_NumericClassData = new Instances(boostData, 0);</span>

<span class="fc" id="L733">    data.randomize(m_RandomInstance);</span>

    // create the committees
<span class="fc" id="L736">    int cSize = m_minChunkSize;</span>
<span class="fc" id="L737">    m_committees = new FastVector();</span>
<span class="fc bfc" id="L738" title="All 2 branches covered.">    while (cSize &lt;= m_maxChunkSize) {</span>
<span class="fc" id="L739">      m_committees.addElement(new Committee(cSize));</span>
<span class="fc" id="L740">      m_maxBatchSizeRequired = cSize;</span>
<span class="fc" id="L741">      cSize *= 2;</span>
    }

    // set up for consumption
<span class="fc" id="L745">    m_validationSet = new Instances(data, m_validationChunkSize);</span>
<span class="fc" id="L746">    m_currentSet = new Instances(data, m_maxBatchSizeRequired);</span>
<span class="fc" id="L747">    m_bestCommittee = null;</span>
<span class="fc" id="L748">    m_numInstancesConsumed = 0;</span>

    // start eating what we've been given
<span class="fc bfc" id="L751" title="All 2 branches covered.">    for (int i=0; i&lt;data.numInstances(); i++) updateClassifier(data.instance(i));</span>
<span class="fc" id="L752">  }</span>

 /**
   * Updates the classifier.
   *
   * @param instance the next instance in the stream of training data
   * @throws Exception if something goes wrong
   */
  public void updateClassifier(Instance instance) throws Exception {

<span class="fc" id="L762">    m_numInstancesConsumed++;</span>

<span class="pc bpc" id="L764" title="1 of 2 branches missed.">    if (m_validationSet.numInstances() &lt; m_validationChunkSize) {</span>
<span class="fc" id="L765">      m_validationSet.add(instance);</span>
<span class="fc" id="L766">      m_validationSetChanged = true;</span>
    } else {
<span class="nc" id="L768">      m_currentSet.add(instance);</span>
<span class="nc" id="L769">      boolean hasChanged = false;</span>
      
      // update each committee
<span class="nc bnc" id="L772" title="All 2 branches missed.">      for (int i=0; i&lt;m_committees.size(); i++) {</span>
<span class="nc" id="L773">	Committee c = (Committee) m_committees.elementAt(i);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">	if (c.update()) {</span>
	  
<span class="nc" id="L776">	  hasChanged = true;</span>
	  
<span class="nc bnc" id="L778" title="All 2 branches missed.">	  if (m_PruningType == PRUNETYPE_LOGLIKELIHOOD) {</span>
<span class="nc" id="L779">	    double oldLL = c.logLikelihood();</span>
<span class="nc" id="L780">	    double newLL = c.logLikelihoodAfter();</span>
<span class="nc bnc" id="L781" title="All 4 branches missed.">	    if (newLL &gt;= oldLL &amp;&amp; c.committeeSize() &gt; 1) {</span>
<span class="nc" id="L782">	      c.pruneLastModel();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">	      if (m_Debug) System.out.println(&quot;Pruning &quot; + c.chunkSize()+ &quot; committee (&quot; +</span>
<span class="nc" id="L784">					      oldLL + &quot; &lt; &quot; + newLL + &quot;)&quot;);</span>
<span class="nc" id="L785">	    } else c.keepLastModel();</span>
<span class="nc" id="L786">	  } else c.keepLastModel(); // no pruning</span>
	} 
      }
<span class="nc bnc" id="L789" title="All 2 branches missed.">      if (hasChanged) {</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">	if (m_Debug) System.out.println(&quot;After consuming &quot; + m_numInstancesConsumed</span>
<span class="nc" id="L792">					+ &quot; instances... (&quot; + m_validationSet.numInstances()</span>
<span class="nc" id="L793">					+ &quot; + &quot; + m_currentSet.numInstances()</span>
<span class="nc" id="L794">					+ &quot; instances currently in memory)&quot;);</span>
	
	// find best committee
<span class="nc" id="L797">	double lowestError = 1.0;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">	for (int i=0; i&lt;m_committees.size(); i++) {</span>
<span class="nc" id="L799">	  Committee c = (Committee) m_committees.elementAt(i);</span>

<span class="nc bnc" id="L801" title="All 2 branches missed.">	  if (c.committeeSize() &gt; 0) {</span>

<span class="nc" id="L803">	    double err = c.validationError();</span>
<span class="nc" id="L804">	    double ll = c.logLikelihood();</span>

<span class="nc bnc" id="L806" title="All 2 branches missed.">	    if (m_Debug) System.out.println(&quot;Chunk size &quot; + c.chunkSize() + &quot; with &quot;</span>
<span class="nc" id="L807">					    + c.committeeSize() + &quot; models, has validation error of &quot;</span>
<span class="nc" id="L808">					    + err + &quot;, log likelihood of &quot; + ll);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">	    if (err &lt; lowestError) {</span>
<span class="nc" id="L810">	      lowestError = err;</span>
<span class="nc" id="L811">	      m_bestCommittee = c;</span>
	    }
	  }
	}
      }
<span class="nc bnc" id="L816" title="All 2 branches missed.">      if (m_currentSet.numInstances() &gt;= m_maxBatchSizeRequired) {</span>
<span class="nc" id="L817">	m_currentSet = new Instances(m_currentSet, m_maxBatchSizeRequired);</span>

	// reset consumation counts
<span class="nc bnc" id="L820" title="All 2 branches missed.">	for (int i=0; i&lt;m_committees.size(); i++) {</span>
<span class="nc" id="L821">	  Committee c = (Committee) m_committees.elementAt(i);</span>
<span class="nc" id="L822">	  c.resetConsumed();</span>
	}
      }
    }
<span class="fc" id="L826">  }</span>

  /**
   * Convert from function responses to probabilities
   *
   * @param Fs an array containing the responses from each function
   * @param j the class value of interest
   * @return the probability prediction for j
   * @throws Exception if can't normalize
   */
  protected static double RtoP(double []Fs, int j) 
    throws Exception {

<span class="nc" id="L839">    double maxF = -Double.MAX_VALUE;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">    for (int i = 0; i &lt; Fs.length; i++) {</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">      if (Fs[i] &gt; maxF) {</span>
<span class="nc" id="L842">	maxF = Fs[i];</span>
      }
    }
<span class="nc" id="L845">    double sum = 0;</span>
<span class="nc" id="L846">    double[] probs = new double[Fs.length];</span>
<span class="nc bnc" id="L847" title="All 2 branches missed.">    for (int i = 0; i &lt; Fs.length; i++) {</span>
<span class="nc" id="L848">      probs[i] = Math.exp(Fs[i] - maxF);</span>
<span class="nc" id="L849">      sum += probs[i];</span>
    }
<span class="nc bnc" id="L851" title="All 2 branches missed.">    if (sum == 0) {</span>
<span class="nc" id="L852">      throw new Exception(&quot;Can't normalize&quot;);</span>
    }
<span class="nc" id="L854">    return probs[j] / sum;</span>
  }

  /**
   * Computes class distribution of an instance using the best committee.
   * 
   * @param instance the instance to get the distribution for
   * @return the distribution
   * @throws Exception if anything goes wrong
   */
  public double[] distributionForInstance(Instance instance) throws Exception {

<span class="pc bpc" id="L866" title="1 of 2 branches missed.">    if (m_bestCommittee != null) return m_bestCommittee.distributionForInstance(instance);</span>
    else {
<span class="fc bfc" id="L868" title="All 4 branches covered.">      if (m_validationSetChanged || m_zeroR == null) {</span>
<span class="fc" id="L869">	m_zeroR = new ZeroR();</span>
<span class="fc" id="L870">	m_zeroR.buildClassifier(m_validationSet);</span>
<span class="fc" id="L871">	m_validationSetChanged = false;</span>
      }
<span class="fc" id="L873">      return m_zeroR.distributionForInstance(instance);</span>
    }
  }

  /**
   * Returns an enumeration describing the available options
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {

<span class="fc" id="L884">    Vector newVector = new Vector(9);</span>

<span class="fc" id="L886">    newVector.addElement(new Option(</span>
<span class="fc" id="L887">	      &quot;\tMinimum size of chunks.\n&quot;</span>
	      +&quot;\t(default 500)&quot;,
<span class="fc" id="L889">	      &quot;C&quot;, 1, &quot;-C &lt;num&gt;&quot;));</span>

<span class="fc" id="L891">    newVector.addElement(new Option(</span>
<span class="fc" id="L892">	      &quot;\tMaximum size of chunks.\n&quot;</span>
	      +&quot;\t(default 2000)&quot;,
<span class="fc" id="L894">	      &quot;M&quot;, 1, &quot;-M &lt;num&gt;&quot;));</span>

<span class="fc" id="L896">    newVector.addElement(new Option(</span>
<span class="fc" id="L897">	      &quot;\tSize of validation set.\n&quot;</span>
	      +&quot;\t(default 1000)&quot;,
<span class="fc" id="L899">	      &quot;V&quot;, 1, &quot;-V &lt;num&gt;&quot;));</span>

<span class="fc" id="L901">    newVector.addElement(new Option(</span>
<span class="fc" id="L902">	      &quot;\tCommittee pruning to perform.\n&quot;</span>
	      +&quot;\t0=none, 1=log likelihood (default)&quot;,
<span class="fc" id="L904">	      &quot;P&quot;, 1, &quot;-P &lt;pruning type&gt;&quot;));</span>

<span class="fc" id="L906">    newVector.addElement(new Option(</span>
<span class="fc" id="L907">	      &quot;\tUse resampling for boosting.&quot;,</span>
<span class="fc" id="L908">	      &quot;Q&quot;, 0, &quot;-Q&quot;));</span>


<span class="fc" id="L911">    Enumeration enu = super.listOptions();</span>
<span class="fc bfc" id="L912" title="All 2 branches covered.">    while (enu.hasMoreElements()) {</span>
<span class="fc" id="L913">      newVector.addElement(enu.nextElement());</span>
    }
<span class="fc" id="L915">    return newVector.elements();</span>
  }


  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;num&amp;gt;
   *  Minimum size of chunks.
   *  (default 500)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;num&amp;gt;
   *  Maximum size of chunks.
   *  (default 2000)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -V &amp;lt;num&amp;gt;
   *  Size of validation set.
   *  (default 1000)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;pruning type&amp;gt;
   *  Committee pruning to perform.
   *  0=none, 1=log likelihood (default)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -Q
   *  Use resampling for boosting.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Random number seed.
   *  (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W
   *  Full name of base classifier.
   *  (default: weka.classifiers.trees.DecisionStump)&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to classifier weka.classifiers.trees.DecisionStump:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

<span class="fc" id="L971">    String minChunkSize = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">    if (minChunkSize.length() != 0) {</span>
<span class="fc" id="L973">      setMinChunkSize(Integer.parseInt(minChunkSize));</span>
    } else {
<span class="fc" id="L975">      setMinChunkSize(500);</span>
    }

<span class="fc" id="L978">    String maxChunkSize = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">    if (maxChunkSize.length() != 0) {</span>
<span class="fc" id="L980">      setMaxChunkSize(Integer.parseInt(maxChunkSize));</span>
    } else {
<span class="fc" id="L982">      setMaxChunkSize(2000);</span>
    }

<span class="fc" id="L985">    String validationChunkSize = Utils.getOption('V', options);</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">    if (validationChunkSize.length() != 0) {</span>
<span class="fc" id="L987">      setValidationChunkSize(Integer.parseInt(validationChunkSize));</span>
    } else {
<span class="fc" id="L989">      setValidationChunkSize(1000);</span>
    }

<span class="fc" id="L992">    String pruneType = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">    if (pruneType.length() != 0) {</span>
<span class="fc" id="L994">      setPruningType(new SelectedTag(Integer.parseInt(pruneType), TAGS_PRUNETYPE));</span>
    } else {
<span class="fc" id="L996">      setPruningType(new SelectedTag(PRUNETYPE_LOGLIKELIHOOD, TAGS_PRUNETYPE));</span>
    }

<span class="fc" id="L999">    setUseResampling(Utils.getFlag('Q', options));</span>

<span class="fc" id="L1001">    super.setOptions(options);</span>
<span class="fc" id="L1002">  }</span>

  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L1011">    String [] superOptions = super.getOptions();</span>
<span class="fc" id="L1012">    String [] options = new String [superOptions.length + 9];</span>

<span class="fc" id="L1014">    int current = 0;</span>

<span class="pc bpc" id="L1016" title="1 of 2 branches missed.">    if (getUseResampling()) {</span>
<span class="nc" id="L1017">      options[current++] = &quot;-Q&quot;;</span>
    }
<span class="fc" id="L1019">    options[current++] = &quot;-C&quot;; options[current++] = &quot;&quot; + getMinChunkSize();</span>

<span class="fc" id="L1021">    options[current++] = &quot;-M&quot;; options[current++] = &quot;&quot; + getMaxChunkSize();</span>

<span class="fc" id="L1023">    options[current++] = &quot;-V&quot;; options[current++] = &quot;&quot; + getValidationChunkSize();</span>

<span class="fc" id="L1025">    options[current++] = &quot;-P&quot;; options[current++] = &quot;&quot; + m_PruningType;</span>

<span class="fc" id="L1027">    System.arraycopy(superOptions, 0, options, current, </span>
<span class="fc" id="L1028">		     superOptions.length);</span>

<span class="fc" id="L1030">    current += superOptions.length;</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L1032">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L1034">    return options;</span>
  }

  /**
   * @return a description of the classifier suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L1043">    return &quot;Classifier for incremental learning of large datasets by way of &quot; +</span>
    &quot;racing logit-boosted committees.\n\nFor more information see:\n\n&quot; +
<span class="nc" id="L1045">    getTechnicalInformation().toString();</span>
  }
  
  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation result;
    
<span class="nc" id="L1058">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L1059">    result.setValue(Field.AUTHOR, &quot;Eibe Frank and Geoffrey Holmes and Richard &quot; +</span>
                &quot;Kirkby and Mark Hall&quot;);
<span class="nc" id="L1061">    result.setValue(Field.TITLE, &quot; Racing committees for large datasets&quot;);</span>
<span class="nc" id="L1062">    result.setValue(Field.BOOKTITLE, &quot;Proceedings of the 5th International Conference&quot; +</span>
                &quot;on Discovery Science&quot;);
<span class="nc" id="L1064">    result.setValue(Field.YEAR, &quot;2002&quot;);</span>
<span class="nc" id="L1065">    result.setValue(Field.PAGES, &quot;153-164&quot;);</span>
<span class="nc" id="L1066">    result.setValue(Field.PUBLISHER, &quot;Springer&quot;);</span>
    
<span class="nc" id="L1068">    return result;</span>
  }

  /**
   * Set the base learner.
   *
   * @param newClassifier 		the classifier to use.
   * @throws IllegalArgumentException 	if base classifier cannot handle numeric 
   * 					class
   */
  public void setClassifier(Classifier newClassifier) {
<span class="fc" id="L1079">    Capabilities cap = newClassifier.getCapabilities();</span>
    
<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">    if (!cap.handles(Capability.NUMERIC_CLASS))</span>
<span class="nc" id="L1082">      throw new IllegalArgumentException(&quot;Base classifier cannot handle numeric class!&quot;);</span>
      
<span class="fc" id="L1084">    super.setClassifier(newClassifier);</span>
<span class="fc" id="L1085">  }</span>

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minChunkSizeTipText() {

<span class="nc" id="L1093">    return &quot;The minimum number of instances to train the base learner with.&quot;;</span>
  }

  /**
   * Set the minimum chunk size
   *
   * @param chunkSize the minimum chunk size
   */
  public void setMinChunkSize(int chunkSize) {

<span class="fc" id="L1103">    m_minChunkSize = chunkSize;</span>
<span class="fc" id="L1104">  }</span>

  /**
   * Get the minimum chunk size
   *
   * @return the chunk size
   */
  public int getMinChunkSize() {

<span class="fc" id="L1113">    return m_minChunkSize;</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String maxChunkSizeTipText() {

<span class="nc" id="L1122">    return &quot;The maximum number of instances to train the base learner with. The chunk sizes used will start at minChunkSize and grow twice as large for as many times as they are less than or equal to the maximum size.&quot;;</span>
  }

  /**
   * Set the maximum chunk size
   *
   * @param chunkSize the maximum chunk size
   */
  public void setMaxChunkSize(int chunkSize) {

<span class="fc" id="L1132">    m_maxChunkSize = chunkSize;</span>
<span class="fc" id="L1133">  }</span>

  /**
   * Get the maximum chunk size
   *
   * @return the chunk size
   */
  public int getMaxChunkSize() {

<span class="fc" id="L1142">    return m_maxChunkSize;</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String validationChunkSizeTipText() {

<span class="nc" id="L1151">    return &quot;The number of instances to hold out for validation. These instances will be taken from the beginning of the stream, so learning will not start until these instances have been consumed first.&quot;;</span>
  }

  /**
   * Set the validation chunk size
   *
   * @param chunkSize the validation chunk size
   */
  public void setValidationChunkSize(int chunkSize) {

<span class="fc" id="L1161">    m_validationChunkSize = chunkSize;</span>
<span class="fc" id="L1162">  }</span>

  /**
   * Get the validation chunk size
   *
   * @return the chunk size
   */
  public int getValidationChunkSize() {

<span class="fc" id="L1171">    return m_validationChunkSize;</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String pruningTypeTipText() {

<span class="nc" id="L1180">    return &quot;The pruning method to use within each committee. Log likelihood pruning will discard new models if they have a negative effect on the log likelihood of the validation data.&quot;;</span>
  }

  /**
   * Set the pruning type
   *
   * @param pruneType the pruning type
   */
  public void setPruningType(SelectedTag pruneType) {

<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">    if (pruneType.getTags() == TAGS_PRUNETYPE) {</span>
<span class="fc" id="L1191">      m_PruningType = pruneType.getSelectedTag().getID();</span>
    }
<span class="fc" id="L1193">  }</span>

  /**
   * Get the pruning type
   *
   * @return the type
   */
  public SelectedTag getPruningType() {

<span class="nc" id="L1202">    return new SelectedTag(m_PruningType, TAGS_PRUNETYPE);</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useResamplingTipText() {

<span class="nc" id="L1211">    return &quot;Force the use of resampling data rather than using the weight-handling capabilities of the base classifier. Resampling is always used if the base classifier cannot handle weighted instances.&quot;;</span>
  }

  /**
   * Set resampling mode
   *
   * @param r true if resampling should be done
   */
  public void setUseResampling(boolean r) {
    
<span class="fc" id="L1221">    m_UseResampling = r;</span>
<span class="fc" id="L1222">  }</span>

  /**
   * Get whether resampling is turned on
   *
   * @return true if resampling output is on
   */
  public boolean getUseResampling() {
    
<span class="fc" id="L1231">    return m_UseResampling;</span>
  }

  /**
   * Get the best committee chunk size
   * 
   * @return the best committee chunk size
   */
  public int getBestCommitteeChunkSize() {

<span class="nc bnc" id="L1241" title="All 2 branches missed.">    if (m_bestCommittee != null) {</span>
<span class="nc" id="L1242">      return m_bestCommittee.chunkSize();</span>
    }
<span class="nc" id="L1244">    else return 0;</span>
  }

  /**
   * Get the number of members in the best committee
   * 
   * @return the number of members
   */
  public int getBestCommitteeSize() {

<span class="nc bnc" id="L1254" title="All 2 branches missed.">    if (m_bestCommittee != null) {</span>
<span class="nc" id="L1255">      return m_bestCommittee.committeeSize();</span>
    }
<span class="nc" id="L1257">    else return 0;</span>
  }

  /**
   * Get the best committee's error on the validation data
   * 
   * @return the best committee's error
   */
  public double getBestCommitteeErrorEstimate() {

<span class="nc bnc" id="L1267" title="All 2 branches missed.">    if (m_bestCommittee != null) {</span>
      try {
<span class="nc" id="L1269">	return m_bestCommittee.validationError() * 100.0;</span>
<span class="nc" id="L1270">      } catch (Exception e) {</span>
<span class="nc" id="L1271">	System.err.println(e.getMessage());</span>
<span class="nc" id="L1272">	return 100.0;</span>
      }
    }
<span class="nc" id="L1275">    else return 100.0;</span>
  }

  /**
   * Get the best committee's log likelihood on the validation data
   * 
   * @return best committee's log likelihood
   */
  public double getBestCommitteeLLEstimate() {

<span class="nc bnc" id="L1285" title="All 2 branches missed.">    if (m_bestCommittee != null) {</span>
      try {
<span class="nc" id="L1287">	return m_bestCommittee.logLikelihood();</span>
<span class="nc" id="L1288">      } catch (Exception e) {</span>
<span class="nc" id="L1289">	System.err.println(e.getMessage());</span>
<span class="nc" id="L1290">	return Double.MAX_VALUE;</span>
      }
    }
<span class="nc" id="L1293">    else return Double.MAX_VALUE;</span>
  }
  
  /**
   * Returns description of the boosted classifier.
   *
   * @return description of the boosted classifier as a string
   */
  public String toString() {
        
<span class="pc bpc" id="L1303" title="1 of 2 branches missed.">    if (m_bestCommittee != null) {</span>
<span class="nc" id="L1304">      return m_bestCommittee.toString();</span>
    } else {
<span class="pc bpc" id="L1306" title="3 of 6 branches missed.">      if ((m_validationSetChanged || m_zeroR == null) &amp;&amp; m_validationSet != null</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">	  &amp;&amp; m_validationSet.numInstances() &gt; 0) {</span>
<span class="nc" id="L1308">	m_zeroR = new ZeroR();</span>
	try {
<span class="nc" id="L1310">	  m_zeroR.buildClassifier(m_validationSet);</span>
<span class="nc" id="L1311">	} catch (Exception e) {}</span>
<span class="nc" id="L1312">	m_validationSetChanged = false;</span>
      }
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">      if (m_zeroR != null) {</span>
<span class="nc" id="L1315">	return (&quot;RacedIncrementalLogitBoost: insufficient data to build model, resorting to ZeroR:\n\n&quot;</span>
<span class="nc" id="L1316">		+ m_zeroR.toString());</span>
      }
<span class="fc" id="L1318">      else return (&quot;RacedIncrementalLogitBoost: no model built yet.&quot;);</span>
    }
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1328">    return RevisionUtils.extract(&quot;$Revision: 6477 $&quot;);</span>
  }

  /**
   * Main method for this class.
   * 
   * @param argv the commandline parameters
   */
  public static void main(String[] argv) {
<span class="nc" id="L1337">    runClassifier(new RacedIncrementalLogitBoost(), argv);</span>
<span class="nc" id="L1338">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>