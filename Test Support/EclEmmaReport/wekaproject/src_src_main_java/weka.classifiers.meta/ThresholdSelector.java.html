<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ThresholdSelector.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.meta</a> &gt; <span class="el_source">ThresholdSelector.java</span></div><h1>ThresholdSelector.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    ThresholdSelector.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.meta;

import weka.classifiers.RandomizableSingleClassifierEnhancer;
import weka.classifiers.evaluation.EvaluationUtils;
import weka.classifiers.evaluation.ThresholdCurve;
import weka.core.Attribute;
import weka.core.AttributeStats;
import weka.core.Capabilities;
import weka.core.Drawable;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.Utils;
import weka.core.Capabilities.Capability;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * A metaclassifier that selecting a mid-point threshold on the probability output by a Classifier. The midpoint threshold is set so that a given performance measure is optimized. Currently this is the F-measure. Performance is measured either on the training data, a hold-out set or using cross-validation. In addition, the probabilities returned by the base learner can have their range expanded so that the output probabilities will reside between 0 and 1 (this is useful if the scheme normally produces probabilities in a very narrow range).
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;integer&amp;gt;
 *  The class for which threshold is determined. Valid values are:
 *  1, 2 (for first and second classes, respectively), 3 (for whichever
 *  class is least frequent), and 4 (for whichever class value is most
 *  frequent), and 5 (for the first class named any of &quot;yes&quot;,&quot;pos(itive)&quot;
 *  &quot;1&quot;, or method 3 if no matches). (default 5).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
 *  Number of folds used for cross validation. If just a
 *  hold-out set is used, this determines the size of the hold-out set
 *  (default 3).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;integer&amp;gt;
 *  Sets whether confidence range correction is applied. This
 *  can be used to ensure the confidences range from 0 to 1.
 *  Use 0 for no range correction, 1 for correction based on
 *  the min/max values seen during threshold selection
 *  (default 0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;integer&amp;gt;
 *  Sets the evaluation mode. Use 0 for
 *  evaluation using cross-validation,
 *  1 for evaluation using hold-out set,
 *  and 2 for evaluation on the
 *  training data (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M [FMEASURE|ACCURACY|TRUE_POS|TRUE_NEG|TP_RATE|PRECISION|RECALL]
 *  Measure used for evaluation (default is FMEASURE).
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -manual &amp;lt;real&amp;gt;
 *  Set a manual threshold to use. This option overrides
 *  automatic selection and options pertaining to
 *  automatic selection will be ignored.
 *  (default -1, i.e. do not use a manual threshold).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Random number seed.
 *  (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W
 *  Full name of base classifier.
 *  (default: weka.classifiers.functions.Logistic)&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to classifier weka.classifiers.functions.Logistic:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  Turn on debugging output.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;ridge&amp;gt;
 *  Set the ridge in the log-likelihood.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;number&amp;gt;
 *  Set the maximum number of iterations (default -1, until convergence).&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * Options after -- are passed to the designated sub-classifier. &lt;p&gt;
 *
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @version $Revision: 1.43 $ 
 */
<span class="fc" id="L124">public class ThresholdSelector </span>
  extends RandomizableSingleClassifierEnhancer 
  implements OptionHandler, Drawable {

  /** for serialization */
  static final long serialVersionUID = -1795038053239867444L;

  /** no range correction */
  public static final int RANGE_NONE = 0;
  /** Correct based on min/max observed */
  public static final int RANGE_BOUNDS = 1;
  /** Type of correction applied to threshold range */ 
<span class="fc" id="L136">  public static final Tag [] TAGS_RANGE = {</span>
<span class="fc" id="L137">    new Tag(RANGE_NONE, &quot;No range correction&quot;),</span>
<span class="fc" id="L138">    new Tag(RANGE_BOUNDS, &quot;Correct based on min/max observed&quot;)</span>
  };

  /** entire training set */
  public static final int EVAL_TRAINING_SET = 2;
  /** single tuned fold */
  public static final int EVAL_TUNED_SPLIT = 1;
  /** n-fold cross-validation */
  public static final int EVAL_CROSS_VALIDATION = 0;
  /** The evaluation modes */
<span class="fc" id="L148">  public static final Tag [] TAGS_EVAL = {</span>
<span class="fc" id="L149">    new Tag(EVAL_TRAINING_SET, &quot;Entire training set&quot;),</span>
<span class="fc" id="L150">    new Tag(EVAL_TUNED_SPLIT, &quot;Single tuned fold&quot;),</span>
<span class="fc" id="L151">    new Tag(EVAL_CROSS_VALIDATION, &quot;N-Fold cross validation&quot;)</span>
  };

  /** first class value */
  public static final int OPTIMIZE_0     = 0;
  /** second class value */
  public static final int OPTIMIZE_1     = 1;
  /** least frequent class value */
  public static final int OPTIMIZE_LFREQ = 2;
  /** most frequent class value */
  public static final int OPTIMIZE_MFREQ = 3;
  /** class value name, either 'yes' or 'pos(itive)' */
  public static final int OPTIMIZE_POS_NAME = 4;
  /** How to determine which class value to optimize for */
<span class="fc" id="L165">  public static final Tag [] TAGS_OPTIMIZE = {</span>
<span class="fc" id="L166">    new Tag(OPTIMIZE_0, &quot;First class value&quot;),</span>
<span class="fc" id="L167">    new Tag(OPTIMIZE_1, &quot;Second class value&quot;),</span>
<span class="fc" id="L168">    new Tag(OPTIMIZE_LFREQ, &quot;Least frequent class value&quot;),</span>
<span class="fc" id="L169">    new Tag(OPTIMIZE_MFREQ, &quot;Most frequent class value&quot;),</span>
<span class="fc" id="L170">    new Tag(OPTIMIZE_POS_NAME, &quot;Class value named: \&quot;yes\&quot;, \&quot;pos(itive)\&quot;,\&quot;1\&quot;&quot;)</span>
  };

  /** F-measure */
  public static final int FMEASURE  = 1;
  /** accuracy */
  public static final int ACCURACY  = 2;
  /** true-positive */
  public static final int TRUE_POS  = 3;
  /** true-negative */
  public static final int TRUE_NEG  = 4;
  /** true-positive rate */
  public static final int TP_RATE   = 5;
  /** precision */
  public static final int PRECISION = 6;
  /** recall */
  public static final int RECALL    = 7;
  /** the measure to use */
<span class="fc" id="L188">  public static final Tag[] TAGS_MEASURE = {</span>
<span class="fc" id="L189">    new Tag(FMEASURE,  &quot;FMEASURE&quot;),</span>
<span class="fc" id="L190">    new Tag(ACCURACY,  &quot;ACCURACY&quot;),</span>
<span class="fc" id="L191">    new Tag(TRUE_POS,  &quot;TRUE_POS&quot;),</span>
<span class="fc" id="L192">    new Tag(TRUE_NEG,  &quot;TRUE_NEG&quot;), </span>
<span class="fc" id="L193">    new Tag(TP_RATE,   &quot;TP_RATE&quot;),   </span>
<span class="fc" id="L194">    new Tag(PRECISION, &quot;PRECISION&quot;), </span>
<span class="fc" id="L195">    new Tag(RECALL,    &quot;RECALL&quot;)</span>
  };

  /** The upper threshold used as the basis of correction */
<span class="fc" id="L199">  protected double m_HighThreshold = 1;</span>

  /** The lower threshold used as the basis of correction */
<span class="fc" id="L202">  protected double m_LowThreshold = 0;</span>

  /** The threshold that lead to the best performance */
<span class="fc" id="L205">  protected double m_BestThreshold = -Double.MAX_VALUE;</span>

  /** The best value that has been observed */
<span class="fc" id="L208">  protected double m_BestValue = - Double.MAX_VALUE;</span>
  
  /** The number of folds used in cross-validation */
<span class="fc" id="L211">  protected int m_NumXValFolds = 3;</span>

  /** Designated class value, determined during building */
<span class="fc" id="L214">  protected int m_DesignatedClass = 0;</span>

  /** Method to determine which class to optimize for */
<span class="fc" id="L217">  protected int m_ClassMode = OPTIMIZE_POS_NAME;</span>

  /** The evaluation mode */
<span class="fc" id="L220">  protected int m_EvalMode = EVAL_TUNED_SPLIT;</span>

  /** The range correction mode */
<span class="fc" id="L223">  protected int m_RangeMode = RANGE_NONE;</span>

  /** evaluation measure used for determining threshold **/
<span class="fc" id="L226">  int m_nMeasure = FMEASURE;</span>

  /** True if a manually set threshold is being used */
<span class="fc" id="L229">  protected boolean m_manualThreshold = false;</span>
  /** -1 = not used by default */
<span class="fc" id="L231">  protected double m_manualThresholdValue = -1;</span>

  /** The minimum value for the criterion. If threshold adjustment
      yields less than that, the default threshold of 0.5 is used. */
  protected static final double MIN_VALUE = 0.05;
    
  /**
   * Constructor.
   */
<span class="fc" id="L240">  public ThresholdSelector() {</span>
    
<span class="fc" id="L242">    m_Classifier = new weka.classifiers.functions.Logistic();</span>
<span class="fc" id="L243">  }</span>

  /**
   * String describing default classifier.
   * 
   * @return the default classifier classname
   */
  protected String defaultClassifierString() {
    
<span class="fc" id="L252">    return &quot;weka.classifiers.functions.Logistic&quot;;</span>
  }

  /**
   * Collects the classifier predictions using the specified evaluation method.
   *
   * @param instances the set of &lt;code&gt;Instances&lt;/code&gt; to generate
   * predictions for.
   * @param mode the evaluation mode.
   * @param numFolds the number of folds to use if not evaluating on the
   * full training set.
   * @return a &lt;code&gt;FastVector&lt;/code&gt; containing the predictions.
   * @throws Exception if an error occurs generating the predictions.
   */
  protected FastVector getPredictions(Instances instances, int mode, int numFolds) 
    throws Exception {

<span class="fc" id="L269">    EvaluationUtils eu = new EvaluationUtils();</span>
<span class="fc" id="L270">    eu.setSeed(m_Seed);</span>
    
<span class="pc bpc" id="L272" title="1 of 4 branches missed.">    switch (mode) {</span>
    case EVAL_TUNED_SPLIT:
<span class="fc" id="L274">      Instances trainData = null, evalData = null;</span>
<span class="fc" id="L275">      Instances data = new Instances(instances);</span>
<span class="fc" id="L276">      Random random = new Random(m_Seed);</span>
<span class="fc" id="L277">      data.randomize(random);</span>
<span class="fc" id="L278">      data.stratify(numFolds);</span>
      
      // Make sure that both subsets contain at least one positive instance
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">      for (int subsetIndex = 0; subsetIndex &lt; numFolds; subsetIndex++) {</span>
<span class="fc" id="L282">        trainData = data.trainCV(numFolds, subsetIndex, random);</span>
<span class="fc" id="L283">        evalData = data.testCV(numFolds, subsetIndex);</span>
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">        if (checkForInstance(trainData) &amp;&amp; checkForInstance(evalData)) {</span>
<span class="fc" id="L285">          break;</span>
        }
      }
<span class="fc" id="L288">      return eu.getTrainTestPredictions(m_Classifier, trainData, evalData);</span>
    case EVAL_TRAINING_SET:
<span class="fc" id="L290">      return eu.getTrainTestPredictions(m_Classifier, instances, instances);</span>
    case EVAL_CROSS_VALIDATION:
<span class="fc" id="L292">      return eu.getCVPredictions(m_Classifier, instances, numFolds);</span>
    default:
<span class="nc" id="L294">      throw new RuntimeException(&quot;Unrecognized evaluation mode&quot;);</span>
    }
  }

  /**
   * Tooltip for this property.
   * 
   * @return 	tip text for this property suitable for
   * 		displaying in the explorer/experimenter gui
   */
  public String measureTipText() {
<span class="nc" id="L305">    return &quot;Sets the measure for determining the threshold.&quot;;</span>
  }

  /** 
   * set measure used for determining threshold
   * 
   * @param newMeasure Tag representing measure to be used
   */
  public void setMeasure(SelectedTag newMeasure) {
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">    if (newMeasure.getTags() == TAGS_MEASURE) {</span>
<span class="fc" id="L315">      m_nMeasure = newMeasure.getSelectedTag().getID();</span>
    }
<span class="fc" id="L317">  }</span>

  /**
   * get measure used for determining threshold 
   * 
   * @return Tag representing measure used
   */
  public SelectedTag getMeasure() {
<span class="fc" id="L325">    return new SelectedTag(m_nMeasure, TAGS_MEASURE);</span>
  }


  /**
   * Finds the best threshold, this implementation searches for the
   * highest FMeasure. If no FMeasure higher than MIN_VALUE is found,
   * the default threshold of 0.5 is used.
   *
   * @param predictions a &lt;code&gt;FastVector&lt;/code&gt; containing the predictions.
   */
  protected void findThreshold(FastVector predictions) {

<span class="fc" id="L338">    Instances curve = (new ThresholdCurve()).getCurve(predictions, m_DesignatedClass);</span>

<span class="fc" id="L340">    double low = 1.0;</span>
<span class="fc" id="L341">    double high = 0.0;</span>

    //System.err.println(curve);
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">    if (curve.numInstances() &gt; 0) {</span>
<span class="fc" id="L345">      Instance maxInst = curve.instance(0);</span>
<span class="fc" id="L346">      double maxValue = 0; </span>
<span class="fc" id="L347">      int index1 = 0;</span>
<span class="fc" id="L348">      int index2 = 0;</span>
<span class="pc bpc" id="L349" title="7 of 8 branches missed.">      switch (m_nMeasure) {</span>
        case FMEASURE:
<span class="fc" id="L351">          index1 = curve.attribute(ThresholdCurve.FMEASURE_NAME).index();</span>
<span class="fc" id="L352">          maxValue = maxInst.value(index1);</span>
<span class="fc" id="L353">          break;</span>
        case TRUE_POS:
<span class="nc" id="L355">          index1 = curve.attribute(ThresholdCurve.TRUE_POS_NAME).index();</span>
<span class="nc" id="L356">          maxValue = maxInst.value(index1);</span>
<span class="nc" id="L357">          break;</span>
        case TRUE_NEG:
<span class="nc" id="L359">          index1 = curve.attribute(ThresholdCurve.TRUE_NEG_NAME).index();</span>
<span class="nc" id="L360">          maxValue = maxInst.value(index1);</span>
<span class="nc" id="L361">          break;</span>
        case TP_RATE:
<span class="nc" id="L363">          index1 = curve.attribute(ThresholdCurve.TP_RATE_NAME).index();</span>
<span class="nc" id="L364">          maxValue = maxInst.value(index1);</span>
<span class="nc" id="L365">          break;</span>
        case PRECISION:
<span class="nc" id="L367">          index1 = curve.attribute(ThresholdCurve.PRECISION_NAME).index();</span>
<span class="nc" id="L368">          maxValue = maxInst.value(index1);</span>
<span class="nc" id="L369">          break;</span>
        case RECALL:
<span class="nc" id="L371">          index1 = curve.attribute(ThresholdCurve.RECALL_NAME).index();</span>
<span class="nc" id="L372">          maxValue = maxInst.value(index1);</span>
<span class="nc" id="L373">          break;</span>
        case ACCURACY:
<span class="nc" id="L375">          index1 = curve.attribute(ThresholdCurve.TRUE_POS_NAME).index();</span>
<span class="nc" id="L376">          index2 = curve.attribute(ThresholdCurve.TRUE_NEG_NAME).index();</span>
<span class="nc" id="L377">          maxValue = maxInst.value(index1) + maxInst.value(index2);</span>
          break;
      }
<span class="fc" id="L380">      int indexThreshold = curve.attribute(ThresholdCurve.THRESHOLD_NAME).index();</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      for (int i = 1; i &lt; curve.numInstances(); i++) {</span>
<span class="fc" id="L382">        Instance current = curve.instance(i);</span>
<span class="fc" id="L383">        double currentValue = 0;</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (m_nMeasure ==  ACCURACY) {</span>
<span class="nc" id="L385">          currentValue= current.value(index1) + current.value(index2);</span>
	  } else {
<span class="fc" id="L387">	      currentValue= current.value(index1);</span>
	  }

<span class="fc bfc" id="L390" title="All 2 branches covered.">	  if (currentValue&gt; maxValue) {</span>
<span class="fc" id="L391">	      maxInst = current;</span>
<span class="fc" id="L392">	      maxValue = currentValue;</span>
	  }
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">	  if (m_RangeMode == RANGE_BOUNDS) {</span>
<span class="nc" id="L395">	      double thresh = current.value(indexThreshold);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">	      if (thresh &lt; low) {</span>
<span class="nc" id="L397">		  low = thresh;</span>
	      }
<span class="nc bnc" id="L399" title="All 2 branches missed.">	      if (thresh &gt; high) {</span>
<span class="nc" id="L400">		  high = thresh;</span>
	      }
	  }
      }
<span class="pc bpc" id="L404" title="1 of 2 branches missed.">      if (maxValue &gt; MIN_VALUE) {</span>
<span class="fc" id="L405">        m_BestThreshold = maxInst.value(indexThreshold);</span>
<span class="fc" id="L406">        m_BestValue = maxValue;</span>
        //System.err.println(&quot;maxFM: &quot; + maxFM);
      }
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">      if (m_RangeMode == RANGE_BOUNDS) {</span>
<span class="nc" id="L410">	  m_LowThreshold = low;</span>
<span class="nc" id="L411">	  m_HighThreshold = high;</span>
        //System.err.println(&quot;Threshold range: &quot; + low + &quot; - &quot; + high);
      }
    }

<span class="fc" id="L416">  }</span>

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="fc" id="L425">    Vector newVector = new Vector(5);</span>

<span class="fc" id="L427">    newVector.addElement(new Option(</span>
<span class="fc" id="L428">        &quot;\tThe class for which threshold is determined. Valid values are:\n&quot; +</span>
        &quot;\t1, 2 (for first and second classes, respectively), 3 (for whichever\n&quot; +
        &quot;\tclass is least frequent), and 4 (for whichever class value is most\n&quot; +
        &quot;\tfrequent), and 5 (for the first class named any of \&quot;yes\&quot;,\&quot;pos(itive)\&quot;\n&quot; +
        &quot;\t\&quot;1\&quot;, or method 3 if no matches). (default 5).&quot;,
<span class="fc" id="L433">        &quot;C&quot;, 1, &quot;-C &lt;integer&gt;&quot;));</span>
    
<span class="fc" id="L435">    newVector.addElement(new Option(</span>
<span class="fc" id="L436">	      &quot;\tNumber of folds used for cross validation. If just a\n&quot; +</span>
	      &quot;\thold-out set is used, this determines the size of the hold-out set\n&quot; +
	      &quot;\t(default 3).&quot;,
<span class="fc" id="L439">	      &quot;X&quot;, 1, &quot;-X &lt;number of folds&gt;&quot;));</span>
    
<span class="fc" id="L441">    newVector.addElement(new Option(</span>
<span class="fc" id="L442">        &quot;\tSets whether confidence range correction is applied. This\n&quot; +</span>
        &quot;\tcan be used to ensure the confidences range from 0 to 1.\n&quot; +
        &quot;\tUse 0 for no range correction, 1 for correction based on\n&quot; +
        &quot;\tthe min/max values seen during threshold selection\n&quot;+
        &quot;\t(default 0).&quot;,
<span class="fc" id="L447">        &quot;R&quot;, 1, &quot;-R &lt;integer&gt;&quot;));</span>
    
<span class="fc" id="L449">    newVector.addElement(new Option(</span>
<span class="fc" id="L450">	      &quot;\tSets the evaluation mode. Use 0 for\n&quot; +</span>
	      &quot;\tevaluation using cross-validation,\n&quot; +
	      &quot;\t1 for evaluation using hold-out set,\n&quot; +
	      &quot;\tand 2 for evaluation on the\n&quot; +
	      &quot;\ttraining data (default 1).&quot;,
<span class="fc" id="L455">	      &quot;E&quot;, 1, &quot;-E &lt;integer&gt;&quot;));</span>

<span class="fc" id="L457">    newVector.addElement(new Option(</span>
<span class="fc" id="L458">	      &quot;\tMeasure used for evaluation (default is FMEASURE).\n&quot;,</span>
<span class="fc" id="L459">	      &quot;M&quot;, 1, &quot;-M [FMEASURE|ACCURACY|TRUE_POS|TRUE_NEG|TP_RATE|PRECISION|RECALL]&quot;));</span>
    
<span class="fc" id="L461">    newVector.addElement(new Option(</span>
<span class="fc" id="L462">              &quot;\tSet a manual threshold to use. This option overrides\n&quot;</span>
              + &quot;\tautomatic selection and options pertaining to\n&quot;
              + &quot;\tautomatic selection will be ignored.\n&quot;
              + &quot;\t(default -1, i.e. do not use a manual threshold).&quot;,
<span class="fc" id="L466">              &quot;manual&quot;, 1, &quot;-manual &lt;real&gt;&quot;));</span>

<span class="fc" id="L468">    Enumeration enu = super.listOptions();</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">    while (enu.hasMoreElements()) {</span>
<span class="fc" id="L470">      newVector.addElement(enu.nextElement());</span>
    }
<span class="fc" id="L472">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;integer&amp;gt;
   *  The class for which threshold is determined. Valid values are:
   *  1, 2 (for first and second classes, respectively), 3 (for whichever
   *  class is least frequent), and 4 (for whichever class value is most
   *  frequent), and 5 (for the first class named any of &quot;yes&quot;,&quot;pos(itive)&quot;
   *  &quot;1&quot;, or method 3 if no matches). (default 5).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -X &amp;lt;number of folds&amp;gt;
   *  Number of folds used for cross validation. If just a
   *  hold-out set is used, this determines the size of the hold-out set
   *  (default 3).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;integer&amp;gt;
   *  Sets whether confidence range correction is applied. This
   *  can be used to ensure the confidences range from 0 to 1.
   *  Use 0 for no range correction, 1 for correction based on
   *  the min/max values seen during threshold selection
   *  (default 0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E &amp;lt;integer&amp;gt;
   *  Sets the evaluation mode. Use 0 for
   *  evaluation using cross-validation,
   *  1 for evaluation using hold-out set,
   *  and 2 for evaluation on the
   *  training data (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M [FMEASURE|ACCURACY|TRUE_POS|TRUE_NEG|TP_RATE|PRECISION|RECALL]
   *  Measure used for evaluation (default is FMEASURE).
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -manual &amp;lt;real&amp;gt;
   *  Set a manual threshold to use. This option overrides
   *  automatic selection and options pertaining to
   *  automatic selection will be ignored.
   *  (default -1, i.e. do not use a manual threshold).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Random number seed.
   *  (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W
   *  Full name of base classifier.
   *  (default: weka.classifiers.functions.Logistic)&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to classifier weka.classifiers.functions.Logistic:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  Turn on debugging output.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;ridge&amp;gt;
   *  Set the ridge in the log-likelihood.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;number&amp;gt;
   *  Set the maximum number of iterations (default -1, until convergence).&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * Options after -- are passed to the designated sub-classifier. &lt;p&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    
<span class="fc" id="L551">    String manualS = Utils.getOption(&quot;manual&quot;, options);</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">    if (manualS.length() &gt; 0) {</span>
<span class="nc" id="L553">      double val = Double.parseDouble(manualS);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">      if (val &gt;= 0.0) {</span>
<span class="nc" id="L555">        setManualThresholdValue(val);</span>
      } 
    }

<span class="fc" id="L559">    String classString = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">    if (classString.length() != 0) {</span>
<span class="fc" id="L561">      setDesignatedClass(new SelectedTag(Integer.parseInt(classString) - 1, </span>
<span class="fc" id="L562">                                         TAGS_OPTIMIZE));</span>
    } else {
<span class="fc" id="L564">      setDesignatedClass(new SelectedTag(OPTIMIZE_POS_NAME, TAGS_OPTIMIZE));</span>
    }

<span class="fc" id="L567">    String modeString = Utils.getOption('E', options);</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">    if (modeString.length() != 0) {</span>
<span class="fc" id="L569">      setEvaluationMode(new SelectedTag(Integer.parseInt(modeString), </span>
<span class="fc" id="L570">                                         TAGS_EVAL));</span>
    } else {
<span class="fc" id="L572">      setEvaluationMode(new SelectedTag(EVAL_TUNED_SPLIT, TAGS_EVAL));</span>
    }

<span class="fc" id="L575">    String rangeString = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L576" title="All 2 branches covered.">    if (rangeString.length() != 0) {</span>
<span class="fc" id="L577">      setRangeCorrection(new SelectedTag(Integer.parseInt(rangeString), </span>
<span class="fc" id="L578">                                         TAGS_RANGE));</span>
    } else {
<span class="fc" id="L580">      setRangeCorrection(new SelectedTag(RANGE_NONE, TAGS_RANGE));</span>
    }

<span class="fc" id="L583">    String measureString = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">    if (measureString.length() != 0) {</span>
<span class="fc" id="L585">      setMeasure(new SelectedTag(measureString, TAGS_MEASURE));</span>
    } else {
<span class="fc" id="L587">      setMeasure(new SelectedTag(FMEASURE, TAGS_MEASURE));</span>
    }

<span class="fc" id="L590">    String foldsString = Utils.getOption('X', options);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">    if (foldsString.length() != 0) {</span>
<span class="fc" id="L592">      setNumXValFolds(Integer.parseInt(foldsString));</span>
    } else {
<span class="fc" id="L594">      setNumXValFolds(3);</span>
    }

<span class="fc" id="L597">    super.setOptions(options);</span>
<span class="fc" id="L598">  }</span>

  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L607">    String [] superOptions = super.getOptions();</span>
<span class="fc" id="L608">    String [] options = new String [superOptions.length + 12];</span>

<span class="fc" id="L610">    int current = 0;</span>

<span class="pc bpc" id="L612" title="1 of 2 branches missed.">    if (m_manualThreshold) {</span>
<span class="nc" id="L613">      options[current++] = &quot;-manual&quot;; options[current++] = &quot;&quot; + getManualThresholdValue();</span>
    }
<span class="fc" id="L615">    options[current++] = &quot;-C&quot;; options[current++] = &quot;&quot; + (m_ClassMode + 1);</span>
<span class="fc" id="L616">    options[current++] = &quot;-X&quot;; options[current++] = &quot;&quot; + getNumXValFolds();</span>
<span class="fc" id="L617">    options[current++] = &quot;-E&quot;; options[current++] = &quot;&quot; + m_EvalMode;</span>
<span class="fc" id="L618">    options[current++] = &quot;-R&quot;; options[current++] = &quot;&quot; + m_RangeMode;</span>
<span class="fc" id="L619">    options[current++] = &quot;-M&quot;; options[current++] = &quot;&quot; + getMeasure().getSelectedTag().getReadable();</span>

<span class="fc" id="L621">    System.arraycopy(superOptions, 0, options, current, </span>
<span class="fc" id="L622">		     superOptions.length);</span>

<span class="fc" id="L624">    current += superOptions.length;</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L626">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L628">    return options;</span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L637">    Capabilities result = super.getCapabilities();</span>

    // class
<span class="fc" id="L640">    result.disableAllClasses();</span>
<span class="fc" id="L641">    result.disableAllClassDependencies();</span>
<span class="fc" id="L642">    result.enable(Capability.BINARY_CLASS);</span>
    
<span class="fc" id="L644">    return result;</span>
  }

  /**
   * Generates the classifier.
   *
   * @param instances set of instances serving as training data 
   * @throws Exception if the classifier has not been generated successfully
   */
  public void buildClassifier(Instances instances) 
    throws Exception {

    // can classifier handle the data?
<span class="fc" id="L657">    getCapabilities().testWithFail(instances);</span>

    // remove instances with missing class
<span class="fc" id="L660">    instances = new Instances(instances);</span>
<span class="fc" id="L661">    instances.deleteWithMissingClass();</span>
    
<span class="fc" id="L663">    AttributeStats stats = instances.attributeStats(instances.classIndex());</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">    if (m_manualThreshold) {</span>
<span class="nc" id="L665">      m_BestThreshold = m_manualThresholdValue;</span>
    } else {
<span class="fc" id="L667">      m_BestThreshold = 0.5;</span>
    }
<span class="fc" id="L669">    m_BestValue = MIN_VALUE;</span>
<span class="fc" id="L670">    m_HighThreshold = 1;</span>
<span class="fc" id="L671">    m_LowThreshold = 0;</span>

    // If data contains only one instance of positive data
    // optimize on training data
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">    if (stats.distinctCount != 2) {</span>
<span class="nc" id="L676">      System.err.println(&quot;Couldn't find examples of both classes. No adjustment.&quot;);</span>
<span class="nc" id="L677">      m_Classifier.buildClassifier(instances);</span>
    } else {
      
      // Determine which class value to look for
<span class="pc bpc" id="L681" title="1 of 6 branches missed.">      switch (m_ClassMode) {</span>
      case OPTIMIZE_0:
<span class="fc" id="L683">        m_DesignatedClass = 0;</span>
<span class="fc" id="L684">        break;</span>
      case OPTIMIZE_1:
<span class="fc" id="L686">        m_DesignatedClass = 1;</span>
<span class="fc" id="L687">        break;</span>
      case OPTIMIZE_POS_NAME:
<span class="fc" id="L689">        Attribute cAtt = instances.classAttribute();</span>
<span class="fc" id="L690">        boolean found = false;</span>
<span class="pc bpc" id="L691" title="1 of 4 branches missed.">        for (int i = 0; i &lt; cAtt.numValues() &amp;&amp; !found; i++) {</span>
<span class="fc" id="L692">          String name = cAtt.value(i).toLowerCase();</span>
<span class="pc bpc" id="L693" title="2 of 4 branches missed.">          if (name.startsWith(&quot;yes&quot;) || name.equals(&quot;1&quot;) || </span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">              name.startsWith(&quot;pos&quot;)) {</span>
<span class="nc" id="L695">            found = true;</span>
<span class="nc" id="L696">            m_DesignatedClass = i;</span>
          }
        }
<span class="pc bpc" id="L699" title="1 of 2 branches missed.">        if (found) {</span>
<span class="nc" id="L700">          break;</span>
        }
        // No named class found, so fall through to default of least frequent
      case OPTIMIZE_LFREQ:
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        m_DesignatedClass = (stats.nominalCounts[0] &gt; stats.nominalCounts[1]) ? 1 : 0;</span>
<span class="fc" id="L705">        break;</span>
      case OPTIMIZE_MFREQ:
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">        m_DesignatedClass = (stats.nominalCounts[0] &gt; stats.nominalCounts[1]) ? 0 : 1;</span>
<span class="fc" id="L708">        break;</span>
      default:
<span class="nc" id="L710">        throw new Exception(&quot;Unrecognized class value selection mode&quot;);</span>
      }
      
      /*
        System.err.println(&quot;ThresholdSelector: Using mode=&quot; 
        + TAGS_OPTIMIZE[m_ClassMode].getReadable());
        System.err.println(&quot;ThresholdSelector: Optimizing using class &quot;
        + m_DesignatedClass + &quot;/&quot; 
        + instances.classAttribute().value(m_DesignatedClass));
      */
      
<span class="pc bpc" id="L721" title="1 of 2 branches missed.">      if (m_manualThreshold) {</span>
<span class="nc" id="L722">        m_Classifier.buildClassifier(instances);</span>
<span class="nc" id="L723">        return;</span>
      }

<span class="pc bpc" id="L726" title="1 of 2 branches missed.">      if (stats.nominalCounts[m_DesignatedClass] == 1) {</span>
<span class="nc" id="L727">        System.err.println(&quot;Only 1 positive found: optimizing on training data&quot;);</span>
<span class="nc" id="L728">        findThreshold(getPredictions(instances, EVAL_TRAINING_SET, 0));</span>
      } else {
<span class="fc" id="L730">        int numFolds = Math.min(m_NumXValFolds, stats.nominalCounts[m_DesignatedClass]);</span>
        //System.err.println(&quot;Number of folds for threshold selector: &quot; + numFolds);
<span class="fc" id="L732">        findThreshold(getPredictions(instances, m_EvalMode, numFolds));</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">        if (m_EvalMode != EVAL_TRAINING_SET) {</span>
<span class="fc" id="L734">          m_Classifier.buildClassifier(instances);</span>
        }
      }
    }
<span class="fc" id="L738">  }</span>

  /**
   * Checks whether instance of designated class is in subset.
   * 
   * @param data the data to check for instance
   * @return true if the instance is in the subset
   * @throws Exception if checking fails
   */
  private boolean checkForInstance(Instances data) throws Exception {

<span class="pc bpc" id="L749" title="1 of 2 branches missed.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">      if (((int)data.instance(i).classValue()) == m_DesignatedClass) {</span>
<span class="fc" id="L751">	return true;</span>
      }
    }
<span class="nc" id="L754">    return false;</span>
  }


  /**
   * Calculates the class membership probabilities for the given test instance.
   *
   * @param instance the instance to be classified
   * @return predicted class probability distribution
   * @throws Exception if instance could not be classified
   * successfully
   */
  public double [] distributionForInstance(Instance instance) 
    throws Exception {
    
<span class="fc" id="L769">    double [] pred = m_Classifier.distributionForInstance(instance);</span>
<span class="fc" id="L770">    double prob = pred[m_DesignatedClass];</span>

    // Warp probability
<span class="fc bfc" id="L773" title="All 2 branches covered.">    if (prob &gt; m_BestThreshold) {</span>
<span class="fc" id="L774">      prob = 0.5 + (prob - m_BestThreshold) / </span>
<span class="fc" id="L775">        ((m_HighThreshold - m_BestThreshold) * 2);</span>
    } else {
<span class="fc" id="L777">      prob = (prob - m_LowThreshold) / </span>
<span class="fc" id="L778">        ((m_BestThreshold - m_LowThreshold) * 2);</span>
    }
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">    if (prob &lt; 0) {</span>
<span class="nc" id="L781">      prob = 0.0;</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">    } else if (prob &gt; 1) {</span>
<span class="nc" id="L783">      prob = 1.0;</span>
    }

    // Alter the distribution
<span class="fc" id="L787">    pred[m_DesignatedClass] = prob;</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">    if (pred.length == 2) { // Handle case when there's only one class</span>
<span class="fc" id="L789">      pred[(m_DesignatedClass + 1) % 2] = 1.0 - prob;</span>
    }
<span class="fc" id="L791">    return pred;</span>
  }

  /**
   * @return a description of the classifier suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L800">    return &quot;A metaclassifier that selecting a mid-point threshold on the &quot;</span>
      + &quot;probability output by a Classifier. The midpoint &quot;
      + &quot;threshold is set so that a given performance measure is optimized. &quot;
      + &quot;Currently this is the F-measure. Performance is measured either on &quot;
      + &quot;the training data, a hold-out set or using cross-validation. In &quot;
      + &quot;addition, the probabilities returned by the base learner can &quot;
      + &quot;have their range expanded so that the output probabilities will &quot;
      + &quot;reside between 0 and 1 (this is useful if the scheme normally &quot;
      + &quot;produces probabilities in a very narrow range).&quot;;
  }
    
  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String designatedClassTipText() {

<span class="nc" id="L817">    return &quot;Sets the class value for which the optimization is performed. &quot;</span>
      + &quot;The options are: pick the first class value; pick the second &quot;
      + &quot;class value; pick whichever class is least frequent; pick whichever &quot;
      + &quot;class value is most frequent; pick the first class named any of &quot;
      + &quot;\&quot;yes\&quot;,\&quot;pos(itive)\&quot;, \&quot;1\&quot;, or the least frequent if no matches).&quot;;
  }

  /**
   * Gets the method to determine which class value to optimize. Will
   * be one of OPTIMIZE_0, OPTIMIZE_1, OPTIMIZE_LFREQ, OPTIMIZE_MFREQ,
   * OPTIMIZE_POS_NAME.
   *
   * @return the class selection mode.
   */
  public SelectedTag getDesignatedClass() {

<span class="nc" id="L833">    return new SelectedTag(m_ClassMode, TAGS_OPTIMIZE);</span>
  }
  
  /**
   * Sets the method to determine which class value to optimize. Will
   * be one of OPTIMIZE_0, OPTIMIZE_1, OPTIMIZE_LFREQ, OPTIMIZE_MFREQ,
   * OPTIMIZE_POS_NAME.
   *
   * @param newMethod the new class selection mode.
   */
  public void setDesignatedClass(SelectedTag newMethod) {
    
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">    if (newMethod.getTags() == TAGS_OPTIMIZE) {</span>
<span class="fc" id="L846">      m_ClassMode = newMethod.getSelectedTag().getID();</span>
    }
<span class="fc" id="L848">  }</span>

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String evaluationModeTipText() {

<span class="nc" id="L856">    return &quot;Sets the method used to determine the threshold/performance &quot;</span>
      + &quot;curve. The options are: perform optimization based on the entire &quot;
      + &quot;training set (may result in overfitting); perform an n-fold &quot;
      + &quot;cross-validation (may be time consuming); perform one fold of &quot;
      + &quot;an n-fold cross-validation (faster but likely less accurate).&quot;;
  }

  /**
   * Sets the evaluation mode used. Will be one of
   * EVAL_TRAINING, EVAL_TUNED_SPLIT, or EVAL_CROSS_VALIDATION
   *
   * @param newMethod the new evaluation mode.
   */
  public void setEvaluationMode(SelectedTag newMethod) {
    
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">    if (newMethod.getTags() == TAGS_EVAL) {</span>
<span class="fc" id="L872">      m_EvalMode = newMethod.getSelectedTag().getID();</span>
    }
<span class="fc" id="L874">  }</span>

  /**
   * Gets the evaluation mode used. Will be one of
   * EVAL_TRAINING, EVAL_TUNED_SPLIT, or EVAL_CROSS_VALIDATION
   *
   * @return the evaluation mode.
   */
  public SelectedTag getEvaluationMode() {

<span class="nc" id="L884">    return new SelectedTag(m_EvalMode, TAGS_EVAL);</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String rangeCorrectionTipText() {

<span class="nc" id="L893">    return &quot;Sets the type of prediction range correction performed. &quot;</span>
      + &quot;The options are: do not do any range correction; &quot;
      + &quot;expand predicted probabilities so that the minimum probability &quot;
      + &quot;observed during the optimization maps to 0, and the maximum &quot;
      + &quot;maps to 1 (values outside this range are clipped to 0 and 1).&quot;;
  }

  /**
   * Sets the confidence range correction mode used. Will be one of
   * RANGE_NONE, or RANGE_BOUNDS
   *
   * @param newMethod the new correciton mode.
   */
  public void setRangeCorrection(SelectedTag newMethod) {
    
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">    if (newMethod.getTags() == TAGS_RANGE) {</span>
<span class="fc" id="L909">      m_RangeMode = newMethod.getSelectedTag().getID();</span>
    }
<span class="fc" id="L911">  }</span>

  /**
   * Gets the confidence range correction mode used. Will be one of
   * RANGE_NONE, or RANGE_BOUNDS
   *
   * @return the confidence correction mode.
   */
  public SelectedTag getRangeCorrection() {

<span class="nc" id="L921">    return new SelectedTag(m_RangeMode, TAGS_RANGE);</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numXValFoldsTipText() {

<span class="nc" id="L930">    return &quot;Sets the number of folds used during full cross-validation &quot;</span>
      + &quot;and tuned fold evaluation. This number will be automatically &quot;
      + &quot;reduced if there are insufficient positive examples.&quot;;
  }

  /**
   * Get the number of folds used for cross-validation.
   *
   * @return the number of folds used for cross-validation.
   */
  public int getNumXValFolds() {
    
<span class="fc" id="L942">    return m_NumXValFolds;</span>
  }
  
  /**
   * Set the number of folds used for cross-validation.
   *
   * @param newNumFolds the number of folds used for cross-validation.
   */
  public void setNumXValFolds(int newNumFolds) {
    
<span class="fc bfc" id="L952" title="All 2 branches covered.">    if (newNumFolds &lt; 2) {</span>
<span class="fc" id="L953">      throw new IllegalArgumentException(&quot;Number of folds must be greater than 1&quot;);</span>
    }
<span class="fc" id="L955">    m_NumXValFolds = newNumFolds;</span>
<span class="fc" id="L956">  }</span>

  /**
   * Returns the type of graph this classifier
   * represents.
   *  
   * @return the type of graph this classifier represents
   */   
  public int graphType() {
    
<span class="nc bnc" id="L966" title="All 2 branches missed.">    if (m_Classifier instanceof Drawable)</span>
<span class="nc" id="L967">      return ((Drawable)m_Classifier).graphType();</span>
    else 
<span class="nc" id="L969">      return Drawable.NOT_DRAWABLE;</span>
  }

  /**
   * Returns graph describing the classifier (if possible).
   *
   * @return the graph of the classifier in dotty format
   * @throws Exception if the classifier cannot be graphed
   */
  public String graph() throws Exception {
    
<span class="nc bnc" id="L980" title="All 2 branches missed.">    if (m_Classifier instanceof Drawable)</span>
<span class="nc" id="L981">      return ((Drawable)m_Classifier).graph();</span>
<span class="nc" id="L982">    else throw new Exception(&quot;Classifier: &quot; + getClassifierSpec()</span>
<span class="nc" id="L983">			     + &quot; cannot be graphed&quot;);</span>
  }

  /**
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String manualThresholdValueTipText() {

<span class="nc" id="L992">    return &quot;Sets a manual threshold value to use. &quot;</span>
      + &quot;If this is set (non-negative value between 0 and 1), then &quot;
      + &quot;all options pertaining to automatic threshold selection are &quot;
      + &quot;ignored. &quot;;
  }

  /**
   * Sets the value for a manual threshold. If this option
   * is set (non-negative value between 0 and 1), then options 
   * pertaining to automatic threshold selection are ignored.
   *
   * @param threshold the manual threshold to use
   */
  public void setManualThresholdValue(double threshold) throws Exception {
<span class="nc" id="L1006">    m_manualThresholdValue = threshold;</span>
<span class="nc bnc" id="L1007" title="All 4 branches missed.">    if (threshold &gt;= 0.0 &amp;&amp; threshold &lt;= 1.0) {</span>
<span class="nc" id="L1008">      m_manualThreshold = true;</span>
    } else {
<span class="nc" id="L1010">      m_manualThreshold = false;</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">      if (threshold &gt;= 0) {</span>
<span class="nc" id="L1012">        throw new IllegalArgumentException(&quot;Threshold must be in the &quot;</span>
                                           + &quot;range 0..1.&quot;);
      }
    }
<span class="nc" id="L1016">  }</span>

  /**
   * Returns the value of the manual threshold. (a negative
   * value indicates that no manual threshold is being used.
   *
   * @return the value of the manual threshold.
   */
  public double getManualThresholdValue() {
<span class="nc" id="L1025">    return m_manualThresholdValue;</span>
  }
 
  /**
   * Returns description of the cross-validated classifier.
   *
   * @return description of the cross-validated classifier as a string
   */
  public String toString() {

<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">    if (m_BestValue == -Double.MAX_VALUE)</span>
<span class="fc" id="L1036">      return &quot;ThresholdSelector: No model built yet.&quot;;</span>

<span class="nc" id="L1038">    String result = &quot;Threshold Selector.\n&quot;</span>
<span class="nc" id="L1039">    + &quot;Classifier: &quot; + m_Classifier.getClass().getName() + &quot;\n&quot;;</span>

<span class="nc" id="L1041">    result += &quot;Index of designated class: &quot; + m_DesignatedClass + &quot;\n&quot;;</span>

<span class="nc bnc" id="L1043" title="All 2 branches missed.">    if (m_manualThreshold) {</span>
<span class="nc" id="L1044">      result += &quot;User supplied threshold: &quot; + m_BestThreshold + &quot;\n&quot;;</span>
    } else {
<span class="nc" id="L1046">      result += &quot;Evaluation mode: &quot;;</span>
<span class="nc bnc" id="L1047" title="All 3 branches missed.">      switch (m_EvalMode) {</span>
      case EVAL_CROSS_VALIDATION:
<span class="nc" id="L1049">        result += m_NumXValFolds + &quot;-fold cross-validation&quot;;</span>
<span class="nc" id="L1050">        break;</span>
      case EVAL_TUNED_SPLIT:
<span class="nc" id="L1052">        result += &quot;tuning on 1/&quot; + m_NumXValFolds + &quot; of the data&quot;;</span>
<span class="nc" id="L1053">        break;</span>
      case EVAL_TRAINING_SET:
      default:
<span class="nc" id="L1056">        result += &quot;tuning on the training data&quot;;</span>
      }
<span class="nc" id="L1058">      result += &quot;\n&quot;;</span>

<span class="nc" id="L1060">      result += &quot;Threshold: &quot; + m_BestThreshold + &quot;\n&quot;;</span>
<span class="nc" id="L1061">      result += &quot;Best value: &quot; + m_BestValue + &quot;\n&quot;;</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">      if (m_RangeMode == RANGE_BOUNDS) {</span>
<span class="nc" id="L1063">        result += &quot;Expanding range [&quot; + m_LowThreshold + &quot;,&quot; + m_HighThreshold</span>
<span class="nc" id="L1064">          + &quot;] to [0, 1]\n&quot;;</span>
      }
<span class="nc" id="L1066">      result += &quot;Measure: &quot; + getMeasure().getSelectedTag().getReadable() + &quot;\n&quot;;</span>
    }
<span class="nc" id="L1068">    result += m_Classifier.toString();</span>
<span class="nc" id="L1069">    return result;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1078">    return RevisionUtils.extract(&quot;$Revision: 1.43 $&quot;);</span>
  }
  
  /**
   * Main method for testing this class.
   *
   * @param argv the options
   */
  public static void main(String [] argv) {
<span class="nc" id="L1087">    runClassifier(new ThresholdSelector(), argv);</span>
<span class="nc" id="L1088">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>