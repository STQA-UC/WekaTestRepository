<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>FPGrowth.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.associations</a> &gt; <span class="el_source">FPGrowth.java</span></div><h1>FPGrowth.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    FPGrowth.java
 *    Copyright (C) 2009 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.associations;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.SparseInstance;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

/**
 &lt;!-- globalinfo-start --&gt;
 * Class implementing the FP-growth algorithm for finding large item sets without candidate generation. Iteratively reduces the minimum support until it finds the required number of rules with the given minimum metric. For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * J. Han, J.Pei, Y. Yin: Mining frequent patterns without candidate generation. In: Proceedings of the 2000 ACM-SIGMID International Conference on Management of Data, 1-12, 2000.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Han2000,
 *    author = {J. Han and J.Pei and Y. Yin},
 *    booktitle = {Proceedings of the 2000 ACM-SIGMID International Conference on Management of Data},
 *    pages = {1-12},
 *    title = {Mining frequent patterns without candidate generation},
 *    year = {2000}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;attribute index of positive value&amp;gt;
 *  Set the index of the attribute value to consider as 'positive'
 *  for binary attributes in normal dense instances. Index 2 is always
 *  used for sparse instances. (default = 2)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;max items&amp;gt;
 *  The maximum number of items to include in large items sets (and rules). (default = -1, i.e. no limit.)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;require number of rules&amp;gt;
 *  The required number of rules. (default = 10)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T &amp;lt;0=confidence | 1=lift | 2=leverage | 3=Conviction&amp;gt;
 *  The metric by which to rank rules. (default = confidence)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;minimum metric score of a rule&amp;gt;
 *  The minimum metric score of a rule. (default = 0.9)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -U &amp;lt;upper bound for minimum support&amp;gt;
 *  Upper bound for minimum support. (default = 1.0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;lower bound for minimum support&amp;gt;
 *  The lower bound for the minimum support. (default = 0.1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D &amp;lt;delta for minimum support&amp;gt;
 *  The delta by which the minimum support is decreased in
 *  each iteration. (default = 0.05)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Find all rules that meet the lower bound on
 *  minimum support and the minimum metric constraint.
 *  Turning this mode on will disable the iterative support reduction
 *  procedure to find the specified number of rules.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -transactions &amp;lt;comma separated list of attribute names&amp;gt;
 *  Only consider transactions that contain these items (default = no restriction)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -rules &amp;lt;comma separated list of attribute names&amp;gt;
 *  Only print rules that contain these items. (default = no restriction)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -use-or
 *  Use OR instead of AND for must contain list(s). Use in conjunction
 *  with -transactions and/or -rules&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Mark Hall (mhall{[at]}pentaho{[dot]}com)
 * @version $Revision: 7092 $
 */
public class FPGrowth extends AbstractAssociator 
  implements OptionHandler, TechnicalInformationHandler {
  
  /** For serialization */
  private static final long serialVersionUID = 3620717108603442911L;

  /**
   * Inner class that handles a single binary item
   */
  public static class BinaryItem implements Serializable, Comparable&lt;BinaryItem&gt; {
    
    /** For serialization */
    private static final long serialVersionUID = -3372941834914147669L;
    
    /** The frequency of the item */
    protected int m_frequency;
    
    /** The attribute that the item corresponds to */
    protected Attribute m_attribute;
    
    /** The index of the value considered to be positive */
    protected int m_valueIndex;
    
<span class="nc" id="L152">    public BinaryItem(Attribute att, int valueIndex) throws Exception {</span>
<span class="nc bnc" id="L153" title="All 6 branches missed.">      if (att.isNumeric() || (att.isNominal() &amp;&amp; att.numValues() &gt; 2)) {</span>
<span class="nc" id="L154">        throw new Exception(&quot;BinaryItem must be constructed using a nominal attribute&quot; +</span>
        		&quot; with at most 2 values!&quot;);
      }
<span class="nc" id="L157">      m_attribute = att;</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (m_attribute.numValues() == 1) {</span>
<span class="nc" id="L159">        m_valueIndex = 0; // unary attribute (? used to indicate absence from a basket)</span>
      } else {
<span class="nc" id="L161">        m_valueIndex = valueIndex;</span>
      }
<span class="nc" id="L163">    }</span>
    
    /**
     * Increase the frequency of this item.
     * 
     * @param f the amount to increase the frequency by.
     */
    public void increaseFrequency(int f) {
<span class="nc" id="L171">      m_frequency += f;</span>
<span class="nc" id="L172">    }</span>
    
    /**
     * Decrease the frequency of this item.
     * 
     * @param f the amount by which to decrease the frequency.
     */
    public void decreaseFrequency(int f) {
<span class="nc" id="L180">      m_frequency -= f;</span>
<span class="nc" id="L181">    }</span>
    
    /**
     * Increment the frequency of this item.
     */
    public void increaseFrequency() {
<span class="nc" id="L187">      m_frequency++;</span>
<span class="nc" id="L188">    }</span>
    
    /**
     * Decrement the frequency of this item.
     */
    public void decreaseFrequency() {
<span class="nc" id="L194">      m_frequency--;</span>
<span class="nc" id="L195">    }</span>
    
    /**
     * Get the frequency of this item.
     * 
     * @return the frequency.
     */
    public int getFrequency() {
<span class="nc" id="L203">      return m_frequency;</span>
    }
    
    /**
     * Get the attribute that this item corresponds to.
     * 
     * @return the corresponding attribute.
     */
    public Attribute getAttribute() {
<span class="nc" id="L212">      return m_attribute;</span>
    }
    
    /**
     * Get the value index for this item.
     * 
     * @return the value index.
     */
    public int getValueIndex() {
<span class="nc" id="L221">      return m_valueIndex;</span>
    }
    
    /**
     * A string representation of this item.
     * 
     * @return a string representation of this item.
     */
    public String toString() {
<span class="nc" id="L230">      return toString(false);</span>
    }
    
    /**
     * A string representation of this item.
     * 
     * @param freq true if the frequency should be included.
     * @return a string representation of this item. 
     */
    public String toString(boolean freq) {
<span class="nc" id="L240">      String result = m_attribute.name() + &quot;=&quot; + m_attribute.value(m_valueIndex);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      if (freq) {</span>
<span class="nc" id="L242">        result += &quot;:&quot; + m_frequency;</span>
      }
<span class="nc" id="L244">      return result;</span>
    }
    
    public String toXML() {
<span class="nc" id="L248">      String result = &quot;&lt;ITEM name=\&quot;&quot; +  m_attribute.name() + &quot;\&quot; value=\&quot;=&quot; </span>
<span class="nc" id="L249">      + m_attribute.value(m_valueIndex) + &quot;\&quot;/&gt;&quot;;</span>
      
<span class="nc" id="L251">      return result;</span>
    }
    
    /**
     * Ensures that items will be sorted in descending order of frequency.
     * Ties are ordered by attribute name.
     * 
     * @param comp the BinaryItem to compare against.
     */
    public int compareTo(BinaryItem comp) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">      if (m_frequency == comp.getFrequency()) {</span>
        // sort by name
<span class="nc" id="L263">        return -1 * m_attribute.name().compareTo(comp.getAttribute().name());</span>
      }
<span class="nc bnc" id="L265" title="All 2 branches missed.">      if (comp.getFrequency() &lt; m_frequency) {</span>
<span class="nc" id="L266">        return -1;</span>
      }
<span class="nc" id="L268">      return 1;</span>
    }
    
    public boolean equals(Object compareTo) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (!(compareTo instanceof BinaryItem)) {</span>
<span class="nc" id="L273">        return false;</span>
      }
      
<span class="nc" id="L276">      BinaryItem b = (BinaryItem)compareTo;</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">      if (m_attribute.equals(b.getAttribute()) &amp;&amp; m_frequency == b.getFrequency()) {</span>
<span class="nc" id="L278">        return true;</span>
      }
      
<span class="nc" id="L281">      return false;</span>
    }
    
    public int hashCode() {
<span class="nc" id="L285">      return (m_attribute.name().hashCode() ^ </span>
<span class="nc" id="L286">          m_attribute.numValues()) * m_frequency;</span>
    }
  }
  
  /**
   * Class for maintaining a frequent item set.
   */
  protected static class FrequentBinaryItemSet 
    implements Serializable, Cloneable {
    
    /** For serialization */
    private static final long serialVersionUID = -6543815873565829448L;

    /** The list of items in the item set */
<span class="nc" id="L300">    protected ArrayList&lt;BinaryItem&gt; m_items = new ArrayList&lt;BinaryItem&gt;();</span>
    
    /** the support of this item set **/
    protected int m_support;
    
    /**
     * Constructor
     * 
     * @param items the items that make up the frequent item set.
     * @param support the support of this item set.
     */
<span class="nc" id="L311">    public FrequentBinaryItemSet(ArrayList&lt;BinaryItem&gt; items, int support) {</span>
<span class="nc" id="L312">      m_items = items;</span>
<span class="nc" id="L313">      m_support = support;</span>
<span class="nc" id="L314">      Collections.sort(m_items);</span>
<span class="nc" id="L315">    }</span>
    
    /**
     * Add an item to this item set.
     * 
     * @param i the item to add.
     */
    public void addItem(BinaryItem i) {
<span class="nc" id="L323">      m_items.add(i);</span>
<span class="nc" id="L324">      Collections.sort(m_items);</span>
<span class="nc" id="L325">    }</span>
    
    /**
     * Set the support for this item set.
     * 
     * @param support the support for this item set.
     */
    public void setSupport(int support) {
<span class="nc" id="L333">      m_support = support;</span>
<span class="nc" id="L334">    }</span>
    
    /**
     * Get the support of this item set.
     * 
     * @return the support of this item set.
     */
    public int getSupport() {
<span class="nc" id="L342">      return m_support;</span>
    }
    
    /**
     * Get the items in this item set.
     * 
     * @return the items in this item set.
     */
    public Collection&lt;BinaryItem&gt; getItems() {
<span class="nc" id="L351">      return m_items;</span>
    }
    
    /**
     * Get a particular item from this item set.
     * 
     * @param index the index of the item to get.
     * @return the item.
     */
    public BinaryItem getItem(int index) {
<span class="nc" id="L361">      return m_items.get(index);</span>
    }
    
    /**
     * Get the number of items in this item set.
     * 
     * @return the number of items in this item set.
     */
    public int numberOfItems() {
<span class="nc" id="L370">      return m_items.size();</span>
    }
    
    /**
     * Get a textual description of this item set.
     * 
     * @return a textual description of this item set.
     */
    public String toString() {
<span class="nc" id="L379">      StringBuffer buff = new StringBuffer();</span>
<span class="nc" id="L380">      Iterator&lt;BinaryItem&gt; i = m_items.iterator();</span>
      
<span class="nc bnc" id="L382" title="All 2 branches missed.">      while (i.hasNext()) {</span>
<span class="nc" id="L383">        buff.append(i.next().toString() + &quot; &quot;);        </span>
      }
<span class="nc" id="L385">      buff.append(&quot;: &quot; + m_support);</span>
<span class="nc" id="L386">      return buff.toString();</span>
    }
    
    /**
     * Make a copy of this item set.
     * 
     * @return a copy of this item set.
     */
    public Object clone() {
<span class="nc" id="L395">      ArrayList&lt;BinaryItem&gt; items = new ArrayList&lt;BinaryItem&gt;(m_items);</span>
<span class="nc" id="L396">      return new FrequentBinaryItemSet(items, m_support);</span>
    }
  }
  
  /**
   * Maintains a list of frequent item sets.
   */
  protected static class FrequentItemSets implements Serializable {
    
    /** For serialization */
    private static final long serialVersionUID = 4173606872363973588L;

    /** The list of frequent item sets */
<span class="nc" id="L409">    protected ArrayList&lt;FrequentBinaryItemSet&gt; m_sets = </span>
<span class="nc" id="L410">      new ArrayList&lt;FrequentBinaryItemSet&gt;();</span>
    
    /** The total number of transactions in the data */
    protected int m_numberOfTransactions;
    
    /**
     * Constructor.
     * 
     * @param numTransactions the total number of transactions in the data.
     */
<span class="nc" id="L420">    public FrequentItemSets(int numTransactions) {</span>
<span class="nc" id="L421">      m_numberOfTransactions = numTransactions;</span>
<span class="nc" id="L422">    }</span>
        
    /**
     * Get an item set.
     * 
     * @param index the index of the item set to get.
     * @return an item set.
     */
    public FrequentBinaryItemSet getItemSet(int index) {
<span class="nc" id="L431">      return m_sets.get(index);</span>
    }
    
    /**
     * Get an iterator that can be used to access all the item sets.
     * 
     * @return an iterator.
     */
    public Iterator&lt;FrequentBinaryItemSet&gt; iterator() {
<span class="nc" id="L440">      return m_sets.iterator();</span>
    }
    
    /**
     * Get the total number of transactions in the data that the item
     * sets were derived from.
     * 
     * @return the total number of transactions in the data.
     */
    public int getNumberOfTransactions() {
<span class="nc" id="L450">      return m_numberOfTransactions;</span>
    }
    
    /**
     * Add an item set.
     * 
     * @param setToAdd the item set to add.
     */
    public void addItemSet(FrequentBinaryItemSet setToAdd) {
<span class="nc" id="L459">      m_sets.add(setToAdd);</span>
<span class="nc" id="L460">    }</span>
    
    /**
     * Sort the item sets according to the supplied comparator.
     * 
     * @param comp the comparator to use.
     */
    public void sort(Comparator&lt;FrequentBinaryItemSet&gt; comp) {
<span class="nc" id="L468">      Collections.sort(m_sets, comp);</span>
<span class="nc" id="L469">    }</span>
    
    /**
     * Get the number of item sets.
     * 
     * @return the number of item sets.
     */
    public int size() {
<span class="nc" id="L477">      return m_sets.size();</span>
    }
    
    /**
     * Sort the item sets. Sorts by item set length. Ties are broken by comparing
     * the items in the two item sets.
     */
    public void sort() {
<span class="nc" id="L485">      Comparator&lt;FrequentBinaryItemSet&gt; compF = new Comparator&lt;FrequentBinaryItemSet&gt;() {</span>
        public int compare(FrequentBinaryItemSet one, FrequentBinaryItemSet two) {
<span class="nc" id="L487">          Collection&lt;BinaryItem&gt; compOne = one.getItems();</span>
<span class="nc" id="L488">          Collection&lt;BinaryItem&gt; compTwo = two.getItems();</span>
          
//          if (one.getSupport() == two.getSupport()) {
            // if supports are equal then list shorter item sets before longer ones
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (compOne.size() &lt; compTwo.size()) {</span>
<span class="nc" id="L493">              return -1;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">            } else if (compOne.size() &gt; compTwo.size()) {</span>
<span class="nc" id="L495">              return 1;</span>
            } else {
              // compare items
<span class="nc" id="L498">              Iterator&lt;BinaryItem&gt; twoIterator = compTwo.iterator();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">              for (BinaryItem oneI : compOne) {</span>
<span class="nc" id="L500">                BinaryItem twoI = twoIterator.next();</span>
<span class="nc" id="L501">                int result = oneI.compareTo(twoI);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (result != 0) {</span>
<span class="nc" id="L503">                  return result;</span>
                }
              }
<span class="nc" id="L506">              return 0; // equal</span>
            }
            
//            return 0;
    /*      } else if (one.getSupport() &gt; two.getSupport()) {
            // reverse ordering (i.e. descending by support)
            return -1;
          } */
          
    //      return 1;
        }
      };
      
<span class="nc" id="L519">      sort(compF);</span>
<span class="nc" id="L520">    }</span>
    
    /**
     * Get a textual description of this list of item sets.
     * 
     * @param numSets the number of item sets to display.
     * @return a textual description of the item sets.
     */
    public String toString(int numSets) {
<span class="nc bnc" id="L529" title="All 2 branches missed.">      if (m_sets.size() == 0) {</span>
<span class="nc" id="L530">        return &quot;No frequent items sets found!&quot;;</span>
      }
      
<span class="nc" id="L533">      StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L534">      result.append(&quot;&quot; + m_sets.size() + &quot; frequent item sets found&quot;);</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      if (numSets &gt; 0) {</span>
<span class="nc" id="L536">        result.append(&quot; , displaying &quot; + numSets);</span>
      }
<span class="nc" id="L538">      result.append(&quot;:\n\n&quot;);</span>
      
<span class="nc" id="L540">      int count = 0;</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">      for (FrequentBinaryItemSet i : m_sets) {</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">        if (numSets &gt; 0 &amp;&amp; count &gt; numSets) {</span>
<span class="nc" id="L543">          break;</span>
        }
<span class="nc" id="L545">        result.append(i.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L546">        count++;</span>
      }
      
<span class="nc" id="L549">      return result.toString();</span>
    }
  }
  
  /**
   * This class holds the counts for projected tree nodes
   * and header lists.
   */
<span class="nc" id="L557">  protected static class ShadowCounts implements Serializable {</span>
    
    /** For serialization */
    private static final long serialVersionUID = 4435433714185969155L;
    
    /** Holds the counts at different recursion levels */
<span class="nc" id="L563">    private ArrayList&lt;Integer&gt; m_counts = new ArrayList&lt;Integer&gt;();</span>
    
    /**
     * Get the count at the specified recursion depth.
     * 
     * @param recursionLevel the depth of the recursion.
     * @return the count.
     */
    public int getCount(int recursionLevel) {
<span class="nc bnc" id="L572" title="All 2 branches missed.">      if (recursionLevel &gt;= m_counts.size()) {</span>
<span class="nc" id="L573">        return 0;</span>
      } else {
<span class="nc" id="L575">        return m_counts.get(recursionLevel);</span>
      }
    }
    
    /**
     * Increase the count at a given recursion level.
     * 
     * @param recursionLevel the level at which to increase the count.
     * @param incr the amount by which to increase the count.
     */
    public void increaseCount(int recursionLevel, int incr) {
      // basically treat the list like a stack where we
      // can add a new element, or increment the element
      // at the top
      
<span class="nc bnc" id="L590" title="All 2 branches missed.">      if (recursionLevel == m_counts.size()) {</span>
        // new element
<span class="nc" id="L592">        m_counts.add(incr);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">      } else if (recursionLevel == m_counts.size() - 1) {</span>
        // otherwise increment the top
<span class="nc" id="L595">        int n = m_counts.get(recursionLevel).intValue();</span>
<span class="nc" id="L596">        m_counts.set(recursionLevel, (n + incr));</span>
      }
<span class="nc" id="L598">    }</span>
    
    /**
     * Remove the count at the given recursion level.
     * 
     * @param recursionLevel the level at which to remove the count.
     */
    public void removeCount(int recursionLevel) {
<span class="nc bnc" id="L606" title="All 2 branches missed.">      if (recursionLevel &lt; m_counts.size()) {</span>
<span class="nc" id="L607">        m_counts.remove(recursionLevel);</span>
      }
<span class="nc" id="L609">    }</span>
  }
  
  /**
   * A node in the FP-tree.
   */
  protected static class FPTreeNode implements Serializable {
                
    /** For serialization */
    private static final long serialVersionUID = 4396315323673737660L;

    /** link to another sibling at this level in the tree */
    protected FPTreeNode m_levelSibling;
    
    /** link to the parent node */
    protected FPTreeNode m_parent;
    
    /** item at this node */
    protected BinaryItem m_item;
    
    /** ID (for graphing the tree) */
    protected int m_ID;
    
    /** the children of this node */
<span class="nc" id="L633">    protected Map&lt;BinaryItem, FPTreeNode&gt; m_children = </span>
<span class="nc" id="L634">      new HashMap&lt;BinaryItem, FPTreeNode&gt;();</span>
    
    /** counts associated with projected versions of this node */
<span class="nc" id="L637">    protected ShadowCounts m_projectedCounts = new ShadowCounts();</span>
    
    /**
     * Construct a new node with the given parent link and item.
     * 
     * @param parent a pointer to the parent of this node.
     * @param item the item at this node.
     */
<span class="nc" id="L645">    public FPTreeNode(FPTreeNode parent, BinaryItem item) {</span>
<span class="nc" id="L646">      m_parent = parent;</span>
<span class="nc" id="L647">      m_item = item;</span>
<span class="nc" id="L648">    }</span>
    
    /**
     * Insert an item set into the tree at this node. Removes the first item
     * from the supplied item set and makes a recursive call to insert the
     * remaining items.
     * 
     * @param itemSet the item set to insert.
     * @param headerTable the header table for the tree.
     * @param incr the amount by which to increase counts.
     */
    public void addItemSet(Collection&lt;BinaryItem&gt; itemSet, 
        Map&lt;BinaryItem, FPTreeRoot.Header&gt; headerTable, int incr) {
     
<span class="nc" id="L662">      Iterator&lt;BinaryItem&gt; i = itemSet.iterator();</span>
      
<span class="nc bnc" id="L664" title="All 2 branches missed.">      if (i.hasNext()) {</span>
<span class="nc" id="L665">        BinaryItem first = i.next();</span>
        
        FPTreeNode aChild;
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (!m_children.containsKey(first)) {</span>
          // not in the tree, so add it.
<span class="nc" id="L670">          aChild = new FPTreeNode(this, first);</span>
<span class="nc" id="L671">          m_children.put(first, aChild);</span>
          
          // update the header
<span class="nc bnc" id="L674" title="All 2 branches missed.">          if (!headerTable.containsKey(first)) {</span>
<span class="nc" id="L675">            headerTable.put(first, new FPTreeRoot.Header());</span>
          }
          
          // append new node to header list
<span class="nc" id="L679">          headerTable.get(first).addToList(aChild);</span>
        } else {
          // get the appropriate child node
<span class="nc" id="L682">          aChild = m_children.get(first);</span>
        }
        
        // update counts in header table
<span class="nc" id="L686">        headerTable.get(first).getProjectedCounts().increaseCount(0, incr);</span>
        
        // increase the child's count
<span class="nc" id="L689">        aChild.increaseProjectedCount(0, incr);</span>
        
        // proceed recursively
<span class="nc" id="L692">        itemSet.remove(first);        </span>
<span class="nc" id="L693">        aChild.addItemSet(itemSet, headerTable, incr);</span>
      }
<span class="nc" id="L695">    }</span>
    
    /**
     * Increase the projected count at the given recursion level at this
     * node
     * 
     * @param recursionLevel the recursion level to increase the node count
     * at.
     * @param incr the amount by which to increase the count.
     */
    public void increaseProjectedCount(int recursionLevel, int incr) {
<span class="nc" id="L706">      m_projectedCounts.increaseCount(recursionLevel, incr);</span>
<span class="nc" id="L707">    }</span>
    
    /**
     * Remove the projected count at the given recursion level for this
     * node.
     * 
     * @param recursionLevel the recursion level at which to remove the count.
     */
    public void removeProjectedCount(int recursionLevel) {
<span class="nc" id="L716">      m_projectedCounts.removeCount(recursionLevel);</span>
<span class="nc" id="L717">    }</span>
    
    /**
     * Get the projected count at the given recursion level for this node.
     * 
     * @param recursionLevel the recursion level at which to get the count.
     * @return the count.
     */
    public int getProjectedCount(int recursionLevel) {
<span class="nc" id="L726">      return m_projectedCounts.getCount(recursionLevel);</span>
    }
    
    /**
     * Get the parent node.
     * 
     * @return the parent node.
     */
    public FPTreeNode getParent() {
<span class="nc" id="L735">      return m_parent;</span>
    }
    
    /**
     * Get the item at this node.
     * 
     * @return the item at this node.
     */
    public BinaryItem getItem() {
<span class="nc" id="L744">      return m_item;</span>
    }    
    
    /**
     * Return a textual description of this node for a given recursion
     * level.
     * 
     * @param recursionLevel the recursion depth to use.
     * @return a textual description of this node.
     */
    public String toString(int recursionLevel) {
<span class="nc" id="L755">      return toString(&quot;&quot;, recursionLevel);</span>
    }

    /**
     * Return a textual description of this node for a given recursion
     * level.
     * 
     * @param prefix a prefix string to prepend.
     * @param recursionLevel the recursion level to use.
     * @return a textual description of this node. 
     */
    public String toString(String prefix, int recursionLevel) {
<span class="nc" id="L767">      StringBuffer buffer = new StringBuffer();</span>
<span class="nc" id="L768">      buffer.append(prefix);</span>
<span class="nc" id="L769">      buffer.append(&quot;|  &quot;);</span>
<span class="nc" id="L770">      buffer.append(m_item.toString());</span>
<span class="nc" id="L771">      buffer.append(&quot; (&quot;);</span>
<span class="nc" id="L772">      buffer.append(m_projectedCounts.getCount(recursionLevel));</span>
<span class="nc" id="L773">      buffer.append(&quot;)\n&quot;);</span>
      
<span class="nc bnc" id="L775" title="All 2 branches missed.">      for (FPTreeNode node : m_children.values()) {</span>
<span class="nc" id="L776">        buffer.append(node.toString(prefix + &quot;|  &quot;, recursionLevel));</span>
      }
<span class="nc" id="L778">      return buffer.toString();</span>
    }
    
    protected int assignIDs(int lastID) {
<span class="nc" id="L782">      int currentLastID = lastID + 1;</span>
<span class="nc" id="L783">      m_ID = currentLastID;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">      if (m_children != null) {</span>
<span class="nc" id="L785">        Collection&lt;FPTreeNode&gt; kids = m_children.values();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        for (FPTreeNode n : kids) {</span>
<span class="nc" id="L787">          currentLastID = n.assignIDs(currentLastID);</span>
        }
      }
<span class="nc" id="L790">      return currentLastID;</span>
    }
    
    /**
     * Generate a dot graph description string for the tree.
     * 
     * @param text a StringBuffer to store the graph description
     * in.
     */
    public void graphFPTree(StringBuffer text) {
<span class="nc bnc" id="L800" title="All 2 branches missed.">      if (m_children != null) {</span>
<span class="nc" id="L801">        Collection&lt;FPTreeNode&gt; kids = m_children.values();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">        for (FPTreeNode n : kids) {</span>
<span class="nc" id="L803">          text.append(&quot;N&quot; + n.m_ID);</span>
<span class="nc" id="L804">          text.append(&quot; [label=\&quot;&quot;);</span>
<span class="nc" id="L805">          text.append(n.getItem().toString() + &quot; (&quot; + n.getProjectedCount(0) + &quot;)\\n&quot;);</span>
<span class="nc" id="L806">          text.append(&quot;\&quot;]\n&quot;);</span>
<span class="nc" id="L807">          n.graphFPTree(text);</span>
<span class="nc" id="L808">          text.append(&quot;N&quot; + m_ID + &quot;-&gt;&quot; + &quot;N&quot; + n.m_ID + &quot;\n&quot;);</span>
        }
      }
<span class="nc" id="L811">    }</span>
  }
  
  /**
   * Root of the FPTree
   */
  private static class FPTreeRoot extends FPTreeNode {
    
    /** For serialization */
    private static final long serialVersionUID = 632150939785333297L;

    /**
     * Stores a header entry for an FPTree 
     */
<span class="nc" id="L825">    protected static class Header implements Serializable {</span>
      
      /** For serialization */
      private static final long serialVersionUID = -6583156284891368909L;
      
      /** The list of pointers into the tree structure */
<span class="nc" id="L831">      protected List&lt;FPTreeNode&gt; m_headerList = new LinkedList&lt;FPTreeNode&gt;();</span>
      
      /** Projected header counts for this entry */
<span class="nc" id="L834">      protected ShadowCounts m_projectedHeaderCounts = new ShadowCounts();</span>
      
      /**
       * Add a tree node into the list for this header entry.
       * 
       * @param toAdd the node to add.
       */
      public void addToList(FPTreeNode toAdd) {
<span class="nc" id="L842">        m_headerList.add(toAdd);</span>
<span class="nc" id="L843">      }</span>
      
      /**
       * Get the list of nodes for this header entry.
       * 
       * @return the list of nodes for this header entry.
       */
      public List&lt;FPTreeNode&gt; getHeaderList() {
<span class="nc" id="L851">        return m_headerList;</span>
      }
      
      /**
       * Get the projected counts for this header entry.
       * 
       * @return the projected counts for this header entry.
       */
      public ShadowCounts getProjectedCounts() {
<span class="nc" id="L860">        return m_projectedHeaderCounts;</span>
      }
    }
    
    /** Stores the header table as mapped Header entries */
<span class="nc" id="L865">    protected Map&lt;BinaryItem, Header&gt; m_headerTable = </span>
<span class="nc" id="L866">      new HashMap&lt;BinaryItem, Header&gt;();</span>
    
    /**
     * Create a new FPTreeRoot.
     */
    public FPTreeRoot() {
<span class="nc" id="L872">      super(null, null);</span>
<span class="nc" id="L873">    }</span>
    
    /**
     * Insert an item set into the tree.
     * 
     * @param itemSet the item set to insert into the tree.
     * @param incr the increment by which to increase counters.
     */
    public void addItemSet(Collection&lt;BinaryItem&gt; itemSet, int incr) {
<span class="nc" id="L882">      super.addItemSet(itemSet, m_headerTable, incr);</span>
<span class="nc" id="L883">    }</span>
    
    /**
     * Get the header table for this tree.
     * 
     * @return the header table for this tree.
     */
    public Map&lt;BinaryItem, Header&gt; getHeaderTable() {
<span class="nc" id="L891">      return m_headerTable;</span>
    }
    
    public boolean isEmpty(int recursionLevel) {
<span class="nc bnc" id="L895" title="All 2 branches missed.">      for (FPTreeNode c : m_children.values()) {</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">        if (c.getProjectedCount(recursionLevel) &gt; 0) {</span>
<span class="nc" id="L897">          return false;</span>
        }
      }
<span class="nc" id="L900">      return true;</span>
    }
    
    /**
     * Get a textual description of the tree at a given recursion
     * (projection) level.
     * 
     * @param pad the string to use as a prefix for indenting nodes.
     * @param recursionLevel the recursion level (projection) to use.
     * @return the textual description of the tree.
     */
    public String toString(String pad, int recursionLevel) {
<span class="nc" id="L912">      StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L913">      result.append(pad);</span>
<span class="nc" id="L914">      result.append(&quot;+ ROOT\n&quot;);</span>

<span class="nc bnc" id="L916" title="All 2 branches missed.">      for (FPTreeNode node : m_children.values()) {</span>
<span class="nc" id="L917">        result.append(node.toString(pad + &quot;|  &quot;, recursionLevel));</span>
      }
<span class="nc" id="L919">      return result.toString();</span>
    }

    /**
     * Get a textual description of the header table for this tree.
     * 
     * @param recursionLevel the recursion level to use.
     * @return a textual description of the header table for this
     * tree at a given recursion level.
     */
    public String printHeaderTable(int recursionLevel) {
<span class="nc" id="L930">      StringBuffer buffer = new StringBuffer();</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">      for (BinaryItem item : m_headerTable.keySet()) {</span>
<span class="nc" id="L932">        buffer.append(item.toString());</span>
<span class="nc" id="L933">        buffer.append(&quot; : &quot;);</span>
<span class="nc" id="L934">        buffer.append(m_headerTable.get(item).getProjectedCounts().getCount(recursionLevel));</span>
<span class="nc" id="L935">        buffer.append(&quot;\n&quot;);</span>
      }
<span class="nc" id="L937">      return buffer.toString();</span>
    }
    
    public void graphHeaderTable(StringBuffer text, int maxID) {

<span class="nc bnc" id="L942" title="All 2 branches missed.">      for (BinaryItem item : m_headerTable.keySet()) {</span>
<span class="nc" id="L943">        Header h = m_headerTable.get(item);</span>
<span class="nc" id="L944">        List&lt;FPTreeNode&gt; headerList = h.getHeaderList();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (headerList.size() &gt; 1) {</span>
<span class="nc" id="L946">          text.append(&quot;N&quot; + maxID + &quot; [label=\&quot;&quot; + headerList.get(0).getItem().toString() </span>
<span class="nc" id="L947">              + &quot; (&quot; + h.getProjectedCounts().getCount(0) + &quot;)&quot;</span>
<span class="nc" id="L948">              + &quot;\&quot; shape=plaintext]\n&quot;);</span>

<span class="nc" id="L950">          text.append(&quot;N&quot; + maxID + &quot;-&gt;&quot; + &quot;N&quot; + headerList.get(1).m_ID + &quot;\n&quot;);</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">          for (int i = 1; i &lt; headerList.size() - 1; i++) {</span>
<span class="nc" id="L952">            text.append(&quot;N&quot; + headerList.get(i).m_ID + &quot;-&gt;&quot; + &quot;N&quot; + headerList.get(i+1).m_ID + &quot;\n&quot;);</span>
          }
<span class="nc" id="L954">          maxID++;</span>
        }
      }
<span class="nc" id="L957">    }</span>
  }
  
  /**
   * Class for storing and manipulating an association rule. Also has a utility
   * routine for generating (by brute force) all the association rules that meet
   * a given metric threshold from a list of large item sets.
   * 
   * @author Mark Hall (mhall{[at]}pentaho{[dot]}com).
   */
  /**
   * @author mhall
   *
   */
<span class="fc" id="L971">  public static class AssociationRule implements Serializable, Comparable&lt;AssociationRule&gt; {</span>
    
    /** For serialization */
    private static final long serialVersionUID = -661269018702294489L;

    /** Enum for holding different metric types */
<span class="fc" id="L977">    public static enum METRIC_TYPE {</span>
<span class="fc" id="L978">      CONFIDENCE(&quot;conf&quot;) {</span>
        double compute(int premiseSupport, int consequenceSupport, 
            int totalSupport, int totalTransactions) {
          
<span class="nc" id="L982">          return (double)totalSupport / (double)premiseSupport;</span>
        }
      },
<span class="fc" id="L985">      LIFT(&quot;lift&quot;) {</span>
        double compute(int premiseSupport, int consequenceSupport, 
            int totalSupport, int totalTransactions) {
          
<span class="nc" id="L989">          double confidence = </span>
<span class="nc" id="L990">            METRIC_TYPE.CONFIDENCE.compute(premiseSupport, consequenceSupport, </span>
<span class="nc" id="L991">                totalSupport, totalTransactions);</span>
<span class="nc" id="L992">          return confidence / ((double)consequenceSupport /</span>
<span class="nc" id="L993">              (double)totalTransactions);</span>
        }
      },
<span class="fc" id="L996">      LEVERAGE(&quot;lev&quot;) {</span>
        double compute(int premiseSupport, int consequenceSupport, 
            int totalSupport, int totalTransactions) {
          
<span class="nc" id="L1000">          double coverageForItemSet = (double)totalSupport /</span>
<span class="nc" id="L1001">            (double)totalTransactions;</span>
<span class="nc" id="L1002">          double expectedCoverageIfIndependent = </span>
<span class="nc" id="L1003">            ((double)premiseSupport / (double)totalTransactions) *</span>
<span class="nc" id="L1004">            ((double)consequenceSupport / (double)totalTransactions);</span>
<span class="nc" id="L1005">          return coverageForItemSet - expectedCoverageIfIndependent;</span>
        }
      },
<span class="fc" id="L1008">      CONVICTION(&quot;conv&quot;) {</span>
        double compute(int premiseSupport, int consequenceSupport, 
            int totalSupport, int totalTransactions) {
          
<span class="nc" id="L1012">          double num = </span>
<span class="nc" id="L1013">            (double)premiseSupport * (double)(totalTransactions - consequenceSupport) /</span>
<span class="nc" id="L1014">            (double)totalTransactions;</span>
<span class="nc" id="L1015">          double denom = premiseSupport - totalSupport + 1;</span>
<span class="nc" id="L1016">          return num / denom;</span>
        }
      };
      
      private final String m_stringVal;
<span class="fc" id="L1021">      METRIC_TYPE(String name) {</span>
<span class="fc" id="L1022">        m_stringVal = name;</span>
<span class="fc" id="L1023">      }</span>
      
      abstract double compute(int premiseSupport, int consequenceSupport, 
          int totalSupport, int totalTransactions);
      
      public String toString() {
<span class="nc" id="L1029">        return m_stringVal;</span>
      }
      
      public String toStringMetric(int premiseSupport, int consequenceSupport,
          int totalSupport, int totalTransactions) {
<span class="nc" id="L1034">        return m_stringVal + &quot;:(&quot; + Utils.doubleToString(compute(premiseSupport, consequenceSupport,</span>
<span class="nc" id="L1035">            totalSupport, totalTransactions), 2) + &quot;)&quot;;</span>
      }
      
      public String toXML(int premiseSupport, int consequenceSupport,
          int totalSupport, int totalTransactions) {
<span class="nc" id="L1040">        String result = &quot;&lt;CRITERE name=\&quot;&quot; + m_stringVal + &quot;\&quot; value=\&quot; &quot; +</span>
<span class="nc" id="L1041">          Utils.doubleToString(compute(premiseSupport, consequenceSupport,</span>
<span class="nc" id="L1042">            totalSupport, totalTransactions), 2) + &quot;\&quot;/&gt;&quot;;</span>
        
<span class="nc" id="L1044">        return result;</span>
      }
    }
    
    /** Tags for display in the GUI */
<span class="fc" id="L1049">    public static final Tag[] TAGS_SELECTION = {</span>
<span class="fc" id="L1050">      new Tag(METRIC_TYPE.CONFIDENCE.ordinal(), &quot;Confidence&quot;),</span>
<span class="fc" id="L1051">      new Tag(METRIC_TYPE.LIFT.ordinal(), &quot;Lift&quot;),</span>
<span class="fc" id="L1052">      new Tag(METRIC_TYPE.LEVERAGE.ordinal(), &quot;Leverage&quot;),</span>
<span class="fc" id="L1053">      new Tag(METRIC_TYPE.CONVICTION.ordinal(), &quot;Conviction&quot;)</span>
    };
    
    /** The metric type for this rule */
<span class="nc" id="L1057">    protected METRIC_TYPE m_metricType = METRIC_TYPE.CONFIDENCE;</span>
    
    /** The premise of the rule */
    protected Collection&lt;BinaryItem&gt; m_premise;
    
    /** The consequence of the rule */
    protected Collection&lt;BinaryItem&gt; m_consequence;
    
    /** The support for the premise */
    protected int m_premiseSupport;
    
    /** The support for the consequence */
    protected int m_consequenceSupport;
    
    /** The total support for the item set (premise + consequence) */
    protected int m_totalSupport;
    
    /** The total number of transactions in the data */
    protected int m_totalTransactions;
    
    /**
     * Construct a new association rule.
     * 
     * @param premise the premise of the rule
     * @param consequence the consequence of the rule
     * @param metric the metric for the rule
     * @param premiseSupport the support of the premise
     * @param consequenceSupport the support of the consequence
     * @param totalSupport the total support of the rule
     * @param totalTransactions the number of transactions in the data
     */
<span class="nc" id="L1088">    public AssociationRule(Collection&lt;BinaryItem&gt; premise, </span>
        Collection&lt;BinaryItem&gt; consequence, METRIC_TYPE metric,
        int premiseSupport, int consequenceSupport,
        int totalSupport, int totalTransactions) {
<span class="nc" id="L1092">      m_premise = premise;</span>
<span class="nc" id="L1093">      m_consequence = consequence;</span>
<span class="nc" id="L1094">      m_metricType = metric;</span>
<span class="nc" id="L1095">      m_premiseSupport = premiseSupport;</span>
<span class="nc" id="L1096">      m_consequenceSupport = consequenceSupport;</span>
<span class="nc" id="L1097">      m_totalSupport = totalSupport;</span>
<span class="nc" id="L1098">      m_totalTransactions = totalTransactions;</span>
<span class="nc" id="L1099">    }</span>
    
    /**
     * Get the premise of this rule.
     * 
     * @return the premise of this rule.
     */
    public Collection&lt;BinaryItem&gt; getPremise() {
<span class="nc" id="L1107">      return m_premise;</span>
    }
    
    /**
     * Get the consequence of this rule.
     * 
     * @return the consequence of this rule.
     */
    public Collection&lt;BinaryItem&gt; getConsequence() {
<span class="nc" id="L1116">      return m_consequence;</span>
    }
    
    /**
     * Get the metric type of this rule (e.g. confidence).
     * 
     * @return the metric type of this rule.
     */
    public METRIC_TYPE getMetricType() {
<span class="nc" id="L1125">      return m_metricType;</span>
    }
    
    /**
     * Get the value of the metric for this rule. 
     * 
     * @return the value of the metric for this rule.
     */
    public double getMetricValue() {
<span class="nc" id="L1134">      return m_metricType.compute(m_premiseSupport, m_consequenceSupport, </span>
<span class="nc" id="L1135">          m_totalSupport, m_totalTransactions);</span>
    }
    
    /**
     * Get the support for the premise.
     * 
     * @return the support for the premise.
     */
    public int getPremiseSupport() {
<span class="nc" id="L1144">      return m_premiseSupport;</span>
    }
    
    /**
     * Get the support for the consequence.
     * 
     * @return the support for the consequence.
     */
    public int getConsequenceSupport() {
<span class="nc" id="L1153">      return m_consequenceSupport;</span>
    }
    
    /**
     * Get the total support for this rule (premise + consequence).
     * 
     * @return the total support for this rule.
     */
    public int getTotalSupport() {
<span class="nc" id="L1162">      return m_totalSupport;</span>
    }
    
    /**
     * Get the total number of transactions in the data.
     * 
     * @return the total number of transactions in the data.
     */
    public int getTotalTransactions() {
<span class="nc" id="L1171">      return m_totalTransactions;</span>
    }
    
    /**
     * Compare this rule to the supplied rule.
     * 
     * @param other the rule to compare to.
     * @return the result of the comparison.
     */
    public int compareTo(AssociationRule other) {
<span class="nc" id="L1181">      return -Double.compare(getMetricValue(), other.getMetricValue());</span>
    }
    
    /**
     * Return true if this rule is equal to the supplied one.
     * 
     * @return true if this rule is the same as the supplied rule.
     */
    public boolean equals(Object other) {
<span class="nc bnc" id="L1190" title="All 2 branches missed.">      if (!(other instanceof AssociationRule)) {</span>
<span class="nc" id="L1191">        return false;</span>
      }
      
<span class="nc" id="L1194">      AssociationRule otherRule = (AssociationRule)other;</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">      boolean result = m_premise.equals(otherRule.getPremise()) &amp;&amp;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        m_consequence.equals(otherRule.getConsequence()) &amp;&amp; </span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        (getMetricValue() == otherRule.getMetricValue());</span>
      
<span class="nc" id="L1199">      return result;</span>
    }
    
    public boolean containsItems(ArrayList&lt;Attribute&gt; items, boolean useOr) {
<span class="nc" id="L1203">      int numItems = items.size();</span>
<span class="nc" id="L1204">      int count = 0;</span>
      
<span class="nc bnc" id="L1206" title="All 2 branches missed.">      for (BinaryItem i : m_premise) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        if (items.contains(i.getAttribute())) {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">          if (useOr) {</span>
<span class="nc" id="L1209">            return true; // can stop here</span>
          } else {
<span class="nc" id="L1211">            count++;</span>
          }
        }
      }
      
<span class="nc bnc" id="L1216" title="All 2 branches missed.">      for (BinaryItem i : m_consequence) {</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">        if (items.contains(i.getAttribute())) {</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">          if (useOr) {</span>
<span class="nc" id="L1219">            return true; // can stop here</span>
          } else {
<span class="nc" id="L1221">            count++;</span>
          }
        }
      }
      
<span class="nc bnc" id="L1226" title="All 2 branches missed.">      if (!useOr) {</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (count == numItems) {</span>
<span class="nc" id="L1228">          return true;</span>
        }
      }
      
<span class="nc" id="L1232">      return false;</span>
    }
    
    /**
     * Get a textual description of this rule.
     * 
     * @return a textual description of this rule.
     */
    public String toString() {
<span class="nc" id="L1241">      StringBuffer result = new StringBuffer();</span>
      
<span class="nc" id="L1243">      result.append(m_premise.toString() + &quot;: &quot; + m_premiseSupport </span>
<span class="nc" id="L1244">          + &quot; ==&gt; &quot; + m_consequence.toString() + &quot;: &quot; + m_totalSupport </span>
<span class="nc" id="L1245">          + &quot;   &quot;);</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">      for (METRIC_TYPE m : METRIC_TYPE.values()) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">        if (m.equals(m_metricType)) {</span>
<span class="nc" id="L1248">          result.append(&quot;&lt;&quot; + </span>
<span class="nc" id="L1249">              m.toStringMetric(m_premiseSupport, m_consequenceSupport, </span>
<span class="nc" id="L1250">                  m_totalSupport, m_totalTransactions) + &quot;&gt; &quot;);</span>
        } else {
<span class="nc" id="L1252">          result.append(&quot;&quot; + </span>
<span class="nc" id="L1253">              m.toStringMetric(m_premiseSupport, m_consequenceSupport, </span>
<span class="nc" id="L1254">                  m_totalSupport, m_totalTransactions) + &quot; &quot;);</span>
        }
      }
<span class="nc" id="L1257">      return result.toString();</span>
    }
    
    public String toXML() {
<span class="nc" id="L1261">      StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L1262">      result.append(&quot;  &lt;RULE&gt;\n    &lt;LHS&gt;&quot;);</span>
      
<span class="nc bnc" id="L1264" title="All 2 branches missed.">      for (BinaryItem b : m_premise) {</span>
<span class="nc" id="L1265">        result.append(&quot;\n      &quot;);</span>
<span class="nc" id="L1266">        result.append(b.toXML());</span>
      }
<span class="nc" id="L1268">      result.append(&quot;\n    &lt;/LHS&gt;\n    &lt;RHS&gt;&quot;);</span>
      
<span class="nc bnc" id="L1270" title="All 2 branches missed.">      for (BinaryItem b : m_consequence) {</span>
<span class="nc" id="L1271">        result.append(&quot;\n      &quot;);</span>
<span class="nc" id="L1272">        result.append(b.toXML());</span>
      }
<span class="nc" id="L1274">      result.append(&quot;\n    &lt;/RHS&gt;&quot;);</span>
      
      // metrics
      // do support first
<span class="nc" id="L1278">      result.append(&quot;\n    &lt;CRITERE name=\&quot;support\&quot; value=\&quot;&quot; </span>
<span class="nc" id="L1279">          + m_totalSupport + &quot;\&quot;/&gt;&quot;);</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">      for (METRIC_TYPE m : METRIC_TYPE.values()) {</span>
<span class="nc" id="L1281">        result.append(&quot;\n    &quot;);</span>
<span class="nc" id="L1282">        result.append(m.toXML(m_premiseSupport, m_consequenceSupport,</span>
<span class="nc" id="L1283">            m_totalSupport, m_totalTransactions));</span>
      }
<span class="nc" id="L1285">      result.append(&quot;\n  &lt;/RULE&gt;\n&quot;);</span>
      
<span class="nc" id="L1287">      return result.toString();</span>
    }
    
    private static void nextSubset(boolean[] subset) {
<span class="nc bnc" id="L1291" title="All 2 branches missed.">      for (int i = 0; i &lt; subset.length; i++) {</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (!subset[i]) {</span>
<span class="nc" id="L1293">          subset[i] = true;</span>
<span class="nc" id="L1294">          break;</span>
        } else {
<span class="nc" id="L1296">          subset[i] = false;</span>
        }
      }
<span class="nc" id="L1299">    }</span>
    
    private static Collection&lt;BinaryItem&gt; getPremise(FrequentBinaryItemSet fis, 
        boolean[] subset) {
<span class="nc" id="L1303">      boolean ok = false;</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">      for (int i = 0; i &lt; subset.length; i++){</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        if (!subset[i]) {</span>
<span class="nc" id="L1306">          ok = true;</span>
<span class="nc" id="L1307">          break;</span>
        }
      }      
      
<span class="nc bnc" id="L1311" title="All 2 branches missed.">      if (!ok) {</span>
<span class="nc" id="L1312">        return null;</span>
      }
      
<span class="nc" id="L1315">      List&lt;BinaryItem&gt; premise = new ArrayList&lt;BinaryItem&gt;();</span>
<span class="nc" id="L1316">      ArrayList&lt;BinaryItem&gt; items = new ArrayList&lt;BinaryItem&gt;(fis.getItems());</span>

      
<span class="nc bnc" id="L1319" title="All 2 branches missed.">      for (int i = 0; i &lt; subset.length; i++) {</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">        if (subset[i]) {</span>
<span class="nc" id="L1321">          premise.add(items.get(i));</span>
        }
      }
<span class="nc" id="L1324">      return premise;</span>
    }
    
    private static Collection&lt;BinaryItem&gt; getConsequence(FrequentBinaryItemSet fis,
        boolean[] subset) {
<span class="nc" id="L1329">      List&lt;BinaryItem&gt; consequence = new ArrayList&lt;BinaryItem&gt;();</span>
<span class="nc" id="L1330">      ArrayList&lt;BinaryItem&gt; items = new ArrayList&lt;BinaryItem&gt;(fis.getItems());</span>
      
<span class="nc bnc" id="L1332" title="All 2 branches missed.">      for (int i = 0; i &lt; subset.length; i++) {</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (!subset[i]) {</span>
<span class="nc" id="L1334">          consequence.add(items.get(i));</span>
        }
      }
<span class="nc" id="L1337">      return consequence;</span>
    }
        
    /**
     * Generate all association rules, from the supplied frequet item sets,
     * that meet a given minimum metric threshold. Uses a brute force approach.
     * 
     * @param largeItemSets the set of frequent item sets
     * @param metricToUse the metric to use
     * @param metricThreshold the threshold value that a rule must meet
     * @param upperBoundMinSuppAsInstances the upper bound on the support
     * in order to accept the rule
     * @param lowerBoundMinSuppAsInstances the lower bound on the support
     * in order to accept the rule
     * @param totalTransactions the total number of transactions in the data
     * @return a list of association rules
     */
    public static List&lt;AssociationRule&gt; 
      generateRulesBruteForce(FrequentItemSets largeItemSets, METRIC_TYPE metricToUse, 
          double metricThreshold, int upperBoundMinSuppAsInstances,
          int lowerBoundMinSuppAsInstances, int totalTransactions) {
      
<span class="nc" id="L1359">      List&lt;AssociationRule&gt; rules = new ArrayList&lt;AssociationRule&gt;();</span>
<span class="nc" id="L1360">      largeItemSets.sort();</span>
<span class="nc" id="L1361">      Map&lt;Collection&lt;BinaryItem&gt;, Integer&gt; frequencyLookup =</span>
<span class="nc" id="L1362">        new HashMap&lt;Collection&lt;BinaryItem&gt;, Integer&gt;();</span>
      
<span class="nc" id="L1364">      Iterator&lt;FrequentBinaryItemSet&gt; setI = largeItemSets.iterator();</span>
      // process each large item set
<span class="nc bnc" id="L1366" title="All 2 branches missed.">      while (setI.hasNext()) {</span>
<span class="nc" id="L1367">        FrequentBinaryItemSet fis = setI.next();</span>
<span class="nc" id="L1368">        frequencyLookup.put(fis.getItems(), fis.getSupport());</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">        if (fis.getItems().size() &gt; 1) {</span>
          // generate all the possible subsets for the premise
<span class="nc" id="L1371">          boolean[] subset = new boolean[fis.getItems().size()];</span>
<span class="nc" id="L1372">          Collection&lt;BinaryItem&gt; premise = null;</span>
<span class="nc" id="L1373">          Collection&lt;BinaryItem&gt; consequence = null;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">          while ((premise = getPremise(fis, subset)) != null) {</span>
<span class="nc bnc" id="L1375" title="All 4 branches missed.">            if (premise.size() &gt; 0 &amp;&amp; premise.size() &lt; fis.getItems().size()) {</span>
<span class="nc" id="L1376">              consequence = getConsequence(fis, subset);</span>
<span class="nc" id="L1377">              int totalSupport = fis.getSupport();</span>
<span class="nc" id="L1378">              int supportPremise = frequencyLookup.get(premise).intValue();</span>
<span class="nc" id="L1379">              int supportConsequence = frequencyLookup.get(consequence).intValue();</span>
              
              // a candidate rule
<span class="nc" id="L1382">              AssociationRule candidate = </span>
<span class="nc" id="L1383">                new AssociationRule(premise, consequence, metricToUse, supportPremise,</span>
<span class="nc" id="L1384">                    supportConsequence, totalSupport, totalTransactions);</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">              if (candidate.getMetricValue() &gt; metricThreshold &amp;&amp;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">                  candidate.getTotalSupport() &gt;= lowerBoundMinSuppAsInstances &amp;&amp;</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">                  candidate.getTotalSupport() &lt;= upperBoundMinSuppAsInstances) {</span>
                // accept this rule
<span class="nc" id="L1389">                rules.add(candidate);</span>
              }              
            }
<span class="nc" id="L1392">            nextSubset(subset);</span>
          }
        }
      }
<span class="nc" id="L1396">      return rules;</span>
    }
    
    public static List&lt;AssociationRule&gt; pruneRules(List&lt;AssociationRule&gt; rulesToPrune,
        ArrayList&lt;Attribute&gt; itemsToConsider, boolean useOr) {
<span class="nc" id="L1401">      ArrayList&lt;AssociationRule&gt; result = new ArrayList&lt;AssociationRule&gt;();</span>
      
<span class="nc bnc" id="L1403" title="All 2 branches missed.">      for (AssociationRule r : rulesToPrune) {</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">        if (r.containsItems(itemsToConsider, useOr)) {</span>
<span class="nc" id="L1405">          result.add(r);</span>
        }
      }
      
<span class="nc" id="L1409">      return result;</span>
    }
  }
  
  /** The number of rules to find */
<span class="nc" id="L1414">  protected int m_numRulesToFind = 10;</span>
  //protected double m_upperBoundMinSupport = 0.36;
  
  /** The upper bound on the minimum support */
<span class="nc" id="L1418">  protected double m_upperBoundMinSupport = 1.0;</span>
  
  /** The lower bound on minimum support */
<span class="nc" id="L1421">  protected double m_lowerBoundMinSupport = 0.1;</span>
  
  /** The amount by which to decrease the support in each iteration */
<span class="nc" id="L1424">  protected double m_delta = 0.05;</span>
  
  /** 
   * If true, just all rules meeting the lower bound on the minimum
   * support will be found. The number of rules to find will be
   * ignored and the iterative reduction of support will not
   * be done. 
   */
<span class="nc" id="L1432">  protected boolean m_findAllRulesForSupportLevel = false;</span>
  
  //protected double m_lowerBoundMinSupport = 0.0;
  
  /** The index (1 based) of binary attributes to treat as the positive value */
<span class="nc" id="L1437">  protected int m_positiveIndex = 2;</span>
  
<span class="nc" id="L1439">  protected AssociationRule.METRIC_TYPE m_metric = </span>
<span class="nc" id="L1440">    AssociationRule.METRIC_TYPE.CONFIDENCE;</span>
  
<span class="nc" id="L1442">  protected double m_metricThreshold = 0.9;</span>
  
  /** Holds the large item sets found */
  protected FrequentItemSets m_largeItemSets;
  
  /** Holds the rules */
  protected List&lt;AssociationRule&gt; m_rules;
  
  // maximum number of items in a large item set (zero means no limit)
<span class="nc" id="L1451">  protected int m_maxItems = -1;</span>
  
  /**
   *  If set, limit the transactions (instances) input to the
   *  algorithm to those that contain these items
   */
<span class="nc" id="L1457">  protected String m_transactionsMustContain = &quot;&quot;;</span>
  
  /** Use OR rather than AND when considering must contain lists */
<span class="nc" id="L1460">  protected boolean m_mustContainOR = false;</span>
  
  /** If set, then only output rules containing these itmes */
<span class="nc" id="L1463">  protected String m_rulesMustContain = &quot;&quot;;</span>
  
  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="nc" id="L1471">    Capabilities result = super.getCapabilities();</span>
<span class="nc" id="L1472">    result.disableAll();</span>

    // enable what we can handle
    
    // attributes
<span class="nc" id="L1477">    result.enable(Capability.UNARY_ATTRIBUTES);</span>
<span class="nc" id="L1478">    result.enable(Capability.BINARY_ATTRIBUTES);</span>
<span class="nc" id="L1479">    result.enable(Capability.MISSING_VALUES);</span>

<span class="nc" id="L1481">    result.enable(Capability.NO_CLASS);</span>
    
<span class="nc" id="L1483">    return result;</span>
  }
  
  /**
   * Returns a string describing this associator
   * 
   * @return a description of the evaluator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L1493">    return &quot;Class implementing the FP-growth algorithm for finding&quot; +</span>
    		&quot; large item sets without candidate generation. Iteratively&quot; +
    		&quot; reduces the minimum support until it finds the required&quot; +
    		&quot; number of rules with the given minimum metric.&quot; +
    		&quot; For more information see:\n\n&quot; +
<span class="nc" id="L1498">    		getTechnicalInformation().toString();</span>
  }
  
  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation        result;
    
<span class="nc" id="L1511">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L1512">    result.setValue(Field.AUTHOR, &quot;J. Han and J.Pei and Y. Yin&quot;);</span>
<span class="nc" id="L1513">    result.setValue(Field.TITLE, &quot;Mining frequent patterns without candidate generation&quot;);</span>
<span class="nc" id="L1514">    result.setValue(Field.BOOKTITLE, &quot;Proceedings of the 2000 ACM-SIGMID International&quot; +</span>
    		&quot; Conference on Management of Data&quot;);
<span class="nc" id="L1516">    result.setValue(Field.YEAR, &quot;2000&quot;);</span>
<span class="nc" id="L1517">    result.setValue(Field.PAGES, &quot;1-12&quot;);</span>
    
<span class="nc" id="L1519">    return result;</span>
  }
  
  private boolean passesMustContain(Instance inst, 
      boolean[] transactionsMustContainIndexes, 
      int numInTransactionsMustContainList) {
    
<span class="nc" id="L1526">    boolean result = false;</span>
    
<span class="nc bnc" id="L1528" title="All 2 branches missed.">    if (inst instanceof SparseInstance) {</span>
<span class="nc" id="L1529">      int containsCount = 0;</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">      for (int i = 0; i &lt; inst.numValues(); i++) {</span>
<span class="nc" id="L1531">        int attIndex = inst.index(i);</span>
        
<span class="nc bnc" id="L1533" title="All 2 branches missed.">        if (m_mustContainOR) {</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">          if (transactionsMustContainIndexes[attIndex]) {</span>
            // break here since the operator is OR and this
            // instance contains at least one of the items
<span class="nc" id="L1537">            return true;</span>
          }
        } else {
<span class="nc bnc" id="L1540" title="All 2 branches missed.">          if (transactionsMustContainIndexes[attIndex]) {</span>
<span class="nc" id="L1541">            containsCount++;</span>
          }
        }
      }
      
<span class="nc bnc" id="L1546" title="All 2 branches missed.">      if (!m_mustContainOR) {</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">        if (containsCount == numInTransactionsMustContainList) {</span>
<span class="nc" id="L1548">          return true;</span>
        }
      }
    } else {
<span class="nc" id="L1552">      int containsCount = 0;</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">      for (int i = 0; i &lt; transactionsMustContainIndexes.length; i++) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">        if (transactionsMustContainIndexes[i]) {</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">          if ((int)inst.value(i) == m_positiveIndex - 1) {</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">            if (m_mustContainOR) {</span>
              // break here since the operator is OR and
              // this instance contains at least one of the
              // requested items
<span class="nc" id="L1560">              return true;</span>
            } else {
<span class="nc" id="L1562">              containsCount++;</span>
            }
          }
        }
      }
      
<span class="nc bnc" id="L1568" title="All 2 branches missed.">      if (!m_mustContainOR) {</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">        if (containsCount == numInTransactionsMustContainList) {</span>
<span class="nc" id="L1570">          return true;</span>
        }
      }
    }
    
<span class="nc" id="L1575">    return result;</span>
  }
  
  
  /**
   * Get the singleton items in the data
   * 
   * @param data the Instances to process
   * @return a list of singleton item sets
   * @throws Exception if the singletons can't be found for some reason
   */
  protected ArrayList&lt;BinaryItem&gt; getSingletons(Instances data) throws Exception {
<span class="nc" id="L1587">    ArrayList&lt;BinaryItem&gt; singletons = new ArrayList&lt;BinaryItem&gt;();</span>
    
<span class="nc bnc" id="L1589" title="All 2 branches missed.">    for (int i = 0; i &lt; data.numAttributes(); i++) {</span>
<span class="nc" id="L1590">      singletons.add(new BinaryItem(data.attribute(i), m_positiveIndex - 1));</span>
    }
    
<span class="nc bnc" id="L1593" title="All 2 branches missed.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L1594">      Instance current = data.instance(i);</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      if (current instanceof SparseInstance) {</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">        for (int j = 0; j &lt; current.numValues(); j++) {</span>
<span class="nc" id="L1597">          int attIndex = current.index(j);</span>
<span class="nc" id="L1598">          singletons.get(attIndex).increaseFrequency();</span>
        }
      } else {
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        for (int j = 0; j &lt; data.numAttributes(); j++) {</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">          if (!current.isMissing(j)) {</span>
<span class="nc bnc" id="L1603" title="All 2 branches missed.">            if (current.attribute(j).numValues() == 1 </span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                || current.value(j) == m_positiveIndex - 1) {</span>
<span class="nc" id="L1605">              singletons.get(j).increaseFrequency();</span>
            }
          }
        }
      }
    }
    
<span class="nc" id="L1612">    return singletons;</span>
  }
  
  /*protected ArrayList&lt;BinaryItem&gt; getFrequent(ArrayList&lt;BinaryItem&gt; items, int minSupport) {
    ArrayList&lt;BinaryItem&gt; frequent = new ArrayList&lt;BinaryItem&gt;();
    for (BinaryItem b : items) {
      if (b.getFrequency() &gt; minSupport) {
        frequent.add(b);
      }
    }
    
    // sort in descending order of support
    Collections.sort(frequent);
    return frequent;
  } */
  
  /**
   * Construct the frequent pattern tree by inserting each transaction
   * in the data into the tree. Only those items from each transaction that
   * meet the minimum support threshold are inserted.
   * 
   * @param singletons the singleton item sets
   * @param data the Instances containing the transactions
   * @param minSupport the minimum support
   * @return the root of the tree
   */
  protected FPTreeRoot buildFPTree(ArrayList&lt;BinaryItem&gt; singletons, 
      Instances data, int minSupport) {
    
<span class="nc" id="L1641">    FPTreeRoot tree = new FPTreeRoot();</span>
   
<span class="nc bnc" id="L1643" title="All 2 branches missed.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L1644">      Instance current = data.instance(i);</span>
<span class="nc" id="L1645">      ArrayList&lt;BinaryItem&gt; transaction = new ArrayList&lt;BinaryItem&gt;();</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">      if (current instanceof SparseInstance) {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">        for (int j = 0; j &lt; current.numValues(); j++) {</span>
<span class="nc" id="L1648">          int attIndex = current.index(j);</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">          if (singletons.get(attIndex).getFrequency() &gt;= minSupport) {</span>
<span class="nc" id="L1650">            transaction.add(singletons.get(attIndex));</span>
          }
        }
<span class="nc" id="L1653">        Collections.sort(transaction);</span>
<span class="nc" id="L1654">        tree.addItemSet(transaction, 1);</span>
      } else {
<span class="nc bnc" id="L1656" title="All 2 branches missed.">        for (int j = 0; j &lt; data.numAttributes(); j++) {</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">          if (!current.isMissing(j)) {</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">            if (current.attribute(j).numValues() == 1 </span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">                || current.value(j) == m_positiveIndex - 1) {</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">              if (singletons.get(j).getFrequency() &gt;= minSupport) {</span>
<span class="nc" id="L1661">                transaction.add(singletons.get(j));</span>
              }
            }
          }
        }
<span class="nc" id="L1666">        Collections.sort(transaction);</span>
<span class="nc" id="L1667">        tree.addItemSet(transaction, 1);</span>
      }
    }
    
<span class="nc" id="L1671">    return tree;</span>
  }
  
  /**
   * Find large item sets in the FP-tree.
   * 
   * @param tree the root of the tree to mine
   * @param largeItemSets holds the large item sets found
   * @param recursionLevel the recursion level for the current projected
   * counts
   * @param conditionalItems the current set of items that the current
   * (projected) tree is conditional on
   * @param minSupport the minimum acceptable support
   */
  protected void mineTree(FPTreeRoot tree, FrequentItemSets largeItemSets, 
      int recursionLevel, FrequentBinaryItemSet conditionalItems, int minSupport) {
    
<span class="nc bnc" id="L1688" title="All 2 branches missed.">    if (!tree.isEmpty(recursionLevel)) {</span>
<span class="nc bnc" id="L1689" title="All 4 branches missed.">      if (m_maxItems &gt; 0 &amp;&amp; recursionLevel &gt;= m_maxItems) {</span>
        // don't mine any further
<span class="nc" id="L1691">        return;</span>
      }
      
<span class="nc" id="L1694">      Map&lt;BinaryItem, FPTreeRoot.Header&gt; headerTable = tree.getHeaderTable();</span>
<span class="nc" id="L1695">      Set&lt;BinaryItem&gt; keys = headerTable.keySet();</span>
//      System.err.println(&quot;Number of freq item sets collected &quot; + largeItemSets.size());
<span class="nc" id="L1697">      Iterator&lt;BinaryItem&gt; i = keys.iterator();</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">      while (i.hasNext()) {</span>
<span class="nc" id="L1699">        BinaryItem item = i.next();</span>
<span class="nc" id="L1700">        FPTreeRoot.Header itemHeader = headerTable.get(item);</span>
        
        // check for minimum support at this level
<span class="nc" id="L1703">        int support = itemHeader.getProjectedCounts().getCount(recursionLevel);</span>
<span class="nc bnc" id="L1704" title="All 2 branches missed.">        if (support &gt;= minSupport) {          </span>
          // process header list at this recursion level
<span class="nc bnc" id="L1706" title="All 2 branches missed.">          for (FPTreeNode n : itemHeader.getHeaderList()) {</span>
            // push count up path to root
<span class="nc" id="L1708">            int currentCount = n.getProjectedCount(recursionLevel);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">            if (currentCount &gt; 0) {                            </span>
<span class="nc" id="L1710">              FPTreeNode temp = n.getParent();</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">              while (temp != tree) {</span>
                // set/increase for the node
<span class="nc" id="L1713">                temp.increaseProjectedCount(recursionLevel + 1, currentCount);</span>

                // set/increase for the header table
<span class="nc" id="L1716">                headerTable.get(temp.getItem()).</span>
<span class="nc" id="L1717">                getProjectedCounts().increaseCount(recursionLevel + 1, currentCount);</span>
                
<span class="nc" id="L1719">                temp = temp.getParent();</span>
              }
            }
          }
          
<span class="nc" id="L1724">          FrequentBinaryItemSet newConditional = </span>
<span class="nc" id="L1725">            (FrequentBinaryItemSet) conditionalItems.clone();</span>
          
          // this item gets added to the conditional items
<span class="nc" id="L1728">          newConditional.addItem(item);</span>
<span class="nc" id="L1729">          newConditional.setSupport(support);</span>
          
          // now add this conditional item set to the list of large item sets
<span class="nc" id="L1732">          largeItemSets.addItemSet(newConditional);</span>
          
          // now recursively process the new tree
<span class="nc" id="L1735">          mineTree(tree, largeItemSets, recursionLevel + 1, newConditional,</span>
<span class="nc" id="L1736">              minSupport);</span>
          
          // reverse the propagated counts
<span class="nc bnc" id="L1739" title="All 2 branches missed.">          for (FPTreeNode n : itemHeader.getHeaderList()) {</span>
<span class="nc" id="L1740">            FPTreeNode temp = n.getParent();</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">            while (temp != tree) {</span>
<span class="nc" id="L1742">              temp.removeProjectedCount(recursionLevel + 1);</span>
<span class="nc" id="L1743">              temp = temp.getParent();</span>
            }
          }
          
          // reverse the propagated counts in the header list
          // at this recursion level
<span class="nc bnc" id="L1749" title="All 2 branches missed.">          for (FPTreeRoot.Header h : headerTable.values()) {</span>
<span class="nc" id="L1750">            h.getProjectedCounts().removeCount(recursionLevel + 1);</span>
          }          
        }
      }
    }
<span class="nc" id="L1755">  }</span>
  
  /**
   * Construct a new FPGrowth object.
   */
<span class="nc" id="L1760">  public FPGrowth() {</span>
<span class="nc" id="L1761">    resetOptions();</span>
<span class="nc" id="L1762">  }</span>
  
  /**
   * Reset all options to their default values.
   */
  public void resetOptions() {
<span class="nc" id="L1768">    m_delta = 0.05;</span>
<span class="nc" id="L1769">    m_metricThreshold = 0.9;</span>
<span class="nc" id="L1770">    m_numRulesToFind = 10;</span>
<span class="nc" id="L1771">    m_lowerBoundMinSupport = 0.1;</span>
<span class="nc" id="L1772">    m_upperBoundMinSupport = 1.0;</span>
//    m_minSupport = -1;
<span class="nc" id="L1774">    m_positiveIndex = 2;</span>
<span class="nc" id="L1775">    m_transactionsMustContain = &quot;&quot;;</span>
<span class="nc" id="L1776">    m_rulesMustContain = &quot;&quot;;</span>
<span class="nc" id="L1777">    m_mustContainOR = false;</span>
<span class="nc" id="L1778">  }</span>
  
  /**
   * Tip text for this property suitable for displaying
   * in the GUI.
   * 
   * @return the tip text for this property.
   */
  public String positiveIndexTipText() {
<span class="nc" id="L1787">    return &quot;Set the index of binary valued attributes that is to be considered&quot; +</span>
    		&quot; the positive index. Has no effect for sparse data (in this case&quot; +
    		&quot; the first index (i.e. non-zero values) is always treated as &quot; +
    		&quot; positive. Also has no effect for unary valued attributes (i.e.&quot; +
    		&quot; when using the Weka Apriori-style format for market basket data,&quot; +
    		&quot; which uses missing value \&quot;?\&quot; to indicate&quot; +
    		&quot; absence of an item.&quot;;
  }
  
  /**
   * Set the index of the attribute value to consider as positive
   * for binary attributes in normal dense instances. Index 1 is always
   * used for sparse instances.
   * 
   * @param index the index to use for positive values in binary attributes.
   */
  public void setPositiveIndex(int index) {
<span class="nc" id="L1804">    m_positiveIndex = index;</span>
<span class="nc" id="L1805">  }</span>
  
  /**
   * Get the index of the attribute value to consider as positive
   * for binary attributes in normal dense instances. Index 1 is always
   * used for sparse instances.
   * 
   * @return the index to use for positive values in binary attributes.
   */
  public int getPositiveIndex() {
<span class="nc" id="L1815">    return m_positiveIndex;</span>
  }
  
  /**
   * Set the desired number of rules to find.
   * 
   * @param numR the number of rules to find.
   */
  public void setNumRulesToFind(int numR) {
<span class="nc" id="L1824">    m_numRulesToFind = numR;</span>
<span class="nc" id="L1825">  }</span>
  
  /**
   * Get the number of rules to find.
   * 
   * @return the number of rules to find.
   */
  public int getNumRulesToFind() {
<span class="nc" id="L1833">    return m_numRulesToFind;</span>
  }
  
  /**
   * Tip text for this property suitable for displaying
   * in the GUI.
   * 
   * @return the tip text for this property.
   */
  public String numRulesToFindTipText() {
<span class="nc" id="L1843">    return &quot;The number of rules to output&quot;;</span>
  }
  
  /**
   * Set the metric type to use.
   * 
   * @param d the metric type
   */
  public void setMetricType(SelectedTag d) {
<span class="nc" id="L1852">    int ordinal =  d.getSelectedTag().getID();</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">    for (AssociationRule.METRIC_TYPE m : AssociationRule.METRIC_TYPE.values()) {</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">      if (m.ordinal() == ordinal) {</span>
<span class="nc" id="L1855">        m_metric = m;</span>
<span class="nc" id="L1856">        break;</span>
      }
    }
<span class="nc" id="L1859">  }</span>
  
  /**
   * Set the maximum number of items to include in large items sets.
   * 
   * @param max the maxim number of items to include in large item sets.
   */
  public void setMaxNumberOfItems(int max) {
<span class="nc" id="L1867">    m_maxItems = max;</span>
<span class="nc" id="L1868">  }</span>
  
  /**
   * Gets the maximum number of items to be included in large item sets.
   * 
   * @return the maximum number of items to be included in large items sets.
   */
  public int getMaxNumberOfItems() {
<span class="nc" id="L1876">    return m_maxItems;</span>
  }
  
  /**
   * Tip text for this property suitable for displaying
   * in the GUI.
   * 
   * @return the tip text for this property.
   */
  public String maxNumberOfItemsTipText() {
<span class="nc" id="L1886">    return &quot;The maximum number of items to include in frequent item sets. -1 &quot; +</span>
    		&quot;means no limit.&quot;;
  }
  
  /**
   * Get the metric type to use.
   * 
   * @return the metric type to use.
   */
  public SelectedTag getMetricType() {
<span class="nc" id="L1896">    return new SelectedTag(m_metric.ordinal(), AssociationRule.TAGS_SELECTION);</span>
  }
  
  /**
   * Tip text for this property suitable for displaying
   * in the GUI.
   * 
   * @return the tip text for this property.
   */
  public String metricTypeTipText() {
<span class="nc" id="L1906">    return &quot;Set the type of metric by which to rank rules. Confidence is &quot;</span>
    +&quot;the proportion of the examples covered by the premise that are also &quot;
    +&quot;covered by the consequence(Class association rules can only be mined using confidence). Lift is confidence divided by the &quot;
    +&quot;proportion of all examples that are covered by the consequence. This &quot;
    +&quot;is a measure of the importance of the association that is independent &quot;
    +&quot;of support. Leverage is the proportion of additional examples covered &quot;
    +&quot;by both the premise and consequence above those expected if the &quot;
    +&quot;premise and consequence were independent of each other. The total &quot;
    +&quot;number of examples that this represents is presented in brackets &quot;
    +&quot;following the leverage. Conviction is &quot;
    +&quot;another measure of departure from independence.&quot;;
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minMetricTipText() {
<span class="nc" id="L1926">    return &quot;Minimum metric score. Consider only rules with scores higher than &quot;</span>
      +&quot;this value.&quot;;
  }

  /**
   * Get the value of minConfidence.
   *
   * @return Value of minConfidence.
   */
  public double getMinMetric() {
    
<span class="nc" id="L1937">    return m_metricThreshold;</span>
  }
  
  /**
   * Set the value of minConfidence.
   *
   * @param v  Value to assign to minConfidence.
   */
  public void setMinMetric(double v) {
    
<span class="nc" id="L1947">    m_metricThreshold = v;</span>
<span class="nc" id="L1948">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String transactionsMustContainTipText() {
<span class="nc" id="L1957">    return &quot;Limit input to FPGrowth to those transactions (instances)&quot; +</span>
    		&quot; that contain these items. Provide a comma separated&quot; +
    		&quot; list of attribute names.&quot;;
  }
  
  /**
   * Set the comma separated list of items that transactions
   * must contain in order to be considered for large
   * item sets and rules.
   * 
   * @param list a comma separated list of items (empty
   * string indicates no restriction on the transactions).
   */
  public void setTransactionsMustContain(String list) {
<span class="nc" id="L1971">    m_transactionsMustContain = list;</span>
<span class="nc" id="L1972">  }</span>
  
  /**
   * Gets the comma separated list of items that
   * transactions must contain in order to be considered
   * for large item sets and rules.
   * 
   * @return return the comma separated list of
   * items that transactions must contain.
   */
  public String getTransactionsMustContain() {
<span class="nc" id="L1983">    return m_transactionsMustContain;</span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String rulesMustContainTipText() {
<span class="nc" id="L1993">    return &quot;Only print rules that contain these items. Provide &quot; +</span>
    		&quot;a comma separated list of attribute names.&quot;;
  }
  
  /**
   * Set the comma separated list of items that rules
   * must contain in order to be output. 
   * 
   * @param list a comma separated list of items (empty
   * string indicates no restriction on the rules).
   */
  public void setRulesMustContain(String list) {
<span class="nc" id="L2005">    m_rulesMustContain = list;</span>
<span class="nc" id="L2006">  }</span>
  
  /**
   * Get the comma separated list of items that
   * rules must contain in order to be output.
   * 
   * @return the comma separated list of items
   * that rules must contain in order to be output.
   */
  public String getRulesMustContain() {
<span class="nc" id="L2016">    return m_rulesMustContain;</span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useORForMustContainListTipText() {
<span class="nc" id="L2026">    return &quot;Use OR instead of AND for transactions/rules must contain lists.&quot;;</span>
  }
  
  /**
   * Set whether to use OR rather than AND when considering
   * must contain lists.
   * 
   * @param b true if OR should be used instead of AND when
   * considering transaction and rules must contain lists.
   */
  public void setUseORForMustContainList(boolean b) {
<span class="nc" id="L2037">    m_mustContainOR = b;</span>
<span class="nc" id="L2038">  }</span>
  
  /**
   * Gets whether OR is to be used rather than AND when
   * considering must contain lists.
   * 
   * @return true if OR is used instead of AND.
   */
  public boolean getUseORForMustContainList() {
<span class="nc" id="L2047">    return m_mustContainOR;</span>
  }
  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying, in the explorer/experimenter gui
   */
  public String deltaTipText() {
<span class="nc" id="L2056">    return &quot;Iteratively decrease support by this factor. Reduces support &quot;</span>
      +&quot;until min support is reached or required number of rules has been &quot;
      +&quot;generated.&quot;;
  }
    
  /**
   * Get the value of delta.
   *
   * @return Value of delta.
   */
  public double getDelta() {
    
<span class="nc" id="L2068">    return m_delta;</span>
  }
  
  /**
   * Set the value of delta.
   *
   * @param v  Value to assign to delta.
   */
  public void setDelta(double v) {
    
<span class="nc" id="L2078">    m_delta = v;</span>
<span class="nc" id="L2079">  }</span>
  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String lowerBoundMinSupportTipText() {
<span class="nc" id="L2087">    return &quot;Lower bound for minimum support as a fraction or number of instances.&quot;;</span>
  }

  /**
   * Get the value of lowerBoundMinSupport.
   *
   * @return Value of lowerBoundMinSupport.
   */
  public double getLowerBoundMinSupport() {
    
<span class="nc" id="L2097">    return m_lowerBoundMinSupport;</span>
  }
  
  /**
   * Set the value of lowerBoundMinSupport.
   *
   * @param v  Value to assign to lowerBoundMinSupport.
   */
  public void setLowerBoundMinSupport(double v) {
    
<span class="nc" id="L2107">    m_lowerBoundMinSupport = v;</span>
<span class="nc" id="L2108">  }</span>
  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String upperBoundMinSupportTipText() {
<span class="nc" id="L2116">    return &quot;Upper bound for minimum support as a fraction or&quot; +</span>
    		&quot;number of instances. Start iteratively decreasing &quot;
      +&quot;minimum support from this value.&quot;;
  }

  /**
   * Get the value of upperBoundMinSupport.
   *
   * @return Value of upperBoundMinSupport.
   */
  public double getUpperBoundMinSupport() {
    
<span class="nc" id="L2128">    return m_upperBoundMinSupport;</span>
  }
  
  /**
   * Set the value of upperBoundMinSupport.
   *
   * @param v  Value to assign to upperBoundMinSupport.
   */
  public void setUpperBoundMinSupport(double v) {
    
<span class="nc" id="L2138">    m_upperBoundMinSupport = v;</span>
<span class="nc" id="L2139">  }</span>
  
  /**
   * Tip text for this property suitable for displaying
   * in the GUI.
   * 
   * @return the tip text for this property.
   */
  public String findAllRulesForSupportLevelTipText() {
<span class="nc" id="L2148">    return &quot;Find all rules that meet &quot; +</span>
    &quot;the lower bound on minimum support and the minimum metric constraint. &quot; +
    &quot;Turning this mode on will disable the iterative support reduction &quot; +
    &quot;procedure to find the specified number of rules.&quot;;
  }
  
  /**
   * If true then turn off the iterative support reduction method
   * of finding x rules that meet the minimum support and metric
   * thresholds and just return all the rules that meet the
   * lower bound on minimum support and the minimum metric.
   * 
   * @param s true if all rules meeting the lower bound on the support
   * and minimum metric thresholds are to be found.
   */
  public void setFindAllRulesForSupportLevel(boolean s) {
<span class="nc" id="L2164">    m_findAllRulesForSupportLevel = s;</span>
<span class="nc" id="L2165">  }</span>
  
  /**
   * Get whether all rules meeting the lower bound on min support
   * and the minimum metric threshold are to be found.
   * 
   * @return true if all rules meeting the lower bound on min
   * support and the min metric threshold are to be found.
   */
  public boolean getFindAllRulesForSupportLevel() {
<span class="nc" id="L2175">    return m_findAllRulesForSupportLevel;</span>
  }
  
  /* public void setMinimumSupport(double minSupp) {
    m_minSupport = minSupp;
  }
  
  public double getMinimumSupport() {
    return m_minSupport;
  } */    
  
  /**
   * Gets the list of mined association rules.
   * 
   * @return the list of association rules discovered during mining.
   * Returns null if mining hasn't been performed yet.
   */
  public List&lt;AssociationRule&gt; getAssociationRules() {
<span class="nc" id="L2193">    return m_rules;</span>
  }
  
  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration&lt;Option&gt; listOptions() {
<span class="nc" id="L2202">    Vector&lt;Option&gt; newVector = new Vector&lt;Option&gt;();</span>
    
<span class="nc" id="L2204">    String string00 = &quot;\tSet the index of the attribute value to consider as 'positive'\n\t&quot;</span>
   + &quot;for binary attributes in normal dense instances. Index 2 is always\n\t&quot;
   + &quot;used for sparse instances. (default = 2)&quot;;    
<span class="nc" id="L2207">    String string0 = &quot;\tThe maximum number of items to include &quot; +</span>
    		&quot;in large items sets (and rules). (default &quot; +
    		&quot;= -1, i.e. no limit.)&quot;; 
      
<span class="nc" id="L2211">    String string1 = &quot;\tThe required number of rules. (default = &quot; </span>
<span class="nc" id="L2212">      + m_numRulesToFind + &quot;)&quot;;</span>
<span class="nc" id="L2213">    String string2 = &quot;\tThe minimum metric score of a rule. (default&quot; +</span>
<span class="nc" id="L2214">    		&quot; = &quot; + m_metricThreshold + &quot;)&quot;;</span>
<span class="nc" id="L2215">    String string3 = &quot;\tThe metric by which to rank rules. (default&quot;</span>
      + &quot; = confidence)&quot;;
<span class="nc" id="L2217">    String string4 = &quot;\tThe lower bound for the minimum support as a &quot; +</span>
    		&quot;fraction or number of instances. (default = &quot;
<span class="nc" id="L2219">      + m_lowerBoundMinSupport + &quot;)&quot;;</span>
<span class="nc" id="L2220">    String string5 = &quot;\tUpper bound for minimum support as a fraction or number of instances. &quot;</span>
      + &quot;(default = 1.0)&quot;;
<span class="nc" id="L2222">    String string6 = &quot;\tThe delta by which the minimum support is decreased in\n&quot;</span>
<span class="nc" id="L2223">     + &quot;\teach iteration as a fraction or number of instances. (default = &quot; + m_delta + &quot;)&quot;;</span>
<span class="nc" id="L2224">    String string7 = &quot;\tFind all rules that meet the lower bound on\n\t&quot; +</span>
    		&quot;minimum support and the minimum metric constraint.\n\t&quot; +
    		&quot;Turning this mode on will disable the iterative support reduction\n\t&quot; +
    		&quot;procedure to find the specified number of rules.&quot;;
<span class="nc" id="L2228">    String string8 = &quot;\tOnly consider transactions that contain these items (default = no restriction)&quot;;</span>
<span class="nc" id="L2229">    String string9 = &quot;\tOnly print rules that contain these items. (default = no restriction)&quot;;</span>
<span class="nc" id="L2230">    String string10 = &quot;\tUse OR instead of AND for must contain list(s). Use in conjunction&quot; +</span>
    		&quot;\n\twith -transactions and/or -rules&quot;;
    
<span class="nc" id="L2233">    newVector.add(new Option(string00, &quot;P&quot;, 1, &quot;-P &lt;attribute index of positive value&gt;&quot;));</span>
<span class="nc" id="L2234">    newVector.add(new Option(string0, &quot;I&quot;, 1, &quot;-I &lt;max items&gt;&quot;));</span>
<span class="nc" id="L2235">    newVector.add(new Option(string1, &quot;N&quot;, 1, &quot;-N &lt;require number of rules&gt;&quot;));</span>
<span class="nc" id="L2236">    newVector.add(new Option(string3, &quot;T&quot;, 1, &quot;-T &lt;0=confidence | 1=lift | &quot;</span>
                                    + &quot;2=leverage | 3=Conviction&gt;&quot;));
<span class="nc" id="L2238">    newVector.add(new Option(string2, &quot;C&quot;, 1, &quot;-C &lt;minimum metric score of a rule&gt;&quot;));</span>
<span class="nc" id="L2239">    newVector.add(new Option(string5, &quot;U&quot;, 1, &quot;-U &lt;upper bound for minimum support&gt;&quot;));</span>
<span class="nc" id="L2240">    newVector.add(new Option(string4, &quot;M&quot;, 1, &quot;-M &lt;lower bound for minimum support&gt;&quot;));</span>
<span class="nc" id="L2241">    newVector.add(new Option(string6, &quot;D&quot;, 1, &quot;-D &lt;delta for minimum support&gt;&quot;));</span>
<span class="nc" id="L2242">    newVector.add(new Option(string7, &quot;S&quot;, 0, &quot;-S&quot;));</span>
<span class="nc" id="L2243">    newVector.add(new Option(string8, &quot;transactions&quot;, 1, &quot;-transactions &lt;comma separated &quot; +</span>
    		&quot;list of attribute names&gt;&quot;));
<span class="nc" id="L2245">    newVector.add(new Option(string9, &quot;rules&quot;, 1, &quot;-rules &lt;comma separated list &quot; +</span>
    		&quot;of attribute names&gt;&quot;));
<span class="nc" id="L2247">    newVector.add(new Option(string10, &quot;use-or&quot;, 0, &quot;-use-or&quot;));</span>
    
<span class="nc" id="L2249">    return newVector.elements();</span>
  }
  
  /**
   * 
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;attribute index of positive value&amp;gt;
   *  Set the index of the attribute value to consider as 'positive'
   *  for binary attributes in normal dense instances. Index 2 is always
   *  used for sparse instances. (default = 2)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;max items&amp;gt;
   *  The maximum number of items to include in large items sets (and rules). (default = -1, i.e. no limit.)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;require number of rules&amp;gt;
   *  The required number of rules. (default = 10)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -T &amp;lt;0=confidence | 1=lift | 2=leverage | 3=Conviction&amp;gt;
   *  The metric by which to rank rules. (default = confidence)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;minimum metric score of a rule&amp;gt;
   *  The minimum metric score of a rule. (default = 0.9)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -U &amp;lt;upper bound for minimum support&amp;gt;
   *  Upper bound for minimum support. (default = 1.0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;lower bound for minimum support&amp;gt;
   *  The lower bound for the minimum support. (default = 0.1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D &amp;lt;delta for minimum support&amp;gt;
   *  The delta by which the minimum support is decreased in
   *  each iteration. (default = 0.05)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Find all rules that meet the lower bound on
   *  minimum support and the minimum metric constraint.
   *  Turning this mode on will disable the iterative support reduction
   *  procedure to find the specified number of rules.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -transactions &amp;lt;comma separated list of attribute names&amp;gt;
   *  Only consider transactions that contain these items (default = no restriction)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -rules &amp;lt;comma separated list of attribute names&amp;gt;
   *  Only print rules that contain these items. (default = no restriction)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -use-or
   *  Use OR instead of AND for must contain list(s). Use in conjunction
   *  with -transactions and/or -rules&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
<span class="nc" id="L2308">    resetOptions();</span>
<span class="nc" id="L2309">    String positiveIndexString = Utils.getOption('P', options);</span>
<span class="nc" id="L2310">    String maxItemsString = Utils.getOption('I', options);</span>
<span class="nc" id="L2311">    String numRulesString = Utils.getOption('N', options);</span>
<span class="nc" id="L2312">    String minMetricString = Utils.getOption('C', options);</span>
<span class="nc" id="L2313">    String metricTypeString = Utils.getOption(&quot;T&quot;, options);</span>
<span class="nc" id="L2314">    String lowerBoundSupportString = Utils.getOption(&quot;M&quot;, options);</span>
<span class="nc" id="L2315">    String upperBoundSupportString = Utils.getOption(&quot;U&quot;, options);</span>
<span class="nc" id="L2316">    String deltaString = Utils.getOption(&quot;D&quot;, options);</span>
<span class="nc" id="L2317">    String transactionsString = Utils.getOption(&quot;transactions&quot;, options);</span>
<span class="nc" id="L2318">    String rulesString = Utils.getOption(&quot;rules&quot;, options);</span>

<span class="nc bnc" id="L2320" title="All 2 branches missed.">    if (positiveIndexString.length() != 0) {</span>
<span class="nc" id="L2321">      setPositiveIndex(Integer.parseInt(positiveIndexString));</span>
    }
    
<span class="nc bnc" id="L2324" title="All 2 branches missed.">    if (maxItemsString.length() != 0) {</span>
<span class="nc" id="L2325">      setMaxNumberOfItems(Integer.parseInt(maxItemsString));</span>
    }
    
<span class="nc bnc" id="L2328" title="All 2 branches missed.">    if (metricTypeString.length() != 0) {</span>
<span class="nc" id="L2329">      setMetricType(new SelectedTag(Integer.parseInt(metricTypeString),</span>
<span class="nc" id="L2330">          AssociationRule.TAGS_SELECTION));</span>
    }
    
<span class="nc bnc" id="L2333" title="All 2 branches missed.">    if (numRulesString.length() != 0) {</span>
<span class="nc" id="L2334">      setNumRulesToFind(Integer.parseInt(numRulesString));</span>
    }
    
<span class="nc bnc" id="L2337" title="All 2 branches missed.">    if (minMetricString.length() != 0) {</span>
<span class="nc" id="L2338">      setMinMetric(Double.parseDouble(minMetricString));</span>
    }
    
<span class="nc bnc" id="L2341" title="All 2 branches missed.">    if (deltaString.length() != 0) {</span>
<span class="nc" id="L2342">      setDelta(Double.parseDouble(deltaString));</span>
    }
    
<span class="nc bnc" id="L2345" title="All 2 branches missed.">    if (lowerBoundSupportString.length() != 0) {</span>
<span class="nc" id="L2346">      setLowerBoundMinSupport(Double.parseDouble(lowerBoundSupportString));</span>
    }
    
<span class="nc bnc" id="L2349" title="All 2 branches missed.">    if (upperBoundSupportString.length() != 0) {</span>
<span class="nc" id="L2350">      setUpperBoundMinSupport(Double.parseDouble(upperBoundSupportString));</span>
    }
    
<span class="nc bnc" id="L2353" title="All 2 branches missed.">    if (transactionsString.length() != 0) {</span>
<span class="nc" id="L2354">      setTransactionsMustContain(transactionsString);</span>
    }
    
<span class="nc bnc" id="L2357" title="All 2 branches missed.">    if (rulesString.length() &gt; 0) {</span>
<span class="nc" id="L2358">      setRulesMustContain(rulesString);</span>
    }
    
<span class="nc" id="L2361">    setUseORForMustContainList(Utils.getFlag(&quot;use-or&quot;, options));</span>
    
<span class="nc" id="L2363">    setFindAllRulesForSupportLevel(Utils.getFlag('S', options));</span>
<span class="nc" id="L2364">  }</span>
  
  /**
   * Gets the current settings of the classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
<span class="nc" id="L2372">    ArrayList&lt;String&gt; options = new ArrayList&lt;String&gt;();</span>
    
<span class="nc" id="L2374">    options.add(&quot;-P&quot;); options.add(&quot;&quot; + getPositiveIndex());</span>
<span class="nc" id="L2375">    options.add(&quot;-I&quot;); options.add(&quot;&quot; + getMaxNumberOfItems());</span>
<span class="nc" id="L2376">    options.add(&quot;-N&quot;); options.add(&quot;&quot; + getNumRulesToFind());</span>
<span class="nc" id="L2377">    options.add(&quot;-T&quot;); options.add(&quot;&quot; + getMetricType().getSelectedTag().getID());</span>
<span class="nc" id="L2378">    options.add(&quot;-C&quot;); options.add(&quot;&quot; + getMinMetric());</span>
<span class="nc" id="L2379">    options.add(&quot;-D&quot;); options.add(&quot;&quot; + getDelta());</span>
<span class="nc" id="L2380">    options.add(&quot;-U&quot;); options.add(&quot;&quot; + getUpperBoundMinSupport());</span>
<span class="nc" id="L2381">    options.add(&quot;-M&quot;); options.add(&quot;&quot; + getLowerBoundMinSupport());</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">    if (getFindAllRulesForSupportLevel()) {</span>
<span class="nc" id="L2383">      options.add(&quot;-S&quot;);</span>
    }
    
<span class="nc bnc" id="L2386" title="All 2 branches missed.">    if (getTransactionsMustContain().length() &gt; 0) {</span>
<span class="nc" id="L2387">      options.add(&quot;-transactions&quot;); options.add(getTransactionsMustContain());</span>
    }
    
<span class="nc bnc" id="L2390" title="All 2 branches missed.">    if (getRulesMustContain().length() &gt; 0) {</span>
<span class="nc" id="L2391">      options.add(&quot;-rules&quot;); options.add(getRulesMustContain());</span>
    }
    
<span class="nc bnc" id="L2394" title="All 2 branches missed.">    if (getUseORForMustContainList()) {</span>
<span class="nc" id="L2395">      options.add(&quot;-use-or&quot;);</span>
    }
    
<span class="nc" id="L2398">    return options.toArray(new String[1]);</span>
  }
  
  private Instances parseTransactionsMustContain(Instances data) {
<span class="nc" id="L2402">    String[] split = m_transactionsMustContain.trim().split(&quot;,&quot;);</span>
<span class="nc" id="L2403">    boolean[] transactionsMustContainIndexes = new boolean[data.numAttributes()];</span>
<span class="nc" id="L2404">    int numInTransactionsMustContainList = split.length;</span>
    
<span class="nc bnc" id="L2406" title="All 2 branches missed.">    for (int i = 0; i &lt; split.length; i++) {</span>
<span class="nc" id="L2407">      String attName = split[i].trim();</span>
<span class="nc" id="L2408">      Attribute att = data.attribute(attName);</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">      if (att == null) {</span>
<span class="nc" id="L2410">        System.err.println(&quot;[FPGrowth] : WARNING - can't find attribute &quot; </span>
<span class="nc" id="L2411">            + attName + &quot; in the data.&quot;);</span>
<span class="nc" id="L2412">        numInTransactionsMustContainList--;</span>
      } else {
<span class="nc" id="L2414">        transactionsMustContainIndexes[att.index()] = true;</span>
      }
    }
    
<span class="nc bnc" id="L2418" title="All 2 branches missed.">    if (numInTransactionsMustContainList == 0) {</span>
<span class="nc" id="L2419">      return data;</span>
    } else {
<span class="nc" id="L2421">      Instances newInsts = new Instances(data, 0);</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">      for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">        if (passesMustContain(data.instance(i), </span>
<span class="nc" id="L2424">            transactionsMustContainIndexes, numInTransactionsMustContainList)) {</span>
<span class="nc" id="L2425">          newInsts.add(data.instance(i));</span>
        }
      }
<span class="nc" id="L2428">      newInsts.compactify();</span>
<span class="nc" id="L2429">      return newInsts;</span>
    }
  }
  
  private ArrayList&lt;Attribute&gt; parseRulesMustContain(Instances data) {
<span class="nc" id="L2434">    ArrayList&lt;Attribute&gt; result = new ArrayList&lt;Attribute&gt;();</span>
    
<span class="nc" id="L2436">    String[] split = m_rulesMustContain.trim().split(&quot;,&quot;);</span>
    
<span class="nc bnc" id="L2438" title="All 2 branches missed.">    for (int i = 0; i &lt; split.length; i++) {</span>
<span class="nc" id="L2439">      String attName = split[i].trim();</span>
<span class="nc" id="L2440">      Attribute att = data.attribute(attName);</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">      if (att == null) {</span>
<span class="nc" id="L2442">        System.err.println(&quot;[FPGrowth] : WARNING - can't find attribute &quot; </span>
<span class="nc" id="L2443">            + attName + &quot; in the data.&quot;);</span>
      } else {
<span class="nc" id="L2445">        result.add(att);</span>
      }
    }
    
<span class="nc" id="L2449">    return result;</span>
  }

  /**
   * Method that generates all large item sets with a minimum support, and from
   * these all association rules with a minimum metric (i.e. confidence, 
   * lift etc.).
   *
   * @param data the instances to be used for generating the associations
   * @throws Exception if rules can't be built successfully
   */
  public void buildAssociations(Instances data) throws Exception {
    
    // can we handle the data?
<span class="nc" id="L2463">    getCapabilities().testWithFail(data);</span>
<span class="nc" id="L2464">    boolean breakOnNext = false;</span>
    
    // prune any instances that don't contain the requested items (if any)
<span class="nc bnc" id="L2467" title="All 2 branches missed.">    if (m_transactionsMustContain.length() &gt; 0) {</span>
<span class="nc" id="L2468">      data = parseTransactionsMustContain(data);</span>
<span class="nc" id="L2469">      getCapabilities().testWithFail(data);</span>
    }
    
<span class="nc" id="L2472">    ArrayList&lt;Attribute&gt; rulesMustContain = null;</span>
<span class="nc bnc" id="L2473" title="All 2 branches missed.">    if (m_rulesMustContain.length() &gt; 0) {</span>
<span class="nc" id="L2474">      rulesMustContain = parseRulesMustContain(data);</span>
    }
        
    
<span class="nc bnc" id="L2478" title="All 2 branches missed.">    int upperBoundMinSuppAsInstances = (m_upperBoundMinSupport &gt; 1) </span>
<span class="nc" id="L2479">    ? (int) m_upperBoundMinSupport</span>
<span class="nc" id="L2480">    : (int)Math.ceil(m_upperBoundMinSupport * data.numInstances());</span>
    
<span class="nc bnc" id="L2482" title="All 2 branches missed.">    int lowerBoundMinSuppAsInstances = (m_lowerBoundMinSupport &gt; 1)</span>
<span class="nc" id="L2483">    ? (int)m_lowerBoundMinSupport</span>
<span class="nc" id="L2484">        : (int)Math.ceil(m_lowerBoundMinSupport * data.numInstances());</span>


<span class="nc bnc" id="L2487" title="All 2 branches missed.">    double upperBoundMinSuppAsFraction = (m_upperBoundMinSupport &gt; 1)</span>
<span class="nc" id="L2488">    ? m_upperBoundMinSupport / data.numInstances()</span>
<span class="nc" id="L2489">        : m_upperBoundMinSupport;</span>

<span class="nc bnc" id="L2491" title="All 2 branches missed.">    double lowerBoundMinSuppAsFraction = (m_lowerBoundMinSupport &gt; 1)</span>
<span class="nc" id="L2492">    ? m_lowerBoundMinSupport / data.numInstances()</span>
<span class="nc" id="L2493">        : m_lowerBoundMinSupport;</span>

<span class="nc bnc" id="L2495" title="All 2 branches missed.">    double deltaAsFraction = (m_delta &gt; 1)</span>
<span class="nc" id="L2496">    ? m_delta / data.numInstances()</span>
<span class="nc" id="L2497">        : m_delta;</span>

    //double currentSupport = upperBoundMinSuppAsFraction;      
<span class="nc" id="L2500">    double currentSupport = 1.0;</span>

<span class="nc bnc" id="L2502" title="All 2 branches missed.">    if (m_findAllRulesForSupportLevel) {</span>
<span class="nc" id="L2503">      currentSupport = lowerBoundMinSuppAsFraction;</span>
    }
    // first compute singletons
<span class="nc" id="L2506">    ArrayList&lt;BinaryItem&gt; singletons = getSingletons(data);</span>
    //ArrayList&lt;BinaryItem&gt; singletonsCopy = new ArrayList&lt;BinaryItem&gt;(singletons);
/*    Collections.sort(singletonsCopy);
    for (int i = 0; i &lt; singletonsCopy.size(); i++) {
      System.out.println(singletonsCopy.get(i).toString(true));
    }
    System.out.println(&quot;---------&quot;); */
//    System.out.println(&quot;Finished finding singletons...&quot;);
    
    // while not enough rules
    do {
<span class="nc bnc" id="L2517" title="All 2 branches missed.">      int currentSupportAsInstances = (currentSupport &gt; 1)</span>
<span class="nc" id="L2518">      ? (int)currentSupport</span>
<span class="nc" id="L2519">      : (int)Math.ceil(currentSupport * data.numInstances());</span>
      
      //System.err.println(&quot;Current support &quot; + currentSupportAsInstances);
      //ArrayList&lt;BinaryItem&gt; prunedSingletons = removeNonFrequent(singletons);

      // build the FPTree
<span class="nc" id="L2525">      FPTreeRoot tree = buildFPTree(singletons, data, currentSupportAsInstances);</span>
//      System.out.println(&quot;Finished building tree...&quot;);
//      System.out.println(tree.toString(0));
    /*System.out.println(tree.printHeaderTable(0)); */

<span class="nc" id="L2530">      FrequentItemSets largeItemSets = new FrequentItemSets(data.numInstances());</span>

      // mine the tree
<span class="nc" id="L2533">      FrequentBinaryItemSet conditionalItems = </span>
<span class="nc" id="L2534">        new FrequentBinaryItemSet(new ArrayList&lt;BinaryItem&gt;(), 0);</span>
<span class="nc" id="L2535">      mineTree(tree, largeItemSets, 0, conditionalItems, currentSupportAsInstances);      </span>

<span class="nc" id="L2537">      m_largeItemSets = largeItemSets;</span>
//      System.err.println(&quot;Number of large item sets: &quot; + m_largeItemSets.size());
  //    System.err.println(m_largeItemSets.toString(100));

      //    m_largeItemSets.sort(compF);
//      System.err.println(&quot;Finished mining tree...&quot;);
      
      // save memory
<span class="nc" id="L2545">      tree = null;</span>

<span class="nc" id="L2547">      m_rules = </span>
<span class="nc" id="L2548">        AssociationRule.generateRulesBruteForce(m_largeItemSets, m_metric, </span>
<span class="nc" id="L2549">            m_metricThreshold, upperBoundMinSuppAsInstances, </span>
<span class="nc" id="L2550">            lowerBoundMinSuppAsInstances, data.numInstances());</span>
      
<span class="nc bnc" id="L2552" title="All 4 branches missed.">      if (rulesMustContain != null &amp;&amp; rulesMustContain.size() &gt; 0) {</span>
<span class="nc" id="L2553">        m_rules = AssociationRule.pruneRules(m_rules, rulesMustContain, </span>
<span class="nc" id="L2554">            m_mustContainOR);</span>
      }
      
      
<span class="nc bnc" id="L2558" title="All 2 branches missed.">      if (!m_findAllRulesForSupportLevel) {</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">        if (breakOnNext) {</span>
<span class="nc" id="L2560">          break;</span>
        }
<span class="nc" id="L2562">        currentSupport -= deltaAsFraction;</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">        if (currentSupport &lt; lowerBoundMinSuppAsFraction) {</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">          if (currentSupport + deltaAsFraction &gt; lowerBoundMinSuppAsFraction) {</span>
            // ensure that the lower bound does get evaluated
<span class="nc" id="L2566">            currentSupport = lowerBoundMinSuppAsFraction;</span>
<span class="nc" id="L2567">            breakOnNext = true;</span>
          } else {
            break;
          }
        }
      } else {
        // just break out of the loop as we are just finding all rules
        // with a minimum support + metric
        break;
      }
<span class="nc bnc" id="L2577" title="All 2 branches missed.">    } while (m_rules.size() &lt; m_numRulesToFind);</span>
    
<span class="nc" id="L2579">    Collections.sort(m_rules);</span>
//    for (AssociationRule)
    
//    System.out.println(graph(tree));
<span class="nc" id="L2583">  }</span>
    
  /**
   * Output the association rules.
   * 
   * @return a string representation of the model.
   */
  public String toString() {
//    return m_largeItemSets.toString(m_numItemSetsToFind);
<span class="nc bnc" id="L2592" title="All 2 branches missed.">    if (m_rules == null) {</span>
<span class="nc" id="L2593">      return &quot;FPGrowth hasn't been trained yet!&quot;;</span>
    }

<span class="nc" id="L2596">    StringBuffer result = new StringBuffer();</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">    int numRules = (m_rules.size() &lt; m_numRulesToFind)</span>
<span class="nc" id="L2598">      ? m_rules.size()</span>
<span class="nc" id="L2599">      : m_numRulesToFind;</span>
      
<span class="nc bnc" id="L2601" title="All 2 branches missed.">    if (m_rules.size() == 0) {</span>
<span class="nc" id="L2602">      return &quot;No rules found!&quot;;</span>
    } else {      
<span class="nc" id="L2604">      result.append(&quot;FPGrowth found &quot; + m_rules.size() + &quot; rules&quot;);</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">      if (!m_findAllRulesForSupportLevel) {</span>
<span class="nc" id="L2606">        result.append(&quot; (displaying top &quot; + numRules + &quot;)&quot;);</span>
      }
      
<span class="nc bnc" id="L2609" title="All 2 branches missed.">      if (m_transactionsMustContain.length() &gt; 0 || </span>
<span class="nc bnc" id="L2610" title="All 2 branches missed.">          m_rulesMustContain.length() &gt; 0) {</span>
<span class="nc" id="L2611">        result.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">        if (m_transactionsMustContain.length() &gt; 0) {</span>
<span class="nc" id="L2613">          result.append(&quot;\nUsing only transactions that contain: &quot; </span>
<span class="nc" id="L2614">              + m_transactionsMustContain);</span>
        }
<span class="nc bnc" id="L2616" title="All 2 branches missed.">        if (m_rulesMustContain.length() &gt; 0) {</span>
<span class="nc" id="L2617">          result.append(&quot;\nShowing only rules that contain: &quot; </span>
<span class="nc" id="L2618">              + m_rulesMustContain);</span>
        }
      }
      
<span class="nc" id="L2622">      result.append(&quot;\n\n&quot;);</span>
    }

<span class="nc" id="L2625">    int count = 0;</span>
<span class="nc bnc" id="L2626" title="All 2 branches missed.">    for (AssociationRule r : m_rules) {</span>
<span class="nc" id="L2627">      result.append(Utils.doubleToString((double)count+1,</span>
<span class="nc" id="L2628">          (int)(Math.log(numRules)/Math.log(10)+1), 0) + &quot;. &quot;);</span>
<span class="nc" id="L2629">      result.append(r + &quot;\n&quot;);</span>
<span class="nc" id="L2630">      count++;</span>
<span class="nc bnc" id="L2631" title="All 4 branches missed.">      if (!m_findAllRulesForSupportLevel &amp;&amp; count == m_numRulesToFind) {</span>
<span class="nc" id="L2632">        break;</span>
      }
    }
<span class="nc" id="L2635">    return result.toString();</span>
  }
  
  /**
   * Assemble a dot graph representation of the FP-tree.
   * 
   * @param tree the root of the FP-tree
   * @return a graph representation as a String in dot format.
   */
  public String graph(FPTreeRoot tree) {
    //int maxID = tree.assignIDs(-1);
    
    
<span class="nc" id="L2648">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L2649">    text.append(&quot;digraph FPTree {\n&quot;);</span>
<span class="nc" id="L2650">    text.append(&quot;N0 [label=\&quot;ROOT\&quot;]\n&quot;);</span>
<span class="nc" id="L2651">    tree.graphFPTree(text);</span>
    
//    tree.graphHeaderTable(text, maxID+1);
<span class="nc" id="L2654">    text.append(&quot;}\n&quot;);</span>
    
<span class="nc" id="L2656">    return text.toString();</span>
  }
  
  public String xmlRules() {
<span class="nc" id="L2660">    StringBuffer rulesBuff = new StringBuffer();</span>
    
<span class="nc" id="L2662">    rulesBuff.append(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;iso-8859-15\&quot;?&gt;\n&quot;);</span>
<span class="nc" id="L2663">    rulesBuff.append(&quot;&lt;RULES&gt;\n&quot;);</span>
<span class="nc" id="L2664">    int count = 0;</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">    for (AssociationRule r : m_rules) {</span>
<span class="nc" id="L2666">      rulesBuff.append(r.toXML());</span>
<span class="nc" id="L2667">      count++;</span>
<span class="nc bnc" id="L2668" title="All 4 branches missed.">      if (!m_findAllRulesForSupportLevel &amp;&amp; count == m_numRulesToFind) {</span>
<span class="nc" id="L2669">        break;</span>
      } 
    }
<span class="nc" id="L2672">    rulesBuff.append(&quot;&lt;/RULES&gt;\n&quot;);</span>
    
<span class="nc" id="L2674">    return rulesBuff.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return            the revision
   */
  public String getRevision() {
<span class="nc" id="L2683">    return RevisionUtils.extract(&quot;$Revision: 7092 $&quot;);</span>
  }
  
  /**
   * Main method.
   * 
   * @param args the commandline options
   */
  public static void main(String[] args) {
<span class="nc" id="L2692">    runAssociator(new FPGrowth(), args);</span>
<span class="nc" id="L2693">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>