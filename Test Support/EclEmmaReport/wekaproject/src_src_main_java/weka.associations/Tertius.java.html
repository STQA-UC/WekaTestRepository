<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Tertius.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.associations</a> &gt; <span class="el_source">Tertius.java</span></div><h1>Tertius.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    Tertius.java
 *    Copyright (C) 2003 Peter A. Flach, Nicolas Lachiche
 *
 *    Thanks to Amelie Deltour for porting the original C code to Java
 *    and integrating it into Weka.
 */

package weka.associations;

import weka.associations.tertius.AttributeValueLiteral;
import weka.associations.tertius.IndividualInstances;
import weka.associations.tertius.IndividualLiteral;
import weka.associations.tertius.Literal;
import weka.associations.tertius.Predicate;
import weka.associations.tertius.Rule;
import weka.associations.tertius.SimpleLinkedList;
import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.awt.BorderLayout;
import java.awt.Button;
import java.awt.Font;
import java.awt.Frame;
import java.awt.Label;
import java.awt.TextField;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Date;
import java.util.Enumeration;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Finds rules according to confirmation measure (Tertius-type algorithm).&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * P. A. Flach, N. Lachiche (1999). Confirmation-Guided Discovery of first-order rules with Tertius. Machine Learning. 42:61-95.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;article{Flach1999,
 *    author = {P. A. Flach and N. Lachiche},
 *    journal = {Machine Learning},
 *    pages = {61-95},
 *    title = {Confirmation-Guided Discovery of first-order rules with Tertius},
 *    volume = {42},
 *    year = {1999}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -K &amp;lt;number of values in result&amp;gt;
 *  Set maximum number of confirmation  values in the result. (default: 10)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -F &amp;lt;frequency threshold&amp;gt;
 *  Set frequency threshold for pruning. (default: 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;confirmation threshold&amp;gt;
 *  Set confirmation threshold. (default: 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;noise threshold&amp;gt;
 *  Set noise threshold : maximum frequency of counter-examples.
 *  0 gives only satisfied rules. (default: 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Allow attributes to be repeated in a same rule.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L &amp;lt;number of literals&amp;gt;
 *  Set maximum number of literals in a rule. (default: 4)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G &amp;lt;0=no negation | 1=body | 2=head | 3=body and head&amp;gt;
 *  Set the negations in the rule. (default: 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Consider only classification rules.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -c &amp;lt;class index&amp;gt;
 *  Set index of class attribute. (default: last).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H
 *  Consider only horn clauses.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E
 *  Keep equivalent rules.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M
 *  Keep same clauses.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -T
 *  Keep subsumed rules.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;0=always match | 1=never match | 2=significant&amp;gt;
 *  Set the way to handle missing values. (default: 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O
 *  Use ROC analysis. &lt;/pre&gt;
 * 
 * &lt;pre&gt; -p &amp;lt;name of file&amp;gt;
 *  Set the file containing the parts of the individual for individual-based learning.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;0=no output | 1=on stdout | 2=in separate window&amp;gt;
 *  Set output of current values. (default: 0)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author &lt;a href=&quot;mailto:adeltour@netcourrier.com&quot;&gt;Amelie Deltour&lt;/a&gt;
 * @version $Revision: 6368 $
 */

<span class="fc" id="L152">public class Tertius </span>
  extends AbstractAssociator 
  implements OptionHandler, Runnable, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = 5556726848380738179L;
  
  /** The results. */
  private SimpleLinkedList m_results;

  /** Number of hypotheses considered. */
  private int m_hypotheses;

  /** Number of hypotheses explored. */
  private int m_explored;

  /** Time needed for the search. */
  private Date m_time;

  /** Field to output the current values. */ 
  private TextField m_valuesText;

  /** Instances used for the search. */
  private Instances m_instances;

  /** Predicates used in the rules. */
  private ArrayList m_predicates;

  /** Status of the search. */
  private int m_status;
  /** Status of the search: normal */
  private static final int NORMAL = 0;
  /** Status of the search: memory problem */
  private static final int MEMORY = 1;
  /** Status of the search: user interruption */
  private static final int STOP = 2;
  
  /* Pruning options. */

  /** Number of best confirmation values to search. */
  private int m_best;

  /** Frequency threshold for the body and the negation of the head. */
  private double m_frequencyThreshold;

  /** Confirmation threshold for the rules. */
  private double m_confirmationThreshold;

  /** Maximal number of counter-instances. */
  private double m_noiseThreshold;

  /* Search space &amp; language bias options. */

  /** Repeat attributes ? */
  private boolean m_repeat;

  /** Number of literals in a rule. */
  private int m_numLiterals;

  /** Type of negation: none */
  private static final int NONE = 0;
  /** Type of negation: body */
  private static final int BODY = 1;
  /** Type of negation: head */
  private static final int HEAD = 2;
  /** Type of negation: all */
  private static final int ALL = 3;
  /** Types of negation. */
<span class="fc" id="L220">  private static final Tag [] TAGS_NEGATION = {</span>
<span class="fc" id="L221">    new Tag(NONE, &quot;None&quot;),</span>
<span class="fc" id="L222">    new Tag(BODY, &quot;Body&quot;),</span>
<span class="fc" id="L223">    new Tag(HEAD, &quot;Head&quot;),</span>
<span class="fc" id="L224">    new Tag(ALL, &quot;Both&quot;)</span>
      };

  /** Type of negation used in the rules. */
  private int m_negation;

  /** Classification bias. */
  private boolean m_classification;

  /** Index of class attribute. */
  private int m_classIndex;

  /** Horn clauses bias. */
  private boolean m_horn;

  /* Subsumption tests options. */

  /** Perform test on equivalent rules ? */
  private boolean m_equivalent;

  /** Perform test on same clauses ? */
  private boolean m_sameClause;
  
  /** Perform subsumption test ? */
  private boolean m_subsumption;

  /** Way of handling missing values: min counterinstances */
  public static final int EXPLICIT = 0;
  /** Way of handling missing values: max counterinstances */
  public static final int IMPLICIT = 1;
  /** Way of handling missing values: missing as a particular value */
  public static final int SIGNIFICANT = 2;
  /** Ways of handling missing values.  */
<span class="fc" id="L257">  private static final Tag [] TAGS_MISSING = {</span>
<span class="fc" id="L258">    new Tag(EXPLICIT, &quot;Matches all&quot;),</span>
<span class="fc" id="L259">    new Tag(IMPLICIT, &quot;Matches none&quot;),</span>
<span class="fc" id="L260">    new Tag(SIGNIFICANT, &quot;Significant&quot;)</span>
      };

  /** Way of handling missing values in the search. */
  private int m_missing;

  /** Perform ROC analysis ? */
  private boolean m_roc;

  /** Name of the file containing the parts for individual-based learning. */
  private String m_partsString;
  
  /** Part instances for individual-based learning. */
  private Instances m_parts;

  /** Type of values output: No */ 
  private static final int NO = 0;
  /** Type of values output: stdout */ 
  private static final int OUT = 1;
  /** Type of values output: Window */ 
  private static final int WINDOW = 2;
  /** Types of values output. */ 
<span class="fc" id="L282">  private static final Tag [] TAGS_VALUES = {</span>
<span class="fc" id="L283">    new Tag(NO, &quot;No&quot;),</span>
<span class="fc" id="L284">    new Tag(OUT, &quot;stdout&quot;),</span>
<span class="fc" id="L285">    new Tag(WINDOW, &quot;Window&quot;)</span>
      };

  /** Type of values output. */
  private int m_printValues;

  /**
   * Constructor that sets the options to the default values.
   */
<span class="nc" id="L294">  public Tertius() {</span>

<span class="nc" id="L296">    resetOptions();</span>
<span class="nc" id="L297">  }</span>

  /**
   * Returns a string describing this associator.
   *
   * @return A description of the evaluator suitable for
   * displaying in the explorer/experimenter gui.
   */
  public String globalInfo() {
<span class="nc" id="L306">    return </span>
<span class="nc" id="L307">        &quot;Finds rules according to confirmation measure (Tertius-type &quot;</span>
      + &quot;algorithm).\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L310">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L323">    result = new TechnicalInformation(Type.ARTICLE);</span>
<span class="nc" id="L324">    result.setValue(Field.AUTHOR, &quot;P. A. Flach and N. Lachiche&quot;);</span>
<span class="nc" id="L325">    result.setValue(Field.YEAR, &quot;1999&quot;);</span>
<span class="nc" id="L326">    result.setValue(Field.TITLE, &quot;Confirmation-Guided Discovery of first-order rules with Tertius&quot;);</span>
<span class="nc" id="L327">    result.setValue(Field.JOURNAL, &quot;Machine Learning&quot;);</span>
<span class="nc" id="L328">    result.setValue(Field.VOLUME, &quot;42&quot;);</span>
<span class="nc" id="L329">    result.setValue(Field.PAGES, &quot;61-95&quot;);</span>
    
<span class="nc" id="L331">    return result;</span>
  }

  /**
   * Resets the options to the default values.
   */
  public void resetOptions() {

    /* Pruning options. */
<span class="nc" id="L340">    m_best = 10;</span>
<span class="nc" id="L341">    m_frequencyThreshold = 0;</span>
<span class="nc" id="L342">    m_confirmationThreshold = 0;</span>
<span class="nc" id="L343">    m_noiseThreshold = 1;</span>

    /* Search space &amp; language bias options. */
<span class="nc" id="L346">    m_repeat = false;</span>
<span class="nc" id="L347">    m_numLiterals = 4;</span>
<span class="nc" id="L348">    m_negation = NONE;</span>
<span class="nc" id="L349">    m_classification = false;</span>
<span class="nc" id="L350">    m_classIndex = 0;</span>
<span class="nc" id="L351">    m_horn = false;</span>

    /* Subsumption tests options. */
<span class="nc" id="L354">    m_equivalent = true;</span>
<span class="nc" id="L355">    m_sameClause = true;</span>
<span class="nc" id="L356">    m_subsumption = true;</span>

    /* Missing values. */
<span class="nc" id="L359">    m_missing = EXPLICIT;</span>

    /* ROC analysis. */
<span class="nc" id="L362">    m_roc = false;</span>

    /* Individual-based learning. */
<span class="nc" id="L365">    m_partsString = &quot;&quot;;</span>
<span class="nc" id="L366">    m_parts = null;</span>

    /* Values output. */
<span class="nc" id="L369">    m_printValues = NO;</span>
<span class="nc" id="L370">  }</span>

  /**
   * Returns an enumeration describing the available options.
   *
   * @return An enumeration of all the available options.
   */
  public Enumeration listOptions() {
    
<span class="nc" id="L379">    Vector newVector = new Vector(17);</span>

    /* Pruning options. */
<span class="nc" id="L382">    newVector.addElement(new Option(&quot;\tSet maximum number of confirmation  &quot;</span>
				    + &quot;values in the result. (default: 10)&quot;,
<span class="nc" id="L384">				    &quot;K&quot;, 1, &quot;-K &lt;number of values in result&gt;&quot;));</span>
<span class="nc" id="L385">    newVector.addElement(new Option(&quot;\tSet frequency threshold for pruning. &quot;</span>
				    + &quot;(default: 0)&quot;,
<span class="nc" id="L387">				    &quot;F&quot;, 1, &quot;-F &lt;frequency threshold&gt;&quot;));</span>
<span class="nc" id="L388">    newVector.addElement(new Option(&quot;\tSet confirmation threshold. &quot;</span>
				    + &quot;(default: 0)&quot;,
<span class="nc" id="L390">				    &quot;C&quot;, 1, &quot;-C &lt;confirmation threshold&gt;&quot;));</span>
<span class="nc" id="L391">    newVector.addElement(new Option(&quot;\tSet noise threshold : maximum frequency &quot;</span>
				    + &quot;of counter-examples.\n\t0 gives only &quot;
				    + &quot;satisfied rules. (default: 1)&quot;,
<span class="nc" id="L394">				    &quot;N&quot;, 1, &quot;-N &lt;noise threshold&gt;&quot;));</span>

    /* Search space &amp; language bias options. */
<span class="nc" id="L397">    newVector.addElement(new Option(&quot;\tAllow attributes to be repeated in a &quot;</span>
				    + &quot;same rule.&quot;,
<span class="nc" id="L399">				    &quot;R&quot;, 0, &quot;-R&quot;));</span>
<span class="nc" id="L400">    newVector.addElement(new Option(&quot;\tSet maximum number of literals in a &quot;</span>
				    + &quot;rule. (default: 4)&quot;,
<span class="nc" id="L402">				    &quot;L&quot;, 1, &quot;-L &lt;number of literals&gt;&quot;));</span>
<span class="nc" id="L403">    newVector.addElement(new Option(&quot;\tSet the negations in the rule. &quot;</span>
				    + &quot;(default: 0)&quot;,
<span class="nc" id="L405">				    &quot;G&quot;, 1, &quot;-G &lt;0=no negation | &quot;</span>
				    + &quot;1=body | &quot;
				    + &quot;2=head | &quot;
				    + &quot;3=body and head&gt;&quot;));
<span class="nc" id="L409">    newVector.addElement(new Option(&quot;\tConsider only classification rules.&quot;,</span>
<span class="nc" id="L410">				    &quot;S&quot;, 0, &quot;-S&quot;));</span>
<span class="nc" id="L411">    newVector.addElement(new Option(&quot;\tSet index of class attribute. &quot;</span>
				    + &quot;(default: last).&quot;,
<span class="nc" id="L413">				    &quot;c&quot;, 1, &quot;-c &lt;class index&gt;&quot;));</span>
<span class="nc" id="L414">    newVector.addElement(new Option(&quot;\tConsider only horn clauses.&quot;,</span>
<span class="nc" id="L415">				    &quot;H&quot;, 0, &quot;-H&quot;));</span>

    /* Subsumption tests options. */
<span class="nc" id="L418">    newVector.addElement(new Option(&quot;\tKeep equivalent rules.&quot;,</span>
<span class="nc" id="L419">				    &quot;E&quot;, 0, &quot;-E&quot;));</span>
<span class="nc" id="L420">    newVector.addElement(new Option(&quot;\tKeep same clauses.&quot;,</span>
<span class="nc" id="L421">				    &quot;M&quot;, 0, &quot;-M&quot;));</span>
<span class="nc" id="L422">    newVector.addElement(new Option(&quot;\tKeep subsumed rules.&quot;,</span>
<span class="nc" id="L423">				    &quot;T&quot;, 0, &quot;-T&quot;));</span>

    /* Missing values options. */
<span class="nc" id="L426">    newVector.addElement(new Option(&quot;\tSet the way to handle missing values. &quot; </span>
				    + &quot;(default: 0)&quot;,
<span class="nc" id="L428">				    &quot;I&quot;, 1, &quot;-I &lt;0=always match | &quot;</span>
				    + &quot;1=never match | &quot;
				    + &quot;2=significant&gt;&quot;));

    /* ROC analysis. */
<span class="nc" id="L433">    newVector.addElement(new Option(&quot;\tUse ROC analysis. &quot;,</span>
<span class="nc" id="L434">				    &quot;O&quot;, 0, &quot;-O&quot;));</span>

    /* Individual-based learning. */
<span class="nc" id="L437">    newVector.addElement(new Option(&quot;\tSet the file containing the parts of &quot;</span>
				    + &quot;the individual for individual-based &quot;
				    + &quot;learning.&quot;,
<span class="nc" id="L440">				    &quot;p&quot;, 1, &quot;-p &lt;name of file&gt;&quot;));</span>

    /* Values output. */
<span class="nc" id="L443">    newVector.addElement(new Option(&quot;\tSet output of current values. &quot;</span>
				    + &quot;(default: 0)&quot;,
<span class="nc" id="L445">				    &quot;P&quot;, 1, &quot;-P &lt;0=no output | &quot;</span>
				    + &quot;1=on stdout | &quot;
				    + &quot;2=in separate window&gt;&quot;));
    
<span class="nc" id="L449">    return newVector.elements();</span>
  }
  
  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -K &amp;lt;number of values in result&amp;gt;
   *  Set maximum number of confirmation  values in the result. (default: 10)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -F &amp;lt;frequency threshold&amp;gt;
   *  Set frequency threshold for pruning. (default: 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;confirmation threshold&amp;gt;
   *  Set confirmation threshold. (default: 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;noise threshold&amp;gt;
   *  Set noise threshold : maximum frequency of counter-examples.
   *  0 gives only satisfied rules. (default: 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Allow attributes to be repeated in a same rule.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L &amp;lt;number of literals&amp;gt;
   *  Set maximum number of literals in a rule. (default: 4)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G &amp;lt;0=no negation | 1=body | 2=head | 3=body and head&amp;gt;
   *  Set the negations in the rule. (default: 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Consider only classification rules.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -c &amp;lt;class index&amp;gt;
   *  Set index of class attribute. (default: last).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -H
   *  Consider only horn clauses.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E
   *  Keep equivalent rules.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M
   *  Keep same clauses.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -T
   *  Keep subsumed rules.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;0=always match | 1=never match | 2=significant&amp;gt;
   *  Set the way to handle missing values. (default: 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O
   *  Use ROC analysis. &lt;/pre&gt;
   * 
   * &lt;pre&gt; -p &amp;lt;name of file&amp;gt;
   *  Set the file containing the parts of the individual for individual-based learning.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;0=no output | 1=on stdout | 2=in separate window&amp;gt;
   *  Set output of current values. (default: 0)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options The list of options as an array of strings.
   * @throws Exception if an option is not supported.
   */
  public void setOptions(String [] options) throws Exception {
    
<span class="nc" id="L517">    resetOptions();</span>
    
    /* Pruning options. */
<span class="nc" id="L520">    String bestString = Utils.getOption('K', options);</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">    if (bestString.length() != 0) {</span>
      try {
<span class="nc" id="L523">	m_best = Integer.parseInt(bestString);</span>
<span class="nc" id="L524">      } catch (Exception e) {</span>
<span class="nc" id="L525">	throw new Exception(&quot;Invalid value for -K option: &quot;</span>
<span class="nc" id="L526">			    + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc bnc" id="L528" title="All 2 branches missed.">      if (m_best &lt; 1) {</span>
<span class="nc" id="L529">	throw new Exception(&quot;Number of confirmation values has to be &quot;</span>
			    + &quot;greater than one!&quot;);
      }
    }
<span class="nc" id="L533">    String frequencyThresholdString = Utils.getOption('F', options);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">    if (frequencyThresholdString.length() != 0) {</span>
      try {	
<span class="nc" id="L536">	m_frequencyThreshold </span>
<span class="nc" id="L537">	  = (new Double(frequencyThresholdString)).doubleValue();</span>
<span class="nc" id="L538">      } catch (Exception e) {</span>
<span class="nc" id="L539">	throw new Exception(&quot;Invalid value for -F option: &quot;</span>
<span class="nc" id="L540">			    + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc bnc" id="L542" title="All 4 branches missed.">      if (m_frequencyThreshold &lt; 0 || m_frequencyThreshold &gt; 1) {</span>
<span class="nc" id="L543">	throw new Exception(&quot;Frequency threshold has to be between &quot;</span>
			    + &quot;zero and one!&quot;);
      }
    }
<span class="nc" id="L547">    String confirmationThresholdString = Utils.getOption('C', options);</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">    if (confirmationThresholdString.length() != 0) {</span>
      try {
<span class="nc" id="L550">	m_confirmationThreshold </span>
<span class="nc" id="L551">	  = (new Double(confirmationThresholdString)).doubleValue();</span>
<span class="nc" id="L552">      } catch (Exception e) {</span>
<span class="nc" id="L553">	throw new Exception(&quot;Invalid value for -C option: &quot;</span>
<span class="nc" id="L554">			    + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc bnc" id="L556" title="All 4 branches missed.">      if (m_confirmationThreshold &lt; 0 || m_confirmationThreshold &gt; 1) {</span>
<span class="nc" id="L557">	throw new Exception(&quot;Confirmation threshold has to be between &quot;</span>
			    + &quot;zero and one!&quot;);
      }
<span class="nc bnc" id="L560" title="All 2 branches missed.">      if (bestString.length() != 0) {</span>
<span class="nc" id="L561">	throw new Exception(&quot;Specifying both a number of confirmation &quot;</span>
			    + &quot;values and a confirmation threshold &quot;
			    + &quot;doesn't make sense!&quot;);
      }
<span class="nc bnc" id="L565" title="All 2 branches missed.">      if (m_confirmationThreshold != 0) {</span>
<span class="nc" id="L566">	m_best = 0;</span>
      }
    }
<span class="nc" id="L569">    String noiseThresholdString = Utils.getOption('N', options);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">    if (noiseThresholdString.length() != 0) {</span>
      try {
<span class="nc" id="L572">	m_noiseThreshold = (new Double(noiseThresholdString)).doubleValue();</span>
<span class="nc" id="L573">      } catch (Exception e) {</span>
<span class="nc" id="L574">	throw new Exception(&quot;Invalid value for -N option: &quot;</span>
<span class="nc" id="L575">			    + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc bnc" id="L577" title="All 4 branches missed.">      if (m_noiseThreshold &lt; 0 || m_noiseThreshold &gt; 1) {</span>
<span class="nc" id="L578">	throw new Exception(&quot;Noise threshold has to be between &quot;</span>
			    + &quot;zero and one!&quot;);
      }
    }

    /* Search space and language bias options. */
<span class="nc" id="L584">    m_repeat = Utils.getFlag('R', options);</span>
<span class="nc" id="L585">    String numLiteralsString = Utils.getOption('L', options);</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">    if (numLiteralsString.length() != 0) {</span>
      try {
<span class="nc" id="L588">	m_numLiterals = Integer.parseInt(numLiteralsString);</span>
<span class="nc" id="L589">      } catch (Exception e) {</span>
<span class="nc" id="L590">	throw new Exception(&quot;Invalid value for -L option: &quot;</span>
<span class="nc" id="L591">			    + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (m_numLiterals &lt; 1) {</span>
<span class="nc" id="L594">	throw new Exception(&quot;Number of literals has to be &quot;</span>
			    + &quot;greater than one!&quot;);
      }
    }
<span class="nc" id="L598">    String negationString = Utils.getOption('G', options);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">    if (negationString.length() != 0) {</span>
      SelectedTag selected;
      int tag;
      try {
<span class="nc" id="L603">	tag = Integer.parseInt(negationString);</span>
<span class="nc" id="L604">      } catch (Exception e) {</span>
<span class="nc" id="L605">	throw new Exception(&quot;Invalid value for -G option: &quot;</span>
<span class="nc" id="L606">			    + e.getMessage() + &quot;.&quot;);</span>
      }
      try {
<span class="nc" id="L609">	selected = new SelectedTag(tag, TAGS_NEGATION);</span>
<span class="nc" id="L610">      } catch (Exception e) {</span>
<span class="nc" id="L611">	throw new Exception(&quot;Value for -G option has to be &quot;</span>
			    + &quot;between zero and three!&quot;);
      }
<span class="nc" id="L614">      setNegation(selected);</span>
    }
<span class="nc" id="L616">    m_classification = Utils.getFlag('S', options);</span>
<span class="nc" id="L617">    String classIndexString = Utils.getOption('c', options);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">    if (classIndexString.length() != 0) {</span>
      try {
<span class="nc" id="L620">	m_classIndex = Integer.parseInt(classIndexString);</span>
<span class="nc" id="L621">      } catch (Exception e) {</span>
<span class="nc" id="L622">	throw new Exception(&quot;Invalid value for -c option: &quot;</span>
<span class="nc" id="L623">			    + e.getMessage() + &quot;.&quot;);</span>
      }
    }
<span class="nc" id="L626">    m_horn = Utils.getFlag('H', options);</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">    if (m_horn &amp;&amp; (m_negation != NONE)) {</span>
<span class="nc" id="L628">      throw new Exception(&quot;Considering horn clauses doesn't make sense &quot;</span>
			  + &quot;if negation allowed!&quot;);
    }
    
    /* Subsumption tests options. */
<span class="nc bnc" id="L633" title="All 2 branches missed.">    m_equivalent = !(Utils.getFlag('E', options));</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">    m_sameClause = !(Utils.getFlag('M', options));</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    m_subsumption = !(Utils.getFlag('T', options));</span>

    /* Missing values options. */
<span class="nc" id="L638">    String missingString = Utils.getOption('I', options);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">    if (missingString.length() != 0) {</span>
      SelectedTag selected;
      int tag;
      try {
<span class="nc" id="L643">	tag = Integer.parseInt(missingString);</span>
<span class="nc" id="L644">      } catch (Exception e) {</span>
<span class="nc" id="L645">	throw new Exception(&quot;Invalid value for -I option: &quot;</span>
<span class="nc" id="L646">			    + e.getMessage() + &quot;.&quot;);</span>
      }
      try {
<span class="nc" id="L649">	selected = new SelectedTag(tag, TAGS_MISSING);</span>
<span class="nc" id="L650">      } catch (Exception e) {</span>
<span class="nc" id="L651">	throw new Exception(&quot;Value for -I option has to be &quot;</span>
			    + &quot;between zero and two!&quot;);
      }
<span class="nc" id="L654">      setMissingValues(selected);</span>
    }

    /* ROC analysis. */
<span class="nc" id="L658">    m_roc = Utils.getFlag('O', options);</span>


    /* Individual-based learning. */
<span class="nc" id="L662">    m_partsString = Utils.getOption('p', options);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">    if (m_partsString.length() != 0) {</span>
      Reader reader;
      try {
<span class="nc" id="L666">	reader = new BufferedReader(new FileReader(m_partsString));</span>
<span class="nc" id="L667">      } catch (Exception e) {</span>
<span class="nc" id="L668">	throw new Exception(&quot;Can't open file &quot; + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc" id="L670">      m_parts = new Instances(reader);	</span>
    }

    /* Values output. */
<span class="nc" id="L674">    String printValuesString = Utils.getOption('P', options);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">    if (printValuesString.length() != 0) {</span>
      SelectedTag selected;
      int tag;
      try {
<span class="nc" id="L679">	tag = Integer.parseInt(printValuesString);</span>
<span class="nc" id="L680">      } catch (Exception e) {</span>
<span class="nc" id="L681">	throw new Exception(&quot;Invalid value for -P option: &quot;</span>
<span class="nc" id="L682">			    + e.getMessage() + &quot;.&quot;);</span>
      }
      try {
<span class="nc" id="L685">	selected = new SelectedTag(tag, TAGS_VALUES);</span>
<span class="nc" id="L686">      } catch (Exception e) {</span>
<span class="nc" id="L687">	throw new Exception(&quot;Value for -P option has to be &quot;</span>
			    + &quot;between zero and two!&quot;);
      }
<span class="nc" id="L690">      setValuesOutput(selected);</span>
    }
<span class="nc" id="L692">  }</span>

  /**
   * Gets the current settings of the Tertius object.
   *
   * @return An array of strings suitable for passing to setOptions.
   */
  public String [] getOptions() {
    Vector    	result;

<span class="nc" id="L702">    result = new Vector();</span>

    /* Pruning options. */
<span class="nc bnc" id="L705" title="All 2 branches missed.">    if (m_best &gt; 0) {</span>
<span class="nc" id="L706">      result.add(&quot;-K&quot;);</span>
<span class="nc" id="L707">      result.add(&quot;&quot; + m_best);</span>
    }
    
<span class="nc" id="L710">    result.add(&quot;-F&quot;);</span>
<span class="nc" id="L711">    result.add(&quot;&quot; + m_frequencyThreshold);</span>
    
<span class="nc bnc" id="L713" title="All 2 branches missed.">    if (m_confirmationThreshold &gt; 0) {</span>
<span class="nc" id="L714">      result.add(&quot;-C&quot;);</span>
<span class="nc" id="L715">      result.add(&quot;&quot; + m_confirmationThreshold);</span>
    }
    
<span class="nc" id="L718">    result.add(&quot;-N&quot;);</span>
<span class="nc" id="L719">    result.add(&quot;&quot; + m_noiseThreshold);</span>
    
    /* Search space and language bias options. */
<span class="nc bnc" id="L722" title="All 2 branches missed.">    if (m_repeat)</span>
<span class="nc" id="L723">      result.add(&quot;-R&quot;);</span>
    
<span class="nc" id="L725">    result.add(&quot;-L&quot;);</span>
<span class="nc" id="L726">    result.add(&quot;&quot; + m_numLiterals);</span>
    
<span class="nc" id="L728">    result.add(&quot;-G&quot;);</span>
<span class="nc" id="L729">    result.add(&quot;&quot; + m_negation);</span>
    
<span class="nc bnc" id="L731" title="All 2 branches missed.">    if (m_classification)</span>
<span class="nc" id="L732">      result.add(&quot;-S&quot;);</span>
      
<span class="nc" id="L734">    result.add(&quot;-c&quot;);</span>
<span class="nc" id="L735">    result.add(&quot;&quot; + m_classIndex);</span>
    
<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (m_horn)</span>
<span class="nc" id="L738">      result.add(&quot;-H&quot;);</span>

    /* Subsumption tests options. */
<span class="nc bnc" id="L741" title="All 2 branches missed.">    if (!m_equivalent)</span>
<span class="nc" id="L742">      result.add(&quot;-E&quot;);</span>
    
<span class="nc bnc" id="L744" title="All 2 branches missed.">    if (!m_sameClause)</span>
<span class="nc" id="L745">      result.add(&quot;-M&quot;);</span>
    
<span class="nc bnc" id="L747" title="All 2 branches missed.">    if (!m_subsumption)</span>
<span class="nc" id="L748">      result.add(&quot;-T&quot;);</span>

    /* Missing values options. */
<span class="nc" id="L751">    result.add(&quot;-I&quot;);</span>
<span class="nc" id="L752">    result.add(&quot;&quot; + m_missing);</span>

    /* ROC analysis. */
<span class="nc bnc" id="L755" title="All 2 branches missed.">    if (m_roc)</span>
<span class="nc" id="L756">      result.add(&quot;-O&quot;);</span>

    /* Individual-based learning. */
<span class="nc bnc" id="L759" title="All 2 branches missed.">    if (m_partsString.length() &gt; 0) {</span>
<span class="nc" id="L760">      result.add(&quot;-p&quot;);</span>
<span class="nc" id="L761">      result.add(&quot;&quot; + m_partsString);</span>
    }

    /* Values output. */
<span class="nc" id="L765">    result.add(&quot;-P&quot;);</span>
<span class="nc" id="L766">    result.add(&quot;&quot; + m_printValues);</span>

<span class="nc" id="L768">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String confirmationValuesTipText() {

<span class="nc" id="L779">    return &quot;Number of best confirmation values to find.&quot;;</span>
  }

  /**
   * Get the value of confirmationValues.
   *
   * @return Value of confirmationValues.
   */
  public int getConfirmationValues() {

<span class="nc" id="L789">    return m_best;</span>
  }

  /**
   * Set the value of confirmationValues.
   *
   * @param v  Value to assign to confirmationValues.
   */
  public void setConfirmationValues(int v) {

<span class="nc" id="L799">    m_best = v;</span>
<span class="nc" id="L800">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String frequencyThresholdTipText() {
    
<span class="nc" id="L810">    return &quot;Minimum proportion of instances satisfying head and body of rules&quot;;</span>
  }

  /**
   * Get the value of frequencyThreshold.
   *
   * @return Value of frequencyThreshold.
   */
  public double getFrequencyThreshold() {
    
<span class="nc" id="L820">    return m_frequencyThreshold;</span>
  }

  /**
   * Set the value of frequencyThreshold.
   *
   * @param v  Value to assign to frequencyThreshold.
   */
  public void setFrequencyThreshold(double v) {
    
<span class="nc" id="L830">    m_frequencyThreshold = v;</span>
<span class="nc" id="L831">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String confirmationThresholdTipText() {
    
<span class="nc" id="L841">    return &quot;Minimum confirmation of the rules.&quot;;</span>
  }

  /**
   * Get the value of confirmationThreshold.
   *
   * @return Value of confirmationThreshold.
   */
  public double getConfirmationThreshold() {
    
<span class="nc" id="L851">    return m_confirmationThreshold;</span>
  }

  /**
   * Set the value of confirmationThreshold.
   *
   * @param v  Value to assign to confirmationThreshold.
   */
  public void setConfirmationThreshold(double v) {
    
<span class="nc" id="L861">    m_confirmationThreshold = v;</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">    if (v != 0) {</span>
<span class="nc" id="L863">      m_best = 0;</span>
    }
<span class="nc" id="L865">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String noiseThresholdTipText() {
    
<span class="nc" id="L875">    return &quot;Maximum proportion of counter-instances of rules. &quot;</span>
      + &quot;If set to 0, only satisfied rules will be given.&quot;;
  }

  /**
   * Get the value of noiseThreshold.
   *
   * @return Value of noiseThreshold.
   */
  public double getNoiseThreshold() {
    
<span class="nc" id="L886">    return m_noiseThreshold;</span>
  }

  /**
   * Set the value of noiseThreshold.
   *
   * @param v  Value to assign to noiseThreshold.
   */
  public void setNoiseThreshold(double v) {
    
<span class="nc" id="L896">    m_noiseThreshold = v;</span>
<span class="nc" id="L897">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String repeatLiteralsTipText() {

<span class="nc" id="L907">    return &quot;Repeated attributes allowed.&quot;;</span>
  }

  /**
   * Get the value of repeatLiterals.
   *
   * @return Value of repeatLiterals.
   */
  public boolean getRepeatLiterals() {
    
<span class="nc" id="L917">    return m_repeat;</span>
  }

  /**
   * Set the value of repeatLiterals.
   *
   * @param v  Value to assign to repeatLiterals.
   */
  public void setRepeatLiterals(boolean v) {
    
<span class="nc" id="L927">    m_repeat = v;</span>
<span class="nc" id="L928">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String numberLiteralsTipText() {
    
<span class="nc" id="L938">    return &quot;Maximum number of literals in a rule.&quot;;</span>
  }

  /**
   * Get the value of numberLiterals.
   *
   * @return Value of numberLiterals.
   */
  public int getNumberLiterals() {

<span class="nc" id="L948">    return m_numLiterals;</span>
  }

  /**
   * Set the value of numberLiterals.
   *
   * @param v  Value to assign to numberLiterals.
   */
  public void setNumberLiterals(int v) {
    
<span class="nc" id="L958">    m_numLiterals = v;</span>
<span class="nc" id="L959">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String negationTipText() {
    
<span class="nc" id="L969">    return &quot;Set the type of negation allowed in the rule. &quot;</span>
      + &quot;Negation can be allowed in the body, in the head, in both &quot;
      + &quot;or in none.&quot;;
  }

  /**
   * Get the value of negation.
   *
   * @return Value of negation.
   */
  public SelectedTag getNegation() {
    
<span class="nc" id="L981">    return new SelectedTag(m_negation, TAGS_NEGATION);</span>
  }

  /**
   * Set the value of negation.
   *
   * @param v  Value to assign to negation.
   */
  public void setNegation(SelectedTag v) {
    
<span class="nc bnc" id="L991" title="All 2 branches missed.">    if (v.getTags() == TAGS_NEGATION) {</span>
<span class="nc" id="L992">      m_negation = v.getSelectedTag().getID();</span>
    }
<span class="nc" id="L994">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String classificationTipText() {
    
<span class="nc" id="L1004">    return &quot;Find only rules with the class in the head.&quot;;</span>
  }

  /**
   * Get the value of classification.
   *
   * @return Value of classification.
   */
  public boolean getClassification() {

<span class="nc" id="L1014">    return m_classification;</span>
  }

  /**
   * Set the value of classification.
   *
   * @param v  Value to assign to classification.
   */
  public void setClassification(boolean v) {

<span class="nc" id="L1024">    m_classification = v;</span>
<span class="nc" id="L1025">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String classIndexTipText() {

<span class="nc" id="L1035">    return &quot;Index of the class attribute. If set to 0, the class will be the last attribute.&quot;;</span>
  }

  /**
   * Get the value of classIndex.
   *
   * @return Value of classIndex.
   */
  public int getClassIndex() {

<span class="nc" id="L1045">    return m_classIndex;</span>
  }

  /**
   * Set the value of classIndex.
   *
   * @param v  Value to assign to classIndex.
   */
  public void setClassIndex(int v) {

<span class="nc" id="L1055">    m_classIndex = v;</span>
<span class="nc" id="L1056">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String hornClausesTipText() {
    
<span class="nc" id="L1066">    return &quot;Find rules with a single conclusion literal only.&quot;;</span>
  }

  /**
   * Get the value of hornClauses.
   *
   * @return Value of hornClauses.
   */
  public boolean getHornClauses() {

<span class="nc" id="L1076">    return m_horn;</span>
  }

  /**
   * Set the value of hornClauses.
   *
   * @param v  Value to assign to hornClauses.
   */
  public void setHornClauses(boolean v) {

<span class="nc" id="L1086">    m_horn = v;</span>
<span class="nc" id="L1087">  }</span>
  
  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String equivalentTipText() {
    
<span class="nc" id="L1097">    return &quot;Keep equivalent rules. &quot;</span>
      + &quot;A rule r2 is equivalent to a rule r1 if the body of r2 is the &quot;
      + &quot;negation of the head of r1, and the head of r2 is the &quot;
      + &quot;negation of the body of r1.&quot;;
  }

  /**
   * Get the value of equivalent.
   *
   * @return Value of equivalent.
   */
  public boolean disabled_getEquivalent() {
    
<span class="nc bnc" id="L1110" title="All 2 branches missed.">    return !m_equivalent;</span>
  }

  /**
   * Set the value of equivalent.
   *
   * @param v  Value to assign to equivalent.
   */
  public void disabled_setEquivalent(boolean v) {
    
<span class="nc bnc" id="L1120" title="All 2 branches missed.">    m_equivalent = !v;</span>
<span class="nc" id="L1121">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String sameClauseTipText() {

<span class="nc" id="L1131">    return &quot;Keep rules corresponding to the same clauses. &quot;</span>
      + &quot;If set to false, only the rule with the best confirmation &quot;
      + &quot;value and rules with a lower number of counter-instances &quot;
      + &quot;will be kept.&quot;;
  }

  /**
   * Get the value of sameClause.
   *
   * @return Value of sameClause.
   */
  public boolean disabled_getSameClause() {

<span class="nc bnc" id="L1144" title="All 2 branches missed.">    return !m_sameClause;</span>
  }

  /**
   * Set the value of sameClause.
   *
   * @param v  Value to assign to sameClause.
   */
  public void disabled_setSameClause(boolean v) {

<span class="nc bnc" id="L1154" title="All 2 branches missed.">    m_sameClause = !v;</span>
<span class="nc" id="L1155">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String subsumptionTipText() {

<span class="nc" id="L1165">    return &quot;Keep subsumed rules. &quot;</span>
      + &quot;If set to false, subsumed rules will only be kept if they &quot;
      + &quot;have a better confirmation or a lower number of counter-instances.&quot;;
  }

  /**
   * Get the value of subsumption.
   *
   * @return Value of subsumption.
   */
  public boolean disabled_getSubsumption() {

<span class="nc bnc" id="L1177" title="All 2 branches missed.">    return !m_subsumption;</span>
  }

  /**
   * Set the value of subsumption.
   *
   * @param v  Value to assign to subsumption.
   */
  public void disabled_setSubsumption(boolean v) {

<span class="nc bnc" id="L1187" title="All 2 branches missed.">    m_subsumption = !v;</span>
<span class="nc" id="L1188">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String missingValuesTipText() {
    
<span class="nc" id="L1198">    return &quot;Set the way to handle missing values. &quot;</span>
      + &quot;Missing values can be set to match any value, or never match values &quot;
      + &quot;or to be significant and possibly appear in rules.&quot;;
  }

  /**
   * Get the value of missingValues.
   *
   * @return Value of missingValues.
   */
  public SelectedTag getMissingValues() {
    
<span class="nc" id="L1210">    return new SelectedTag(m_missing, TAGS_MISSING);</span>
  }

  /**
   * Set the value of missingValues.
   *
   * @param v  Value to assign to missingValues.
   */
  public void setMissingValues(SelectedTag v) {
    
<span class="nc bnc" id="L1220" title="All 2 branches missed.">    if (v.getTags() == TAGS_MISSING) {</span>
<span class="nc" id="L1221">      m_missing = v.getSelectedTag().getID();</span>
    }
<span class="nc" id="L1223">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String rocAnalysisTipText() {
    
<span class="nc" id="L1233">    return &quot;Return TP-rate and FP-rate for each rule found.&quot;;</span>
  }

  /**
   * Get the value of rocAnalysis.
   *
   * @return Value of rocAnalysis.
   */
  public boolean getRocAnalysis() {

<span class="nc" id="L1243">    return m_roc;</span>
  }

  /**
   * Set the value of rocAnalysis.
   *
   * @param v  Value to assign to rocAnalysis.
   */
  public void setRocAnalysis(boolean v) {

<span class="nc" id="L1253">    m_roc = v;</span>
<span class="nc" id="L1254">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String partFileTipText() {
    
<span class="nc" id="L1264">    return &quot;Set file containing the parts of the individual &quot;</span>
      + &quot;for individual-based learning.&quot;;
  }

  /**
   * Get the value of partFile.
   *
   * @return Value of partFile.
   */
  public File disabled_getPartFile() {

<span class="nc" id="L1275">    return new File(m_partsString);</span>
  }

  /**
   * Set the value of partFile.
   *
   * @param v  Value to assign to partFile.
   * @throws Exception if file cannot be opened
   */
  public void disabled_setPartFile(File v) throws Exception {

<span class="nc" id="L1286">    m_partsString = v.getAbsolutePath();</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">    if (m_partsString.length() != 0) {</span>
      Reader reader;
      try {
<span class="nc" id="L1290">	reader = new BufferedReader(new FileReader(m_partsString));</span>
<span class="nc" id="L1291">      } catch (Exception e) {</span>
<span class="nc" id="L1292">	throw new Exception(&quot;Can't open file &quot; + e.getMessage() + &quot;.&quot;);</span>
      }
<span class="nc" id="L1294">      m_parts = new Instances(reader);	</span>
    }
<span class="nc" id="L1296">  }</span>

  /**
   * Returns the tip text for this property.
   *
   * @return Tip text for this property suitable for
   * displaying in the explorer/experimenter GUI.
   */
  public String valuesOutputTipText() {
    
<span class="nc" id="L1306">    return &quot;Give visual feedback during the search. &quot;</span>
      + &quot;The current best and worst values can be output either to stdout or to a separate window.&quot;;
  }

  /**
   * Get the value of valuesOutput.
   *
   * @return Value of valuesOutput.
   */
  public SelectedTag getValuesOutput() {
    
<span class="nc" id="L1317">    return new SelectedTag(m_printValues, TAGS_VALUES);</span>
  }

  /**
   * Set the value of valuesOutput.
   *
   * @param v  Value to assign to valuesOutput.
   */
  public void setValuesOutput(SelectedTag v) {
    
<span class="nc bnc" id="L1327" title="All 2 branches missed.">    if (v.getTags() == TAGS_VALUES) {</span>
<span class="nc" id="L1328">      m_printValues = v.getSelectedTag().getID();</span>
    }
<span class="nc" id="L1330">  }</span>

  /**
   * Build the predicate corresponding to an attribute.
   *
   * @param instances The instances this predicates comes from.
   * @param attr The attribute this predicate corresponds to.
   * @param isClass Saying if the attribute is the class attribute.
   * @return The corresponding Predicate.
   * @throws Exception if the predicate could not be build 
   * (the attribute is numeric).
   */
  private Predicate buildPredicate(Instances instances,
				   Attribute attr, boolean isClass) 
    throws Exception {

    Predicate predicate; /* The result. */
    Literal lit;
    Literal negation;
    boolean missingValues; /* Missing values for this attribute ? */
<span class="nc bnc" id="L1350" title="All 2 branches missed.">    boolean individual = (m_parts != null); /* Individual-based learning ? */</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">    int type = (instances == m_parts)</span>
<span class="nc" id="L1352">      ? IndividualLiteral.PART_PROPERTY</span>
<span class="nc" id="L1353">      : IndividualLiteral.INDIVIDUAL_PROPERTY; /* Type of property. */</span>

<span class="nc bnc" id="L1355" title="All 2 branches missed.">    if (attr.isNumeric()) {</span>
<span class="nc" id="L1356">      throw new Exception(&quot;Can't handle numeric attributes!&quot;);</span>
    }
	
<span class="nc bnc" id="L1359" title="All 2 branches missed.">    missingValues = instances.attributeStats(attr.index()).missingCount &gt; 0;</span>

    /* Build predicate. */
<span class="nc bnc" id="L1362" title="All 2 branches missed.">    if (individual) {</span>
<span class="nc" id="L1363">      predicate = new Predicate(instances.relationName() + &quot;.&quot; + attr.name(), </span>
<span class="nc" id="L1364">				attr.index(), isClass);</span>
    } else {
<span class="nc" id="L1366">      predicate = new Predicate(attr.name(), attr.index(), isClass);</span>
    }
	
<span class="nc bnc" id="L1369" title="All 2 branches missed.">    if (attr.numValues() == 2</span>
<span class="nc bnc" id="L1370" title="All 4 branches missed.">	&amp;&amp; (!missingValues || m_missing == EXPLICIT)) {</span>
      /* Case of two values.
       * If there are missing values, this case is treated like other cases.
       */
<span class="nc bnc" id="L1374" title="All 2 branches missed.">      if (individual) {</span>
<span class="nc" id="L1375">	lit = new IndividualLiteral(predicate, attr.value(0), 0, </span>
<span class="nc" id="L1376">				    Literal.POS, m_missing, type);</span>
<span class="nc" id="L1377">	negation = new IndividualLiteral(predicate, attr.value(1), 1, </span>
<span class="nc" id="L1378">					 Literal.POS, m_missing, type);</span>
      } else {
<span class="nc" id="L1380">	lit = new AttributeValueLiteral(predicate, attr.value(0), 0, </span>
<span class="nc" id="L1381">					Literal.POS, m_missing);</span>
<span class="nc" id="L1382">	negation = new AttributeValueLiteral(predicate, attr.value(1), 1, </span>
<span class="nc" id="L1383">					     Literal.POS, m_missing);</span>
      }
<span class="nc" id="L1385">      lit.setNegation(negation);</span>
<span class="nc" id="L1386">      negation.setNegation(lit);</span>
<span class="nc" id="L1387">      predicate.addLiteral(lit);      </span>
    } else {
      /* Case of several values. */
<span class="nc bnc" id="L1390" title="All 2 branches missed.">      for (int i = 0; i &lt; attr.numValues(); i++) {</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">	if (individual) {</span>
<span class="nc" id="L1392">	  lit = new IndividualLiteral(predicate, attr.value(i), i,</span>
<span class="nc" id="L1393">				      Literal.POS, m_missing, type);</span>
	} else {
<span class="nc" id="L1395">	  lit = new AttributeValueLiteral(predicate, attr.value(i), i, </span>
<span class="nc" id="L1396">					  Literal.POS, m_missing);</span>
	}
<span class="nc bnc" id="L1398" title="All 2 branches missed.">	if (m_negation != NONE) {</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">	  if (individual) {</span>
<span class="nc" id="L1400">	    negation = new IndividualLiteral(predicate, attr.value(i), i, </span>
<span class="nc" id="L1401">					     Literal.NEG, m_missing, type);</span>
	  } else {
<span class="nc" id="L1403">	    negation = new AttributeValueLiteral(predicate, attr.value(i), i, </span>
<span class="nc" id="L1404">						 Literal.NEG, m_missing);</span>
	  }
<span class="nc" id="L1406">	  lit.setNegation(negation);</span>
<span class="nc" id="L1407">	  negation.setNegation(lit);</span>
	}
<span class="nc" id="L1409">	predicate.addLiteral(lit);</span>
      }

      /* One more value if missing is significant. */
<span class="nc bnc" id="L1413" title="All 4 branches missed.">      if (missingValues &amp;&amp; m_missing == SIGNIFICANT) {</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">	if (individual) {</span>
<span class="nc" id="L1415">	  lit = new IndividualLiteral(predicate, &quot;?&quot;, -1, </span>
<span class="nc" id="L1416">				      Literal.POS, m_missing, type);</span>
	} else {
<span class="nc" id="L1418">	  lit = new AttributeValueLiteral(predicate, &quot;?&quot;, -1, </span>
<span class="nc" id="L1419">					  Literal.POS, m_missing);</span>
	}
<span class="nc bnc" id="L1421" title="All 2 branches missed.">	if (m_negation != NONE) {</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">	  if (individual) {</span>
<span class="nc" id="L1423">	    negation = new IndividualLiteral(predicate, &quot;?&quot;, -1, </span>
<span class="nc" id="L1424">					     Literal.NEG, m_missing, type);</span>
	  } else {
<span class="nc" id="L1426">	    negation = new AttributeValueLiteral(predicate, &quot;?&quot;, -1, </span>
<span class="nc" id="L1427">						 Literal.NEG, m_missing);</span>
	  }
<span class="nc" id="L1429">	  lit.setNegation(negation);</span>
<span class="nc" id="L1430">	  negation.setNegation(lit);</span>
	}
<span class="nc" id="L1432">	predicate.addLiteral(lit);</span>
      }
    }
<span class="nc" id="L1435">    return predicate;</span>
  }
   
  /**
   * Build the predicates to use in the rules.
   *
   * @return the predicates
   * @throws Exception If the predicates could not be built 
   * (numeric attribute).
   */
  private ArrayList buildPredicates() throws Exception {

<span class="nc" id="L1447">    ArrayList predicates = new ArrayList(); /* The result. */</span>
    Predicate predicate;
    Attribute attr;
<span class="nc" id="L1450">    Enumeration attributes = m_instances.enumerateAttributes();</span>
<span class="nc bnc" id="L1451" title="All 2 branches missed.">    boolean individual = (m_parts != null); /* Individual-based learning ? */</span>

    /* Attributes. */
<span class="nc bnc" id="L1454" title="All 2 branches missed.">    while (attributes.hasMoreElements()) {</span>
<span class="nc" id="L1455">      attr = (Attribute) attributes.nextElement();</span>
      /* Identifiers do not appear in rules in individual-based learning. */
<span class="nc bnc" id="L1457" title="All 4 branches missed.">      if (!(individual &amp;&amp; attr.name().equals(&quot;id&quot;))) {</span>
<span class="nc" id="L1458">	predicate = buildPredicate(m_instances, attr, false);</span>
<span class="nc" id="L1459">	predicates.add(predicate);</span>
      }
    }
    /* Class attribute. */
<span class="nc" id="L1463">    attr = m_instances.classAttribute();</span>
    /* Identifiers do not appear in rules. */
<span class="nc bnc" id="L1465" title="All 4 branches missed.">    if (!(individual &amp;&amp; attr.name().equals(&quot;id&quot;))) {</span>
<span class="nc" id="L1466">      predicate = buildPredicate(m_instances, attr, true);</span>
<span class="nc" id="L1467">      predicates.add(predicate);</span>
    }

    /* Attributes of the parts in individual-based learning. */
<span class="nc bnc" id="L1471" title="All 2 branches missed.">    if (individual) {</span>
<span class="nc" id="L1472">      attributes = m_parts.enumerateAttributes();</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">      while (attributes.hasMoreElements()) {</span>
<span class="nc" id="L1474">	attr = (Attribute) attributes.nextElement();</span>
	/* Identifiers do not appear in rules. */
<span class="nc bnc" id="L1476" title="All 2 branches missed.">	if (!attr.name().equals(&quot;id&quot;)) {</span>
<span class="nc" id="L1477">	  predicate = buildPredicate(m_parts, attr, false);</span>
<span class="nc" id="L1478">	  predicates.add(predicate);</span>
	}
      }
    }
	
<span class="nc" id="L1483">    return predicates;</span>
  }

  /**
   * Count the number of distinct confirmation values in the results.
   *
   * @return Number of confirmation values in the results.
   */
  private int numValuesInResult() {

<span class="nc" id="L1493">    int result = 0;</span>
<span class="nc" id="L1494">    SimpleLinkedList.LinkedListIterator iter = m_results.iterator();</span>
    Rule current;
    Rule next;
<span class="nc bnc" id="L1497" title="All 2 branches missed.">    if (!iter.hasNext()) {</span>
<span class="nc" id="L1498">      return result;</span>
    } else {
<span class="nc" id="L1500">      current = (Rule) iter.next();</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">      while (iter.hasNext()) {</span>
<span class="nc" id="L1502">	next = (Rule) iter.next();</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">	if (current.getConfirmation() &gt; next.getConfirmation()) {</span>
<span class="nc" id="L1504">	  result++;</span>
	}
<span class="nc" id="L1506">	current = next;</span>
      }
<span class="nc" id="L1508">      return result + 1;</span>
    }
  }

  /**
   * Test if it is worth refining a rule.
   *
   * @param rule The rule to consider.
   * @return True if the rule can be refined, false otherwise.
   */
  private boolean canRefine(Rule rule) {
<span class="nc bnc" id="L1519" title="All 2 branches missed.">    if (rule.isEmpty()) {</span>
<span class="nc" id="L1520">      return true;</span>
    }
<span class="nc bnc" id="L1522" title="All 2 branches missed.">    if (m_best != 0) {</span>
<span class="nc bnc" id="L1523" title="All 2 branches missed.">      if (numValuesInResult() &lt; m_best) {</span>
<span class="nc" id="L1524">	return true;</span>
      }
<span class="nc" id="L1526">      Rule worstResult = (Rule) m_results.getLast();</span>
<span class="nc bnc" id="L1527" title="All 2 branches missed.">      if (rule.getOptimistic() &gt;= worstResult.getConfirmation()) {</span>
<span class="nc" id="L1528">	return true;</span>
      }
<span class="nc" id="L1530">      return false;</span>
    } else {
<span class="nc" id="L1532">      return true;</span>
    }
  }

  /**
   * Test if it is worth calculating the optimistic estimate of a rule.
   *
   * @param rule The rule to consider.
   * @return True if the optimistic estimate can be calculated, false otherwise.
   */
  private boolean canCalculateOptimistic(Rule rule) {
<span class="nc bnc" id="L1543" title="All 4 branches missed.">    if (rule.hasTrueBody() || rule.hasFalseHead()) {</span>
<span class="nc" id="L1544">      return false;</span>
    }
<span class="nc bnc" id="L1546" title="All 2 branches missed.">    if (!rule.overFrequencyThreshold(m_frequencyThreshold)) {</span>
<span class="nc" id="L1547">      return false;</span>
    }
<span class="nc" id="L1549">    return true;</span>
  }

  /**
   * Test if a rule can be explored (if it is interesting for the results 
   * or for refining).
   *
   * @param rule The rule to consider.
   * @return True if the rule can be explored, false otherwise.
   */
  private boolean canExplore(Rule rule) {
<span class="nc bnc" id="L1560" title="All 2 branches missed.">    if (rule.getOptimistic() &lt; m_confirmationThreshold) {</span>
<span class="nc" id="L1561">      return false;</span>
    }
<span class="nc bnc" id="L1563" title="All 2 branches missed.">    if (m_best != 0) {</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">      if (numValuesInResult() &lt; m_best) {</span>
<span class="nc" id="L1565">	return true;</span>
      }	
<span class="nc" id="L1567">      Rule worstResult = (Rule) m_results.getLast();</span>
<span class="nc bnc" id="L1568" title="All 2 branches missed.">      if (rule.getOptimistic() &gt;= worstResult.getConfirmation()) {</span>
<span class="nc" id="L1569">	return true;</span>
      }
<span class="nc" id="L1571">      return false;      </span>
    } else {
<span class="nc" id="L1573">      return true;</span>
    }
  }    

  /**
   * Test if a rule can be stored in the agenda.
   *
   * @param rule The rule to consider.
   * @return True if the rule can be stored, false otherwise.
   */
  private boolean canStoreInNodes(Rule rule) {
<span class="nc bnc" id="L1584" title="All 2 branches missed.">    if (rule.getObservedNumber() == 0) {</span>
<span class="nc" id="L1585">      return false;</span>
    }
<span class="nc" id="L1587">    return true;</span>
  }

  /**
   * Test if it is worth calculating the confirmation of a rule.
   *
   * @param rule The rule to consider.
   * @return True if the confirmation can be calculated, false otherwise.
   */
  private boolean canCalculateConfirmation(Rule rule) {
<span class="nc bnc" id="L1597" title="All 2 branches missed.">    if (rule.getObservedFrequency() &gt; m_noiseThreshold) {</span>
<span class="nc" id="L1598">      return false;</span>
    }
<span class="nc" id="L1600">    return true;</span>
  }

  /**
   * Test if a rule can be added to the results.
   *
   * @param rule The rule to consider.
   * @return True if the rule can be stored, false otherwise.
   */
  private boolean canStoreInResults(Rule rule) {
<span class="nc bnc" id="L1610" title="All 2 branches missed.">    if (rule.getConfirmation() &lt; m_confirmationThreshold) {</span>
<span class="nc" id="L1611">      return false;</span>
    }
<span class="nc bnc" id="L1613" title="All 2 branches missed.">    if (m_best != 0) {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">      if (numValuesInResult() &lt; m_best) {</span>
<span class="nc" id="L1615">	return true;</span>
      }
<span class="nc" id="L1617">      Rule worstResult = (Rule) m_results.getLast();</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">      if (rule.getConfirmation() &gt;= worstResult.getConfirmation()) {</span>
<span class="nc" id="L1619">	return true;</span>
      }
<span class="nc" id="L1621">      return false;    </span>
    } else {
<span class="nc" id="L1623">      return true;</span>
    }
  }

  /**
   * Add a rule in the appropriate place in the list of the results, 
   * according to the confirmation and 
   * number of counter-instances of the rule. &lt;p&gt;
   * Subsumption tests are performed and the rule may not be added. &lt;p&gt;
   * Previous results may also be removed because of sumption.
   */
  private void addResult(Rule rule) {

    Rule current;
<span class="nc" id="L1637">    boolean added = false;</span>

    /* Iterate the list until we find the right place. */
<span class="nc" id="L1640">    SimpleLinkedList.LinkedListIterator iter = m_results.iterator();</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L1642">      current = (Rule) iter.next();</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">      if (Rule.confirmationThenObservedComparator.compare(current, rule) &gt; 0) {</span>
<span class="nc" id="L1644">	iter.addBefore(rule);</span>
<span class="nc" id="L1645">	added = true;</span>
<span class="nc" id="L1646">	break;</span>
      }
      /* Subsumption tests to see if the rule can be added. */
<span class="nc bnc" id="L1649" title="All 6 branches missed.">      if ((m_subsumption || m_sameClause || m_equivalent)</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">	  &amp;&amp; current.subsumes(rule)) {</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">	if (current.numLiterals() == rule.numLiterals()) {</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">	  if (current.equivalentTo(rule)) {</span>
	    /* Equivalent rules. */
<span class="nc bnc" id="L1654" title="All 2 branches missed.">	    if (m_equivalent) {</span>
<span class="nc" id="L1655">	      return;</span>
	    }
	  } else {
	    /* Same clauses. */
<span class="nc bnc" id="L1659" title="All 2 branches missed.">	    if (m_sameClause</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">		&amp;&amp; Rule.confirmationComparator.compare(current, rule) &lt; 0) {</span>
<span class="nc" id="L1661">	      return;</span>
	    }
	  }
	} else {
	  /* Subsumption. */
<span class="nc bnc" id="L1666" title="All 2 branches missed.">	  if (m_subsumption</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">	      &amp;&amp; Rule.observedComparator.compare(current, rule) &lt;= 0) {	</span>
<span class="nc" id="L1668">	    return;</span>
	  }
	}
      }
    }

<span class="nc bnc" id="L1674" title="All 2 branches missed.">    if (added == false) {</span>
      /* The rule must be added in the end of the results. */
<span class="nc" id="L1676">      m_results.add(rule);</span>
    }

    /* Iterate the results with a lower confirmation 
     *  to see if some of them must be removed. */
<span class="nc" id="L1681">    SimpleLinkedList.LinkedListInverseIterator inverse </span>
<span class="nc" id="L1682">      = m_results.inverseIterator();</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">    while (inverse.hasPrevious()) {</span>
<span class="nc" id="L1684">      current = (Rule) inverse.previous();</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">      if (Rule.confirmationThenObservedComparator.compare(current, rule) &lt; 0) {</span>
<span class="nc" id="L1686">	break;</span>
      }
<span class="nc bnc" id="L1688" title="All 4 branches missed.">      if (current != rule &amp;&amp; rule.subsumes(current)) {</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">	if (current.numLiterals() == rule.numLiterals()) {</span>
<span class="nc bnc" id="L1690" title="All 2 branches missed.">	  if (!current.equivalentTo(rule)) {</span>
	    /* Same clauses. */
<span class="nc bnc" id="L1692" title="All 2 branches missed.">	    if (m_sameClause</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">		&amp;&amp; Rule.confirmationComparator.compare(current, rule) &gt; 0) {</span>
<span class="nc" id="L1694">	      inverse.remove();</span>
	    }
	  }
	} else {
	  /* Subsumption. */
<span class="nc bnc" id="L1699" title="All 2 branches missed.">	  if (m_subsumption</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">	      &amp;&amp; Rule.observedComparator.compare(rule, current) &lt;= 0) {	</span>
<span class="nc" id="L1701">	    inverse.remove();</span>
	  }
	}	
      }
    }

    /* Remove the rules with the worst confirmation value 
     * if there are too many results. */
<span class="nc bnc" id="L1709" title="All 4 branches missed.">    if (m_best != 0 &amp;&amp; numValuesInResult() &gt; m_best) {</span>
<span class="nc" id="L1710">      Rule worstRule = (Rule) m_results.getLast();</span>
<span class="nc" id="L1711">      inverse = m_results.inverseIterator();</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">      while (inverse.hasPrevious()) {</span>
<span class="nc" id="L1713">	current = (Rule) inverse.previous();</span>
<span class="nc bnc" id="L1714" title="All 2 branches missed.">	if (Rule.confirmationComparator.compare(current, worstRule) &lt; 0) {</span>
<span class="nc" id="L1715">	  break;</span>
	}
<span class="nc" id="L1717">	inverse.remove();</span>
      }
    }

    /* Print the new current values. */
<span class="nc" id="L1722">    printValues();</span>
<span class="nc" id="L1723">  }</span>

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="nc" id="L1731">    Capabilities result = super.getCapabilities();</span>
<span class="nc" id="L1732">    result.disableAll();</span>

    // attributes
<span class="nc" id="L1735">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="nc" id="L1736">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="nc" id="L1739">    result.enable(Capability.NO_CLASS);</span>
<span class="nc" id="L1740">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="nc" id="L1741">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
<span class="nc" id="L1743">    return result;</span>
  }
  
  /**
   * Method that launches the search to find the rules with the highest 
   * confirmation.
   *
   * @param instances The instances to be used for generating the rules.
   * @throws Exception if rules can't be built successfully.
   */
  public void buildAssociations(Instances instances) throws Exception {

<span class="nc" id="L1755">    Frame valuesFrame = null; /* Frame to display the current values. */</span>

    /* Initialization of the search. */
<span class="nc bnc" id="L1758" title="All 2 branches missed.">    if (m_parts == null) {</span>
<span class="nc" id="L1759">      m_instances = new Instances(instances);</span>
    } else {
<span class="nc" id="L1761">      m_instances = new IndividualInstances(new Instances(instances), m_parts);</span>
    }    
<span class="nc" id="L1763">    m_results = new SimpleLinkedList();</span>
<span class="nc" id="L1764">    m_hypotheses = 0;</span>
<span class="nc" id="L1765">    m_explored = 0;</span>
<span class="nc" id="L1766">    m_status = NORMAL;</span>

<span class="nc bnc" id="L1768" title="All 2 branches missed.">    if (m_classIndex == -1)</span>
<span class="nc" id="L1769">      m_instances.setClassIndex(m_instances.numAttributes()-1);     </span>
<span class="nc bnc" id="L1770" title="All 4 branches missed.">    else if (m_classIndex &lt; m_instances.numAttributes() &amp;&amp; m_classIndex &gt;= 0)</span>
<span class="nc" id="L1771">      m_instances.setClassIndex(m_classIndex);</span>
    else
<span class="nc" id="L1773">      throw new Exception(&quot;Invalid class index.&quot;);</span>
    
    // can associator handle the data?
<span class="nc" id="L1776">    getCapabilities().testWithFail(m_instances);</span>
    
    /* Initialization of the window for current values. */
<span class="nc bnc" id="L1779" title="All 2 branches missed.">    if (m_printValues == WINDOW) {</span>
<span class="nc" id="L1780">      m_valuesText = new TextField(37);</span>
<span class="nc" id="L1781">      m_valuesText.setEditable(false);</span>
<span class="nc" id="L1782">      m_valuesText.setFont(new Font(&quot;Monospaced&quot;, Font.PLAIN, 12));    </span>
<span class="nc" id="L1783">      Label valuesLabel = new Label(&quot;Best and worst current values:&quot;);</span>
<span class="nc" id="L1784">      Button stop = new Button(&quot;Stop search&quot;);</span>
<span class="nc" id="L1785">      stop.addActionListener(new ActionListener() {</span>
	  public void actionPerformed(ActionEvent e) {
	    /* Signal the interruption to the search. */
<span class="nc" id="L1788">	    m_status = STOP;</span>
<span class="nc" id="L1789">	  }</span>
	});
<span class="nc" id="L1791">      valuesFrame = new Frame(&quot;Tertius status&quot;);</span>
<span class="nc" id="L1792">      valuesFrame.setResizable(false);</span>
<span class="nc" id="L1793">      valuesFrame.add(m_valuesText, BorderLayout.CENTER);</span>
<span class="nc" id="L1794">      valuesFrame.add(stop, BorderLayout.SOUTH);</span>
<span class="nc" id="L1795">      valuesFrame.add(valuesLabel, BorderLayout.NORTH);</span>
<span class="nc" id="L1796">      valuesFrame.pack();</span>
<span class="nc" id="L1797">      valuesFrame.setVisible(true);</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">    } else if (m_printValues == OUT) {</span>
<span class="nc" id="L1799">      System.out.println(&quot;Best and worst current values:&quot;);</span>
    }
      
<span class="nc" id="L1802">    Date start = new Date();</span>

    /* Build the predicates and launch the search. */
<span class="nc" id="L1805">    m_predicates = buildPredicates();</span>
<span class="nc" id="L1806">    beginSearch();    </span>

<span class="nc" id="L1808">    Date end = new Date();</span>

<span class="nc bnc" id="L1810" title="All 2 branches missed.">    if (m_printValues == WINDOW) {</span>
<span class="nc" id="L1811">      valuesFrame.dispose();</span>
    }

<span class="nc" id="L1814">    m_time = new Date(end.getTime() - start.getTime());</span>
<span class="nc" id="L1815">  }</span>

  /**
   * Run the search.
   */
  public void run() {
    try {
<span class="nc" id="L1822">      search();</span>
<span class="nc" id="L1823">    } catch (OutOfMemoryError e) {</span>
      /* Garbage collect what can be collected to be able to continue. */
<span class="nc" id="L1825">      System.gc();</span>
<span class="nc" id="L1826">      m_status = MEMORY;</span>
    }
<span class="nc" id="L1828">    endSearch();</span>
<span class="nc" id="L1829">  }</span>

  /**
   * Begin the search by starting a new thread.
   */
  private synchronized void beginSearch() throws Exception {
    /* This method must be synchronized to be able to 
     * call the wait() method. */
<span class="nc" id="L1837">    Thread search = new Thread(this);</span>
<span class="nc" id="L1838">    search.start();</span>
    try {
      /* Wait for the end of the thread. */
<span class="nc" id="L1841">      wait();</span>
<span class="nc" id="L1842">    } catch (InterruptedException e) {</span>
      /* Signal the interruption to the search. */
<span class="nc" id="L1844">      m_status = STOP;</span>
    }
<span class="nc" id="L1846">  }</span>

  /**
   * End the search by notifying to the waiting thread that it is finished.
   */
  private synchronized void endSearch() {
    /* This method must be synchronized to be able to
     * call the notify() method. */
<span class="nc" id="L1854">    notify();</span>
<span class="nc" id="L1855">  }</span>

  /**
   * Search in the space of hypotheses the rules that have the highest 
   * confirmation.
   * The search starts with the empty rule, other rules are generated by 
   * refinement.
   */
  public void search() {

<span class="nc" id="L1865">    SimpleLinkedList nodes = new SimpleLinkedList(); /* The agenda. */</span>
    Rule currentNode;
    SimpleLinkedList children;
    SimpleLinkedList.LinkedListIterator iter;
    Rule child;
<span class="nc bnc" id="L1870" title="All 4 branches missed.">    boolean negBody = (m_negation == BODY || m_negation == ALL);</span>
<span class="nc bnc" id="L1871" title="All 4 branches missed.">    boolean negHead = (m_negation == HEAD || m_negation == ALL);</span>

    /* Start with the empty rule. */
<span class="nc" id="L1874">      nodes.add(new Rule(m_repeat, m_numLiterals, negBody, negHead,</span>
<span class="nc" id="L1875">			 m_classification, m_horn));</span>
    
    /* Print the current values. */
<span class="nc" id="L1878">    printValues();</span>

    /* Explore the rules in the agenda. */
<span class="nc bnc" id="L1881" title="All 4 branches missed.">    while (m_status != STOP &amp;&amp; !nodes.isEmpty()) {</span>
<span class="nc" id="L1882">      currentNode = (Rule) nodes.removeFirst();</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">      if (canRefine(currentNode)) {</span>
<span class="nc" id="L1884">	children = currentNode.refine(m_predicates);</span>
<span class="nc" id="L1885">	iter = children.iterator();</span>
	/* Calculate the optimistic estimate of the children and 
	 * consider them for adding to the agenda and to the results. */
<span class="nc bnc" id="L1888" title="All 2 branches missed.">	while (iter.hasNext()) {</span>
<span class="nc" id="L1889">	  m_hypotheses++;</span>
<span class="nc" id="L1890">	  child = (Rule) iter.next();</span>
<span class="nc" id="L1891">	  child.upDate(m_instances);</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">	  if (canCalculateOptimistic(child)) {</span>
<span class="nc" id="L1893">	    child.calculateOptimistic();</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">	    if (canExplore(child)) {</span>
<span class="nc" id="L1895">	      m_explored++;</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">	      if (canStoreInNodes(child)) {</span>
	      } else {
<span class="nc" id="L1898">		iter.remove();</span>
	      }
<span class="nc bnc" id="L1900" title="All 2 branches missed.">	      if (canCalculateConfirmation(child)) {</span>
<span class="nc" id="L1901">		child.calculateConfirmation();</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">		if (canStoreInResults(child)) {</span>
<span class="nc" id="L1903">		  addResult(child);</span>
		}	  
	      }
	    } else {
<span class="nc" id="L1907">	      iter.remove();</span>
	    }
	  } else {
<span class="nc" id="L1910">	    iter.remove();</span>
	  }
	}
	/* Since the agenda is already sorted it is more efficient
	 * to sort the children only and then merge. */
<span class="nc" id="L1915">	children.sort(Rule.optimisticThenObservedComparator);</span>
<span class="nc" id="L1916">	nodes.merge(children, Rule.optimisticThenObservedComparator);</span>
      } else {
	/* The agenda being sorted, it is not worth considering the following 
	 * nodes. */
	break;
      }
    }
<span class="nc" id="L1923">  }</span>

  /**
   * returns the results
   * 
   * @return		the results
   */
  public SimpleLinkedList getResults() {
<span class="nc" id="L1931">    return m_results;</span>
  }

  /**
   * Print the current best and worst values. 
   */
  private void printValues() {

<span class="nc bnc" id="L1939" title="All 2 branches missed.">    if (m_printValues == NO) {</span>
<span class="nc" id="L1940">      return;</span>
    } else {
<span class="nc bnc" id="L1942" title="All 2 branches missed.">      if (m_results.isEmpty()) {</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">	if (m_printValues == OUT) {</span>
<span class="nc" id="L1944">	  System.out.print(&quot;0.000000 0.000000 - 0.000000 0.000000&quot;);</span>
	} else { //m_printValues == WINDOW
<span class="nc" id="L1946">	  m_valuesText.setText(&quot;0.000000 0.000000 - 0.000000 0.000000&quot;);</span>
	}
      } else {
<span class="nc" id="L1949">	Rule best = (Rule) m_results.getFirst();</span>
<span class="nc" id="L1950">	Rule worst = (Rule) m_results.getLast();</span>
<span class="nc" id="L1951">	String values = best.valuesToString() + &quot; - &quot; + worst.valuesToString();</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">	if (m_printValues == OUT) {</span>
<span class="nc" id="L1953">	  System.out.print(&quot;\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b&quot;</span>
			   + &quot;\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b&quot;);
<span class="nc" id="L1955">	  System.out.print(values);</span>
	} else { //m_printValues == WINDOW
<span class="nc" id="L1957">	  m_valuesText.setText(values);</span>
	}
      }
    }
<span class="nc" id="L1961">  }</span>

  /**
   * Outputs the best rules found with their confirmation value and number 
   * of counter-instances.
   * Also gives the number of hypotheses considered and explored, and the 
   * time needed. 
   */
  public String toString() {

<span class="nc" id="L1971">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L1972">    SimpleLinkedList.LinkedListIterator iter = m_results.iterator();</span>
<span class="nc" id="L1973">    int size = m_results.size();</span>
<span class="nc" id="L1974">    int i = 0;</span>

<span class="nc" id="L1976">    text.append(&quot;\nTertius\n=======\n\n&quot;);</span>

<span class="nc bnc" id="L1978" title="All 2 branches missed.">    while (iter.hasNext()) {</span>
<span class="nc" id="L1979">      Rule current = (Rule) iter.next();</span>
<span class="nc" id="L1980">      text.append(Utils.doubleToString((double) i + 1,</span>
<span class="nc" id="L1981">				       (int) (Math.log(size) </span>
<span class="nc" id="L1982">					      / Math.log(10) + 1),</span>
<span class="nc" id="L1983">				       0)</span>
<span class="nc" id="L1984">		  + &quot;. &quot;);</span>
<span class="nc" id="L1985">      text.append(&quot;/* &quot;);</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">      if (m_roc) {</span>
<span class="nc" id="L1987">	text.append(current.rocToString());</span>
      } else {
<span class="nc" id="L1989">	text.append(current.valuesToString());</span>
      }
<span class="nc" id="L1991">      text.append(&quot; */ &quot;);</span>
<span class="nc" id="L1992">      text.append(current.toString());</span>
<span class="nc" id="L1993">      text.append(&quot;\n&quot;);</span>
<span class="nc" id="L1994">      i++;</span>
    }
 
<span class="nc" id="L1997">    text.append(&quot;\nNumber of hypotheses considered: &quot; + m_hypotheses);</span>
<span class="nc" id="L1998">    text.append(&quot;\nNumber of hypotheses explored: &quot; + m_explored);</span>

<span class="nc bnc" id="L2000" title="All 2 branches missed.">    if (m_status == MEMORY) {</span>
<span class="nc" id="L2001">      text.append(&quot;\n\nNot enough memory to continue the search&quot;);</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">    } else if (m_status == STOP) {</span>
<span class="nc" id="L2003">      text.append(&quot;\n\nSearch interrupted&quot;);</span>
    }

<span class="nc" id="L2006">    return text.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L2015">    return RevisionUtils.extract(&quot;$Revision: 6368 $&quot;);</span>
  }

  /**
   * Main method.
   * 
   * @param args the commandline parameters
   */
  public static void main(String [] args) {
<span class="nc" id="L2024">    runAssociator(new Tertius(), args);</span>
<span class="nc" id="L2025">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>