<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Discretize.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.filters.supervised.attribute</a> &gt; <span class="el_source">Discretize.java</span></div><h1>Discretize.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    Discretize.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */


package weka.filters.supervised.attribute;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.ContingencyTables;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.ProtectedProperties;
import weka.core.Range;
import weka.core.RevisionUtils;
import weka.core.SparseInstance;
import weka.core.SpecialFunctions;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.SupervisedFilter;

import java.util.Enumeration;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * An instance filter that discretizes a range of numeric attributes in the dataset into nominal attributes. Discretization is by Fayyad &amp;amp; Irani's MDL method (the default).&lt;br/&gt;
 * &lt;br/&gt;
 * For more information, see:&lt;br/&gt;
 * &lt;br/&gt;
 * Usama M. Fayyad, Keki B. Irani: Multi-interval discretization of continuousvalued attributes for classification learning. In: Thirteenth International Joint Conference on Articial Intelligence, 1022-1027, 1993.&lt;br/&gt;
 * &lt;br/&gt;
 * Igor Kononenko: On Biases in Estimating Multi-Valued Attributes. In: 14th International Joint Conference on Articial Intelligence, 1034-1040, 1995.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Fayyad1993,
 *    author = {Usama M. Fayyad and Keki B. Irani},
 *    booktitle = {Thirteenth International Joint Conference on Articial Intelligence},
 *    pages = {1022-1027},
 *    publisher = {Morgan Kaufmann Publishers},
 *    title = {Multi-interval discretization of continuousvalued attributes for classification learning},
 *    volume = {2},
 *    year = {1993}
 * }
 * 
 * &amp;#64;inproceedings{Kononenko1995,
 *    author = {Igor Kononenko},
 *    booktitle = {14th International Joint Conference on Articial Intelligence},
 *    pages = {1034-1040},
 *    title = {On Biases in Estimating Multi-Valued Attributes},
 *    year = {1995},
 *    PS = {http://ai.fri.uni-lj.si/papers/kononenko95-ijcai.ps.gz}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;col1,col2-col4,...&amp;gt;
 *  Specifies list of columns to Discretize. First and last are valid indexes.
 *  (default none)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V
 *  Invert matching sense of column indexes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  Output binary attributes for discretized attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E
 *  Use better encoding of split point for MDL.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -K
 *  Use Kononenko's MDL criterion.&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Len Trigg (trigg@cs.waikato.ac.nz)
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @version $Revision: 9090 $
 */
public class Discretize 
  extends Filter 
  implements SupervisedFilter, OptionHandler, WeightedInstancesHandler, 
  	     TechnicalInformationHandler {
  
  /** for serialization */
  static final long serialVersionUID = -3141006402280129097L;

  /** Stores which columns to Discretize */
<span class="fc" id="L123">  protected Range m_DiscretizeCols = new Range();</span>

  /** Store the current cutpoints */
<span class="fc" id="L126">  protected double [][] m_CutPoints = null;</span>

  /** Output binary attributes for discretized attributes. */
<span class="fc" id="L129">  protected boolean m_MakeBinary = false;</span>

  /** Use better encoding of split point for MDL. */
<span class="fc" id="L132">  protected boolean m_UseBetterEncoding = false;</span>

  /** Use Kononenko's MDL criterion instead of Fayyad et al.'s */
<span class="fc" id="L135">  protected boolean m_UseKononenko = false;</span>

  /** Constructor - initialises the filter */
<span class="fc" id="L138">  public Discretize() {</span>

<span class="fc" id="L140">    setAttributeIndices(&quot;first-last&quot;);</span>
<span class="fc" id="L141">  }</span>


  /**
   * Gets an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {

<span class="nc" id="L151">    Vector newVector = new Vector(7);</span>

<span class="nc" id="L153">    newVector.addElement(new Option(</span>
<span class="nc" id="L154">              &quot;\tSpecifies list of columns to Discretize. First&quot;</span>
	      + &quot; and last are valid indexes.\n&quot;
	      + &quot;\t(default none)&quot;,
<span class="nc" id="L157">              &quot;R&quot;, 1, &quot;-R &lt;col1,col2-col4,...&gt;&quot;));</span>

<span class="nc" id="L159">    newVector.addElement(new Option(</span>
<span class="nc" id="L160">              &quot;\tInvert matching sense of column indexes.&quot;,</span>
<span class="nc" id="L161">              &quot;V&quot;, 0, &quot;-V&quot;));</span>

<span class="nc" id="L163">    newVector.addElement(new Option(</span>
<span class="nc" id="L164">              &quot;\tOutput binary attributes for discretized attributes.&quot;,</span>
<span class="nc" id="L165">              &quot;D&quot;, 0, &quot;-D&quot;));</span>

<span class="nc" id="L167">    newVector.addElement(new Option(</span>
<span class="nc" id="L168">              &quot;\tUse better encoding of split point for MDL.&quot;,</span>
<span class="nc" id="L169">              &quot;E&quot;, 0, &quot;-E&quot;));</span>

<span class="nc" id="L171">    newVector.addElement(new Option(</span>
<span class="nc" id="L172">              &quot;\tUse Kononenko's MDL criterion.&quot;,</span>
<span class="nc" id="L173">              &quot;K&quot;, 0, &quot;-K&quot;));</span>

<span class="nc" id="L175">    return newVector.elements();</span>
  }


  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;col1,col2-col4,...&amp;gt;
   *  Specifies list of columns to Discretize. First and last are valid indexes.
   *  (default none)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -V
   *  Invert matching sense of column indexes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  Output binary attributes for discretized attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E
   *  Use better encoding of split point for MDL.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -K
   *  Use Kononenko's MDL criterion.&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {

<span class="fc" id="L208">    setMakeBinary(Utils.getFlag('D', options));</span>
<span class="fc" id="L209">    setUseBetterEncoding(Utils.getFlag('E', options));</span>
<span class="fc" id="L210">    setUseKononenko(Utils.getFlag('K', options));</span>
<span class="fc" id="L211">    setInvertSelection(Utils.getFlag('V', options));</span>
    
<span class="fc" id="L213">    String convertList = Utils.getOption('R', options);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">    if (convertList.length() != 0) {</span>
<span class="fc" id="L215">      setAttributeIndices(convertList);</span>
    } else {
<span class="nc" id="L217">      setAttributeIndices(&quot;first-last&quot;);</span>
    }

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (getInputFormat() != null) {</span>
<span class="nc" id="L221">      setInputFormat(getInputFormat());</span>
    }
<span class="fc" id="L223">  }</span>
  /**
   * Gets the current settings of the filter.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {

<span class="fc" id="L231">    String [] options = new String [12];</span>
<span class="fc" id="L232">    int current = 0;</span>

<span class="pc bpc" id="L234" title="1 of 2 branches missed.">    if (getMakeBinary()) {</span>
<span class="nc" id="L235">      options[current++] = &quot;-D&quot;;</span>
    }
<span class="fc bfc" id="L237" title="All 2 branches covered.">    if (getUseBetterEncoding()) {</span>
<span class="fc" id="L238">      options[current++] = &quot;-E&quot;;</span>
    }
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (getUseKononenko()) {</span>
<span class="nc" id="L241">      options[current++] = &quot;-K&quot;;</span>
    }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">    if (getInvertSelection()) {</span>
<span class="nc" id="L244">      options[current++] = &quot;-V&quot;;</span>
    }
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">    if (!getAttributeIndices().equals(&quot;&quot;)) {</span>
<span class="fc" id="L247">      options[current++] = &quot;-R&quot;; options[current++] = getAttributeIndices();</span>
    }
<span class="fc bfc" id="L249" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L250">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L252">    return options;</span>
  }

  /** 
   * Returns the Capabilities of this filter.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L262">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L263">    result.disableAll();</span>

    // attributes
<span class="fc" id="L266">    result.enableAllAttributes();</span>
<span class="fc" id="L267">    result.enable(Capability.MISSING_VALUES);</span>
    
    // class
<span class="fc" id="L270">    result.enable(Capability.NOMINAL_CLASS);</span>
    
<span class="fc" id="L272">    return result;</span>
  }

  /**
   * Sets the format of the input instances.
   *
   * @param instanceInfo an Instances object containing the input instance
   * structure (any instances contained in the object are ignored - only the
   * structure is required).
   * @return true if the outputFormat may be collected immediately
   * @throws Exception if the input format can't be set successfully
   */
  public boolean setInputFormat(Instances instanceInfo) throws Exception {

<span class="fc" id="L286">    super.setInputFormat(instanceInfo);</span>

<span class="fc" id="L288">    m_DiscretizeCols.setUpper(instanceInfo.numAttributes() - 1);</span>
<span class="fc" id="L289">    m_CutPoints = null;</span>
    
    // If we implement loading cutfiles, then load 
    //them here and set the output format
<span class="fc" id="L293">    return false;</span>
  }

  

  /**
   * Input an instance for filtering. Ordinarily the instance is processed
   * and made available for output immediately. Some filters require all
   * instances be read before producing output.
   *
   * @param instance the input instance
   * @return true if the filtered instance may now be
   * collected with output().
   * @throws IllegalStateException if no input format has been defined.
   */
  public boolean input(Instance instance) {

<span class="pc bpc" id="L310" title="1 of 2 branches missed.">    if (getInputFormat() == null) {</span>
<span class="nc" id="L311">      throw new IllegalStateException(&quot;No input instance format defined&quot;);</span>
    }
<span class="fc bfc" id="L313" title="All 2 branches covered.">    if (m_NewBatch) {</span>
<span class="fc" id="L314">      resetQueue();</span>
<span class="fc" id="L315">      m_NewBatch = false;</span>
    }
    
<span class="fc bfc" id="L318" title="All 2 branches covered.">    if (m_CutPoints != null) {</span>
<span class="fc" id="L319">      convertInstance(instance);</span>
<span class="fc" id="L320">      return true;</span>
    }

<span class="fc" id="L323">    bufferInput(instance);</span>
<span class="fc" id="L324">    return false;</span>
  }


  /**
   * Signifies that this batch of input to the filter is finished. If the 
   * filter requires all instances prior to filtering, output() may now 
   * be called to retrieve the filtered instances.
   *
   * @return true if there are instances pending output
   * @throws IllegalStateException if no input structure has been defined
   */
  public boolean batchFinished() {

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">    if (getInputFormat() == null) {</span>
<span class="nc" id="L339">      throw new IllegalStateException(&quot;No input instance format defined&quot;);</span>
    }
<span class="fc bfc" id="L341" title="All 2 branches covered.">    if (m_CutPoints == null) {</span>
<span class="fc" id="L342">      calculateCutPoints();</span>

<span class="fc" id="L344">      setOutputFormat();</span>

      // If we implement saving cutfiles, save the cuts here

      // Convert pending input instances
<span class="fc bfc" id="L349" title="All 2 branches covered.">      for(int i = 0; i &lt; getInputFormat().numInstances(); i++) {</span>
<span class="fc" id="L350">	convertInstance(getInputFormat().instance(i));</span>
      }
    } 
<span class="fc" id="L353">    flushInput();</span>

<span class="fc" id="L355">    m_NewBatch = true;</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">    return (numPendingOutput() != 0);</span>
  }

  /**
   * Returns a string describing this filter
   *
   * @return a description of the filter suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {

<span class="nc" id="L367">    return &quot;An instance filter that discretizes a range of numeric&quot;</span>
      + &quot; attributes in the dataset into nominal attributes.&quot;
      + &quot; Discretization is by Fayyad &amp; Irani's MDL method (the default).\n\n&quot;
      + &quot;For more information, see:\n\n&quot;
<span class="nc" id="L371">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    TechnicalInformation 	additional;
    
<span class="nc" id="L385">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L386">    result.setValue(Field.AUTHOR, &quot;Usama M. Fayyad and Keki B. Irani&quot;);</span>
<span class="nc" id="L387">    result.setValue(Field.TITLE, &quot;Multi-interval discretization of continuousvalued attributes for classification learning&quot;);</span>
<span class="nc" id="L388">    result.setValue(Field.BOOKTITLE, &quot;Thirteenth International Joint Conference on Articial Intelligence&quot;);</span>
<span class="nc" id="L389">    result.setValue(Field.YEAR, &quot;1993&quot;);</span>
<span class="nc" id="L390">    result.setValue(Field.VOLUME, &quot;2&quot;);</span>
<span class="nc" id="L391">    result.setValue(Field.PAGES, &quot;1022-1027&quot;);</span>
<span class="nc" id="L392">    result.setValue(Field.PUBLISHER, &quot;Morgan Kaufmann Publishers&quot;);</span>
    
<span class="nc" id="L394">    additional = result.add(Type.INPROCEEDINGS);</span>
<span class="nc" id="L395">    additional.setValue(Field.AUTHOR, &quot;Igor Kononenko&quot;);</span>
<span class="nc" id="L396">    additional.setValue(Field.TITLE, &quot;On Biases in Estimating Multi-Valued Attributes&quot;);</span>
<span class="nc" id="L397">    additional.setValue(Field.BOOKTITLE, &quot;14th International Joint Conference on Articial Intelligence&quot;);</span>
<span class="nc" id="L398">    additional.setValue(Field.YEAR, &quot;1995&quot;);</span>
<span class="nc" id="L399">    additional.setValue(Field.PAGES, &quot;1034-1040&quot;);</span>
<span class="nc" id="L400">    additional.setValue(Field.PS, &quot;http://ai.fri.uni-lj.si/papers/kononenko95-ijcai.ps.gz&quot;);</span>
    
<span class="nc" id="L402">    return result;</span>
  }
  
  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String makeBinaryTipText() {

<span class="nc" id="L413">    return &quot;Make resulting attributes binary.&quot;;</span>
  }

  /**
   * Gets whether binary attributes should be made for discretized ones.
   *
   * @return true if attributes will be binarized
   */
  public boolean getMakeBinary() {

<span class="fc" id="L423">    return m_MakeBinary;</span>
  }

  /** 
   * Sets whether binary attributes should be made for discretized ones.
   *
   * @param makeBinary if binary attributes are to be made
   */
  public void setMakeBinary(boolean makeBinary) {

<span class="fc" id="L433">    m_MakeBinary = makeBinary;</span>
<span class="fc" id="L434">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useKononenkoTipText() {

<span class="nc" id="L444">    return &quot;Use Kononenko's MDL criterion. If set to false&quot;</span>
      + &quot; uses the Fayyad &amp; Irani criterion.&quot;;
  }
  
  /**
   * Gets whether Kononenko's MDL criterion is to be used.
   *
   * @return true if Kononenko's criterion will be used.
   */
  public boolean getUseKononenko() {

<span class="fc" id="L455">    return m_UseKononenko;</span>
  }

  /** 
   * Sets whether Kononenko's MDL criterion is to be used.
   *
   * @param useKon true if Kononenko's one is to be used
   */
  public void setUseKononenko(boolean useKon) {

<span class="fc" id="L465">    m_UseKononenko = useKon;</span>
<span class="fc" id="L466">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String useBetterEncodingTipText() {

<span class="nc" id="L476">    return &quot;Uses a more efficient split point encoding.&quot;;</span>
  }

  /**
   * Gets whether better encoding is to be used for MDL.
   *
   * @return true if the better MDL encoding will be used
   */
  public boolean getUseBetterEncoding() {

<span class="fc" id="L486">    return m_UseBetterEncoding;</span>
  }

  /** 
   * Sets whether better encoding is to be used for MDL.
   *
   * @param useBetterEncoding true if better encoding to be used.
   */
  public void setUseBetterEncoding(boolean useBetterEncoding) {

<span class="fc" id="L496">    m_UseBetterEncoding = useBetterEncoding;</span>
<span class="fc" id="L497">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String invertSelectionTipText() {

<span class="nc" id="L507">    return &quot;Set attribute selection mode. If false, only selected&quot;</span>
      + &quot; (numeric) attributes in the range will be discretized; if&quot;
      + &quot; true, only non-selected attributes will be discretized.&quot;;
  }

  /**
   * Gets whether the supplied columns are to be removed or kept
   *
   * @return true if the supplied columns will be kept
   */
  public boolean getInvertSelection() {

<span class="fc" id="L519">    return m_DiscretizeCols.getInvert();</span>
  }

  /**
   * Sets whether selected columns should be removed or kept. If true the 
   * selected columns are kept and unselected columns are deleted. If false
   * selected columns are deleted and unselected columns are kept.
   *
   * @param invert the new invert setting
   */
  public void setInvertSelection(boolean invert) {

<span class="fc" id="L531">    m_DiscretizeCols.setInvert(invert);</span>
<span class="fc" id="L532">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String attributeIndicesTipText() {
<span class="nc" id="L541">    return &quot;Specify range of attributes to act on.&quot;</span>
      + &quot; This is a comma separated list of attribute indices, with&quot;
      + &quot; \&quot;first\&quot; and \&quot;last\&quot; valid values. Specify an inclusive&quot;
      + &quot; range with \&quot;-\&quot;. E.g: \&quot;first-3,5,6-10,last\&quot;.&quot;;
  }

  /**
   * Gets the current range selection
   *
   * @return a string containing a comma separated list of ranges
   */
  public String getAttributeIndices() {

<span class="fc" id="L554">    return m_DiscretizeCols.getRanges();</span>
  }

  /**
   * Sets which attributes are to be Discretized (only numeric
   * attributes among the selection will be Discretized).
   *
   * @param rangeList a string representing the list of attributes. Since
   * the string will typically come from a user, attributes are indexed from
   * 1. &lt;br&gt;
   * eg: first-3,5,6-last
   * @throws IllegalArgumentException if an invalid range list is supplied 
   */
  public void setAttributeIndices(String rangeList) {

<span class="fc" id="L569">    m_DiscretizeCols.setRanges(rangeList);</span>
<span class="fc" id="L570">  }</span>

  /**
   * Sets which attributes are to be Discretized (only numeric
   * attributes among the selection will be Discretized).
   *
   * @param attributes an array containing indexes of attributes to Discretize.
   * Since the array will typically come from a program, attributes are indexed
   * from 0.
   * @throws IllegalArgumentException if an invalid set of ranges
   * is supplied 
   */
  public void setAttributeIndicesArray(int [] attributes) {

<span class="nc" id="L584">    setAttributeIndices(Range.indicesToRangeList(attributes));</span>
<span class="nc" id="L585">  }</span>

  /**
   * Gets the cut points for an attribute
   *
   * @param attributeIndex the index (from 0) of the attribute to get the cut points of
   * @return an array containing the cutpoints (or null if the
   * attribute requested isn't being Discretized
   */
  public double [] getCutPoints(int attributeIndex) {

<span class="nc bnc" id="L596" title="All 2 branches missed.">    if (m_CutPoints == null) {</span>
<span class="nc" id="L597">      return null;</span>
    }
<span class="nc" id="L599">    return m_CutPoints[attributeIndex];</span>
  }

  /** Generate the cutpoints for each attribute */
  protected void calculateCutPoints() {

<span class="fc" id="L605">    Instances copy = null;</span>

<span class="fc" id="L607">    m_CutPoints = new double [getInputFormat().numAttributes()] [];</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">    for(int i = getInputFormat().numAttributes() - 1; i &gt;= 0; i--) {</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">      if ((m_DiscretizeCols.isInRange(i)) &amp;&amp; </span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">	  (getInputFormat().attribute(i).isNumeric())) {</span>

	// Use copy to preserve order
<span class="fc bfc" id="L613" title="All 2 branches covered.">	if (copy == null) {</span>
<span class="fc" id="L614">	  copy = new Instances(getInputFormat());</span>
	}
<span class="fc" id="L616">	calculateCutPointsByMDL(i, copy);</span>
      }
    }
<span class="fc" id="L619">  }</span>

  /**
   * Set cutpoints for a single attribute using MDL.
   *
   * @param index the index of the attribute to set cutpoints for
   * @param data the data to work with
   */
  protected void calculateCutPointsByMDL(int index,
					 Instances data) {

    // Sort instances
<span class="fc" id="L631">    data.sort(data.attribute(index));</span>

    // Find first instances that's missing
<span class="fc" id="L634">    int firstMissing = data.numInstances();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">      if (data.instance(i).isMissing(index)) {</span>
<span class="fc" id="L637">        firstMissing = i;</span>
<span class="fc" id="L638">        break;</span>
      }
    }
<span class="fc" id="L641">    m_CutPoints[index] = cutPointsForSubset(data, index, 0, firstMissing);</span>
<span class="fc" id="L642">  }</span>

  /** 
   * Test using Kononenko's MDL criterion.
   * 
   * @param priorCounts
   * @param bestCounts
   * @param numInstances
   * @param numCutPoints
   * @return true if the split is acceptable
   */
  private boolean KononenkosMDL(double[] priorCounts,
				double[][] bestCounts,
				double numInstances,
				int numCutPoints) {

<span class="nc" id="L658">    double distPrior, instPrior, distAfter = 0, sum, instAfter = 0;</span>
    double before, after;
    int numClassesTotal;

    // Number of classes occuring in the set
<span class="nc" id="L663">    numClassesTotal = 0;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">    for (int i = 0; i &lt; priorCounts.length; i++) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">      if (priorCounts[i] &gt; 0) {</span>
<span class="nc" id="L666">	numClassesTotal++;</span>
      }
    }

    // Encode distribution prior to split
<span class="nc" id="L671">    distPrior = SpecialFunctions.log2Binomial(numInstances </span>
<span class="nc" id="L672">					      + numClassesTotal - 1,</span>
<span class="nc" id="L673">					      numClassesTotal - 1);</span>

    // Encode instances prior to split.
<span class="nc" id="L676">    instPrior = SpecialFunctions.log2Multinomial(numInstances,</span>
<span class="nc" id="L677">						 priorCounts);</span>

<span class="nc" id="L679">    before = instPrior + distPrior;</span>

    // Encode distributions and instances after split.
<span class="nc bnc" id="L682" title="All 2 branches missed.">    for (int i = 0; i &lt; bestCounts.length; i++) {</span>
<span class="nc" id="L683">      sum = Utils.sum(bestCounts[i]);</span>
<span class="nc" id="L684">      distAfter += SpecialFunctions.log2Binomial(sum + numClassesTotal - 1,</span>
<span class="nc" id="L685">						 numClassesTotal - 1);</span>
<span class="nc" id="L686">      instAfter += SpecialFunctions.log2Multinomial(sum,</span>
<span class="nc" id="L687">						    bestCounts[i]);</span>
    }

    // Coding cost after split
<span class="nc" id="L691">    after = Utils.log2(numCutPoints) + distAfter + instAfter;</span>

    // Check if split is to be accepted
<span class="nc bnc" id="L694" title="All 2 branches missed.">    return (before &gt; after);</span>
  }


  /** 
   * Test using Fayyad and Irani's MDL criterion.
   * 
   * @param priorCounts
   * @param bestCounts
   * @param numInstances
   * @param numCutPoints
   * @return true if the splits is acceptable
   */
  private boolean FayyadAndIranisMDL(double[] priorCounts,
				     double[][] bestCounts,
				     double numInstances,
				     int numCutPoints) {

    double priorEntropy, entropy, gain; 
    double entropyLeft, entropyRight, delta;
    int numClassesTotal, numClassesRight, numClassesLeft;

    // Compute entropy before split.
<span class="fc" id="L717">    priorEntropy = ContingencyTables.entropy(priorCounts);</span>

    // Compute entropy after split.
<span class="fc" id="L720">    entropy = ContingencyTables.entropyConditionedOnRows(bestCounts);</span>

    // Compute information gain.
<span class="fc" id="L723">    gain = priorEntropy - entropy;</span>

    // Number of classes occuring in the set
<span class="fc" id="L726">    numClassesTotal = 0;</span>
<span class="fc bfc" id="L727" title="All 2 branches covered.">    for (int i = 0; i &lt; priorCounts.length; i++) {</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">      if (priorCounts[i] &gt; 0) {</span>
<span class="fc" id="L729">	numClassesTotal++;</span>
      }
    }

    // Number of classes occuring in the left subset
<span class="fc" id="L734">    numClassesLeft = 0;</span>
<span class="fc bfc" id="L735" title="All 2 branches covered.">    for (int i = 0; i &lt; bestCounts[0].length; i++) {</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">      if (bestCounts[0][i] &gt; 0) {</span>
<span class="fc" id="L737">	numClassesLeft++;</span>
      }
    }

    // Number of classes occuring in the right subset
<span class="fc" id="L742">    numClassesRight = 0;</span>
<span class="fc bfc" id="L743" title="All 2 branches covered.">    for (int i = 0; i &lt; bestCounts[1].length; i++) {</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">      if (bestCounts[1][i] &gt; 0) {</span>
<span class="fc" id="L745">	numClassesRight++;</span>
      }
    }

    // Entropy of the left and the right subsets
<span class="fc" id="L750">    entropyLeft = ContingencyTables.entropy(bestCounts[0]);</span>
<span class="fc" id="L751">    entropyRight = ContingencyTables.entropy(bestCounts[1]);</span>

    // Compute terms for MDL formula
<span class="fc" id="L754">    delta = Utils.log2(Math.pow(3, numClassesTotal) - 2) - </span>
<span class="fc" id="L755">      (((double) numClassesTotal * priorEntropy) - </span>
<span class="fc" id="L756">       (numClassesRight * entropyRight) - </span>
<span class="fc" id="L757">       (numClassesLeft * entropyLeft));</span>

    // Check if split is to be accepted
<span class="fc bfc" id="L760" title="All 2 branches covered.">    return (gain &gt; (Utils.log2(numCutPoints) + delta) / (double)numInstances);</span>
  }
    

  /** 
   * Selects cutpoints for sorted subset.
   * 
   * @param instances
   * @param attIndex
   * @param first
   * @param lastPlusOne
   * @return
   */
  private double[] cutPointsForSubset(Instances instances, int attIndex, 
				      int first, int lastPlusOne) { 

    double[][] counts, bestCounts;
    double[] priorCounts, left, right, cutPoints;
<span class="fc" id="L778">    double currentCutPoint = -Double.MAX_VALUE, bestCutPoint = -1, </span>
      currentEntropy, bestEntropy, priorEntropy, gain;
<span class="fc" id="L780">    int bestIndex = -1, numCutPoints = 0;</span>
<span class="fc" id="L781">    double numInstances = 0;</span>

    // Compute number of instances in set
<span class="fc bfc" id="L784" title="All 2 branches covered.">    if ((lastPlusOne - first) &lt; 2) {</span>
<span class="fc" id="L785">      return null;</span>
    }

    // Compute class counts.
<span class="fc" id="L789">    counts = new double[2][instances.numClasses()];</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">    for (int i = first; i &lt; lastPlusOne; i++) {</span>
<span class="fc" id="L791">      numInstances += instances.instance(i).weight();</span>
<span class="fc" id="L792">      counts[1][(int)instances.instance(i).classValue()] +=</span>
<span class="fc" id="L793">	instances.instance(i).weight();</span>
    }

    // Save prior counts
<span class="fc" id="L797">    priorCounts = new double[instances.numClasses()];</span>
<span class="fc" id="L798">    System.arraycopy(counts[1], 0, priorCounts, 0, </span>
<span class="fc" id="L799">		     instances.numClasses());</span>

    // Entropy of the full set
<span class="fc" id="L802">    priorEntropy = ContingencyTables.entropy(priorCounts);</span>
<span class="fc" id="L803">    bestEntropy = priorEntropy;</span>
    
    // Find best entropy.
<span class="fc" id="L806">    bestCounts = new double[2][instances.numClasses()];</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">    for (int i = first; i &lt; (lastPlusOne - 1); i++) {</span>
<span class="fc" id="L808">      counts[0][(int)instances.instance(i).classValue()] +=</span>
<span class="fc" id="L809">	instances.instance(i).weight();</span>
<span class="fc" id="L810">      counts[1][(int)instances.instance(i).classValue()] -=</span>
<span class="fc" id="L811">	instances.instance(i).weight();</span>
<span class="fc" id="L812">      if (instances.instance(i).value(attIndex) &lt; </span>
<span class="fc bfc" id="L813" title="All 2 branches covered.">	  instances.instance(i + 1).value(attIndex)) {</span>
<span class="fc" id="L814">	currentCutPoint = (instances.instance(i).value(attIndex) + </span>
<span class="fc" id="L815">	  instances.instance(i + 1).value(attIndex)) / 2.0;</span>
<span class="fc" id="L816">	currentEntropy = ContingencyTables.entropyConditionedOnRows(counts);</span>
<span class="fc bfc" id="L817" title="All 2 branches covered.">	if (currentEntropy &lt; bestEntropy) {</span>
<span class="fc" id="L818">	  bestCutPoint = currentCutPoint;</span>
<span class="fc" id="L819">	  bestEntropy = currentEntropy;</span>
<span class="fc" id="L820">	  bestIndex = i;</span>
<span class="fc" id="L821">	  System.arraycopy(counts[0], 0, </span>
<span class="fc" id="L822">			   bestCounts[0], 0, instances.numClasses());</span>
<span class="fc" id="L823">	  System.arraycopy(counts[1], 0, </span>
<span class="fc" id="L824">			   bestCounts[1], 0, instances.numClasses()); </span>
	}
<span class="fc" id="L826">	numCutPoints++;</span>
      }
    }

    // Use worse encoding?
<span class="fc bfc" id="L831" title="All 2 branches covered.">    if (!m_UseBetterEncoding) {</span>
<span class="fc" id="L832">      numCutPoints = (lastPlusOne - first) - 1;</span>
    }

    // Checks if gain is zero
<span class="fc" id="L836">    gain = priorEntropy - bestEntropy;</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">    if (gain &lt;= 0) {</span>
<span class="fc" id="L838">      return null;</span>
    }

    // Check if split is to be accepted
<span class="pc bpc" id="L842" title="3 of 4 branches missed.">    if ((m_UseKononenko &amp;&amp; KononenkosMDL(priorCounts, bestCounts,</span>
<span class="nc" id="L843">					 numInstances, numCutPoints)) ||</span>
<span class="pc bpc" id="L844" title="1 of 4 branches missed.">	(!m_UseKononenko &amp;&amp; FayyadAndIranisMDL(priorCounts, bestCounts,</span>
<span class="fc" id="L845">					       numInstances, numCutPoints))) {</span>
      
      // Select split points for the left and right subsets
<span class="fc" id="L848">      left = cutPointsForSubset(instances, attIndex, first, bestIndex + 1);</span>
<span class="fc" id="L849">      right = cutPointsForSubset(instances, attIndex, </span>
<span class="fc" id="L850">				 bestIndex + 1, lastPlusOne);</span>
      
      // Merge cutpoints and return them
<span class="fc bfc" id="L853" title="All 4 branches covered.">      if ((left == null) &amp;&amp; (right) == null) {</span>
<span class="fc" id="L854">	cutPoints = new double[1];</span>
<span class="fc" id="L855">	cutPoints[0] = bestCutPoint;</span>
<span class="fc bfc" id="L856" title="All 2 branches covered.">      } else if (right == null) {</span>
<span class="fc" id="L857">	cutPoints = new double[left.length + 1];</span>
<span class="fc" id="L858">	System.arraycopy(left, 0, cutPoints, 0, left.length);</span>
<span class="fc" id="L859">	cutPoints[left.length] = bestCutPoint;</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">      } else if (left == null) {</span>
<span class="fc" id="L861">	cutPoints = new double[1 + right.length];</span>
<span class="fc" id="L862">	cutPoints[0] = bestCutPoint;</span>
<span class="fc" id="L863">	System.arraycopy(right, 0, cutPoints, 1, right.length);</span>
      } else {
<span class="fc" id="L865">	cutPoints = new double[left.length + right.length + 1];</span>
<span class="fc" id="L866">	System.arraycopy(left, 0, cutPoints, 0, left.length);</span>
<span class="fc" id="L867">	cutPoints[left.length] = bestCutPoint;</span>
<span class="fc" id="L868">	System.arraycopy(right, 0, cutPoints, left.length + 1, right.length);</span>
      }
      
<span class="fc" id="L871">      return cutPoints;</span>
    } else
<span class="fc" id="L873">      return null;</span>
  }
 
  /**
   * Set the output format. Takes the currently defined cutpoints and 
   * m_InputFormat and calls setOutputFormat(Instances) appropriately.
   */
  protected void setOutputFormat() {

<span class="pc bpc" id="L882" title="1 of 2 branches missed.">    if (m_CutPoints == null) {</span>
<span class="nc" id="L883">      setOutputFormat(null);</span>
<span class="nc" id="L884">      return;</span>
    }
<span class="fc" id="L886">    FastVector attributes = new FastVector(getInputFormat().numAttributes());</span>
<span class="fc" id="L887">    int classIndex = getInputFormat().classIndex();</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">    for(int i = 0; i &lt; getInputFormat().numAttributes(); i++) {</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">      if ((m_DiscretizeCols.isInRange(i)) </span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">	  &amp;&amp; (getInputFormat().attribute(i).isNumeric())) {</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">	if (!m_MakeBinary) {</span>
<span class="fc" id="L892">	  FastVector attribValues = new FastVector(1);</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">	  if (m_CutPoints[i] == null) {</span>
<span class="fc" id="L894">	    attribValues.addElement(&quot;'All'&quot;);</span>
	  } else {
<span class="fc bfc" id="L896" title="All 2 branches covered.">	    for(int j = 0; j &lt;= m_CutPoints[i].length; j++) {</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">	      if (j == 0) {</span>
<span class="fc" id="L898">		attribValues.addElement(&quot;'(-inf-&quot;</span>
<span class="fc" id="L899">			+ Utils.doubleToString(m_CutPoints[i][j], 6) + &quot;]'&quot;);</span>
<span class="fc bfc" id="L900" title="All 2 branches covered.">	      } else if (j == m_CutPoints[i].length) {</span>
<span class="fc" id="L901">		attribValues.addElement(&quot;'(&quot;</span>
<span class="fc" id="L902">			+ Utils.doubleToString(m_CutPoints[i][j - 1], 6) </span>
<span class="fc" id="L903">					+ &quot;-inf)'&quot;);</span>
	      } else {
<span class="fc" id="L905">		attribValues.addElement(&quot;'(&quot;</span>
<span class="fc" id="L906">			+ Utils.doubleToString(m_CutPoints[i][j - 1], 6) + &quot;-&quot;</span>
<span class="fc" id="L907">			+ Utils.doubleToString(m_CutPoints[i][j], 6) + &quot;]'&quot;);</span>
	      }
	    }
	  }
<span class="fc" id="L911">	  Attribute newA = new Attribute(getInputFormat().</span>
<span class="fc" id="L912">              attribute(i).name(),</span>
<span class="fc" id="L913">              attribValues);</span>
<span class="fc" id="L914">	  newA.setWeight(getInputFormat().attribute(i).weight());</span>
<span class="fc" id="L915">	  attributes.addElement(newA);</span>
	      
	} else {
<span class="nc bnc" id="L918" title="All 2 branches missed.">	  if (m_CutPoints[i] == null) {</span>
<span class="nc" id="L919">	    FastVector attribValues = new FastVector(1);</span>
<span class="nc" id="L920">	    attribValues.addElement(&quot;'All'&quot;);</span>
<span class="nc" id="L921">	    Attribute newA = new Attribute(getInputFormat().</span>
<span class="nc" id="L922">                attribute(i).name(),</span>
<span class="nc" id="L923">                attribValues);</span>
<span class="nc" id="L924">	    newA.setWeight(getInputFormat().attribute(i).weight());</span>
<span class="nc" id="L925">	    attributes.addElement(newA);</span>
	  } else {
<span class="nc bnc" id="L927" title="All 2 branches missed.">	    if (i &lt; getInputFormat().classIndex()) {</span>
<span class="nc" id="L928">	      classIndex += m_CutPoints[i].length - 1;</span>
	    }
<span class="nc bnc" id="L930" title="All 2 branches missed.">	    for(int j = 0; j &lt; m_CutPoints[i].length; j++) {</span>
<span class="nc" id="L931">	      FastVector attribValues = new FastVector(2);</span>
<span class="nc" id="L932">	      attribValues.addElement(&quot;'(-inf-&quot;</span>
<span class="nc" id="L933">		      + Utils.doubleToString(m_CutPoints[i][j], 6) + &quot;]'&quot;);</span>
<span class="nc" id="L934">	      attribValues.addElement(&quot;'(&quot;</span>
<span class="nc" id="L935">		      + Utils.doubleToString(m_CutPoints[i][j], 6) + &quot;-inf)'&quot;);</span>
<span class="nc" id="L936">	      Attribute newA = new Attribute(getInputFormat().</span>
<span class="nc" id="L937">                  attribute(i).name() + &quot;_&quot; + (j+1),</span>
<span class="nc" id="L938">                  attribValues);</span>
<span class="nc" id="L939">	      newA.setWeight(getInputFormat().attribute(i).weight());</span>
<span class="nc" id="L940">	      attributes.addElement(newA);</span>
	    }
	  }
	}
      } else {
<span class="fc" id="L945">	attributes.addElement(getInputFormat().attribute(i).copy());</span>
      }
    }
<span class="fc" id="L948">    Instances outputFormat = </span>
<span class="fc" id="L949">      new Instances(getInputFormat().relationName(), attributes, 0);</span>
<span class="fc" id="L950">    outputFormat.setClassIndex(classIndex);</span>
<span class="fc" id="L951">    setOutputFormat(outputFormat);</span>
<span class="fc" id="L952">  }</span>

  /**
   * Convert a single instance over. The converted instance is added to 
   * the end of the output queue.
   *
   * @param instance the instance to convert
   */
  protected void convertInstance(Instance instance) {

<span class="fc" id="L962">    int index = 0;</span>
<span class="fc" id="L963">    double [] vals = new double [outputFormatPeek().numAttributes()];</span>
    // Copy and convert the values
<span class="fc bfc" id="L965" title="All 2 branches covered.">    for(int i = 0; i &lt; getInputFormat().numAttributes(); i++) {</span>
<span class="pc bpc" id="L966" title="1 of 2 branches missed.">      if (m_DiscretizeCols.isInRange(i) &amp;&amp; </span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">	  getInputFormat().attribute(i).isNumeric()) {</span>
	int j;
<span class="fc" id="L969">	double currentVal = instance.value(i);</span>
<span class="fc bfc" id="L970" title="All 2 branches covered.">	if (m_CutPoints[i] == null) {</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">	  if (instance.isMissing(i)) {</span>
<span class="fc" id="L972">	    vals[index] = Instance.missingValue();</span>
	  } else {
<span class="fc" id="L974">	    vals[index] = 0;</span>
	  }
<span class="fc" id="L976">	  index++;</span>
	} else {
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">	  if (!m_MakeBinary) {</span>
<span class="fc bfc" id="L979" title="All 2 branches covered.">	    if (instance.isMissing(i)) {</span>
<span class="fc" id="L980">	      vals[index] = Instance.missingValue();</span>
	    } else {
<span class="fc bfc" id="L982" title="All 2 branches covered.">	      for (j = 0; j &lt; m_CutPoints[i].length; j++) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">		if (currentVal &lt;= m_CutPoints[i][j]) {</span>
<span class="fc" id="L984">		  break;</span>
		}
	      }
<span class="fc" id="L987">              vals[index] = j;</span>
	    }
<span class="fc" id="L989">	    index++;</span>
	  } else {
<span class="nc bnc" id="L991" title="All 2 branches missed.">	    for (j = 0; j &lt; m_CutPoints[i].length; j++) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">	      if (instance.isMissing(i)) {</span>
<span class="nc" id="L993">                vals[index] = Instance.missingValue();</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">	      } else if (currentVal &lt;= m_CutPoints[i][j]) {</span>
<span class="nc" id="L995">                vals[index] = 0;</span>
	      } else {
<span class="nc" id="L997">                vals[index] = 1;</span>
	      }
<span class="nc" id="L999">	      index++;</span>
	    }
	  }   
	}
      } else {
<span class="fc" id="L1004">        vals[index] = instance.value(i);</span>
<span class="fc" id="L1005">	index++;</span>
      }
    }
    
<span class="fc" id="L1009">    Instance inst = null;</span>
<span class="pc bpc" id="L1010" title="1 of 2 branches missed.">    if (instance instanceof SparseInstance) {</span>
<span class="nc" id="L1011">      inst = new SparseInstance(instance.weight(), vals);</span>
    } else {
<span class="fc" id="L1013">      inst = new Instance(instance.weight(), vals);</span>
    }
<span class="fc" id="L1015">    inst.setDataset(getOutputFormat());</span>
<span class="fc" id="L1016">    copyValues(inst, false, instance.dataset(), getOutputFormat());</span>
<span class="fc" id="L1017">    inst.setDataset(getOutputFormat());</span>
<span class="fc" id="L1018">    push(inst);</span>
<span class="fc" id="L1019">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1027">    return RevisionUtils.extract(&quot;$Revision: 9090 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv should contain arguments to the filter: use -h for help
   */
  public static void main(String [] argv) {
<span class="nc" id="L1036">    runFilter(new Discretize(), argv);</span>
<span class="nc" id="L1037">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>