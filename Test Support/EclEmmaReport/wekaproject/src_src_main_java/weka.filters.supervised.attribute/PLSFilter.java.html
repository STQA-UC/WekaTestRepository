<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>PLSFilter.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.filters.supervised.attribute</a> &gt; <span class="el_source">PLSFilter.java</span></div><h1>PLSFilter.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * PLSFilter.java
 * Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.filters.supervised.attribute;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.core.matrix.EigenvalueDecomposition;
import weka.core.matrix.Matrix;
import weka.filters.Filter;
import weka.filters.SimpleBatchFilter;
import weka.filters.SupervisedFilter;
import weka.filters.unsupervised.attribute.Center;
import weka.filters.unsupervised.attribute.ReplaceMissingValues;
import weka.filters.unsupervised.attribute.Standardize;

import java.util.Enumeration;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * Runs Partial Least Square Regression over the given instances and computes the resulting beta matrix for prediction.&lt;br/&gt;
 * By default it replaces missing values and centers the data.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Tormod Naes, Tomas Isaksson, Tom Fearn, Tony Davies (2002). A User Friendly Guide to Multivariate Calibration and Classification. NIR Publications.&lt;br/&gt;
 * &lt;br/&gt;
 * StatSoft, Inc.. Partial Least Squares (PLS).&lt;br/&gt;
 * &lt;br/&gt;
 * Bent Jorgensen, Yuri Goegebeur. Module 7: Partial least squares regression I.&lt;br/&gt;
 * &lt;br/&gt;
 * S. de Jong (1993). SIMPLS: an alternative approach to partial least squares regression. Chemometrics and Intelligent Laboratory Systems. 18:251-263.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;book{Naes2002,
 *    author = {Tormod Naes and Tomas Isaksson and Tom Fearn and Tony Davies},
 *    publisher = {NIR Publications},
 *    title = {A User Friendly Guide to Multivariate Calibration and Classification},
 *    year = {2002},
 *    ISBN = {0-9528666-2-5}
 * }
 * 
 * &amp;#64;misc{missing_id,
 *    author = {StatSoft, Inc.},
 *    booktitle = {Electronic Textbook StatSoft},
 *    title = {Partial Least Squares (PLS)},
 *    HTTP = {http://www.statsoft.com/textbook/stpls.html}
 * }
 * 
 * &amp;#64;misc{missing_id,
 *    author = {Bent Jorgensen and Yuri Goegebeur},
 *    booktitle = {ST02: Multivariate Data Analysis and Chemometrics},
 *    title = {Module 7: Partial least squares regression I},
 *    HTTP = {http://statmaster.sdu.dk/courses/ST02/module07/}
 * }
 * 
 * &amp;#64;article{Jong1993,
 *    author = {S. de Jong},
 *    journal = {Chemometrics and Intelligent Laboratory Systems},
 *    pages = {251-263},
 *    title = {SIMPLS: an alternative approach to partial least squares regression},
 *    volume = {18},
 *    year = {1993}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  Turns on output of debugging information.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;num&amp;gt;
 *  The number of components to compute.
 *  (default: 20)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -U
 *  Updates the class attribute as well.
 *  (default: off)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M
 *  Turns replacing of missing values on.
 *  (default: off)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -A &amp;lt;SIMPLS|PLS1&amp;gt;
 *  The algorithm to use.
 *  (default: PLS1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;none|center|standardize&amp;gt;
 *  The type of preprocessing that is applied to the data.
 *  (default: center)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 5541 $
 */
<span class="fc" id="L137">public class PLSFilter</span>
  extends SimpleBatchFilter 
  implements SupervisedFilter, TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = -3335106965521265631L;

  /** the type of algorithm: SIMPLS */
  public static final int ALGORITHM_SIMPLS = 1;
  /** the type of algorithm: PLS1 */
  public static final int ALGORITHM_PLS1 = 2;
  /** the types of algorithm */
<span class="fc" id="L149">  public static final Tag[] TAGS_ALGORITHM = {</span>
<span class="fc" id="L150">    new Tag(ALGORITHM_SIMPLS, &quot;SIMPLS&quot;),</span>
<span class="fc" id="L151">    new Tag(ALGORITHM_PLS1, &quot;PLS1&quot;)</span>
  };

  /** the type of preprocessing: None */
  public static final int PREPROCESSING_NONE = 0;
  /** the type of preprocessing: Center */
  public static final int PREPROCESSING_CENTER = 1;
  /** the type of preprocessing: Standardize */
  public static final int PREPROCESSING_STANDARDIZE = 2;
  /** the types of preprocessing */
<span class="fc" id="L161">  public static final Tag[] TAGS_PREPROCESSING = {</span>
<span class="fc" id="L162">    new Tag(PREPROCESSING_NONE, &quot;none&quot;),</span>
<span class="fc" id="L163">    new Tag(PREPROCESSING_CENTER, &quot;center&quot;),</span>
<span class="fc" id="L164">    new Tag(PREPROCESSING_STANDARDIZE, &quot;standardize&quot;)</span>
  };

  /** the maximum number of components to generate */
<span class="fc" id="L168">  protected int m_NumComponents = 20;</span>
  
  /** the type of algorithm */
<span class="fc" id="L171">  protected int m_Algorithm = ALGORITHM_PLS1;</span>

  /** the regression vector &quot;r-hat&quot; for PLS1 */
<span class="fc" id="L174">  protected Matrix m_PLS1_RegVector = null;</span>

  /** the P matrix for PLS1 */
<span class="fc" id="L177">  protected Matrix m_PLS1_P = null;</span>

  /** the W matrix for PLS1 */
<span class="fc" id="L180">  protected Matrix m_PLS1_W = null;</span>

  /** the b-hat vector for PLS1 */
<span class="fc" id="L183">  protected Matrix m_PLS1_b_hat = null;</span>
  
  /** the W matrix for SIMPLS */
<span class="fc" id="L186">  protected Matrix m_SIMPLS_W = null;</span>
  
  /** the B matrix for SIMPLS (used for prediction) */
<span class="fc" id="L189">  protected Matrix m_SIMPLS_B = null;</span>
  
  /** whether to include the prediction, i.e., modifying the class attribute */
<span class="fc" id="L192">  protected boolean m_PerformPrediction = false;</span>

  /** for replacing missing values */
<span class="fc" id="L195">  protected Filter m_Missing = null;</span>
  
  /** whether to replace missing values */
<span class="fc" id="L198">  protected boolean m_ReplaceMissing = true;</span>
  
  /** for centering the data */
<span class="fc" id="L201">  protected Filter m_Filter = null;</span>
  
  /** the type of preprocessing */
<span class="fc" id="L204">  protected int m_Preprocessing = PREPROCESSING_CENTER;</span>

  /** the mean of the class */
<span class="fc" id="L207">  protected double m_ClassMean = 0;</span>

  /** the standard deviation of the class */
<span class="fc" id="L210">  protected double m_ClassStdDev = 0;</span>
  
  /**
   * default constructor
   */
  public PLSFilter() {
<span class="fc" id="L216">    super();</span>
    
    // setup pre-processing
<span class="fc" id="L219">    m_Missing = new ReplaceMissingValues();</span>
<span class="fc" id="L220">    m_Filter  = new Center();</span>
<span class="fc" id="L221">  }</span>
  
  /**
   * Returns a string describing this classifier.
   *
   * @return      a description of the classifier suitable for
   *              displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L230">    return </span>
<span class="nc" id="L231">        &quot;Runs Partial Least Square Regression over the given instances &quot;</span>
      + &quot;and computes the resulting beta matrix for prediction.\n&quot;
      + &quot;By default it replaces missing values and centers the data.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L235">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    TechnicalInformation 	additional;
    
<span class="nc" id="L249">    result = new TechnicalInformation(Type.BOOK);</span>
<span class="nc" id="L250">    result.setValue(Field.AUTHOR, &quot;Tormod Naes and Tomas Isaksson and Tom Fearn and Tony Davies&quot;);</span>
<span class="nc" id="L251">    result.setValue(Field.YEAR, &quot;2002&quot;);</span>
<span class="nc" id="L252">    result.setValue(Field.TITLE, &quot;A User Friendly Guide to Multivariate Calibration and Classification&quot;);</span>
<span class="nc" id="L253">    result.setValue(Field.PUBLISHER, &quot;NIR Publications&quot;);</span>
<span class="nc" id="L254">    result.setValue(Field.ISBN, &quot;0-9528666-2-5&quot;);</span>
    
<span class="nc" id="L256">    additional = result.add(Type.MISC);</span>
<span class="nc" id="L257">    additional.setValue(Field.AUTHOR, &quot;StatSoft, Inc.&quot;);</span>
<span class="nc" id="L258">    additional.setValue(Field.TITLE, &quot;Partial Least Squares (PLS)&quot;);</span>
<span class="nc" id="L259">    additional.setValue(Field.BOOKTITLE, &quot;Electronic Textbook StatSoft&quot;);</span>
<span class="nc" id="L260">    additional.setValue(Field.HTTP, &quot;http://www.statsoft.com/textbook/stpls.html&quot;);</span>
    
<span class="nc" id="L262">    additional = result.add(Type.MISC);</span>
<span class="nc" id="L263">    additional.setValue(Field.AUTHOR, &quot;Bent Jorgensen and Yuri Goegebeur&quot;);</span>
<span class="nc" id="L264">    additional.setValue(Field.TITLE, &quot;Module 7: Partial least squares regression I&quot;);</span>
<span class="nc" id="L265">    additional.setValue(Field.BOOKTITLE, &quot;ST02: Multivariate Data Analysis and Chemometrics&quot;);</span>
<span class="nc" id="L266">    additional.setValue(Field.HTTP, &quot;http://statmaster.sdu.dk/courses/ST02/module07/&quot;);</span>
    
<span class="nc" id="L268">    additional = result.add(Type.ARTICLE);</span>
<span class="nc" id="L269">    additional.setValue(Field.AUTHOR, &quot;S. de Jong&quot;);</span>
<span class="nc" id="L270">    additional.setValue(Field.YEAR, &quot;1993&quot;);</span>
<span class="nc" id="L271">    additional.setValue(Field.TITLE, &quot;SIMPLS: an alternative approach to partial least squares regression&quot;);</span>
<span class="nc" id="L272">    additional.setValue(Field.JOURNAL, &quot;Chemometrics and Intelligent Laboratory Systems&quot;);</span>
<span class="nc" id="L273">    additional.setValue(Field.VOLUME, &quot;18&quot;);</span>
<span class="nc" id="L274">    additional.setValue(Field.PAGES, &quot;251-263&quot;);</span>
    
<span class="nc" id="L276">    return result;</span>
  }

  /**
   * Gets an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {
    Vector		result;
    Enumeration		enm;
    String		param;
    SelectedTag		tag;
    int			i;

<span class="fc" id="L291">    result = new Vector();</span>

<span class="fc" id="L293">    enm = super.listOptions();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">    while (enm.hasMoreElements())</span>
<span class="fc" id="L295">      result.addElement(enm.nextElement());</span>

<span class="fc" id="L297">    result.addElement(new Option(</span>
<span class="fc" id="L298">	&quot;\tThe number of components to compute.\n&quot;</span>
	+ &quot;\t(default: 20)&quot;,
<span class="fc" id="L300">	&quot;C&quot;, 1, &quot;-C &lt;num&gt;&quot;));</span>

<span class="fc" id="L302">    result.addElement(new Option(</span>
<span class="fc" id="L303">	&quot;\tUpdates the class attribute as well.\n&quot;</span>
	+ &quot;\t(default: off)&quot;,
<span class="fc" id="L305">	&quot;U&quot;, 0, &quot;-U&quot;));</span>

<span class="fc" id="L307">    result.addElement(new Option(</span>
<span class="fc" id="L308">	&quot;\tTurns replacing of missing values on.\n&quot;</span>
	+ &quot;\t(default: off)&quot;,
<span class="fc" id="L310">	&quot;M&quot;, 0, &quot;-M&quot;));</span>

<span class="fc" id="L312">    param = &quot;&quot;;</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">    for (i = 0; i &lt; TAGS_ALGORITHM.length; i++) {</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">      if (i &gt; 0)</span>
<span class="fc" id="L315">	param += &quot;|&quot;;</span>
<span class="fc" id="L316">      tag = new SelectedTag(TAGS_ALGORITHM[i].getID(), TAGS_ALGORITHM);</span>
<span class="fc" id="L317">      param += tag.getSelectedTag().getReadable();</span>
    }
<span class="fc" id="L319">    result.addElement(new Option(</span>
<span class="fc" id="L320">	&quot;\tThe algorithm to use.\n&quot;</span>
	+ &quot;\t(default: PLS1)&quot;,
<span class="fc" id="L322">	&quot;A&quot;, 1, &quot;-A &lt;&quot; + param + &quot;&gt;&quot;));</span>

<span class="fc" id="L324">    param = &quot;&quot;;</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (i = 0; i &lt; TAGS_PREPROCESSING.length; i++) {</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">      if (i &gt; 0)</span>
<span class="fc" id="L327">	param += &quot;|&quot;;</span>
<span class="fc" id="L328">      tag = new SelectedTag(TAGS_PREPROCESSING[i].getID(), TAGS_PREPROCESSING);</span>
<span class="fc" id="L329">      param += tag.getSelectedTag().getReadable();</span>
    }
<span class="fc" id="L331">    result.addElement(new Option(</span>
<span class="fc" id="L332">	&quot;\tThe type of preprocessing that is applied to the data.\n&quot;</span>
	+ &quot;\t(default: center)&quot;,
<span class="fc" id="L334">	&quot;P&quot;, 1, &quot;-P &lt;&quot; + param + &quot;&gt;&quot;));</span>

<span class="fc" id="L336">    return result.elements();</span>
  }

  /**
   * returns the options of the current setup
   *
   * @return      the current options
   */
  public String[] getOptions() {
    int       i;
    Vector    result;
    String[]  options;

<span class="fc" id="L349">    result = new Vector();</span>
<span class="fc" id="L350">    options = super.getOptions();</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L352">      result.add(options[i]);</span>

<span class="fc" id="L354">    result.add(&quot;-C&quot;);</span>
<span class="fc" id="L355">    result.add(&quot;&quot; + getNumComponents());</span>

<span class="pc bpc" id="L357" title="1 of 2 branches missed.">    if (getPerformPrediction())</span>
<span class="nc" id="L358">      result.add(&quot;-U&quot;);</span>
    
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">    if (getReplaceMissing())</span>
<span class="fc" id="L361">      result.add(&quot;-M&quot;);</span>
    
<span class="fc" id="L363">    result.add(&quot;-A&quot;);</span>
<span class="fc" id="L364">    result.add(&quot;&quot; + getAlgorithm().getSelectedTag().getReadable());</span>

<span class="fc" id="L366">    result.add(&quot;-P&quot;);</span>
<span class="fc" id="L367">    result.add(&quot;&quot; + getPreprocessing().getSelectedTag().getReadable());</span>

<span class="fc" id="L369">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }

  /**
   * Parses the options for this object. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -D
   *  Turns on output of debugging information.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;num&amp;gt;
   *  The number of components to compute.
   *  (default: 20)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -U
   *  Updates the class attribute as well.
   *  (default: off)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M
   *  Turns replacing of missing values on.
   *  (default: off)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -A &amp;lt;SIMPLS|PLS1&amp;gt;
   *  The algorithm to use.
   *  (default: PLS1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;none|center|standardize&amp;gt;
   *  The type of preprocessing that is applied to the data.
   *  (default: center)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options	the options to use
   * @throws Exception	if the option setting fails
   */
  public void setOptions(String[] options) throws Exception {
    String	tmpStr;

<span class="fc" id="L409">    super.setOptions(options);</span>

<span class="fc" id="L411">    tmpStr = Utils.getOption(&quot;C&quot;, options);</span>
<span class="pc bpc" id="L412" title="1 of 2 branches missed.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L413">      setNumComponents(Integer.parseInt(tmpStr));</span>
    else
<span class="nc" id="L415">      setNumComponents(20);</span>

<span class="fc" id="L417">    setPerformPrediction(Utils.getFlag(&quot;U&quot;, options));</span>
    
<span class="fc" id="L419">    setReplaceMissing(Utils.getFlag(&quot;M&quot;, options));</span>
    
<span class="fc" id="L421">    tmpStr = Utils.getOption(&quot;A&quot;, options);</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L423">      setAlgorithm(new SelectedTag(tmpStr, TAGS_ALGORITHM));</span>
    else
<span class="nc" id="L425">      setAlgorithm(new SelectedTag(ALGORITHM_PLS1, TAGS_ALGORITHM));</span>
    
<span class="fc" id="L427">    tmpStr = Utils.getOption(&quot;P&quot;, options);</span>
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L429">      setPreprocessing(new SelectedTag(tmpStr, TAGS_PREPROCESSING));</span>
    else
<span class="nc" id="L431">      setPreprocessing(new SelectedTag(PREPROCESSING_CENTER, TAGS_PREPROCESSING));</span>
<span class="fc" id="L432">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String numComponentsTipText() {
<span class="nc" id="L441">    return &quot;The number of components to compute.&quot;;</span>
  }

  /**
   * sets the maximum number of attributes to use.
   * 
   * @param value	the maximum number of attributes
   */
  public void setNumComponents(int value) {
<span class="fc" id="L450">    m_NumComponents = value;</span>
<span class="fc" id="L451">  }</span>

  /**
   * returns the maximum number of attributes to use.
   * 
   * @return		the current maximum number of attributes
   */
  public int getNumComponents() {
<span class="fc" id="L459">    return m_NumComponents;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String performPredictionTipText() {
<span class="nc" id="L469">    return &quot;Whether to update the class attribute with the predicted value.&quot;;</span>
  }

  /**
   * Sets whether to update the class attribute with the predicted value.
   * 
   * @param value	if true the class value will be replaced by the 
   * 			predicted value.
   */
  public void setPerformPrediction(boolean value) {
<span class="fc" id="L479">    m_PerformPrediction = value;</span>
<span class="fc" id="L480">  }</span>

  /**
   * Gets whether the class attribute is updated with the predicted value.
   * 
   * @return		true if the class attribute is updated
   */
  public boolean getPerformPrediction() {
<span class="fc" id="L488">    return m_PerformPrediction;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String algorithmTipText() {
<span class="nc" id="L498">    return &quot;Sets the type of algorithm to use.&quot;;</span>
  }

  /**
   * Sets the type of algorithm to use 
   *
   * @param value 	the algorithm type
   */
  public void setAlgorithm(SelectedTag value) {
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">    if (value.getTags() == TAGS_ALGORITHM) {</span>
<span class="fc" id="L508">      m_Algorithm = value.getSelectedTag().getID();</span>
    }
<span class="fc" id="L510">  }</span>

  /**
   * Gets the type of algorithm to use 
   *
   * @return 		the current algorithm type.
   */
  public SelectedTag getAlgorithm() {
<span class="fc" id="L518">    return new SelectedTag(m_Algorithm, TAGS_ALGORITHM);</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String replaceMissingTipText() {
<span class="nc" id="L528">    return &quot;Whether to replace missing values.&quot;;</span>
  }

  /**
   * Sets whether to replace missing values.
   * 
   * @param value	if true missing values are replaced with the
   * 			ReplaceMissingValues filter.
   */
  public void setReplaceMissing(boolean value) {
<span class="fc" id="L538">    m_ReplaceMissing = value;</span>
<span class="fc" id="L539">  }</span>

  /**
   * Gets whether missing values are replace.
   * 
   * @return		true if missing values are replaced with the 
   * 			ReplaceMissingValues filter
   */
  public boolean getReplaceMissing() {
<span class="fc" id="L548">    return m_ReplaceMissing;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String preprocessingTipText() {
<span class="nc" id="L558">    return &quot;Sets the type of preprocessing to use.&quot;;</span>
  }

  /**
   * Sets the type of preprocessing to use 
   *
   * @param value 	the preprocessing type
   */
  public void setPreprocessing(SelectedTag value) {
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">    if (value.getTags() == TAGS_PREPROCESSING) {</span>
<span class="fc" id="L568">      m_Preprocessing = value.getSelectedTag().getID();</span>
    }
<span class="fc" id="L570">  }</span>

  /**
   * Gets the type of preprocessing to use 
   *
   * @return 		the current preprocessing type.
   */
  public SelectedTag getPreprocessing() {
<span class="fc" id="L578">    return new SelectedTag(m_Preprocessing, TAGS_PREPROCESSING);</span>
  }

  /**
   * Determines the output format based on the input format and returns 
   * this. In case the output format cannot be returned immediately, i.e.,
   * immediateOutputFormat() returns false, then this method will be called
   * from batchFinished().
   *
   * @param inputFormat     the input format to base the output format on
   * @return                the output format
   * @throws Exception      in case the determination goes wrong
   * @see   #hasImmediateOutputFormat()
   * @see   #batchFinished()
   */
  protected Instances determineOutputFormat(Instances inputFormat) 
    throws Exception {

    // generate header
<span class="fc" id="L597">    FastVector atts = new FastVector();</span>
<span class="fc" id="L598">    String prefix = getAlgorithm().getSelectedTag().getReadable();</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">    for (int i = 0; i &lt; getNumComponents(); i++)</span>
<span class="fc" id="L600">      atts.addElement(new Attribute(prefix + &quot;_&quot; + (i+1)));</span>
<span class="fc" id="L601">    atts.addElement(new Attribute(&quot;Class&quot;));</span>
<span class="fc" id="L602">    Instances result = new Instances(prefix, atts, 0);</span>
<span class="fc" id="L603">    result.setClassIndex(result.numAttributes() - 1);</span>
    
<span class="fc" id="L605">    return result;</span>
  }
  
  /**
   * returns the data minus the class column as matrix
   * 
   * @param instances	the data to work on
   * @return		the data without class attribute
   */
  protected Matrix getX(Instances instances) {
    double[][]	x;
    double[]	values;
    Matrix	result;
    int		i;
    int		n;
    int		j;
    int		clsIndex;
    
<span class="fc" id="L623">    clsIndex = instances.classIndex();</span>
<span class="fc" id="L624">    x        = new double[instances.numInstances()][];</span>
    
<span class="fc bfc" id="L626" title="All 2 branches covered.">    for (i = 0; i &lt; instances.numInstances(); i++) {</span>
<span class="fc" id="L627">      values = instances.instance(i).toDoubleArray();</span>
<span class="fc" id="L628">      x[i]   = new double[values.length - 1];</span>
      
<span class="fc" id="L630">      j = 0;</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">      for (n = 0; n &lt; values.length; n++) {</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">	if (n != clsIndex) {</span>
<span class="fc" id="L633">	  x[i][j] = values[n];</span>
<span class="fc" id="L634">	  j++;</span>
	}
      }
    }
    
<span class="fc" id="L639">    result = new Matrix(x);</span>
    
<span class="fc" id="L641">    return result;</span>
  }
  
  /**
   * returns the data minus the class column as matrix
   * 
   * @param instance	the instance to work on
   * @return		the data without the class attribute
   */
  protected Matrix getX(Instance instance) {
    double[][]	x;
    double[]	values;
    Matrix	result;
    
<span class="nc" id="L655">    x = new double[1][];</span>
<span class="nc" id="L656">    values = instance.toDoubleArray();</span>
<span class="nc" id="L657">    x[0] = new double[values.length - 1];</span>
<span class="nc" id="L658">    System.arraycopy(values, 0, x[0], 0, values.length - 1);</span>
    
<span class="nc" id="L660">    result = new Matrix(x);</span>
    
<span class="nc" id="L662">    return result;</span>
  }
  
  /**
   * returns the data class column as matrix
   * 
   * @param instances	the data to work on
   * @return		the class attribute
   */
  protected Matrix getY(Instances instances) {
    double[][]	y;
    Matrix	result;
    int		i;
    
<span class="fc" id="L676">    y = new double[instances.numInstances()][1];</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">    for (i = 0; i &lt; instances.numInstances(); i++)</span>
<span class="fc" id="L678">      y[i][0] = instances.instance(i).classValue();</span>
    
<span class="fc" id="L680">    result = new Matrix(y);</span>
    
<span class="fc" id="L682">    return result;</span>
  }
  
  /**
   * returns the data class column as matrix
   * 
   * @param instance	the instance to work on
   * @return		the class attribute
   */
  protected Matrix getY(Instance instance) {
    double[][]	y;
    Matrix	result;
    
<span class="nc" id="L695">    y = new double[1][1];</span>
<span class="nc" id="L696">    y[0][0] = instance.classValue();</span>
    
<span class="nc" id="L698">    result = new Matrix(y);</span>
    
<span class="nc" id="L700">    return result;</span>
  }
  
  /**
   * returns the X and Y matrix again as Instances object, based on the given
   * header (must have a class attribute set).
   * 
   * @param header	the format of the instance object
   * @param x		the X matrix (data)
   * @param y		the Y matrix (class)
   * @return		the assembled data
   */
  protected Instances toInstances(Instances header, Matrix x, Matrix y) {
    double[]	values;
    int		i;
    int		n;
    Instances	result;
    int		rows;
    int		cols;
    int		offset;
    int		clsIdx;
    
<span class="fc" id="L722">    result = new Instances(header, 0);</span>
    
<span class="fc" id="L724">    rows   = x.getRowDimension();</span>
<span class="fc" id="L725">    cols   = x.getColumnDimension();</span>
<span class="fc" id="L726">    clsIdx = header.classIndex();</span>
    
<span class="fc bfc" id="L728" title="All 2 branches covered.">    for (i = 0; i &lt; rows; i++) {</span>
<span class="fc" id="L729">      values = new double[cols + 1];</span>
<span class="fc" id="L730">      offset = 0;</span>

<span class="fc bfc" id="L732" title="All 2 branches covered.">      for (n = 0; n &lt; values.length; n++) {</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">	if (n == clsIdx) {</span>
<span class="fc" id="L734">	  offset--;</span>
<span class="fc" id="L735">	  values[n] = y.get(i, 0);</span>
	}
	else {
<span class="fc" id="L738">	  values[n] = x.get(i, n + offset);</span>
	}
      }
      
<span class="fc" id="L742">      result.add(new Instance(1.0, values));</span>
    }
    
<span class="fc" id="L745">    return result;</span>
  }
  
  /**
   * returns the given column as a vector (actually a n x 1 matrix)
   * 
   * @param m		the matrix to work on
   * @param columnIndex	the column to return
   * @return		the column as n x 1 matrix
   */
  protected Matrix columnAsVector(Matrix m, int columnIndex) {
    Matrix	result;
    int		i;
    
<span class="fc" id="L759">    result = new Matrix(m.getRowDimension(), 1);</span>
    
<span class="fc bfc" id="L761" title="All 2 branches covered.">    for (i = 0; i &lt; m.getRowDimension(); i++)</span>
<span class="fc" id="L762">      result.set(i, 0, m.get(i, columnIndex));</span>
    
<span class="fc" id="L764">    return result;</span>
  }
  
  /**
   * stores the data from the (column) vector in the matrix at the specified 
   * index
   * 
   * @param v		the vector to store in the matrix
   * @param m		the receiving matrix
   * @param columnIndex	the column to store the values in
   */
  protected void setVector(Matrix v, Matrix m, int columnIndex) {
<span class="fc" id="L776">    m.setMatrix(0, m.getRowDimension() - 1, columnIndex, columnIndex, v);</span>
<span class="fc" id="L777">  }</span>
  
  /**
   * returns the (column) vector of the matrix at the specified index
   * 
   * @param m		the matrix to work on
   * @param columnIndex	the column to get the values from
   * @return		the column vector
   */
  protected Matrix getVector(Matrix m, int columnIndex) {
<span class="nc" id="L787">    return m.getMatrix(0, m.getRowDimension() - 1, columnIndex, columnIndex);</span>
  }

  /**
   * determines the dominant eigenvector for the given matrix and returns it
   * 
   * @param m		the matrix to determine the dominant eigenvector for
   * @return		the dominant eigenvector
   */
  protected Matrix getDominantEigenVector(Matrix m) {
    EigenvalueDecomposition	eigendecomp;
    double[]			eigenvalues;
    int				index;
    Matrix			result;
    
<span class="fc" id="L802">    eigendecomp = m.eig();</span>
<span class="fc" id="L803">    eigenvalues = eigendecomp.getRealEigenvalues();</span>
<span class="fc" id="L804">    index       = Utils.maxIndex(eigenvalues);</span>
<span class="fc" id="L805">    result	= columnAsVector(eigendecomp.getV(), index);</span>
    
<span class="fc" id="L807">    return result;</span>
  }
  
  /**
   * normalizes the given vector (inplace) 
   * 
   * @param v		the vector to normalize
   */
  protected void normalizeVector(Matrix v) {
    double	sum;
    int		i;
    
    // determine length
<span class="fc" id="L820">    sum = 0;</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">    for (i = 0; i &lt; v.getRowDimension(); i++)</span>
<span class="fc" id="L822">      sum += v.get(i, 0) * v.get(i, 0);</span>
<span class="fc" id="L823">    sum = StrictMath.sqrt(sum);</span>
    
    // normalize content
<span class="fc bfc" id="L826" title="All 2 branches covered.">    for (i = 0; i &lt; v.getRowDimension(); i++)</span>
<span class="fc" id="L827">      v.set(i, 0, v.get(i, 0) / sum);</span>
<span class="fc" id="L828">  }</span>

  /**
   * processes the instances using the PLS1 algorithm
   *
   * @param instances   the data to process
   * @return            the modified data
   * @throws Exception  in case the processing goes wrong
   */
  protected Instances processPLS1(Instances instances) throws Exception {
    Matrix	X, X_trans, x;
    Matrix	y;
    Matrix	W, w;
    Matrix	T, t, t_trans;
    Matrix	P, p, p_trans;
    double	b;
    Matrix	b_hat;
    int		i;
    int		j;
    Matrix	X_new;
    Matrix	tmp;
    Instances	result;
    Instances	tmpInst;

    // initialization
<span class="nc bnc" id="L853" title="All 2 branches missed.">    if (!isFirstBatchDone()) {</span>
      // split up data
<span class="nc" id="L855">      X       = getX(instances);</span>
<span class="nc" id="L856">      y       = getY(instances);</span>
<span class="nc" id="L857">      X_trans = X.transpose();</span>
      
      // init
<span class="nc" id="L860">      W     = new Matrix(instances.numAttributes() - 1, getNumComponents());</span>
<span class="nc" id="L861">      P     = new Matrix(instances.numAttributes() - 1, getNumComponents());</span>
<span class="nc" id="L862">      T     = new Matrix(instances.numInstances(), getNumComponents());</span>
<span class="nc" id="L863">      b_hat = new Matrix(getNumComponents(), 1);</span>
      
<span class="nc bnc" id="L865" title="All 2 branches missed.">      for (j = 0; j &lt; getNumComponents(); j++) {</span>
	// 1. step: wj
<span class="nc" id="L867">	w = X_trans.times(y);</span>
<span class="nc" id="L868">	normalizeVector(w);</span>
<span class="nc" id="L869">	setVector(w, W, j);</span>
	
	// 2. step: tj
<span class="nc" id="L872">	t       = X.times(w);</span>
<span class="nc" id="L873">	t_trans = t.transpose();</span>
<span class="nc" id="L874">	setVector(t, T, j);</span>
	
	// 3. step: ^bj
<span class="nc" id="L877">	b = t_trans.times(y).get(0, 0) / t_trans.times(t).get(0, 0);</span>
<span class="nc" id="L878">	b_hat.set(j, 0, b);</span>
	
	// 4. step: pj
<span class="nc" id="L881">	p       = X_trans.times(t).times((double) 1 / t_trans.times(t).get(0, 0));</span>
<span class="nc" id="L882">	p_trans = p.transpose();</span>
<span class="nc" id="L883">	setVector(p, P, j);</span>
	
	// 5. step: Xj+1
<span class="nc" id="L886">	X = X.minus(t.times(p_trans));</span>
<span class="nc" id="L887">	y = y.minus(t.times(b));</span>
      }
      
      // W*(P^T*W)^-1
<span class="nc" id="L891">      tmp = W.times(((P.transpose()).times(W)).inverse());</span>
      
      // X_new = X*W*(P^T*W)^-1
<span class="nc" id="L894">      X_new = getX(instances).times(tmp);</span>
      
      // factor = W*(P^T*W)^-1 * b_hat
<span class="nc" id="L897">      m_PLS1_RegVector = tmp.times(b_hat);</span>
   
      // save matrices
<span class="nc" id="L900">      m_PLS1_P     = P;</span>
<span class="nc" id="L901">      m_PLS1_W     = W;</span>
<span class="nc" id="L902">      m_PLS1_b_hat = b_hat;</span>
      
<span class="nc bnc" id="L904" title="All 2 branches missed.">      if (getPerformPrediction())</span>
<span class="nc" id="L905">        result = toInstances(getOutputFormat(), X_new, y);</span>
      else
<span class="nc" id="L907">        result = toInstances(getOutputFormat(), X_new, getY(instances));</span>
    }
    // prediction
    else {
<span class="nc" id="L911">      result = new Instances(getOutputFormat());</span>
      
<span class="nc bnc" id="L913" title="All 2 branches missed.">      for (i = 0; i &lt; instances.numInstances(); i++) {</span>
	// work on each instance
<span class="nc" id="L915">	tmpInst = new Instances(instances, 0);</span>
<span class="nc" id="L916">	tmpInst.add((Instance) instances.instance(i).copy());</span>
<span class="nc" id="L917">	x = getX(tmpInst);</span>
<span class="nc" id="L918">	X = new Matrix(1, getNumComponents());</span>
<span class="nc" id="L919">	T = new Matrix(1, getNumComponents());</span>
	
<span class="nc bnc" id="L921" title="All 2 branches missed.">	for (j = 0; j &lt; getNumComponents(); j++) {</span>
<span class="nc" id="L922">	  setVector(x, X, j);</span>
	  // 1. step: tj = xj * wj
<span class="nc" id="L924">	  t = x.times(getVector(m_PLS1_W, j));</span>
<span class="nc" id="L925">	  setVector(t, T, j);</span>
	  // 2. step: xj+1 = xj - tj*pj^T (tj is 1x1 matrix!)
<span class="nc" id="L927">	  x = x.minus(getVector(m_PLS1_P, j).transpose().times(t.get(0, 0)));</span>
	}
	
<span class="nc bnc" id="L930" title="All 2 branches missed.">	if (getPerformPrediction())</span>
<span class="nc" id="L931">	  tmpInst = toInstances(getOutputFormat(), T, T.times(m_PLS1_b_hat));</span>
	else
<span class="nc" id="L933">	  tmpInst = toInstances(getOutputFormat(), T, getY(tmpInst));</span>
	
<span class="nc" id="L935">	result.add(tmpInst.instance(0));</span>
      }
    }
    
<span class="nc" id="L939">    return result;</span>
  }

  /**
   * processes the instances using the SIMPLS algorithm
   *
   * @param instances   the data to process
   * @return            the modified data
   * @throws Exception  in case the processing goes wrong
   */
  protected Instances processSIMPLS(Instances instances) throws Exception {
    Matrix	A, A_trans;
    Matrix	M;
    Matrix	X, X_trans;
    Matrix	X_new;
    Matrix	Y, y;
    Matrix	C, c;
    Matrix	Q, q;
    Matrix	W, w;
    Matrix	P, p, p_trans;
    Matrix	v, v_trans;
    Matrix	T;
    Instances	result;
    int		h;
    
<span class="fc bfc" id="L964" title="All 2 branches covered.">    if (!isFirstBatchDone()) {</span>
      // init
<span class="fc" id="L966">      X       = getX(instances);</span>
<span class="fc" id="L967">      X_trans = X.transpose();</span>
<span class="fc" id="L968">      Y       = getY(instances);</span>
<span class="fc" id="L969">      A       = X_trans.times(Y);</span>
<span class="fc" id="L970">      M       = X_trans.times(X);</span>
<span class="fc" id="L971">      C       = Matrix.identity(instances.numAttributes() - 1, instances.numAttributes() - 1);</span>
<span class="fc" id="L972">      W       = new Matrix(instances.numAttributes() - 1, getNumComponents());</span>
<span class="fc" id="L973">      P       = new Matrix(instances.numAttributes() - 1, getNumComponents());</span>
<span class="fc" id="L974">      Q       = new Matrix(1, getNumComponents());</span>
      
<span class="fc bfc" id="L976" title="All 2 branches covered.">      for (h = 0; h &lt; getNumComponents(); h++) {</span>
	// 1. qh as dominant EigenVector of Ah'*Ah
<span class="fc" id="L978">	A_trans = A.transpose();</span>
<span class="fc" id="L979">	q       = getDominantEigenVector(A_trans.times(A));</span>
	
	// 2. wh=Ah*qh, ch=wh'*Mh*wh, wh=wh/sqrt(ch), store wh in W as column
<span class="fc" id="L982">	w       = A.times(q);</span>
<span class="fc" id="L983">	c       = w.transpose().times(M).times(w);</span>
<span class="fc" id="L984">	w       = w.times(1.0 / StrictMath.sqrt(c.get(0, 0)));</span>
<span class="fc" id="L985">	setVector(w, W, h);</span>
	
	// 3. ph=Mh*wh, store ph in P as column
<span class="fc" id="L988">	p       = M.times(w);</span>
<span class="fc" id="L989">	p_trans = p.transpose();</span>
<span class="fc" id="L990">	setVector(p, P, h);</span>
	
	// 4. qh=Ah'*wh, store qh in Q as column
<span class="fc" id="L993">	q = A_trans.times(w);</span>
<span class="fc" id="L994">	setVector(q, Q, h);</span>
	
	// 5. vh=Ch*ph, vh=vh/||vh||
<span class="fc" id="L997">	v       = C.times(p);</span>
<span class="fc" id="L998">	normalizeVector(v);</span>
<span class="fc" id="L999">	v_trans = v.transpose();</span>
	
	// 6. Ch+1=Ch-vh*vh', Mh+1=Mh-ph*ph'
<span class="fc" id="L1002">	C = C.minus(v.times(v_trans));</span>
<span class="fc" id="L1003">	M = M.minus(p.times(p_trans));</span>
	
	// 7. Ah+1=ChAh (actually Ch+1)
<span class="fc" id="L1006">	A = C.times(A);</span>
      }
      
      // finish
<span class="fc" id="L1010">      m_SIMPLS_W = W;</span>
<span class="fc" id="L1011">      T          = X.times(m_SIMPLS_W);</span>
<span class="fc" id="L1012">      X_new      = T;</span>
<span class="fc" id="L1013">      m_SIMPLS_B = W.times(Q.transpose());</span>
      
<span class="pc bpc" id="L1015" title="1 of 2 branches missed.">      if (getPerformPrediction())</span>
<span class="nc" id="L1016">	y = T.times(P.transpose()).times(m_SIMPLS_B);</span>
      else
<span class="fc" id="L1018">	y = getY(instances);</span>

<span class="fc" id="L1020">      result = toInstances(getOutputFormat(), X_new, y);</span>
    }
    else {
<span class="fc" id="L1023">      result = new Instances(getOutputFormat());</span>
      
<span class="fc" id="L1025">      X     = getX(instances);</span>
<span class="fc" id="L1026">      X_new = X.times(m_SIMPLS_W);</span>
      
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">      if (getPerformPrediction())</span>
<span class="fc" id="L1029">	y = X.times(m_SIMPLS_B);</span>
      else
<span class="nc" id="L1031">	y = getY(instances);</span>
      
<span class="fc" id="L1033">      result = toInstances(getOutputFormat(), X_new, y);</span>
    }
    
<span class="fc" id="L1036">    return result;</span>
  }

  /** 
   * Returns the Capabilities of this filter.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1046">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1047">    result.disableAll();</span>

    // attributes
<span class="fc" id="L1050">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L1051">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L1052">    result.enable(Capability.MISSING_VALUES);</span>
    
    // class
<span class="fc" id="L1055">    result.enable(Capability.NUMERIC_CLASS);</span>
<span class="fc" id="L1056">    result.enable(Capability.DATE_CLASS);</span>
    
<span class="fc" id="L1058">    return result;</span>
  }
  
  /**
   * Processes the given data (may change the provided dataset) and returns
   * the modified version. This method is called in batchFinished().
   *
   * @param instances   the data to process
   * @return            the modified data
   * @throws Exception  in case the processing goes wrong
   * @see               #batchFinished()
   */
  protected Instances process(Instances instances) throws Exception {
    Instances	result;
    int		i;
    double	clsValue;
    double[]	clsValues;
    
<span class="fc" id="L1076">    result = null;</span>

    // save original class values if no prediction is performed
<span class="fc bfc" id="L1079" title="All 2 branches covered.">    if (!getPerformPrediction())</span>
<span class="fc" id="L1080">      clsValues = instances.attributeToDoubleArray(instances.classIndex());</span>
    else
<span class="fc" id="L1082">      clsValues = null;</span>
    
<span class="fc bfc" id="L1084" title="All 2 branches covered.">    if (!isFirstBatchDone()) {</span>
      // init filters
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">      if (m_ReplaceMissing)</span>
<span class="fc" id="L1087">	m_Missing.setInputFormat(instances);</span>
      
<span class="pc bpc" id="L1089" title="2 of 3 branches missed.">      switch (m_Preprocessing) {</span>
	case PREPROCESSING_CENTER:
<span class="fc" id="L1091">	  m_ClassMean   = instances.meanOrMode(instances.classIndex());</span>
<span class="fc" id="L1092">	  m_ClassStdDev = 1;</span>
<span class="fc" id="L1093">	  m_Filter      = new Center();</span>
<span class="fc" id="L1094">	  ((Center) m_Filter).setIgnoreClass(true);</span>
<span class="fc" id="L1095">      	  break;</span>
	case PREPROCESSING_STANDARDIZE:
<span class="nc" id="L1097">	  m_ClassMean   = instances.meanOrMode(instances.classIndex());</span>
<span class="nc" id="L1098">	  m_ClassStdDev = StrictMath.sqrt(instances.variance(instances.classIndex()));</span>
<span class="nc" id="L1099">	  m_Filter      = new Standardize();</span>
<span class="nc" id="L1100">	  ((Standardize) m_Filter).setIgnoreClass(true);</span>
<span class="nc" id="L1101">      	  break;</span>
	default:
<span class="nc" id="L1103">  	  m_ClassMean   = 0;</span>
<span class="nc" id="L1104">	  m_ClassStdDev = 1;</span>
<span class="nc" id="L1105">	  m_Filter      = null;</span>
      }
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">      if (m_Filter != null)</span>
<span class="fc" id="L1108">	m_Filter.setInputFormat(instances);</span>
    }
    
    // filter data
<span class="pc bpc" id="L1112" title="1 of 2 branches missed.">    if (m_ReplaceMissing)</span>
<span class="fc" id="L1113">      instances = Filter.useFilter(instances, m_Missing);</span>
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">    if (m_Filter != null)</span>
<span class="fc" id="L1115">      instances = Filter.useFilter(instances, m_Filter);</span>
    
<span class="pc bpc" id="L1117" title="2 of 3 branches missed.">    switch (m_Algorithm) {</span>
      case ALGORITHM_SIMPLS:
<span class="fc" id="L1119">	result = processSIMPLS(instances);</span>
<span class="fc" id="L1120">	break;</span>
      case ALGORITHM_PLS1:
<span class="nc" id="L1122">	result = processPLS1(instances);</span>
<span class="nc" id="L1123">	break;</span>
      default:
<span class="nc" id="L1125">	throw new IllegalStateException(</span>
<span class="nc" id="L1126">	    &quot;Algorithm type '&quot; + m_Algorithm + &quot;' is not recognized!&quot;);</span>
    }

    // add the mean to the class again if predictions are to be performed,
    // otherwise restore original class values
<span class="fc bfc" id="L1131" title="All 2 branches covered.">    for (i = 0; i &lt; result.numInstances(); i++) {</span>
<span class="fc bfc" id="L1132" title="All 2 branches covered.">      if (!getPerformPrediction()) {</span>
<span class="fc" id="L1133">	result.instance(i).setClassValue(clsValues[i]);</span>
      }
      else {
<span class="fc" id="L1136">	clsValue = result.instance(i).classValue();</span>
<span class="fc" id="L1137">	result.instance(i).setClassValue(clsValue*m_ClassStdDev + m_ClassMean);</span>
      }
    }
    
<span class="fc" id="L1141">    return result;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1150">    return RevisionUtils.extract(&quot;$Revision: 5541 $&quot;);</span>
  }

  /**
   * runs the filter with the given arguments.
   *
   * @param args      the commandline arguments
   */
  public static void main(String[] args) {
<span class="nc" id="L1159">    runFilter(new PLSFilter(), args);</span>
<span class="nc" id="L1160">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>