<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Rule.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.associations.tertius</a> &gt; <span class="el_source">Rule.java</span></div><h1>Rule.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    Rule.java
 *    Copyright (C) 2003 Peter A. Flach, Nicolas Lachiche
 *
 *    Thanks to Amelie Deltour for porting the original C code to Java
 *    and integrating it into Weka.
 */

package weka.associations.tertius;

import weka.core.Instance;
import weka.core.Instances;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;

import java.io.Serializable;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;

/**
 * Class representing a rule with a body and a head.
 *
 * @author  &lt;a href=&quot;mailto:adeltour@netcourrier.com&quot;&gt;Amelie Deltour&lt;/a&gt;
 * @version $Revision: 1.7 $
 */

<span class="nc" id="L45">public class Rule</span>
  implements Serializable, Cloneable, RevisionHandler {

  /** for serialization */
  private static final long serialVersionUID = -7763378359090435505L;

  /** The body of the rule. */
  private Body m_body;

  /** The head of the rule. */
  private Head m_head;

  /** Can repeat predicates in the rule ? */
  private boolean m_repeatPredicate;

  /** Maximal number of literals in the rule. */
  private int m_maxLiterals;

  /** Can there be negations in the body ? */
  private boolean m_negBody;

  /** Can there be negations in the head ? */
  private boolean m_negHead;

  /** Is this rule a classification rule ? */
  private boolean m_classRule;

  /** Can there be only one literal in the head ? */
  private boolean m_singleHead;

  /** Number of instances in the data this rule deals with. */
  private int m_numInstances;

  /** Set of counter-instances of this rule. */
  private ArrayList m_counterInstances;

  /** Counter for the counter-instances of this rule. */
  private int m_counter;

  /** Confirmation of this rule. */
  private double m_confirmation;

  /** Optimistic estimate of this rule. */
  private double m_optimistic;

  /**
   * Constructor for a rule when the counter-instances are not stored,
   * giving all the constraints applied to this rule.
   * 
   * @param repeatPredicate True if predicates can be repeated.
   * @param maxLiterals Maximum number of literals.
   * @param negBody True if negation is allowed in the body.
   * @param negHead True if negation is allowed in the head. 
   * @param classRule True if the rule is a classification rule.
   * @param horn True if the rule is a horn clause.
   */
<span class="nc" id="L101">  public Rule(boolean repeatPredicate, int maxLiterals, boolean negBody, </span>
      boolean negHead, boolean classRule, boolean horn) {

<span class="nc" id="L104">    m_body = new Body();</span>
<span class="nc" id="L105">    m_head = new Head();</span>
<span class="nc" id="L106">    m_repeatPredicate = repeatPredicate;</span>
<span class="nc" id="L107">    m_maxLiterals = maxLiterals;</span>
<span class="nc bnc" id="L108" title="All 4 branches missed.">    m_negBody = negBody &amp;&amp; !horn;</span>
<span class="nc bnc" id="L109" title="All 4 branches missed.">    m_negHead = negHead &amp;&amp; !horn;</span>
<span class="nc" id="L110">    m_classRule = classRule;</span>
<span class="nc bnc" id="L111" title="All 4 branches missed.">    m_singleHead = classRule || horn;</span>
<span class="nc" id="L112">  }</span>

  /**
   * Constructor for a rule when the counter-instances are stored,
   * giving all the constraints applied to this rule.
   * The counter-instances are initialized to all the instances in the dataset.
   * 
   * @param instances The dataset.
   * @param repeatPredicate True if predicates can be repeated.
   * @param maxLiterals Maximum number of literals.
   * @param negBody True if negation is allowed in the body.
   * @param negHead True if negation is allowed in the head. 
   * @param classRule True if the rule is a classification rule.
   * @param horn True if the rule is a horn clause.
   */
<span class="nc" id="L127">  public Rule(Instances instances,</span>
      boolean repeatPredicate, int maxLiterals, boolean negBody, 
      boolean negHead, boolean classRule, boolean horn) {

<span class="nc" id="L131">    m_body = new Body(instances);</span>
<span class="nc" id="L132">    m_head = new Head(instances);</span>
<span class="nc" id="L133">    m_repeatPredicate = repeatPredicate;</span>
<span class="nc" id="L134">    m_maxLiterals = maxLiterals;</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">    m_negBody = negBody &amp;&amp; !horn;</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">    m_negHead = negHead &amp;&amp; !horn;</span>
<span class="nc" id="L137">    m_classRule = classRule;</span>
<span class="nc bnc" id="L138" title="All 4 branches missed.">    m_singleHead = classRule || horn;</span>
<span class="nc" id="L139">    m_numInstances = instances.numInstances();</span>
<span class="nc" id="L140">    m_counterInstances = new ArrayList(m_numInstances);</span>
<span class="nc" id="L141">    Enumeration enu = instances.enumerateInstances();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">    while (enu.hasMoreElements()) {</span>
<span class="nc" id="L143">      m_counterInstances.add(enu.nextElement());</span>
    }
<span class="nc" id="L145">  }</span>

  /**
   * Returns a shallow copy of this rule.
   * The structured is copied but the literals themselves are not copied.
   *
   * @return A copy of this Rule.
   */
  public Object clone() {

<span class="nc" id="L155">    Object result = null;</span>
    try {
<span class="nc" id="L157">      result = super.clone();</span>
      /* Clone the body and the head. */
<span class="nc" id="L159">      ((Rule) result).m_body = (Body) m_body.clone();</span>
<span class="nc" id="L160">      ((Rule) result).m_head = (Head) m_head.clone();</span>
      /* Clone the set of counter-instances. */
<span class="nc bnc" id="L162" title="All 2 branches missed.">      if (m_counterInstances != null) {</span>
<span class="nc" id="L163">	((Rule) result).m_counterInstances</span>
<span class="nc" id="L164">	= (ArrayList) m_counterInstances.clone();</span>
      }
<span class="nc" id="L166">    } catch (Exception e) {</span>
      /* An exception is not supposed to happen here. */
<span class="nc" id="L168">      e.printStackTrace();</span>
<span class="nc" id="L169">      System.exit(0);</span>
    }
<span class="nc" id="L171">    return result;</span>
  }

  /**
   * Test if an instance is a counter-instance of this rule.
   * 
   * @param instance The instance to test.
   * @return True if the instance is a counter-instance.
   */
  public boolean counterInstance(Instance instance) {

<span class="nc bnc" id="L182" title="All 2 branches missed.">    return ((m_body.counterInstance(instance) </span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">	&amp;&amp; m_head.counterInstance(instance)));</span>
  }

  /**
   * Update the number of counter-instances of this rule in the dataset.
   * This method should be used is the rule does not store its counter-instances.
   *
   * @param instances The dataset.
   */
  public void upDate(Instances instances) {

<span class="nc" id="L194">    Enumeration enu = instances.enumerateInstances();</span>
<span class="nc" id="L195">    m_numInstances = instances.numInstances();</span>
<span class="nc" id="L196">    m_counter = 0;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">    while (enu.hasMoreElements()) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">      if (this.counterInstance((Instance) enu.nextElement())) {</span>
<span class="nc" id="L199">	m_counter++;</span>
      }
    }
<span class="nc" id="L202">    m_head.upDate(instances);</span>
<span class="nc" id="L203">    m_body.upDate(instances);</span>
<span class="nc" id="L204">  }</span>

  /**
   * Get the confirmation value of this rule.
   *
   * @return The confirmation.
   */
  public double getConfirmation() {

<span class="nc" id="L213">    return m_confirmation;</span>
  }

  /**
   * Get the optimistic estimate of the confirmation obtained by refining
   * this rule.
   * 
   * @return The optimistic estimate.
   */
  public double getOptimistic() {

<span class="nc" id="L224">    return m_optimistic;</span>
  }

  /*
   * Get the expected number of counter-instances of this rule,
   * calculated from the number of instances satisfying the body and
   * the number of instances satisfying the negation of the head.
   *
   * @return The expected number of counter-instances.
   */
  public double getExpectedNumber() {

<span class="nc" id="L236">    return (double) m_body.getCounterInstancesNumber() </span>
<span class="nc" id="L237">    * (double) m_head.getCounterInstancesNumber() </span>
<span class="nc" id="L238">    / (double) m_numInstances;</span>
  }

  /**
   * Get the expected frequency of counter-instances of this rule.
   *
   * @return The expected frequency of counter-instances.
   */
  public double getExpectedFrequency() {

<span class="nc" id="L248">    return getExpectedNumber() / (double) m_numInstances;</span>
  }

  /**
   * Get the observed number of counter-instances of this rule in the dataset.
   *
   * @return The observed number of counter-instances.
   */
  public int getObservedNumber() {

<span class="nc bnc" id="L258" title="All 2 branches missed.">    if (m_counterInstances != null) {</span>
<span class="nc" id="L259">      return m_counterInstances.size();</span>
    } else {
<span class="nc" id="L261">      return m_counter;</span>
    }
  }

  /**
   * Get the observed frequency of counter-instances of this rule in the dataset.
   * 
   * @return The expected frequency of counter-instances.
   */
  public double getObservedFrequency() {

<span class="nc" id="L272">    return (double) getObservedNumber() / (double) m_numInstances;</span>
  }

  /**
   * Get the rate of True Positive instances of this rule.
   *
   * @return The TP-rate.
   */
  public double getTPRate() {

<span class="nc" id="L282">    int tp = m_body.getCounterInstancesNumber() - getObservedNumber();</span>
<span class="nc" id="L283">    int fn = m_numInstances - m_head.getCounterInstancesNumber() - tp;</span>
<span class="nc" id="L284">    return ((double) tp / (double) (tp + fn));</span>
  }

  /**
   * Get the rate of False Positive instances of this rule.
   *
   * @return The FP-rate.
   */
  public double getFPRate() {

<span class="nc" id="L294">    int fp = getObservedNumber();</span>
<span class="nc" id="L295">    int tn = m_head.getCounterInstancesNumber() - fp;</span>
<span class="nc" id="L296">    return ((double) fp / (double) (fp + tn));</span>
  }

  /**
   * Calculate the confirmation of this rule.
   */
  public void calculateConfirmation() {

<span class="nc" id="L304">    double expected = getExpectedFrequency();</span>
<span class="nc" id="L305">    double observed = getObservedFrequency();</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">    if ((expected == 0) || (expected == 1)) {</span>
<span class="nc" id="L307">      m_confirmation = 0;</span>
    } else {
<span class="nc" id="L309">      m_confirmation = (expected - observed) / (Math.sqrt(expected) - expected);</span>
    }
<span class="nc" id="L311">  }</span>

  /**
   * Calculate the optimistic estimate of this rule.
   */
  public void calculateOptimistic() {

<span class="nc" id="L318">    int counterInstances = this.getObservedNumber();</span>
<span class="nc" id="L319">    int body = m_body.getCounterInstancesNumber();</span>
<span class="nc" id="L320">    int notHead = m_head.getCounterInstancesNumber();</span>
<span class="nc" id="L321">    int n = m_numInstances;</span>
    double expectedOptimistic;
    /* optimistic expected number of counter-instances */
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (counterInstances &lt;= body - notHead) {</span>
<span class="nc" id="L325">      expectedOptimistic = (double) (notHead * (body - counterInstances)) </span>
<span class="nc" id="L326">      / (double) (n * n);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">    } else if (counterInstances &lt;= notHead - body) {</span>
<span class="nc" id="L328">      expectedOptimistic = (double) (body * (notHead - counterInstances)) </span>
<span class="nc" id="L329">      / (double) (n * n);</span>
    } else {
<span class="nc" id="L331">      expectedOptimistic = (double) ((notHead + body - counterInstances)</span>
<span class="nc" id="L332">	  * (notHead + body - counterInstances)) </span>
<span class="nc" id="L333">	  / (double) (4 * n * n);</span>
    }
<span class="nc bnc" id="L335" title="All 4 branches missed.">    if ((expectedOptimistic == 0) || (expectedOptimistic == 1)) {</span>
<span class="nc" id="L336">      m_optimistic = 0;</span>
    } else {
<span class="nc" id="L338">      m_optimistic = expectedOptimistic </span>
<span class="nc" id="L339">      / (Math.sqrt(expectedOptimistic) - expectedOptimistic);</span>
    }
<span class="nc" id="L341">  }</span>

  /**
   * Test if this rule is empty.
   * 
   * @return True if it is the empty rule.
   */
  public boolean isEmpty() {

<span class="nc bnc" id="L350" title="All 4 branches missed.">    return (m_head.isEmpty() &amp;&amp; m_body.isEmpty());</span>
  }

  /**
   * Give the number of literals in this rule.
   * 
   * @return The number of literals.
   */
  public int numLiterals() {

<span class="nc" id="L360">    return m_body.numLiterals() + m_head.numLiterals();</span>
  }

  /**
   * Add a literal to the body of the rule.
   *
   * @param newLit The literal to add.
   * @return The rule obtained by adding the literal, null if the literal can
   * not be added because of the constraints on the rule.
   */
  private Rule addTermToBody(Literal newLit) {

<span class="nc bnc" id="L372" title="All 4 branches missed.">    if (!m_negBody &amp;&amp; newLit.negative()</span>
<span class="nc bnc" id="L373" title="All 4 branches missed.">	|| (m_classRule &amp;&amp; newLit.getPredicate().isClass())</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">	|| (newLit instanceof IndividualLiteral</span>
<span class="nc" id="L375">	    &amp;&amp; (((IndividualLiteral) newLit).getType() </span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">		- m_body.getType()) &gt; 1</span>
<span class="nc" id="L377">		&amp;&amp; (((IndividualLiteral) newLit).getType() </span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">		    - m_head.getType()) &gt; 1)) {</span>
<span class="nc" id="L379">      return null;</span>
    } else {
<span class="nc" id="L381">      Rule result = (Rule) this.clone();</span>
<span class="nc" id="L382">      result.m_body.addElement(newLit);</span>
      /* Update the counter-instances. */
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (m_counterInstances != null) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">	for (int i = result.m_counterInstances.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L386">	  Instance current = (Instance) result.m_counterInstances.get(i);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">	  if (!result.m_body.canKeep(current, newLit)) {</span>
<span class="nc" id="L388">	    result.m_counterInstances.remove(i);</span>
	  }
	}
      }
<span class="nc" id="L392">      return result;</span>
    }
  }

  /**
   * Add a literal to the head of the rule.
   *
   * @param newLit The literal to add.
   * @return The rule obtained by adding the literal, null if the literal can
   * not be added because of the constraints on the rule.
   */
  private Rule addTermToHead(Literal newLit) {
<span class="nc bnc" id="L404" title="All 4 branches missed.">    if ((!m_negHead &amp;&amp; newLit.negative())</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">	|| (m_classRule &amp;&amp; !newLit.getPredicate().isClass()) </span>
<span class="nc bnc" id="L406" title="All 4 branches missed.">	|| (m_singleHead &amp;&amp; !m_head.isEmpty())</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">	|| (newLit instanceof IndividualLiteral</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">	    &amp;&amp; ((IndividualLiteral) newLit).getType() </span>
<span class="nc" id="L409">	    != IndividualLiteral.INDIVIDUAL_PROPERTY)) {</span>
<span class="nc" id="L410">      return null;</span>
    } else { 
<span class="nc" id="L412">      Rule result = (Rule) this.clone();</span>
<span class="nc" id="L413">      result.m_head.addElement(newLit);</span>
      /* Update counter-instances. */
<span class="nc bnc" id="L415" title="All 2 branches missed.">      if (m_counterInstances != null) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">	for (int i = result.m_counterInstances.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L417">	  Instance current = (Instance) result.m_counterInstances.get(i);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">	  if (!result.m_head.canKeep(current, newLit)) {</span>
<span class="nc" id="L419">	    result.m_counterInstances.remove(i);</span>
	  }
	}
      }
<span class="nc" id="L423">      return result;</span>
    }
  }

  /**
   * Refine a rule by adding a range of literals of a predicate, either to
   * the head or to the body of the rule.
   * 
   * @param pred The predicate to consider.
   * @param firstIndex The index of the first literal of the predicate to add.
   * @param lastIndex The index of the last literal of the predicate to add.
   * @param addTobody True if the literals should be added to the body.
   * @param addToHead True if the literals should be added to the head.
   * @return A list of rules obtained by refinement.
   */
  private SimpleLinkedList refine(Predicate pred, int firstIndex, int lastIndex, 
      boolean addToBody, boolean addToHead) {

<span class="nc" id="L441">    SimpleLinkedList result = new SimpleLinkedList();</span>
    Literal currentLit;
    Literal negation;
    Rule refinement;
<span class="nc bnc" id="L445" title="All 2 branches missed.">    for (int i = firstIndex; i &lt; lastIndex; i++) {</span>
<span class="nc" id="L446">      currentLit = pred.getLiteral(i);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">      if (addToBody) {</span>
<span class="nc" id="L448">	refinement = addTermToBody(currentLit);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">	if (refinement != null) {</span>
<span class="nc" id="L450">	  result.add(refinement);</span>
	}
      }
<span class="nc bnc" id="L453" title="All 2 branches missed.">      if (addToHead) {</span>
<span class="nc" id="L454">	refinement = addTermToHead(currentLit);</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">	if (refinement != null) {</span>
<span class="nc" id="L456">	  result.add(refinement);</span>
	}
      }
<span class="nc" id="L459">      negation = currentLit.getNegation();</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">      if (negation != null) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">	if (addToBody) {</span>
<span class="nc" id="L462">	  refinement = addTermToBody(negation);</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">	  if (refinement != null) {</span>
<span class="nc" id="L464">	    result.add(refinement);</span>
	  }
	}
<span class="nc bnc" id="L467" title="All 2 branches missed.">	if (addToHead) {</span>
<span class="nc" id="L468">	  refinement = addTermToHead(negation);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">	  if (refinement != null) {</span>
<span class="nc" id="L470">	    result.add(refinement);</span>
	  }
	}
      }
    }
<span class="nc" id="L475">    return result;</span>
  }

  /**
   * Refine a rule by adding literal from a set of predictes.
   * 
   * @param predicates The predicates available.
   * @return The list of the children obtained by refining the rule.
   */
  public SimpleLinkedList refine(ArrayList predicates) {

<span class="nc" id="L486">    SimpleLinkedList result = new SimpleLinkedList();</span>
    Predicate currentPred;
    boolean addToBody;
    boolean addToHead;

<span class="nc bnc" id="L491" title="All 2 branches missed.">    if (this.numLiterals() == m_maxLiterals) {</span>
<span class="nc" id="L492">      return result;</span>
    }

<span class="nc bnc" id="L495" title="All 2 branches missed.">    if (this.isEmpty()) {</span>
      /* Literals can be added on both sides of the rule. */
<span class="nc bnc" id="L497" title="All 2 branches missed.">      for (int i = 0; i &lt; predicates.size(); i++) {</span>
<span class="nc" id="L498">	currentPred = (Predicate) predicates.get(i);</span>
<span class="nc" id="L499">	result.addAll(refine(currentPred,</span>
<span class="nc" id="L500">	    0, currentPred.numLiterals(),</span>
<span class="nc" id="L501">	    true, true));</span>
      }
<span class="nc bnc" id="L503" title="All 4 branches missed.">    } else if (m_body.isEmpty() || m_head.isEmpty()) {</span>
      /* Literals can be added to the empty side only. */
      LiteralSet side;
      Literal last;
<span class="nc bnc" id="L507" title="All 2 branches missed.">      if (m_body.isEmpty()) {</span>
<span class="nc" id="L508">	side = m_head;</span>
<span class="nc" id="L509">	addToBody = true;</span>
<span class="nc" id="L510">	addToHead = false;</span>
      } else { // m_head.isEmpty()
<span class="nc" id="L512">	side = m_body;</span>
<span class="nc" id="L513">	addToBody = false;</span>
<span class="nc" id="L514">	addToHead = true;</span>
      }
<span class="nc" id="L516">      last = side.getLastLiteral();</span>
<span class="nc" id="L517">      currentPred = last.getPredicate();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">      if (m_repeatPredicate) {</span>
<span class="nc" id="L519">	result.addAll(refine(currentPred,</span>
<span class="nc" id="L520">	    currentPred.indexOf(last) + 1, </span>
<span class="nc" id="L521">	    currentPred.numLiterals(),</span>
<span class="nc" id="L522">	    addToBody, addToHead));</span>
      }
<span class="nc bnc" id="L524" title="All 2 branches missed.">      for (int i = predicates.indexOf(currentPred) + 1; i &lt; predicates.size(); </span>
<span class="nc" id="L525">      i++) {</span>
<span class="nc" id="L526">	currentPred = (Predicate) predicates.get(i);</span>
<span class="nc" id="L527">	result.addAll(refine(currentPred,</span>
<span class="nc" id="L528">	    0, currentPred.numLiterals(),</span>
<span class="nc" id="L529">	    addToBody, addToHead));		</span>
      }
    } else {
<span class="nc" id="L532">      Literal lastLitBody = m_body.getLastLiteral();</span>
<span class="nc" id="L533">      Literal lastLitHead = m_head.getLastLiteral();</span>
<span class="nc" id="L534">      Predicate lastPredBody = lastLitBody.getPredicate();</span>
<span class="nc" id="L535">      Predicate lastPredHead = lastLitHead.getPredicate();</span>
<span class="nc" id="L536">      int lastLitBodyIndex = lastPredBody.indexOf(lastLitBody);</span>
<span class="nc" id="L537">      int lastLitHeadIndex = lastPredHead.indexOf(lastLitHead);</span>
<span class="nc" id="L538">      int lastPredBodyIndex = predicates.indexOf(lastPredBody);</span>
<span class="nc" id="L539">      int lastPredHeadIndex = predicates.indexOf(lastPredHead);</span>
      Predicate inferiorPred;
      Predicate superiorPred;
      int inferiorLit;
      int superiorLit;
<span class="nc bnc" id="L544" title="All 2 branches missed.">      addToBody = (m_head.numLiterals() == 1</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">	  &amp;&amp; (lastPredBodyIndex &lt; lastPredHeadIndex </span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">	      || (lastPredBodyIndex == lastPredHeadIndex </span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">		  &amp;&amp; lastLitBodyIndex &lt; lastLitHeadIndex)));</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">      addToHead = (m_body.numLiterals() == 1</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">	  &amp;&amp; (lastPredHeadIndex &lt; lastPredBodyIndex</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">	      || (lastPredHeadIndex == lastPredBodyIndex</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">		  &amp;&amp; lastLitHeadIndex &lt; lastLitBodyIndex)));      </span>
<span class="nc bnc" id="L552" title="All 4 branches missed.">      if (addToBody || addToHead) {</span>
	/* Add literals in the gap between the body and the head. */
<span class="nc bnc" id="L554" title="All 2 branches missed.">	if (addToBody) {</span>
<span class="nc" id="L555">	  inferiorPred = lastPredBody;</span>
<span class="nc" id="L556">	  inferiorLit = lastLitBodyIndex;</span>
<span class="nc" id="L557">	  superiorPred = lastPredHead;</span>
<span class="nc" id="L558">	  superiorLit = lastLitHeadIndex;</span>
	} else { // addToHead
<span class="nc" id="L560">	  inferiorPred = lastPredHead;</span>
<span class="nc" id="L561">	  inferiorLit = lastLitHeadIndex;</span>
<span class="nc" id="L562">	  superiorPred = lastPredBody;</span>
<span class="nc" id="L563">	  superiorLit = lastLitBodyIndex;</span>
	}
<span class="nc" id="L565">	if (predicates.indexOf(inferiorPred) </span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">	    &lt; predicates.indexOf(superiorPred)) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">	  if (m_repeatPredicate) {</span>
<span class="nc" id="L568">	    result.addAll(refine(inferiorPred, </span>
<span class="nc" id="L569">		inferiorLit + 1, inferiorPred.numLiterals(),</span>
<span class="nc" id="L570">		addToBody, addToHead));</span>
	  }
<span class="nc" id="L572">	  for (int j = predicates.indexOf(inferiorPred) + 1; </span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">	  j &lt; predicates.indexOf(superiorPred); j++) {</span>
<span class="nc" id="L574">	    currentPred = (Predicate) predicates.get(j);</span>
<span class="nc" id="L575">	    result.addAll(refine(currentPred,</span>
<span class="nc" id="L576">		0, currentPred.numLiterals(),</span>
<span class="nc" id="L577">		addToBody, addToHead));</span>
	  }
<span class="nc bnc" id="L579" title="All 2 branches missed.">	  if (m_repeatPredicate) {</span>
<span class="nc" id="L580">	    result.addAll(refine(superiorPred,</span>
<span class="nc" id="L581">		0, superiorLit,</span>
<span class="nc" id="L582">		addToBody, addToHead));</span>
	  }
	} else { 
	  //((inferiorPred.getIndex() == superiorPred.getIndex())
	  //&amp;&amp; (inferiorLit &lt; superiorLit))
<span class="nc bnc" id="L587" title="All 2 branches missed.">	  if (m_repeatPredicate) {</span>
<span class="nc" id="L588">	    result.addAll(refine(inferiorPred,</span>
<span class="nc" id="L589">		inferiorLit + 1, superiorLit,</span>
<span class="nc" id="L590">		addToBody, addToHead));</span>
	  }
	}	
      }	
      /* Add other literals. */
<span class="nc bnc" id="L595" title="All 2 branches missed.">      if (predicates.indexOf(lastPredBody) &gt; predicates.indexOf(lastPredHead)) {</span>
<span class="nc" id="L596">	superiorPred = lastPredBody;</span>
<span class="nc" id="L597">	superiorLit = lastPredBody.indexOf(lastLitBody);</span>
<span class="nc" id="L598">      } else if (predicates.indexOf(lastPredBody) </span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">	  &lt; predicates.indexOf(lastPredHead)) {</span>
<span class="nc" id="L600">	superiorPred = lastPredHead;</span>
<span class="nc" id="L601">	superiorLit = lastPredHead.indexOf(lastLitHead);</span>
      } else {
<span class="nc" id="L603">	superiorPred = lastPredBody;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">	if (lastLitBodyIndex &gt; lastLitHeadIndex) {</span>
<span class="nc" id="L605">	  superiorLit = lastPredBody.indexOf(lastLitBody);</span>
	} else {
<span class="nc" id="L607">	  superiorLit = lastPredHead.indexOf(lastLitHead);</span>
	}
      }
<span class="nc bnc" id="L610" title="All 2 branches missed.">      if (m_repeatPredicate) {</span>
<span class="nc" id="L611">	result.addAll(refine(superiorPred,</span>
<span class="nc" id="L612">	    superiorLit + 1, superiorPred.numLiterals(),</span>
<span class="nc" id="L613">	    true, true));</span>
      }
<span class="nc bnc" id="L615" title="All 2 branches missed.">      for (int j = predicates.indexOf(superiorPred) + 1; j &lt; predicates.size(); </span>
<span class="nc" id="L616">      j++) {</span>
<span class="nc" id="L617">	currentPred = (Predicate) predicates.get(j);</span>
<span class="nc" id="L618">	result.addAll(refine(currentPred,</span>
<span class="nc" id="L619">	    0, currentPred.numLiterals(),</span>
<span class="nc" id="L620">	    true, true));</span>
      }
    }
<span class="nc" id="L623">    return result;</span>
  }

  /**
   * Test if this rule subsumes another rule.
   *
   * @param otherRule The other rule.
   * @return True if the other rule is subsumed.
   */
  public boolean subsumes(Rule otherRule) {    

<span class="nc bnc" id="L634" title="All 2 branches missed.">    if (this.numLiterals() &gt; otherRule.numLiterals()) {</span>
<span class="nc" id="L635">      return false;</span>
    }
<span class="nc bnc" id="L637" title="All 4 branches missed.">    return (m_body.isIncludedIn(otherRule) &amp;&amp; m_head.isIncludedIn(otherRule));</span>
  }

  /**
   * Test if this rule and another rule correspond to the same clause.
   *
   * @param otherRule The other rule.
   * @return True if both rules correspond to the same clause.
   */
  public boolean sameClauseAs(Rule otherRule) {

<span class="nc bnc" id="L648" title="All 2 branches missed.">    return (this.numLiterals() == otherRule.numLiterals()</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">	&amp;&amp; this.subsumes(otherRule));</span>
  }

  /**
   * Test if this rule is equivalent to another rule.
   *
   * @param otherRule The other rule.
   * @return True if both rules are equivalent.
   */
  public boolean equivalentTo(Rule otherRule) {

<span class="nc bnc" id="L660" title="All 2 branches missed.">    return (this.numLiterals() == otherRule.numLiterals()</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">	&amp;&amp; m_head.negationIncludedIn(otherRule.m_body)</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">	&amp;&amp; m_body.negationIncludedIn(otherRule.m_head));</span>
  }

  /**
   * Test if the body of the rule contains a literal.
   * 
   * @param lit The literal to look for.
   * @return True if the literal is contained in the body of the rule.
   */
  public boolean bodyContains(Literal lit) {

<span class="nc" id="L673">    return m_body.contains(lit);</span>
  }

  /**
   * Test if the head of the rule contains a literal.
   * 
   * @param lit The literal to look for.
   * @return True if the literal is contained in the head of the rule.
   */
  public boolean headContains(Literal lit) {

<span class="nc" id="L684">    return m_head.contains(lit);</span>
  }

  /**
   * Test if this rule is over the frequency threshold.
   *
   * @param minFrequency The frequency threshold.
   * @return True if the rule is over the threshold.
   */
  public boolean overFrequencyThreshold(double minFrequency) {

<span class="nc bnc" id="L695" title="All 2 branches missed.">    return (m_body.overFrequencyThreshold(minFrequency) </span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">	&amp;&amp; m_head.overFrequencyThreshold(minFrequency));</span>
  }

  /**
   * Test if the body of the rule is true.
   *
   * @return True if the body is always satisfied.
   */
  public boolean hasTrueBody() {

<span class="nc bnc" id="L706" title="All 2 branches missed.">    return (!m_body.isEmpty()</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">	&amp;&amp; m_body.hasMaxCounterInstances());</span>
  }

  /**
   * Test if the head of the rule is false.
   *
   * @return True if the body is never satisfied.
   */
  public boolean hasFalseHead() {

<span class="nc bnc" id="L717" title="All 2 branches missed.">    return (!m_head.isEmpty()</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">	&amp;&amp; m_head.hasMaxCounterInstances());</span>
  }

  /**
   * Return a String giving the confirmation and optimistic estimate of 
   * this rule.
   * 
   * @return A String with the values of the rule.
   */
  public String valuesToString() {

<span class="nc" id="L729">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L730">    DecimalFormat decimalFormat = new DecimalFormat(&quot;0.000000&quot;);</span>
<span class="nc" id="L731">    text.append(decimalFormat.format(getConfirmation()));</span>
<span class="nc" id="L732">    text.append(&quot; &quot;);</span>
<span class="nc" id="L733">    text.append(decimalFormat.format(getObservedFrequency()));</span>
<span class="nc" id="L734">    return text.toString();</span>
  }

  /**
   * Return a String giving the TP-rate and FP-rate of 
   * this rule.
   * 
   * @return A String with the values of the rule.
   */
  public String rocToString() {

<span class="nc" id="L745">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L746">    DecimalFormat decimalFormat = new DecimalFormat(&quot;0.000000&quot;);</span>
<span class="nc" id="L747">    text.append(decimalFormat.format(getConfirmation()));</span>
<span class="nc" id="L748">    text.append(&quot; &quot;);</span>
<span class="nc" id="L749">    text.append(decimalFormat.format(getTPRate()));</span>
<span class="nc" id="L750">    text.append(&quot; &quot;);</span>
<span class="nc" id="L751">    text.append(decimalFormat.format(getFPRate()));</span>
<span class="nc" id="L752">    return text.toString();</span>
  }

  /**
   * Retrun a String for this rule.
   *
   * @return The String describing this rule.
   */
  public String toString() {

<span class="nc" id="L762">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L763">    text.append(m_body.toString());</span>
<span class="nc" id="L764">    text.append(&quot; ==&gt; &quot;);</span>
<span class="nc" id="L765">    text.append(m_head.toString());</span>
<span class="nc" id="L766">    return text.toString();</span>
  }

  /**
   * Comparator used to compare two rules according to their confirmation value.
   */
<span class="nc" id="L772">  public static Comparator confirmationComparator = new Comparator() {</span>

    public int compare(Object o1, Object o2) {

<span class="nc" id="L776">      Rule r1 = (Rule) o1;</span>
<span class="nc" id="L777">      Rule r2 = (Rule) o2;</span>
<span class="nc" id="L778">      double conf1 = r1.getConfirmation();</span>
<span class="nc" id="L779">      double conf2 = r2.getConfirmation();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">      if (conf1 &gt; conf2) {</span>
<span class="nc" id="L781">	return -1;</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">      } else if (conf1 &lt; conf2) {</span>
<span class="nc" id="L783">	return 1;</span>
      } else {
<span class="nc" id="L785">	return 0;</span>
      }
    }
  };

  /**
   * Comparator used to compare two rules according to their observed number
   * of counter-instances.
   */
<span class="nc" id="L794">  public static Comparator observedComparator = new Comparator() {</span>

    public int compare(Object o1, Object o2) {

<span class="nc" id="L798">      Rule r1 = (Rule) o1;</span>
<span class="nc" id="L799">      Rule r2 = (Rule) o2;</span>
<span class="nc" id="L800">      double obs1 = r1.getObservedFrequency();</span>
<span class="nc" id="L801">      double obs2 = r2.getObservedFrequency();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">      if (obs1 &lt; obs2) {</span>
<span class="nc" id="L803">	return -1;</span>
<span class="nc bnc" id="L804" title="All 2 branches missed.">      } else if (obs1 &gt; obs2) {</span>
<span class="nc" id="L805">	return 1;</span>
      } else {
<span class="nc" id="L807">	return 0;</span>
      }
    }
  };

  /**
   * Comparator used to compare two rules according to their optimistic estimate.
   */
<span class="nc" id="L815">  public static Comparator optimisticComparator = new Comparator() {</span>

    public int compare(Object o1, Object o2) {

<span class="nc" id="L819">      Rule r1 = (Rule) o1;</span>
<span class="nc" id="L820">      Rule r2 = (Rule) o2;</span>
<span class="nc" id="L821">      double opt1 = r1.getOptimistic();</span>
<span class="nc" id="L822">      double opt2 = r2.getOptimistic();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (opt1 &gt; opt2) {</span>
<span class="nc" id="L824">	return -1;</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">      } else if (opt1 &lt; opt2) {</span>
<span class="nc" id="L826">	return 1;</span>
      } else {
<span class="nc" id="L828">	return 0;</span>
      }
    }
  };

  /**
   * Comparator used to compare two rules according to their confirmation and 
   * then their observed number of counter-instances.
   */
<span class="nc" id="L837">  public static Comparator confirmationThenObservedComparator = new Comparator() {</span>
    public int compare(Object o1, Object o2) {

<span class="nc" id="L840">      int confirmationComparison = confirmationComparator.compare(o1, o2);</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">      if (confirmationComparison != 0) {</span>
<span class="nc" id="L842">	return confirmationComparison;</span>
      } else {
<span class="nc" id="L844">	return observedComparator.compare(o1, o2);</span>
      }
    }
  };

  /**
   * Comparator used to compare two rules according to their optimistic estimate
   * and then their observed number of counter-instances.
   */
<span class="nc" id="L853">  public static Comparator optimisticThenObservedComparator = new Comparator() {</span>
    public int compare(Object o1, Object o2) {
<span class="nc" id="L855">      int optimisticComparison = optimisticComparator.compare(o1, o2);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">      if (optimisticComparison != 0) {</span>
<span class="nc" id="L857">	return optimisticComparison;</span>
      } else {
<span class="nc" id="L859">	return observedComparator.compare(o1, o2);</span>
      }
    }
  };

  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L870">    return RevisionUtils.extract(&quot;$Revision: 1.7 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>