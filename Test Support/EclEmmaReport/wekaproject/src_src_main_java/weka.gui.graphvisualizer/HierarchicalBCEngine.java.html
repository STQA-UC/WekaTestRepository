<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>HierarchicalBCEngine.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.gui.graphvisualizer</a> &gt; <span class="el_source">HierarchicalBCEngine.java</span></div><h1>HierarchicalBCEngine.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    HierarchicalBCEngine.java
 *    Copyright (C) 2003 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.gui.graphvisualizer;

import weka.core.FastVector;
import weka.gui.graphvisualizer.GraphNode;
import weka.gui.graphvisualizer.GraphEdge;

import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JCheckBox;
import javax.swing.ButtonGroup;
import javax.swing.BorderFactory;
import javax.swing.JProgressBar;

import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;

/**
 * This class lays out the vertices of a graph in a
 * hierarchy of vertical levels, with a number of nodes
 * in each level. The number of levels is the depth of
 * the deepest child reachable from some parent at level
 * 0. It implements a layout technique as described by
 * K. Sugiyama, S. Tagawa, and M. Toda. in &quot;Methods for
 * visual understanding of hierarchical systems&quot;, IEEE
 * Transactions on Systems, Man and Cybernetics,
 * SMC-11(2):109-125, Feb. 1981.
 * &lt;p&gt;There have been a few modifications made, however.
 * The crossings function is changed as it was non-linear
 * in time complexity. Furthermore, we don't have any
 * interconnection matrices for each level, instead we
 * just have one big interconnection matrix for the
 * whole graph and a int[][] array which stores the
 * vertices present in each level.
 *
 * @author Ashraf M. Kibriya (amk14@cs.waikato.ac.nz)
 * @version $Revision: 7059 $ - 24 Apr 2003 - Initial version (Ashraf M. Kibriya)
 *
 */
public class HierarchicalBCEngine implements GraphConstants, LayoutEngine {
  
  /** FastVector containing nodes and edges */
  protected FastVector m_nodes, m_edges;
  /**  FastVector containing listeners for
    * layoutCompleteEvent generated by this
    * LayoutEngine  */
  protected FastVector layoutCompleteListeners;
  /**   Interconnection matrix for the graph  */
  protected int graphMatrix[][];
  /** Array containing the indices of nodes in each level.
    * The nodeLevels.length is equal to the number of levels  */
  protected int nodeLevels[][];
  /** The nodeWidth and nodeHeight */
  protected int m_nodeWidth, m_nodeHeight;
  
  /* The following radio buttons control the
     way the layout is performed. If any
     of the following is changed then we
     need to perform a complete relayout
   */
  protected JRadioButton m_jRbNaiveLayout;
  protected JRadioButton m_jRbPriorityLayout;
  protected JRadioButton m_jRbTopdown;
  protected JRadioButton m_jRbBottomup;
  
  /** controls edge concentration by concentrating multilple singular dummy
   * child nodes into one plural dummy child node
   */
  protected JCheckBox m_jCbEdgeConcentration;
  
  /** The panel containing extra options,
   * specific to this LayoutEngine, for
   * greater control over layout of the graph */
  protected JPanel m_controlsPanel;
  
  /** The progress bar to show the progress
   * of the layout process */
  protected JProgressBar m_progress;
  
  /** This tells the the LayoutGraph method if
   * a completeReLayout should be performed
   * when it is called. */
<span class="nc" id="L106">  protected boolean m_completeReLayout=false;</span>
  
  /** This contains the original size of the nodes vector
   * when it was passed in through the constructor, before
   * adding all the dummy vertices */
  private int origNodesSize;
  
  /** Constructor - takes in FastVectors of nodes and edges, and the initial
   *  width and height of a node
   */
<span class="nc" id="L116">  public HierarchicalBCEngine(FastVector nodes, FastVector edges, int nodeWidth, </span>
                              int nodeHeight) {
<span class="nc" id="L118">    m_nodes = nodes; m_edges = edges; m_nodeWidth = nodeWidth; </span>
<span class="nc" id="L119">    m_nodeHeight = nodeHeight;</span>
<span class="nc" id="L120">    makeGUIPanel(false);</span>
<span class="nc" id="L121">  }</span>
  
  /** Constructor - takes in FastVectors of nodes and edges, the initial width
   * and height of a node, and a boolean value to indicate if the edges
   * should be concentrated.
   * @param nodes - FastVector containing all the nodes
   * @param edges - FastVector containing all the edges
   * @param nodeWidth - A node's allowed width
   * @param nodeHeight - A node's allowed height
   * @param edgeConcentration - True: if want to concentrate edges,
   * False: otherwise
   */
<span class="nc" id="L133">  public HierarchicalBCEngine(FastVector nodes, FastVector edges,</span>
  int nodeWidth, int nodeHeight, boolean edgeConcentration) {
<span class="nc" id="L135">    m_nodes = nodes; m_edges = edges; m_nodeWidth = nodeWidth; </span>
<span class="nc" id="L136">    m_nodeHeight = nodeHeight;</span>
<span class="nc" id="L137">    makeGUIPanel(edgeConcentration);</span>
<span class="nc" id="L138">  }</span>
  
  /** SimpleConstructor
   * If we want to instantiate the class first, and if information for
   * nodes and edges is not available. However, we would have to manually
   * provide all the information later on by calling setNodesEdges and
   * setNodeSize methods
   */
<span class="nc" id="L146">  public HierarchicalBCEngine() {   }</span>
  
  /**
   * This methods makes the gui extra controls panel &quot;m_controlsPanel&quot;
   */
  protected void makeGUIPanel(boolean edgeConc) {
<span class="nc" id="L152">    m_jRbNaiveLayout = new JRadioButton(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JRbTopdown_JRadioButton_Text&quot;));</span>
<span class="nc" id="L153">    m_jRbPriorityLayout = new JRadioButton(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JRbPriorityLayout_JRadioButton_Text&quot;));</span>
<span class="nc" id="L154">    ButtonGroup bg = new ButtonGroup();</span>
<span class="nc" id="L155">    bg.add(m_jRbNaiveLayout);</span>
<span class="nc" id="L156">    bg.add(m_jRbPriorityLayout);</span>
<span class="nc" id="L157">    m_jRbPriorityLayout.setSelected(true);</span>
    
<span class="nc" id="L159">    ActionListener a = new ActionListener() {</span>
      public void actionPerformed(ActionEvent ae) {
<span class="nc" id="L161">        m_completeReLayout=true;</span>
<span class="nc" id="L162">      }</span>
    };
    
<span class="nc" id="L165">    m_jRbTopdown = new JRadioButton(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JRbTopdown_JRadioButton_Text&quot;));</span>
<span class="nc" id="L166">    m_jRbBottomup = new JRadioButton(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JRbBottomup_JRadioButton_Text&quot;));</span>
<span class="nc" id="L167">    m_jRbTopdown.addActionListener(a);</span>
<span class="nc" id="L168">    m_jRbBottomup.addActionListener(a);</span>
<span class="nc" id="L169">    bg = new ButtonGroup();</span>
<span class="nc" id="L170">    bg.add(m_jRbTopdown);</span>
<span class="nc" id="L171">    bg.add(m_jRbBottomup);</span>
<span class="nc" id="L172">    m_jRbBottomup.setSelected(true);</span>
    
<span class="nc" id="L174">    m_jCbEdgeConcentration = new JCheckBox(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JP1_JPanel_BorderFactoryCreateTitledBorder_Text&quot;), edgeConc);</span>
<span class="nc" id="L175">    m_jCbEdgeConcentration.setSelected(edgeConc);</span>
<span class="nc" id="L176">    m_jCbEdgeConcentration.addActionListener(a);</span>
    
<span class="nc" id="L178">    JPanel jp1 = new JPanel( new GridBagLayout() );</span>
<span class="nc" id="L179">    GridBagConstraints gbc = new GridBagConstraints();</span>
<span class="nc" id="L180">    gbc.gridwidth = gbc.REMAINDER;</span>
<span class="nc" id="L181">    gbc.anchor = gbc.NORTHWEST;</span>
<span class="nc" id="L182">    gbc.weightx = 1;</span>
<span class="nc" id="L183">    gbc.fill = gbc.HORIZONTAL;</span>
<span class="nc" id="L184">    jp1.add(m_jRbNaiveLayout, gbc);</span>
<span class="nc" id="L185">    jp1.add(m_jRbPriorityLayout, gbc);</span>
<span class="nc" id="L186">    jp1.setBorder( BorderFactory.createTitledBorder(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JP1_SetBorder_Text&quot;)));</span>
    
<span class="nc" id="L188">    JPanel jp2 = new JPanel( new GridBagLayout() );</span>
<span class="nc" id="L189">    jp2.add(m_jRbTopdown, gbc);</span>
<span class="nc" id="L190">    jp2.add(m_jRbBottomup, gbc);</span>
<span class="nc" id="L191">    jp2.setBorder( BorderFactory.createTitledBorder(Messages.getInstance().getString(&quot;HierarchicalBCEngine_JP2_BorderFactoryCreateTitledBorder_Text&quot;)));</span>
    
    
<span class="nc" id="L194">    m_progress = new JProgressBar(0, 11);</span>
<span class="nc" id="L195">    m_progress.setBorderPainted(false);</span>
<span class="nc" id="L196">    m_progress.setStringPainted(true);</span>
<span class="nc" id="L197">    m_progress.setString(&quot;&quot;);</span>
    
<span class="nc" id="L199">    m_progress.setValue(0);</span>
    
<span class="nc" id="L201">    m_controlsPanel = new JPanel( new GridBagLayout() );</span>
<span class="nc" id="L202">    m_controlsPanel.add(jp1, gbc);</span>
<span class="nc" id="L203">    m_controlsPanel.add(jp2, gbc);</span>
<span class="nc" id="L204">    m_controlsPanel.add(m_jCbEdgeConcentration, gbc);</span>
<span class="nc" id="L205">  }</span>
  
    /** give access to set of graph nodes */
    public FastVector getNodes() {
<span class="nc" id="L209">	return m_nodes;</span>
    }
  
  /** This method returns a handle to the extra
   * controls panel, so that the visualizing
   * class can add it to some of it's own
   * gui panel.
   */
  public JPanel getControlPanel() {
<span class="nc" id="L218">    return m_controlsPanel;</span>
  }
  
  /** Returns a handle to the progressBar
   * of this LayoutEngine.
   */
  public JProgressBar getProgressBar() {
<span class="nc" id="L225">    return m_progress;</span>
  }
  
  /** Sets the nodes and edges for this LayoutEngine.
   * Must be used if the class created by simple
   * HierarchicalBCEngine() constructor.
   * @param nodes - FastVector containing all the nodes
   * @param edges - FastVector containing all the edges
   */
  public void setNodesEdges(FastVector nodes, FastVector edges) {
<span class="nc" id="L235">    m_nodes = nodes; m_edges = edges;</span>
<span class="nc" id="L236">  }</span>
  
  /**
   * Sets the size of a node. This method must be
   *	used if the class created by simple
   *	HierarchicalBCEngine() constructor.
   *	@param nodeWidth - A node's allowed width
   *	@param nodeHeight - A node's allowed height
   */
  public void setNodeSize(int nodeWidth, int nodeHeight) {
<span class="nc" id="L246">    m_nodeWidth = nodeWidth;</span>
<span class="nc" id="L247">    m_nodeHeight = nodeHeight;</span>
<span class="nc" id="L248">  }</span>
  
  /**
   * Method to add a LayoutCompleteEventListener
   * @param l - Listener to receive the LayoutCompleteEvent by this
   *            class.
   */
  public void addLayoutCompleteEventListener(LayoutCompleteEventListener l) {
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if(layoutCompleteListeners==null)</span>
<span class="nc" id="L257">      layoutCompleteListeners = new FastVector();</span>
<span class="nc" id="L258">    layoutCompleteListeners.addElement(l);</span>
<span class="nc" id="L259">  }</span>
  
  /**
   * Method to remove a LayoutCompleteEventListener.
   * @param e - The LayoutCompleteEventListener to remove.
   */
  public void removeLayoutCompleteEventListener(LayoutCompleteEventListener e){
<span class="nc bnc" id="L266" title="All 2 branches missed.">    if(layoutCompleteListeners!=null) {</span>
      LayoutCompleteEventListener l;
      
<span class="nc bnc" id="L269" title="All 2 branches missed.">      for(int i=0; i&lt;layoutCompleteListeners.size(); i++) {</span>
<span class="nc" id="L270">        l = (LayoutCompleteEventListener) layoutCompleteListeners.elementAt(i);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if(l==e) {</span>
<span class="nc" id="L272">          layoutCompleteListeners.removeElementAt(i);</span>
<span class="nc" id="L273">          return;</span>
        }
      }
<span class="nc" id="L276">      System.err.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_RemoveLayoutCompleteEventListener_Error_Text_First&quot;));</span>
    }
    else
<span class="nc" id="L279">      System.err.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_RemoveLayoutCompleteEventListener_Error_Text_Second&quot;));</span>
<span class="nc" id="L280">  }</span>
  
  /**
   * Fires a LayoutCompleteEvent.
   * @param e - The LayoutCompleteEvent to fire
   */
  public void fireLayoutCompleteEvent(LayoutCompleteEvent e) {
<span class="nc bnc" id="L287" title="All 4 branches missed.">    if(layoutCompleteListeners!=null &amp;&amp; layoutCompleteListeners.size()!=0) {</span>
      LayoutCompleteEventListener l;
      
<span class="nc bnc" id="L290" title="All 2 branches missed.">      for(int i=0; i&lt;layoutCompleteListeners.size(); i++) {</span>
<span class="nc" id="L291">        l = (LayoutCompleteEventListener) layoutCompleteListeners.elementAt(i);</span>
<span class="nc" id="L292">        l.layoutCompleted(e);</span>
      }
    }
<span class="nc" id="L295">  }</span>
  
  
  /**
   * This method does a complete layout of the graph which includes
   * removing cycles, assigning levels to nodes, reducing edge crossings
   * and laying out the vertices horizontally for better visibility.
   * The removing of cycles and assignment of levels is only performed
   * if hasn't been performed earlier or if some layout option has been
   * changed and it is necessary to do so. It is necessary to do so,
   * if the user selects/deselects edge concentration or topdown/bottomup
   * options.
   * &lt;p&gt; The layout is performed in a separate thread and the progress
   * bar of the class is updated for each of the steps as the process
   * continues.
   */
  public void layoutGraph() {
  //cannot perform a layout if no description of nodes and/or edges is provided
<span class="nc bnc" id="L313" title="All 4 branches missed.">    if(m_nodes==null || m_edges==null)</span>
<span class="nc" id="L314">      return; </span>
    
<span class="nc" id="L316">    Thread th = new Thread() {</span>
      public void run() {
<span class="nc" id="L318">        m_progress.setBorderPainted(true);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if(nodeLevels==null) {</span>
<span class="nc" id="L320">          makeProperHierarchy();</span>
        }
<span class="nc bnc" id="L322" title="All 2 branches missed.">        else if(m_completeReLayout==true) {</span>
<span class="nc" id="L323">          clearTemps_and_EdgesFromNodes(); makeProperHierarchy(); </span>
<span class="nc" id="L324">          m_completeReLayout=false;</span>
        }
        
        //minimizing crossings
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if(m_jRbTopdown.isSelected()) {</span>
<span class="nc" id="L329">          int crossbefore=crossings(nodeLevels), crossafter=0, i=0;</span>
          do {
<span class="nc" id="L331">            m_progress.setValue(i+4);</span>
<span class="nc" id="L332">            m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_LayoutGraph_Progress_SetString_Text_First&quot;) + (i+1));</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if(i!=0)</span>
<span class="nc" id="L334">              crossbefore = crossafter;</span>
<span class="nc" id="L335">            nodeLevels = minimizeCrossings(false, nodeLevels);</span>
<span class="nc" id="L336">            crossafter = crossings(nodeLevels);</span>
<span class="nc" id="L337">            i++;</span>
          }
<span class="nc bnc" id="L339" title="All 4 branches missed.">          while(crossafter&lt;crossbefore &amp;&amp; i&lt;6);</span>
        }
        else {
<span class="nc" id="L342">          int crossbefore=crossings(nodeLevels), crossafter=0, i=0;</span>
          do {
<span class="nc" id="L344">            m_progress.setValue(i+4);</span>
<span class="nc" id="L345">            m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_LayoutGraph_Progress_SetString_Text_Second&quot;) + (i+1));</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if(i!=0)</span>
<span class="nc" id="L347">              crossbefore = crossafter;</span>
<span class="nc" id="L348">            nodeLevels = minimizeCrossings(true, nodeLevels);</span>
<span class="nc" id="L349">            crossafter = crossings(nodeLevels);</span>
<span class="nc" id="L350">            i++;</span>
          }
<span class="nc bnc" id="L352" title="All 4 branches missed.">          while(crossafter&lt;crossbefore &amp;&amp; i&lt;6);</span>
        }
        //System.out.println(&quot;\nCrossings at the end &quot;+
        //                   crossings(nodeLevels)+
        //                   &quot;\n---------------------------------&quot;);
        
<span class="nc" id="L358">        m_progress.setValue(10);</span>
<span class="nc" id="L359">        m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_LayoutGraph_Progress_SetString_Text_Third&quot;));</span>
        //Laying out graph
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if(m_jRbNaiveLayout.isSelected())</span>
<span class="nc" id="L362">          naiveLayout();</span>
        else
<span class="nc" id="L364">          priorityLayout1();</span>
<span class="nc" id="L365">        m_progress.setValue(11);</span>
<span class="nc" id="L366">        m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_LayoutGraph_Progress_SetString_Text_Fourth&quot;));</span>
<span class="nc" id="L367">        m_progress.repaint();</span>
        
<span class="nc" id="L369">        fireLayoutCompleteEvent( new LayoutCompleteEvent(this) );</span>
<span class="nc" id="L370">        m_progress.setValue(0);</span>
<span class="nc" id="L371">        m_progress.setString(&quot;&quot;);</span>
<span class="nc" id="L372">        m_progress.setBorderPainted(false);</span>
<span class="nc" id="L373">      }</span>
    };
<span class="nc" id="L375">    th.start();</span>
<span class="nc" id="L376">  }</span>
  
  /**
   * This method removes the temporary nodes that were
   * added to fill in the gaps, and removes all edges
   * from all nodes in their edges[][] array
   */
  protected void clearTemps_and_EdgesFromNodes() {
    /*
    System.out.println(&quot;Before.............&quot;);
    for(int i=0; i&lt;m_nodes.size(); i++) {
      GraphNode n = (GraphNode)m_nodes.elementAt(i);
      System.out.println(&quot;N: &quot;+n.ID+&quot;,&quot;+i);
    }
    System.out.println(&quot;origNodesSize: &quot;+origNodesSize);
    */
    
<span class="nc" id="L393">    int curSize = m_nodes.size();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">    for(int i=origNodesSize; i&lt;curSize; i++)</span>
<span class="nc" id="L395">      m_nodes.removeElementAt(origNodesSize);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">    for(int j=0; j&lt;m_nodes.size(); j++)</span>
<span class="nc" id="L397">      ((GraphNode)m_nodes.elementAt(j)).edges = null;</span>
    
<span class="nc" id="L399">    nodeLevels=null;</span>
    
    /*
    System.out.println(&quot;After..............&quot;);
    for(int i=0; i&lt;m_nodes.size(); i++) {
      GraphNode n = (GraphNode)m_nodes.elementAt(i);
      System.out.println(&quot;N: &quot;+n.ID+&quot;,&quot;+i);
    }
    */
<span class="nc" id="L408">  }</span>
  
  /**
   * This method makes the &quot;graphMatrix&quot; interconnection
   * matrix for the graph given by m_nodes and m_edges
   * vectors. The matix is used by other methods.
   */
  protected void processGraph() {
<span class="nc" id="L416">    origNodesSize = m_nodes.size();</span>
<span class="nc" id="L417">    graphMatrix = new int[m_nodes.size()][m_nodes.size()];</span>
    /*
    System.out.println(&quot;The &quot;+m_nodes.size()+&quot; nodes are: &quot;);
    for(int i=0; i&lt;m_nodes.size(); i++)
      System.out.println((String)m_nodes.elementAt(i)+&quot; &quot;);
    System.out.println(&quot;\nThe &quot;+m_edges.size()+&quot; edges are: &quot;);
    for(int i=0; i&lt;m_edges.size(); i++)
      System.out.println((GraphEdge)m_edges.elementAt(i));
    */
<span class="nc bnc" id="L426" title="All 2 branches missed.">    for(int i=0; i&lt;m_edges.size(); i++)</span>
<span class="nc" id="L427">      graphMatrix[((GraphEdge)m_edges.elementAt(i)).src]</span>
<span class="nc" id="L428">                 [((GraphEdge)m_edges.elementAt(i)).dest] = </span>
<span class="nc" id="L429">                                         ((GraphEdge)m_edges.elementAt(i)).type;</span>
    /*
    System.out.print(&quot;\t&quot;);
    for(int i=0; i&lt;graphMatrix.length; i++)
      System.out.print(((GraphNode)m_nodes.elementAt(i)).ID+&quot; &quot;);
    System.out.println(&quot;&quot;);
    for(int i=0; i&lt;graphMatrix.length; i++) {
      GraphNode n = (GraphNode)m_nodes.elementAt(i);
      System.out.print(n.ID+&quot;\t&quot;);
      for(int j=0; j&lt;graphMatrix[i].length; j++)
        System.out.print(graphMatrix[i][j]+&quot; &quot;);
      System.out.println(&quot;&quot;);
    }
    */
<span class="nc" id="L443">  }</span>
  
  /*
   * This method makes a proper hierarchy of the graph
   * by first removing cycles, then assigning levels
   * to the nodes and then removing gaps by adding
   * dummy vertices.
   */
  protected void makeProperHierarchy() {
<span class="nc" id="L452">    processGraph();</span>
    
<span class="nc" id="L454">    m_progress.setValue(1);</span>
<span class="nc" id="L455">    m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MakeProperHierarchy_Progress_SetString_Text_First&quot;));</span>
    //****removing cycles
<span class="nc" id="L457">    removeCycles();</span>
    
<span class="nc" id="L459">    m_progress.setValue(2);</span>
<span class="nc" id="L460">    m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MakeProperHierarchy_Progress_SetString_Text_Second&quot;));</span>
    //****Assigning vertical level to each node
<span class="nc" id="L462">    int nodesLevel[] = new int[m_nodes.size()];</span>
<span class="nc" id="L463">    int depth=0;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">    for(int i=0; i&lt;graphMatrix.length; i++) {</span>
<span class="nc" id="L465">      assignLevels(nodesLevel, depth, i, 0);</span>
    }
    
<span class="nc bnc" id="L468" title="All 2 branches missed.">    for(int i=0; i&lt;nodesLevel.length; i++) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">      if(nodesLevel[i]==0) {</span>
<span class="nc" id="L470">        int min=65536;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        for(int j=0; j&lt;graphMatrix[i].length; j++) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">          if(graphMatrix[i][j]==DIRECTED)</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if(min&gt;nodesLevel[j])</span>
<span class="nc" id="L474">              min = nodesLevel[j];</span>
        }
        //if the shallowest child of a parent has a depth greater than 1
        // and it is not a lone parent with no children
<span class="nc bnc" id="L478" title="All 4 branches missed.">        if(min!=65536 &amp;&amp; min&gt;1) </span>
<span class="nc" id="L479">          nodesLevel[i]=min-1;       </span>
      }
    }
    
    //System.out.println(&quot;&quot;);
<span class="nc" id="L484">    int maxLevel=0;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">    for(int i=0; i&lt;nodesLevel.length; i++) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">      if(nodesLevel[i]&gt;maxLevel)</span>
<span class="nc" id="L487">        maxLevel = nodesLevel[i];</span>
      //System.out.println( ((GraphNode)m_nodes.elementAt(i)).ID+&quot; &quot;+i+&quot;&gt;&quot;+
      //                    nodesLevel[i]);
    }
<span class="nc" id="L491">    int levelCounts[] = new int[maxLevel+1];</span>
    
<span class="nc bnc" id="L493" title="All 2 branches missed.">    for(int i=0; i&lt;nodesLevel.length; i++) {</span>
<span class="nc" id="L494">      levelCounts[nodesLevel[i]]++;</span>
    }
    //System.out.println(&quot;------------------------------------------&quot;);
    //****Assigning nodes to each level
<span class="nc" id="L498">    int levelsCounter[] = new int[maxLevel+1];</span>
<span class="nc" id="L499">    nodeLevels = new int[maxLevel+1][];</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">    for(byte i=0; i&lt;nodesLevel.length; i++) {</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">      if(nodeLevels[nodesLevel[i]]==null)</span>
<span class="nc" id="L502">        nodeLevels[nodesLevel[i]] = new int[ levelCounts[nodesLevel[i]] ];</span>
      //nodeLevels[nodesLevel[i]].addElement(new Integer(i));
      //System.out.println(((GraphNode)m_nodes.elementAt(i)).ID+&quot; &quot;+
      //                   nodesLevel[i]+&quot;&gt;&quot;+levelCounts[nodesLevel[i]]);
<span class="nc" id="L506">      nodeLevels[nodesLevel[i]][levelsCounter[nodesLevel[i]]++] = i;</span>
    }
    
<span class="nc" id="L509">    m_progress.setValue(3);</span>
<span class="nc" id="L510">    m_progress.setString(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MakeProperHierarchy_Progress_SetString_Text_Third&quot;));</span>
    //*Making a proper Hierarchy by putting in dummy vertices to close all gaps
<span class="nc bnc" id="L512" title="All 2 branches missed.">    if(m_jCbEdgeConcentration.isSelected())</span>
<span class="nc" id="L513">      removeGapsWithEdgeConcentration(nodesLevel);</span>
    else
<span class="nc" id="L515">      removeGaps(nodesLevel);</span>
    
    //After assigning levels and adding dummy vertices
    //System.out.print(&quot;\n\t&quot;);
    //for(int i=0; i&lt;graphMatrix.length; i++)
    //    System.out.print(((GraphNode)m_nodes.elementAt(i)).ID+&quot; &quot;);
    //System.out.println(&quot;&quot;);
    //for(int i=0; i&lt;graphMatrix.length; i++) {
    //    System.out.print(((GraphNode)m_nodes.elementAt(i)).ID+&quot;\t&quot;);
    //    for(int j=0; j&lt;graphMatrix[i].length; j++)
    //	System.out.print(graphMatrix[i][j]+&quot; &quot;);
    //    System.out.println(&quot;&quot;);
    //}
    
    //****Updating edges[][] array of nodes from
    //****the interconnection matrix, which will be used
    //****by the Visualizer class to draw edges
<span class="nc bnc" id="L532" title="All 2 branches missed.">    for(int i=0; i&lt;graphMatrix.length; i++) {</span>
<span class="nc" id="L533">      GraphNode n = (GraphNode)m_nodes.elementAt(i);</span>
<span class="nc" id="L534">      int sum=0;</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      for(int j=0; j&lt;graphMatrix[i].length; j++)</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if(graphMatrix[i][j]!=0)</span>
<span class="nc" id="L537">          sum++;</span>
      
<span class="nc" id="L539">      n.edges = new int[sum][2];</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">      for(int j=0, k=0; j&lt;graphMatrix[i].length; j++)</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if(graphMatrix[i][j]!=0) {</span>
<span class="nc" id="L542">          n.edges[k][0] = j;</span>
<span class="nc" id="L543">          n.edges[k][1] = graphMatrix[i][j]; k++;</span>
        }
      //n.edges = graphMatrix[i];
    }
    
    //Interconnection matrices at each level, 1 to n-1
    //printMatrices(nodeLevels);
<span class="nc" id="L550">  }</span>
  
  
  /**
   * This method removes gaps from the graph. It doesn't perform
   * any concentration. It takes as an argument of int[]
   * of length m_nodes.size() containing the level of each
   * node.
   */
  private void removeGaps(int nodesLevel[]) {
<span class="nc" id="L560">    int temp = m_nodes.size();</span>
<span class="nc" id="L561">    int temp2=graphMatrix[0].length, tempCnt=1;</span>
    
<span class="nc bnc" id="L563" title="All 2 branches missed.">    for(int n=0; n&lt;temp; n++) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">      for(int i=0; i&lt;temp2; i++) {</span>
<span class="nc" id="L565">        int len = graphMatrix.length;</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if(graphMatrix[n][i]&gt;0)</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">          if(nodesLevel[i]&gt;nodesLevel[n]+1) {</span>
<span class="nc" id="L568">            int tempMatrix[][] =</span>
<span class="nc" id="L569">            new int[graphMatrix.length+(nodesLevel[i]-nodesLevel[n]-1)]</span>
<span class="nc" id="L570">                   [graphMatrix.length+(nodesLevel[i]-nodesLevel[n]-1)];</span>
<span class="nc" id="L571">            int level = nodesLevel[n]+1;</span>
<span class="nc" id="L572">            copyMatrix(graphMatrix, tempMatrix);</span>
            
<span class="nc" id="L574">            String s1 = new String(&quot;S&quot;+tempCnt++);</span>
<span class="nc" id="L575">            m_nodes.addElement(new GraphNode(s1, s1, SINGULAR_DUMMY)); //true));</span>
<span class="nc" id="L576">            int temp3 [] = new int[nodeLevels[level].length+1];</span>
            //for(int j=0; j&lt;nodeLevels[level].length; j++)
            //    temp3[j] = nodeLevels[level][j];
<span class="nc" id="L579">            System.arraycopy(nodeLevels[level], 0, temp3, </span>
<span class="nc" id="L580">                             0, nodeLevels[level].length);</span>
<span class="nc" id="L581">            temp3[temp3.length-1] = m_nodes.size()-1;</span>
<span class="nc" id="L582">            nodeLevels[level] = temp3; level++;</span>
            //nodeLevels[level++].addElement(new Integer(m_nodes.size()-1));
            //System.out.println(&quot;len:&quot;+len+&quot;,&quot;+nodesLevel[i]+&quot;,&quot;+
            //                   nodesLevel[n]);
            
            int k;
<span class="nc bnc" id="L588" title="All 2 branches missed.">            for(k=len; k&lt;len+nodesLevel[i]-nodesLevel[n]-1-1; k++) {</span>
<span class="nc" id="L589">              String s2 =  new String(&quot;S&quot;+tempCnt);</span>
<span class="nc" id="L590">              m_nodes.addElement( new GraphNode(s2, s2, SINGULAR_DUMMY) ); //true) );</span>
<span class="nc" id="L591">              temp3 = new int[nodeLevels[level].length+1];</span>
              //for(int j=0; j&lt;nodeLevels[level].length; j++)
              //	temp3[j] = nodeLevels[level][j];
<span class="nc" id="L594">              System.arraycopy(nodeLevels[level], 0, temp3, </span>
<span class="nc" id="L595">                               0, nodeLevels[level].length);</span>
<span class="nc" id="L596">              temp3[temp3.length-1] = m_nodes.size()-1;</span>
<span class="nc" id="L597">              nodeLevels[level++] = temp3;</span>
              //nodeLevels[level++].addElement(new Integer(m_nodes.size()-1));
<span class="nc" id="L599">              tempMatrix[k][k+1]=tempMatrix[n][i]; tempCnt++;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">              if(k&gt;len)</span>
<span class="nc" id="L601">                tempMatrix[k][k-1]=-1*tempMatrix[n][i];</span>
            }
            
            //temp[lastTempNodeCreated][targetNode]=temp[origNode][targetNode]
<span class="nc" id="L605">            tempMatrix[k][i]=tempMatrix[n][i];</span>
            //System.out.println(&quot;k &quot;+((GraphNode)m_nodes.elementAt(k)).ID+
            //		   &quot; i &quot;+((GraphNode)m_nodes.elementAt(i)).ID+
            //		   &quot; n &quot;+((GraphNode)m_nodes.elementAt(n)).ID+
            //		   &quot; len &quot;+((GraphNode)m_nodes.elementAt(len)).ID );
            //temp[origNode][firstTempNodecreated] = temp[origNode][targetNode]
<span class="nc" id="L611">            tempMatrix[n][len] = tempMatrix[n][i]; </span>
            //temp[firstTempNodeCreated][origNode]  for reverse tracing
<span class="nc" id="L613">            tempMatrix[len][n] = -1*tempMatrix[n][i];</span>
             //temp[targetNode][lastTempNodecreated]  for reverse tracing
<span class="nc" id="L615">            tempMatrix[i][k]   = -1*tempMatrix[n][i]; </span>
            
            //temp[lastTempNodeCreated][secondlastNode] for reverse tracing
            //but only do this if more than 1 temp nodes are created
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if(k&gt;len)                                  </span>
<span class="nc" id="L620">              tempMatrix[k][k-1] = -1*tempMatrix[n][i];</span>
            
            //temp[origNode][targetNode] = 0 unlinking as they have been
            // linked by a chain of temporary nodes now.
<span class="nc" id="L624">            tempMatrix[n][i]   = 0;                    </span>
<span class="nc" id="L625">            tempMatrix[i][n]   = 0;                    </span>
            
<span class="nc" id="L627">            graphMatrix = tempMatrix;</span>
          }
          else {
            //****Even if there is no gap just add a reference for the
            //****parent to the child for reverse tracing, useful if the
            //****there is a reversed edge from parent to child and therefore
            //****visualizer would know to highlight this edge  when 
            //****highlighting the child.
<span class="nc" id="L635">            graphMatrix[i][n]=-1*graphMatrix[n][i];</span>
          }
      }
    }
    //Interconnection matrices at each level, 1 to n-1 after minimizing edges
    //printMatrices(nodeLevels);
<span class="nc" id="L641">  }</span>
  
  
  /**
   * This method removes gaps from the graph. It tries to minimise the number
   * of edges by concentrating multiple dummy nodes from the same parent and
   * on the same vertical level into one. It takes as an argument of int[]
   * of length m_nodes.size() containing the level of each
   * node.
   */
  private void removeGapsWithEdgeConcentration(int nodesLevel[]) {
    
<span class="nc" id="L653">    final int  temp = m_nodes.size(), temp2=graphMatrix[0].length;</span>
<span class="nc" id="L654">    int tempCnt=1;</span>
    
<span class="nc bnc" id="L656" title="All 2 branches missed.">    for(int n=0; n&lt;temp; n++) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">      for(int i=0; i&lt;temp2; i++) {</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if(graphMatrix[n][i]&gt;0)</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">          if(nodesLevel[i]&gt;nodesLevel[n]+1) {</span>
            //System.out.println(&quot;Processing node &quot;+
            //                   ((GraphNode)m_nodes.elementAt(n)).ID+
            //                   &quot; for &quot;+((GraphNode)m_nodes.elementAt(i)).ID);
<span class="nc" id="L663">            int tempLevel=nodesLevel[n];</span>
<span class="nc" id="L664">            boolean tempNodePresent=false;</span>
<span class="nc" id="L665">            int k=temp;</span>
<span class="nc" id="L666">            int tempnode = n;</span>
            
<span class="nc bnc" id="L668" title="All 2 branches missed.">            while(tempLevel &lt; nodesLevel[i]-1 ) {</span>
<span class="nc" id="L669">              tempNodePresent=false;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">              for(; k&lt;graphMatrix.length; k++) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                if(graphMatrix[tempnode][k]&gt;0) {</span>
                  //System.out.println(&quot;tempnode will be true&quot;);
<span class="nc" id="L673">                  tempNodePresent = true; break;</span>
                }
              }
<span class="nc bnc" id="L676" title="All 2 branches missed.">              if(tempNodePresent) {</span>
<span class="nc" id="L677">                tempnode=k; k=k+1;</span>
<span class="nc" id="L678">                tempLevel++;</span>
              }
              else {
<span class="nc bnc" id="L681" title="All 2 branches missed.">                if(tempnode!=n)</span>
<span class="nc" id="L682">                  tempnode=k-1;</span>
                //System.out.println(&quot;breaking from loop&quot;);
<span class="nc" id="L684">                break;</span>
              }
            }
<span class="nc bnc" id="L687" title="All 2 branches missed.">            if(((GraphNode)m_nodes.elementAt(tempnode)).nodeType==SINGULAR_DUMMY)</span>
<span class="nc" id="L688">              ((GraphNode)m_nodes.elementAt(tempnode)).nodeType=PLURAL_DUMMY;</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if(tempNodePresent) {</span>
              //Link the last known temp node to target
<span class="nc" id="L691">              graphMatrix[tempnode][i] = graphMatrix[n][i];</span>
              //System.out.println(&quot;modifying &quot;+
              //                   ((GraphNode)nodes.elementAt(tempnode)).ID+
              //		   &quot;, &quot;+((GraphNode)nodes.elementAt(n)).ID);
              /////matrix[lastknowntempnode][source]=-original_val
              /////graphMatrix[tempnode][n] = -graphMatrix[n][i];
              //System.out.println(&quot;modifying &quot;+
              //                   ((GraphNode)nodes.elementAt(i)).ID+
              //		   &quot;, &quot;+
              //                   ((GraphNode)nodes.elementAt(tempnode)).ID);
              
              //and matrix[target][lastknowntempnode]=-original_val
              //for reverse tracing
<span class="nc" id="L704">              graphMatrix[i][tempnode] = -graphMatrix[n][i];</span>
              //unlink source from the target
<span class="nc" id="L706">              graphMatrix[n][i] = 0;</span>
<span class="nc" id="L707">              graphMatrix[i][n] = 0;</span>
<span class="nc" id="L708">              continue;</span>
              
            }
            
<span class="nc" id="L712">            int len = graphMatrix.length;</span>
<span class="nc" id="L713">            int tempMatrix[][] =</span>
<span class="nc" id="L714">            new int[graphMatrix.length+(nodesLevel[i]-nodesLevel[tempnode]-1)]</span>
<span class="nc" id="L715">            [graphMatrix.length+(nodesLevel[i]-nodesLevel[tempnode]-1)];</span>
<span class="nc" id="L716">            int level = nodesLevel[tempnode]+1;</span>
<span class="nc" id="L717">            copyMatrix(graphMatrix, tempMatrix);</span>
            
<span class="nc" id="L719">            String s1 = new String(&quot;S&quot;+tempCnt++);</span>
            //System.out.println(&quot;Adding dummy &quot;+s1);
<span class="nc" id="L721">            m_nodes.addElement(new GraphNode(s1, s1, SINGULAR_DUMMY));</span>
            
<span class="nc" id="L723">            int temp3 [] = new int[nodeLevels[level].length+1];</span>
<span class="nc" id="L724">            System.arraycopy(nodeLevels[level], 0, temp3, </span>
<span class="nc" id="L725">                             0, nodeLevels[level].length);</span>
<span class="nc" id="L726">            temp3[temp3.length-1] = m_nodes.size()-1;</span>
<span class="nc" id="L727">            nodeLevels[level] = temp3;</span>
<span class="nc" id="L728">            temp3 = new int[m_nodes.size()+1];</span>
<span class="nc" id="L729">            System.arraycopy(nodesLevel, 0, temp3, 0, nodesLevel.length);</span>
<span class="nc" id="L730">            temp3[m_nodes.size()-1] = level;</span>
<span class="nc" id="L731">            nodesLevel = temp3;</span>
<span class="nc" id="L732">            level++;</span>
            //nodeLevels[level++].addElement(new Integer(m_nodes.size()-1));
            //System.out.println(&quot;len:&quot;+len+&quot;(&quot;+
            //                   ((GraphNode)m_nodes.elementAt(len)).ID+&quot;),&quot;+
            //                   nodesLevel[i]+&quot;,&quot;+nodesLevel[tempnode]);
            
            int m;
<span class="nc bnc" id="L739" title="All 2 branches missed.">            for(m=len; m&lt;len+nodesLevel[i]-nodesLevel[tempnode]-1-1; m++) {</span>
<span class="nc" id="L740">              String s2 =  new String(&quot;S&quot;+tempCnt++);</span>
              //System.out.println(&quot;Adding dummy &quot;+s2);
<span class="nc" id="L742">              m_nodes.addElement( new GraphNode(s2, s2, SINGULAR_DUMMY) );</span>
<span class="nc" id="L743">              temp3 = new int[nodeLevels[level].length+1];</span>
              //for(int j=0; j&lt;nodeLevels[level].length; j++)
              //	temp3[j] = nodeLevels[level][j];
<span class="nc" id="L746">              System.arraycopy(nodeLevels[level], 0, temp3, </span>
<span class="nc" id="L747">                               0, nodeLevels[level].length);</span>
<span class="nc" id="L748">              temp3[temp3.length-1] = m_nodes.size()-1;</span>
<span class="nc" id="L749">              nodeLevels[level] = temp3;</span>
<span class="nc" id="L750">              temp3 = new int[m_nodes.size()+1];</span>
<span class="nc" id="L751">              System.arraycopy(nodesLevel, 0, temp3, 0, nodesLevel.length);</span>
<span class="nc" id="L752">              temp3[m_nodes.size()-1] = level;</span>
<span class="nc" id="L753">              nodesLevel = temp3;</span>
<span class="nc" id="L754">              level++;</span>
              //nodeLevels[level++].addElement(new Integer(m_nodes.size()-1));
              //System.out.println(&quot;modifying &quot;+
              //                   ((GraphNode)nodes.elementAt(m)).ID+&quot;, &quot;+
              //                   ((GraphNode)nodes.elementAt(m+1)).ID);
<span class="nc" id="L759">              tempMatrix[m][m+1]=tempMatrix[n][i]; //tempCnt++;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">              if(m&gt;len) {</span>
                //System.out.println(&quot;modifying &quot;+
                //                   ((GraphNode)nodes.elementAt(m)).ID+
                //                   &quot;, &quot;+((GraphNode)nodes.elementAt(m-1)).ID);
<span class="nc" id="L764">                tempMatrix[m][m-1]=-1*tempMatrix[n][i];</span>
              }
            }
            //System.out.println(&quot;m &quot;+((GraphNode)m_nodes.elementAt(m)).ID+
            //	   &quot; i &quot;+((GraphNode)m_nodes.elementAt(i)).ID+
            //     &quot; tempnode &quot;+((GraphNode)m_nodes.elementAt(tempnode)).ID+
            //	   &quot; len &quot;+((GraphNode)m_nodes.elementAt(len)).ID );
            //System.out.println(&quot;modifying &quot;+
            //                   ((GraphNode)nodes.elementAt(m)).ID+&quot;, &quot;+
            //                   ((GraphNode)nodes.elementAt(i)).ID);
            
            //temp[lastTempNodeCreated][targetNode]=temp[origNode][targetNode]
<span class="nc" id="L776">            tempMatrix[m][i]=tempMatrix[n][i];</span>
            //System.out.println(&quot;modifying &quot;+
            //                   ((GraphNode)nodes.elementAt(tempnode)).ID+&quot;, &quot;+
            //                   ((GraphNode)nodes.elementAt(len)).ID);
            
            //temp[origNode][firstTempNodecreated] = temp[origNode][targetNode]
<span class="nc" id="L782">            tempMatrix[tempnode][len] =  tempMatrix[n][i];</span>
            //System.out.println(&quot;modifying &quot;+
            //                   ((GraphNode)nodes.elementAt(len)).ID+&quot;, &quot;+
            //                   ((GraphNode)nodes.elementAt(tempnode)).ID);
            
            //temp[firstTempNodeCreated][origNode]  for reverse tracing
<span class="nc" id="L788">            tempMatrix[len][tempnode] = -1*tempMatrix[n][i]; </span>
            //System.out.println(&quot;modifying &quot;+
            //                   ((GraphNode)nodes.elementAt(i)).ID+&quot;, &quot;+
            //                   ((GraphNode)nodes.elementAt(m)).ID);
            
            //temp[targetNode][lastTempNodecreated]  for reverse tracing
<span class="nc" id="L794">            tempMatrix[i][m] = -1*tempMatrix[n][i];</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if(m&gt;len) {</span>
              //System.out.println(&quot;modifying &quot;+
              //                   ((GraphNode)nodes.elementAt(m)).ID+
              //                   &quot;, &quot;+((GraphNode)nodes.elementAt(m-1)).ID);

              //temp[lastTempNodeCreated][secondlastNode] for reverse tracing
              //but only do this if more than 1 temp nodes are created
<span class="nc" id="L802">              tempMatrix[m][m-1] = -1*tempMatrix[n][i]; </span>
            }

            //temp[origNode][targetNode] = 0 unlinking as they have been
<span class="nc" id="L806">            tempMatrix[n][i]   = 0;</span>
            
            //linked by a chain of temporary nodes now.
<span class="nc" id="L809">            tempMatrix[i][n]   = 0;</span>
            
<span class="nc" id="L811">            graphMatrix = tempMatrix;</span>
          }
          else {
            //System.out.println(&quot;modifying &quot;+
            //                   ((GraphNode)nodes.elementAt(i)).ID+&quot;, &quot;+
            //                   ((GraphNode)nodes.elementAt(n)).ID);
            //****Even if there is no gap just add a reference for the
            //****parent to the child for reverse tracing, useful if the
            //****there is a reversed edge from parent to child and therefore
            //****visualizer would know to highlight this edge  when
            //****highlighting the child.
<span class="nc" id="L822">            graphMatrix[i][n]=-1*graphMatrix[n][i];</span>
          }
      }
    }
<span class="nc" id="L826">  }</span>
  
  
  /**
   * Returns the index of an element in a level.
   * Must never be called with the wrong element and
   * the wrong level, will throw an exception otherwise.
   * It takes as agrument the index of the element (in the m_nodes vector)
   * and the level it is supposed to be in (as each level contains the indices
   * of the nodes present in that level).
   */
  private int indexOfElementInLevel(int element, int level[]) throws Exception {
    int idx;
    
<span class="nc bnc" id="L840" title="All 2 branches missed.">    for(int i=0; i&lt;level.length; i++)</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">      if(level[i]==element)</span>
<span class="nc" id="L842">        return i;</span>
<span class="nc" id="L843">    throw new Exception(Messages.getInstance().getString(&quot;HierarchicalBCEngine_IndexOfElementInLevel_Exception_Text_First&quot;) +</span>
<span class="nc" id="L844">                        ((GraphNode)m_nodes.elementAt(element)).ID+</span>
<span class="nc" id="L845">                        Messages.getInstance().getString(&quot;HierarchicalBCEngine_IndexOfElementInLevel_Exception_Text_Second&quot;)  +</span>
<span class="nc" id="L846">                        &quot;weka.gui.graphvisualizer.HierarchicalBCEngine&quot;);</span>
  }
  
  
  
  /**
   * Computes the number of edge crossings in the whole graph
   * Takes as an argument levels of nodes. It is essentially the
   * same algorithm provided in Universitat des Saarlandes
   * technical report A03/94 by Georg Sander.
   */
  protected int crossings(final int levels[][]) {
<span class="nc" id="L858">    int sum=0;</span>
    
<span class="nc bnc" id="L860" title="All 2 branches missed.">    for(int i=0; i&lt;levels.length-1; i++) {</span>
      //System.out.println(&quot;*****************Processing level &quot;+i+
      //                   &quot;*****************************&quot;);
<span class="nc" id="L863">      MyList upper = new MyList(), lower = new MyList();</span>
<span class="nc" id="L864">      MyListNode lastOcrnce[] = new MyListNode[m_nodes.size()];</span>
<span class="nc" id="L865">      int edgeOcrnce[] = new int[m_nodes.size()];</span>
      
<span class="nc bnc" id="L867" title="All 2 branches missed.">      for(int j=0,uidx=0,lidx=0; j&lt;(levels[i].length+levels[i+1].length); j++) {</span>
<span class="nc bnc" id="L868" title="All 6 branches missed.">        if((j%2==0 &amp;&amp; uidx&lt;levels[i].length) || lidx&gt;=levels[i+1].length) {</span>
<span class="nc" id="L869">          int k1=0, k2=0, k3=0;</span>
<span class="nc" id="L870">          GraphNode n = (GraphNode) m_nodes.elementAt(levels[i][uidx]);</span>
          //Deactivating and counting crossings for all edges ending in it
          //coming from bottom left
<span class="nc bnc" id="L873" title="All 2 branches missed.">          if(lastOcrnce[levels[i][uidx]]!=null) {</span>
<span class="nc" id="L874">            MyListNode temp = new MyListNode(-1); temp.next = upper.first;</span>
            try {
              do {
<span class="nc" id="L877">                temp = temp.next;</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                if(levels[i][uidx]==temp.n) {</span>
<span class="nc" id="L879">                  k1 = k1+1;</span>
<span class="nc" id="L880">                  k3 = k3+k2;</span>
                  //System.out.println(&quot;Removing from upper: &quot;+temp.n);
<span class="nc" id="L882">                  upper.remove(temp);</span>
                }
                else
<span class="nc" id="L885">                  k2 = k2+1;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">              } while(temp!=lastOcrnce[levels[i][uidx]]);</span>
            }
<span class="nc" id="L888">            catch(NullPointerException ex) {</span>
<span class="nc" id="L889">              System.out.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_First&quot;) + levels[i][uidx]+</span>
<span class="nc" id="L890">            		  Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Second&quot;) + ((GraphNode)m_nodes.elementAt(levels[i][uidx])).ID+</span>
<span class="nc" id="L891">            		  Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Third&quot;) + temp+</span>
<span class="nc" id="L892">            		  Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Fourth&quot;) + upper.first);</span>
<span class="nc" id="L893">            ex.printStackTrace();</span>
<span class="nc" id="L894">            System.exit(-1);}</span>
            
<span class="nc" id="L896">            lastOcrnce[levels[i][uidx]]=null;</span>
<span class="nc" id="L897">            sum = sum + k1*lower.size() + k3;</span>
          }
          //Activating all the edges going out towards the bottom 
          //and bottom right
<span class="nc bnc" id="L901" title="All 2 branches missed.">          for(int k=0; k&lt;n.edges.length; k++) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">            if(n.edges[k][1]&gt;0)</span>
              try {
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if( indexOfElementInLevel(n.edges[k][0], levels[i+1]) &gt;= uidx) {</span>
<span class="nc" id="L905">                  edgeOcrnce[n.edges[k][0]]=1;</span>
                }
              }
<span class="nc" id="L908">              catch(Exception ex) {</span>
<span class="nc" id="L909">                ex.printStackTrace();</span>
              }
          }
<span class="nc bnc" id="L912" title="All 2 branches missed.">          for(int k=0; k&lt;levels[i+1].length; k++) {</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">            if(edgeOcrnce[levels[i+1][k]]==1) {</span>
<span class="nc" id="L914">              MyListNode temp = new MyListNode(levels[i+1][k]); //new MyListNode(n.edges[k][0]);</span>
<span class="nc" id="L915">              lower.add(temp);</span>
<span class="nc" id="L916">              lastOcrnce[levels[i+1][k]] = temp;</span>
<span class="nc" id="L917">              edgeOcrnce[levels[i+1][k]] = 0;</span>
              //System.out.println(&quot;Adding to lower: &quot;+levels[i+1][k]+
              //&quot; which is: &quot;+((GraphNode)m_nodes.elementAt(levels[i+1][k])).ID+
              //&quot; first's n is: &quot;+lower.first.n);
            }
            
          }
<span class="nc" id="L924">          uidx++;</span>
        }
        else {
<span class="nc" id="L927">          int k1=0, k2=0, k3=0;</span>
<span class="nc" id="L928">          GraphNode n = (GraphNode) m_nodes.elementAt(levels[i+1][lidx]);</span>
          //Deactivating and counting crossings for all edges ending in it
          //coming from up and upper left
<span class="nc bnc" id="L931" title="All 2 branches missed.">          if(lastOcrnce[levels[i+1][lidx]]!=null) {</span>
            
<span class="nc" id="L933">            MyListNode temp = new MyListNode(-1); temp.next = lower.first;</span>
            try {
              do {
<span class="nc" id="L936">                temp = temp.next;</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if(levels[i+1][lidx]==temp.n) {</span>
<span class="nc" id="L938">                  k1 = k1+1;</span>
<span class="nc" id="L939">                  k3 = k3+k2;</span>
<span class="nc" id="L940">                  lower.remove(temp);</span>
                  //System.out.println(&quot;Removing from lower: &quot;+temp.n);
                }
                else
<span class="nc" id="L944">                  k2 = k2+1;</span>
                //System.out.println(&quot;temp: &quot;+temp+&quot; lastOcrnce: &quot;+
                //                   lastOcrnce[levels[i+1][lidx]]+&quot; temp.n: &quot;+
                //                   temp.n+&quot; lastOcrnce.n: &quot;+
                //                   lastOcrnce[levels[i+1][lidx]].n);
<span class="nc bnc" id="L949" title="All 2 branches missed.">              } while(temp!=lastOcrnce[levels[i+1][lidx]]);</span>
            }
<span class="nc" id="L951">            catch(NullPointerException ex) {</span>
<span class="nc" id="L952">              System.out.print(Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Fifth&quot;) + levels[i+1][lidx]+</span>
<span class="nc" id="L953">            		  Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Sixth&quot;) +</span>
<span class="nc" id="L954">              ((GraphNode)m_nodes.elementAt(levels[i+1][lidx])).ID+</span>
<span class="nc" id="L955">              Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Seventh&quot;) + temp);</span>
<span class="nc" id="L956">              System.out.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_Crossings_Exception_Text_Eighth&quot;) + lower.first);</span>
<span class="nc" id="L957">              ex.printStackTrace();</span>
<span class="nc" id="L958">              System.exit(-1); </span>
            }
            
<span class="nc" id="L961">            lastOcrnce[levels[i+1][lidx]]=null;</span>
<span class="nc" id="L962">            sum = sum + k1*upper.size() + k3;</span>
          }
          
          //Activating all the edges going out towards the upper right
<span class="nc bnc" id="L966" title="All 2 branches missed.">          for(int k=0; k&lt;n.edges.length; k++) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if(n.edges[k][1]&lt;0)</span>
              try {
<span class="nc bnc" id="L969" title="All 2 branches missed.">                if( indexOfElementInLevel(n.edges[k][0], levels[i]) &gt; lidx) {</span>
<span class="nc" id="L970">                  edgeOcrnce[n.edges[k][0]]=1;</span>
                }
              }
<span class="nc" id="L973">              catch(Exception ex) {</span>
<span class="nc" id="L974">                ex.printStackTrace();</span>
              }
          }
<span class="nc bnc" id="L977" title="All 2 branches missed.">          for(int k=0; k&lt;levels[i].length; k++) {</span>
<span class="nc bnc" id="L978" title="All 2 branches missed.">            if(edgeOcrnce[levels[i][k]]==1) {</span>
<span class="nc" id="L979">              MyListNode temp = new MyListNode(levels[i][k]);</span>
<span class="nc" id="L980">              upper.add(temp);</span>
<span class="nc" id="L981">              lastOcrnce[levels[i][k]]=temp;</span>
<span class="nc" id="L982">              edgeOcrnce[levels[i][k]]=0;</span>
              //System.out.println(&quot;Adding to upper: &quot;+levels[i][k]+
              //	       &quot; which is : &quot;+
              //                ((GraphNode)m_nodes.elementAt(levels[i][k])).ID+
              //	       &quot; from node: &quot;+n.ID+&quot;, &quot;+k+
              //	       &quot; first's value: &quot;+upper.first.n);
            }
          }
<span class="nc" id="L990">          lidx++;</span>
        }
      }
      //System.out.println(&quot;Sum at the end is: &quot;+sum);
    }
    
<span class="nc" id="L996">    return sum;</span>
  }
  
  
  /**
   * The following two methods remove cycles from the graph.
   */
  protected void removeCycles() {
    //visited[x]=1 is only  visited AND visited[x]=2 means node is visited
    // and is on the current path
<span class="nc" id="L1006">    int visited[]  = new int[m_nodes.size()];</span>
    
<span class="nc bnc" id="L1008" title="All 2 branches missed.">    for(int i=0; i&lt;graphMatrix.length; i++) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">      if(visited[i]==0){</span>
<span class="nc" id="L1010">        removeCycles2(i, visited);</span>
<span class="nc" id="L1011">        visited[i]=1;</span>
      }
    }
<span class="nc" id="L1014">  }</span>
  
  /** This method should not be called directly. It should be called only from 
      to call removeCycles() */
  private void removeCycles2(int nindex, int visited[]) {
<span class="nc" id="L1019">    visited[nindex]=2;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">    for(int i=0; i&lt;graphMatrix[nindex].length; i++) {</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">      if(graphMatrix[nindex][i]==DIRECTED)</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if(visited[i]==0) {</span>
<span class="nc" id="L1023">          removeCycles2(i, visited);</span>
<span class="nc" id="L1024">          visited[i]=1;</span>
        }
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        else if(visited[i]==2) {</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">          if(nindex==i) {</span>
<span class="nc" id="L1028">            graphMatrix[nindex][i]=0;</span>
          }
<span class="nc bnc" id="L1030" title="All 2 branches missed.">          else if(graphMatrix[i][nindex]==DIRECTED) {</span>
            //System.out.println(&quot;\nFound double &quot;+nindex+','+i);
<span class="nc" id="L1032">            graphMatrix[i][nindex]=DOUBLE;</span>
<span class="nc" id="L1033">            graphMatrix[nindex][i]=-DOUBLE;</span>
          }
          else {
            //System.out.println(&quot;\nReversing &quot;+nindex+','+i);
<span class="nc" id="L1037">            graphMatrix[i][nindex]=REVERSED;</span>
<span class="nc" id="L1038">            graphMatrix[nindex][i]=-REVERSED;</span>
          }
        }
    }
<span class="nc" id="L1042">  }</span>
  
  /**
   * This method assigns a vertical level to each node.
   * See makeProperHierarchy() to see how to use it.
   */
  protected void assignLevels(int levels[], int depth, int i, int j) {
    //System.out.println(i+&quot;,&quot;+j);
<span class="nc bnc" id="L1050" title="All 2 branches missed.">    if(i&gt;=graphMatrix.length)</span>
<span class="nc" id="L1051">      return;</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">    else if(j&gt;=graphMatrix[i].length)</span>
<span class="nc" id="L1053">      return;</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">    if(graphMatrix[i][j]&lt;=0)</span>
<span class="nc" id="L1055">      assignLevels(levels, depth, i, ++j);</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">    else if(graphMatrix[i][j]==DIRECTED || graphMatrix[i][j]==DOUBLE) {</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">      if(depth+1&gt;levels[j]) {</span>
<span class="nc" id="L1058">        levels[j]=depth+1;</span>
<span class="nc" id="L1059">        assignLevels(levels, depth+1, j, 0);</span>
      }
<span class="nc" id="L1061">      assignLevels(levels, depth, i, ++j);</span>
    }
<span class="nc" id="L1063">  }</span>
  
  
  /**
   * This method minimizes the number of edge crossings using the BaryCenter
   * heuristics given by Sugiyama et al. 1981
   * This method processes the graph topdown if reversed is false,
   * otherwise it does bottomup.
   */
  private int[][] minimizeCrossings(boolean reversed, int nodeLevels[][]) {
    
    //Minimizing crossings using Sugiyama's method
<span class="nc bnc" id="L1075" title="All 2 branches missed.">    if(reversed==false) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">      for(int times=0; times&lt;1; times++) {</span>
<span class="nc" id="L1077">        int tempLevels[][] = new int[nodeLevels.length][];</span>
        
        //System.out.println(&quot;---------------------------------&quot;);
        //System.out.println(&quot;Crossings before PHaseID: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1082">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        for(int i=0; i&lt;nodeLevels.length-1; i++)   //Down</span>
<span class="nc" id="L1084">          phaseID(i, tempLevels);</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1086">          nodeLevels = tempLevels;</span>
        
        //System.out.println(&quot;\nCrossings before PHaseIU: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1090">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1091">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        for(int i=nodeLevels.length-2; i&gt;=0; i--)  //Up</span>
<span class="nc" id="L1093">          phaseIU(i, tempLevels);</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1095">          nodeLevels = tempLevels;</span>
        
        //System.out.println(&quot;\nCrossings before PHaseIID: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1099">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1100">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        for(int i=0; i&lt;nodeLevels.length-1; i++) {   //Down</span>
<span class="nc" id="L1102">          phaseIID(i, tempLevels);</span>
        }
<span class="nc bnc" id="L1104" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1105">          nodeLevels = tempLevels;</span>
        //System.out.println(&quot;Crossings temp:&quot;+crossings(tempLevels)+
        //                   &quot; graph:&quot;+crossings(nodeLevels));
        //printMatrices(nodeLevels);
        
        //System.out.println(&quot;\nCrossings before PHaseIIU: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1112">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1113">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">        for(int i=nodeLevels.length-2; i&gt;=0; i--) {   //Up</span>
<span class="nc" id="L1115">          phaseIIU(i, tempLevels);</span>
        }
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1118">          nodeLevels = tempLevels;</span>
        ///System.out.println(&quot;Crossings temp:&quot;+crossings(tempLevels)+
        //                    &quot; graph:&quot;+crossings(nodeLevels));
        ///printMatrices(nodeLevels);
        //System.out.println(&quot;\nCrossings after phaseIIU: &quot;+
        //                   crossings(nodeLevels));
      }
<span class="nc" id="L1125">      return nodeLevels;</span>
    }
    else {
<span class="nc bnc" id="L1128" title="All 2 branches missed.">      for(int times=0; times&lt;1; times++) {</span>
<span class="nc" id="L1129">        int tempLevels[][] = new int[nodeLevels.length][];</span>
        
        //System.out.println(&quot;---------------------------------&quot;);
        //System.out.println(&quot;\nCrossings before PHaseIU: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1134">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        for(int i=nodeLevels.length-2; i&gt;=0; i--)  //Up</span>
<span class="nc" id="L1136">          phaseIU(i, tempLevels);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1138">          nodeLevels = tempLevels;</span>
        //printMatrices(nodeLevels);
        
        //System.out.println(&quot;Crossings before PHaseID: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1143">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1144">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">        for(int i=0; i&lt;nodeLevels.length-1; i++)   //Down</span>
<span class="nc" id="L1146">          phaseID(i, tempLevels);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1148">          nodeLevels = tempLevels;</span>
        ///printMatrices(nodeLevels);
        
        //System.out.println(&quot;\nCrossings before PHaseIIU: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1153">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1154">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">        for(int i=nodeLevels.length-2; i&gt;=0; i--) {   //Up</span>
<span class="nc" id="L1156">          phaseIIU(i, tempLevels);</span>
        }
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1159">          nodeLevels = tempLevels;</span>
        //printMatrices(nodeLevels);
        
        //System.out.println(&quot;\nCrossings before PHaseIID: &quot;+
        //                   crossings(nodeLevels));
<span class="nc" id="L1164">        tempLevels = new int[nodeLevels.length][];</span>
<span class="nc" id="L1165">        copy2DArray(nodeLevels, tempLevels);</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        for(int i=0; i&lt;nodeLevels.length-1; i++) {   //Down</span>
<span class="nc" id="L1167">          phaseIID(i, tempLevels);</span>
        }
<span class="nc bnc" id="L1169" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(nodeLevels))</span>
<span class="nc" id="L1170">          nodeLevels = tempLevels;</span>
        ///printMatrices(nodeLevels);
        //System.out.println(&quot;\nCrossings after phaseIID: &quot;+
        //                   crossings(nodeLevels));
      }
<span class="nc" id="L1175">      return nodeLevels;</span>
    }
  }
  
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   * lindex is the index of the level we want to process.
   * In this method we'll sort the vertices at the level one
   * below lindex according to their UP-barycenters (or column
   * barycenters).
   */
  protected void phaseID(final int lindex, final int levels[][]) {
    float colBC[]; //= new float[levels[lindex+1].size()];
<span class="nc" id="L1189">    colBC = calcColBC(lindex, levels);</span>
    
    //System.out.println(&quot;In ID Level&quot;+(lindex+1)+&quot;:&quot;);
    //System.out.print(&quot;\t&quot;);
    //for(int i=0; i&lt;colBC.length; i++)
    //   {System.out.print(&quot;Col&quot;+(i+1)+&quot;:&quot;+colBC[i]+&quot; &quot;);
    //    }
    //System.out.println(&quot;&quot;);
    //colBC = calcColBC1(lindex, levels);
    //for(int i=0; i&lt;colBC.length; i++)
    //  {System.out.print(&quot;Col&quot;+(i+1)+&quot;:&quot;+colBC[i]+&quot; &quot;);
    //    }
    //System.out.println(&quot;&quot;);
    //System.out.print(&quot;\n\tNodes &quot;);
    //for(int i=0; i&lt;levels[lindex+1].length; i++)
    //    System.out.print(levels[lindex+1][i]+&quot; &quot;);
    //System.out.println(&quot;&quot;);
    //System.out.println(&quot;\nCrossings: &quot;+crossings(levels));
    //inspect(false, lindex, levels, colBC);
    
<span class="nc" id="L1209">    isort(levels[lindex+1], colBC);</span>
    //combSort11(levels[lindex+1], colBC);
    //System.out.println(&quot;After sorting&quot;);
    //System.out.print(&quot;\t&quot;);
    //for(int i=0; i&lt;colBC.length; i++)
    //    {System.out.print(&quot;Col&quot;+(i+1)+&quot;:&quot;+colBC[i]+&quot; &quot;);
    //    }
    //System.out.print(&quot;\n\tNodes &quot;);
    //for(int i=0; i&lt;levels[lindex+1].length; i++)
    //    System.out.print(levels[lindex+1][i]+&quot; &quot;);
    //System.out.println(&quot;\nCrossings: &quot;+crossings(levels));
    ///System.out.println(&quot;&quot;);
<span class="nc" id="L1221">  }</span>
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   * lindex is the index of the level we want to process.
   * In this method we'll sort the vertices at the level
   * lindex according to their DOWN-barycenters (or row
   * barycenters).
   */
  public void phaseIU(final int lindex, final int levels[][]) {
    float rowBC[];
<span class="nc" id="L1232">    rowBC = calcRowBC(lindex, levels);</span>
    
    //System.out.println(&quot;In IU Level&quot;+(lindex+1)+&quot;:&quot;);
    //System.out.print(&quot;\t&quot;);
    //for(int i=0; i&lt;rowBC.length; i++)
    //    {System.out.print(&quot;Row&quot;+(i+1)+&quot;:&quot;+rowBC[i]+&quot; &quot;);
    //    }
    //    System.out.print(&quot;\n\t&quot;);
    //    rowBC = calcRowBC1(lindex, levels);
    //    for(int i=0; i&lt;rowBC.length; i++)
    //      {System.out.print(&quot;Row&quot;+(i+1)+&quot;:&quot;+rowBC[i]+&quot; &quot;);
    //      }
    //    System.out.println(&quot;&quot;);
    //System.out.print(&quot;\n\tNodes &quot;);
    //for(int i=0; i&lt;levels[lindex].length; i++)
    //    System.out.print(levels[lindex][i]+&quot; &quot;);
    //System.out.println(&quot;\nCrossings: &quot;+crossings(levels));
    //inspect(true, lindex, levels, rowBC);
    
<span class="nc" id="L1251">    isort(levels[lindex], rowBC);</span>
    //combSort11(levels[lindex], rowBC);
    //System.out.println(&quot;After sorting\n\t&quot;);
    //for(int i=0; i&lt;rowBC.length; i++)
    //    {System.out.print(&quot;Row&quot;+(i+1)+&quot;:&quot;+rowBC[i]+&quot; &quot;);
    //    }
    //System.out.print(&quot;\n\tNodes &quot;);
    //for(int i=0; i&lt;levels[lindex].length; i++)
    //    System.out.print(levels[lindex][i]+&quot; &quot;);
    //System.out.println(&quot;\nCrossings: &quot;+crossings(levels));
<span class="nc" id="L1261">  }</span>
  
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   */
  public void phaseIID(final int lindex, final int levels[][]) {
    float colBC[];
<span class="nc" id="L1269">    colBC = calcColBC(lindex, levels);</span>
    
    //System.out.println(&quot;getting into phase IID&quot;);
<span class="nc bnc" id="L1272" title="All 2 branches missed.">    for(int i=0; i&lt;colBC.length-1; i++) {</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      if(colBC[i]==colBC[i+1]) {</span>
        //System.out.println(&quot;Crossings before begining of iteration: &quot;+
        //                   crossings(levels));
<span class="nc" id="L1276">        int tempLevels[][] = new int[levels.length][];</span>
<span class="nc" id="L1277">        copy2DArray(levels, tempLevels);</span>
        //System.out.println(&quot;Interchanging: &quot;+
        //       ((GraphNode)m_nodes.elementAt(levels[lindex+1][i])).ID+
        //       &quot; &amp; &quot;+
        //	 ((GraphNode)m_nodes.elementAt(levels[lindex+1][(i+1)])).ID+
        //	 &quot; at level &quot;+(lindex+1) );
<span class="nc" id="L1283">        int node1 = levels[lindex+1][i];</span>
<span class="nc" id="L1284">        int node2 = levels[lindex+1][i+1];</span>
<span class="nc" id="L1285">        levels[lindex+1][i+1] = node1;</span>
<span class="nc" id="L1286">        levels[lindex+1][i] = node2;</span>
        
<span class="nc bnc" id="L1288" title="All 2 branches missed.">        for(int k=lindex+1; k&lt;levels.length-1; k++)</span>
<span class="nc" id="L1289">          phaseID(k, levels);</span>
        //System.out.println(&quot;Crossings temp:&quot;+crossings(tempLevels)+
        //                   &quot; graph:&quot;+crossings(levels));
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if(crossings(levels)&lt;=crossings(tempLevels)) {</span>
          //System.out.println(&quot;Crossings temp: &quot;+crossings(tempLevels)+
          //                   &quot; Crossings levels: &quot;+crossings(levels));
<span class="nc" id="L1295">          copy2DArray(levels, tempLevels); } //printMatrices(levels); }</span>
        else {
<span class="nc" id="L1297">          copy2DArray(tempLevels, levels);</span>
<span class="nc" id="L1298">          levels[lindex+1][i+1] = node1;</span>
<span class="nc" id="L1299">          levels[lindex+1][i] = node2;</span>
        }
        //System.out.println(&quot;Crossings after PhaseID of phaseIID, &quot;+
        //                   &quot;in iteration &quot;+i+&quot; of &quot;+(colBC.length-1)+&quot; at &quot;+
        //                   lindex+&quot;, levels: &quot;+crossings(levels)+
        //                   &quot; temp: &quot;+crossings(tempLevels));
        
        //tempLevels = new int[levels.length][];
        //copy2DArray(levels, tempLevels);
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        for(int k=levels.length-2; k&gt;=0; k--)</span>
<span class="nc" id="L1309">          phaseIU(k, levels);</span>
        //System.out.println(&quot;Crossings temp:&quot;+crossings(tempLevels)+
        //                   &quot; graph:&quot;+crossings(levels));
        //if(crossings(tempLevels)&lt;crossings(levels)) {
        // System.out.println(&quot;Crossings temp: &quot;+crossings(tempLevels)+
        //                    &quot; Crossings levels: &quot;+crossings(levels));
        //      copy2DArray(tempLevels, levels); } //printMatrices(levels); }
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;crossings(levels))</span>
<span class="nc" id="L1317">          copy2DArray(tempLevels, levels);</span>
        
        //System.out.println(&quot;Crossings after PhaseIU of phaseIID, in&quot;+
        //                   &quot; iteration &quot;+i+&quot; of &quot;+(colBC.length-1)+&quot; at &quot;
        //		     +lindex+&quot;, levels: &quot;+crossings(levels)+&quot; temp: &quot;+
        //                   crossings(tempLevels));
        //colBC = calcColBC(lindex, levels);
      }
    }
<span class="nc" id="L1326">  }</span>
  
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   */
  public void phaseIIU(final int lindex, final int levels[][]) {
    float rowBC[];
<span class="nc" id="L1334">    rowBC = calcRowBC(lindex, levels);</span>
    
    //System.out.println(&quot;Getting into phaseIIU&quot;);
<span class="nc bnc" id="L1337" title="All 2 branches missed.">    for(int i=0; i&lt;rowBC.length-1; i++) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">      if(rowBC[i]==rowBC[i+1]) {</span>
        //System.out.println(&quot;Crossings before begining of iteration: &quot;+
        //                   crossings(levels));
<span class="nc" id="L1341">        int tempLevels[][] = new int[levels.length][];</span>
<span class="nc" id="L1342">        copy2DArray(levels, tempLevels);</span>
        //System.out.println(&quot;Interchanging: &quot;+
        //          ((GraphNode)m_nodes.elementAt(levels[lindex][i])).ID+&quot; &amp; &quot;+
        //          ((GraphNode)m_nodes.elementAt(levels[lindex][i+1])).ID+
        //          &quot; at level &quot;+(lindex+1) );
<span class="nc" id="L1347">        int node1 = levels[lindex][i];</span>
<span class="nc" id="L1348">        int node2 = levels[lindex][i+1];</span>
<span class="nc" id="L1349">        levels[lindex][i+1] = node1;</span>
<span class="nc" id="L1350">        levels[lindex][i] = node2;</span>
        
<span class="nc bnc" id="L1352" title="All 2 branches missed.">        for(int k=lindex-1; k&gt;=0; k--)</span>
<span class="nc" id="L1353">          phaseIU(k, levels);</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        if(crossings(levels)&lt;=crossings(tempLevels)) { </span>
          //System.out.println(&quot;Crossings temp: &quot;+crossings(tempLevels)+
          //                   &quot; Crossings levels: &quot;+crossings(levels));
<span class="nc" id="L1357">          copy2DArray(levels, tempLevels); } //printMatrices(levels);</span>
        else {
<span class="nc" id="L1359">          copy2DArray(tempLevels, levels);</span>
<span class="nc" id="L1360">          levels[lindex][i+1] = node1;</span>
<span class="nc" id="L1361">          levels[lindex][i] = node2;</span>
        }
        //System.out.println(&quot;Crossings after PhaseIU of PhaseIIU, in &quot;+
        //                   &quot;iteration &quot;+i+&quot; of &quot;+(rowBC.length-1)+&quot; at &quot;
        //                   +lindex+&quot;, levels: &quot;+crossings(levels)+
        //                   &quot; temp: &quot;+crossings(tempLevels));
        
        //tempLevels = new int[levels.length][];
        //copy2DArray(levels, tempLevels);
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for(int k=0; k&lt;levels.length-1; k++) //lindex-1; k++)</span>
<span class="nc" id="L1371">          phaseID(k, levels);</span>
        //if(crossings(tempLevels)&lt;crossings(levels)) { 
        //  System.out.println(&quot;Crossings temp: &quot;+crossings(tempLevels)+
        //                     &quot; Crossings levels: &quot;+crossings(levels));
        //      copy2DArray(tempLevels, levels); } //printMatrices(levels); }
<span class="nc bnc" id="L1376" title="All 2 branches missed.">        if(crossings(tempLevels)&lt;=crossings(levels))</span>
<span class="nc" id="L1377">          copy2DArray(tempLevels, levels);</span>
        //System.out.println(&quot;Crossings after PhaseID of phaseIIU, in &quot;+
        //                   &quot;iteration &quot;+i+&quot; of &quot;+(rowBC.length-1)+&quot; at &quot;
        //                   +lindex+&quot;, levels: &quot;+crossings(levels)+
        //                   &quot; temp: &quot;+crossings(tempLevels));
        //rowBC = calcRowBC(lindex, levels);
      }
    }
<span class="nc" id="L1385">  }</span>
  
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   */
  protected float [] calcRowBC(final int lindex, final int levels[][]){
<span class="nc" id="L1392">    float rowBC[] = new float[levels[lindex].length];</span>
    GraphNode n;
    
<span class="nc bnc" id="L1395" title="All 2 branches missed.">    for(int i=0; i&lt;levels[lindex].length; i++) {</span>
<span class="nc" id="L1396">      int sum=0;</span>
<span class="nc" id="L1397">      n = (GraphNode)m_nodes.elementAt(levels[lindex][i]);</span>
      
<span class="nc bnc" id="L1399" title="All 2 branches missed.">      for(int j=0; j&lt;n.edges.length; j++) {</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">        if(n.edges[j][1]&gt;0) {</span>
<span class="nc" id="L1401">          sum++;</span>
          try {
<span class="nc" id="L1403">            rowBC[i] = </span>
<span class="nc" id="L1404">              rowBC[i]+indexOfElementInLevel(n.edges[j][0], levels[lindex+1])+1;</span>
          }
<span class="nc" id="L1406">          catch(Exception ex) { return null; }</span>
        }
      }
<span class="nc bnc" id="L1409" title="All 2 branches missed.">      if(rowBC[i]!=0)</span>
<span class="nc" id="L1410">        rowBC[i] = rowBC[i]/sum;</span>
    }
<span class="nc" id="L1412">    return rowBC;</span>
  }
  
  
  /**
   * See Sugiyama et al. 1981 (full reference give at top)
   */
  protected float [] calcColBC(final int lindex, final int levels[][]) {
<span class="nc" id="L1420">    float colBC[] = new float[levels[lindex+1].length];</span>
    GraphNode n;
    
<span class="nc bnc" id="L1423" title="All 2 branches missed.">    for(int i=0; i&lt;levels[lindex+1].length; i++) {</span>
<span class="nc" id="L1424">      int sum=0;</span>
<span class="nc" id="L1425">      n = (GraphNode)m_nodes.elementAt(levels[lindex+1][i]);</span>
      
<span class="nc bnc" id="L1427" title="All 2 branches missed.">      for(int j=0; j&lt;n.edges.length; j++) {</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        if(n.edges[j][1]&lt;1) {</span>
<span class="nc" id="L1429">          sum++;</span>
          try{
<span class="nc" id="L1431">            colBC[i] =</span>
<span class="nc" id="L1432">                colBC[i]+indexOfElementInLevel(n.edges[j][0], levels[lindex])+1;</span>
          }
<span class="nc" id="L1434">          catch(Exception ex) { return null; }</span>
        }
      }
<span class="nc bnc" id="L1437" title="All 2 branches missed.">      if(colBC[i]!=0)</span>
<span class="nc" id="L1438">        colBC[i]=colBC[i]/sum;</span>
    }
<span class="nc" id="L1440">    return colBC;</span>
  }
  
  /**
   * Prints out the interconnection matrix at each level.
   * See Sugiyama et al. 1981 (full reference give at top)
   */
  protected void printMatrices(final int levels[][]) {
<span class="nc" id="L1448">    int i=0;</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">    for(i=0; i&lt;levels.length-1; i++) {</span>
<span class="nc" id="L1450">      float rowBC[]=null; float colBC[]=null;</span>
      try{
<span class="nc" id="L1452">        rowBC = calcRowBC(i, levels); colBC = calcColBC(i, levels);</span>
      }
<span class="nc" id="L1454">      catch(NullPointerException ne) {</span>
<span class="nc" id="L1455">        System.out.println(&quot;i: &quot;+i+&quot; levels.length: &quot;+levels.length);</span>
<span class="nc" id="L1456">        ne.printStackTrace();</span>
<span class="nc" id="L1457">        return;</span>
      }
      
<span class="nc" id="L1460">      System.out.print(&quot;\nM&quot;+(i+1)+&quot;\t&quot;);</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">      for(int j=0; j&lt;levels[i+1].length; j++) {</span>
<span class="nc" id="L1462">        System.out.print( ((GraphNode)m_nodes.elementAt(levels[i+1][j])).ID +</span>
<span class="nc" id="L1463">                          &quot; &quot;);</span>
        //((Integer)levels[i+1].elementAt(j)).intValue())+&quot; &quot;);
      }
<span class="nc" id="L1466">      System.out.println(&quot;&quot;);</span>
      
<span class="nc bnc" id="L1468" title="All 2 branches missed.">      for(int j=0; j&lt;levels[i].length; j++) {</span>
<span class="nc" id="L1469">        System.out.print( ((GraphNode)m_nodes.elementAt(levels[i][j])).ID+&quot;\t&quot;);</span>
        //((Integer)levels[i].elementAt(j)).intValue())+&quot;\t&quot;);
<span class="nc bnc" id="L1471" title="All 2 branches missed.">        for(int k=0; k&lt;levels[i+1].length; k++) {</span>
          
<span class="nc" id="L1473">          System.out.print(graphMatrix[levels[i][j]] </span>
                                 //((Integer)levels[i].elementAt(j)).intValue()]
<span class="nc" id="L1475">                                      [levels[i+1][k]]+&quot; &quot;); </span>
                         //((Integer)levels[i+1].elementAt(k)).intValue()]+&quot; &quot;);
          
        }
<span class="nc" id="L1479">        System.out.println(rowBC[j]);</span>
      }
<span class="nc" id="L1481">      System.out.print(&quot;\t&quot;);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">      for(int k=0; k&lt;levels[i+1].length; k++)</span>
<span class="nc" id="L1483">        System.out.print(colBC[k]+&quot; &quot;);</span>
    }
<span class="nc" id="L1485">    System.out.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_PrintMatrices_Text_Second&quot;) + i + Messages.getInstance().getString(&quot;HierarchicalBCEngine_PrintMatrices_Text_First&quot;) + levels.length);</span>
<span class="nc" id="L1486">  }</span>
  
  /**
   * This methods sorts the vertices in level[] according to their
   * barycenters in BC[], using combsort11. It, however, doesn't touch the
   * vertices with barycenter equal to zero.
   */
    /*
     *  //This method should be removed
     protected static void combSort11(int level[], float BC[]) {  
        int switches, j, top, gap, lhold;
        float hold;
        gap = BC.length;
        do {
            gap=(int)(gap/1.3);
            switch(gap) {
            case 0:
                gap = 1;
                break;
            case 9:
            case 10:
                gap=11;
                break;
            default:
                break;
            }
            switches=0;
            top = BC.length-gap;
            for(int i=0; i&lt;top; i++) {
                j=i+gap;
                if(BC[i]==0 || BC[j]==0)
                    continue;
                if(BC[i] &gt; BC[j]) {
                    hold=BC[i];
                    BC[i]=BC[j];
                    BC[j]=hold;
                    lhold = level[i];
                    level[i] = level[j];
                    level[j] = lhold;
                    switches++;
                }//endif
            }//endfor
        }while(switches&gt;0 || gap&gt;1);
    }
     */
  
  
  /**
   * This methods sorts the vertices in level[] according to their
   * barycenters in BC[], using insertion sort. It, however, doesn't touch the
   * vertices with barycenter equal to zero.
   */
   //Both level and BC have elements in the same order
  protected static void isort(int level[], float BC[]) { 
    float temp;
    int temp2;
<span class="nc bnc" id="L1542" title="All 2 branches missed.">    for(int i=0; i&lt;BC.length-1; i++) {</span>
      
<span class="nc" id="L1544">      int j=i;</span>
<span class="nc" id="L1545">      temp=BC[j+1];</span>
<span class="nc" id="L1546">      temp2=level[j+1];</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">      if(temp==0)</span>
<span class="nc" id="L1548">        continue;</span>
<span class="nc" id="L1549">      int prej=j+1;</span>
      
<span class="nc bnc" id="L1551" title="All 6 branches missed.">      while( j&gt;-1 &amp;&amp; (temp&lt;BC[j]|| BC[j]==0) ) {</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        if(BC[j]==0){</span>
<span class="nc" id="L1553">          j--; continue;}</span>
        else {
<span class="nc" id="L1555">          BC[prej] = BC[j];</span>
<span class="nc" id="L1556">          level[prej] = level[j];</span>
<span class="nc" id="L1557">          prej=j;</span>
<span class="nc" id="L1558">          j--;</span>
        }
      }
      //j++;
<span class="nc" id="L1562">      BC[prej]    = temp;</span>
<span class="nc" id="L1563">      level[prej] = temp2;</span>
      //Integer node = (Integer)level.elementAt(i+1);
      //level.removeElementAt(i+1);
      //level.insertElementAt(node, prej);
    }
<span class="nc" id="L1568">  }</span>
  
  
  /**
   * Copies one Matrix of type int[][] to another.
   */
  protected void copyMatrix(int from[][], int to[][]) {
<span class="nc bnc" id="L1575" title="All 2 branches missed.">    for(int i=0; i&lt;from.length; i++)</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">      for(int j=0; j&lt;from[i].length; j++)</span>
<span class="nc" id="L1577">        to[i][j]=from[i][j];</span>
<span class="nc" id="L1578">  }</span>
  
  /**
   * Copies one array of type int[][] to another.
   */
  protected void copy2DArray(int from[][], int to[][]) {
<span class="nc bnc" id="L1584" title="All 2 branches missed.">    for(int i=0; i&lt;from.length; i++) {</span>
<span class="nc" id="L1585">      to[i] = new int[from[i].length];</span>
<span class="nc" id="L1586">      System.arraycopy(from[i], 0, to[i], 0, from[i].length);</span>
      //for(int j=0; j&lt;from[i].length; j++)
      //	to[i][j] = from[i][j];
    }
<span class="nc" id="L1590">  }</span>
  
  /**
   * This method lays out the vertices horizontally, in each level.
   * It simply assings an x value to a vertex according to its
   * index in the level.
   */
  protected void naiveLayout() {
    /*
    if(maxStringWidth==0) {
      int strWidth;
      for(int i=0; i&lt;m_nodes.size(); i++) {
        strWidth = m_fm.stringWidth(((GraphNode)m_nodes.elementAt(i)).lbl);
        if(strWidth&gt;maxStringWidth)
          maxStringWidth=strWidth;
      }
      
      if(m_nodeSize&lt;maxStringWidth)
      {m_nodeSize = maxStringWidth+4; m_nodeArea = m_nodeSize+8; }
    }
    */
<span class="nc bnc" id="L1611" title="All 2 branches missed.">    if(nodeLevels==null)</span>
<span class="nc" id="L1612">      makeProperHierarchy();</span>
    
    //int nodeHeight = m_nodeHeight*2; //m_fm.getHeight()*2;
<span class="nc bnc" id="L1615" title="All 2 branches missed.">    for(int i=0, temp=0; i&lt;nodeLevels.length; i++) {</span>
<span class="nc bnc" id="L1616" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc" id="L1617">        temp=nodeLevels[i][j];</span>
        //horPositions[temp]=j;
<span class="nc" id="L1619">        GraphNode n = (GraphNode)m_nodes.elementAt(temp);</span>
<span class="nc" id="L1620">        n.x = j*m_nodeWidth; //horPositions[temp]*m_nodeWidth;</span>
<span class="nc" id="L1621">        n.y = i*3*m_nodeHeight;</span>
      }
    }
    //setAppropriateSize();
<span class="nc" id="L1625">  }</span>
  
  
  protected int uConnectivity(int lindex, int eindex) {
<span class="nc" id="L1629">    int n=0;</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">    for(int i=0; i&lt;nodeLevels[lindex-1].length; i++)</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">      if(graphMatrix[ nodeLevels[lindex-1][i] ][ nodeLevels[lindex][eindex] ]&gt;0)</span>
<span class="nc" id="L1632">        n++;</span>
    
<span class="nc" id="L1634">    return n;</span>
  }
  
  protected int lConnectivity(int lindex, int eindex) {
<span class="nc" id="L1638">    int n=0;</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">    for(int i=0; i&lt;nodeLevels[lindex+1].length; i++)</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">      if(graphMatrix[ nodeLevels[lindex][eindex] ][ nodeLevels[lindex+1][i] ]&gt;0)</span>
<span class="nc" id="L1641">        n++;</span>
    
<span class="nc" id="L1643">    return n;</span>
  }
  
  protected int uBCenter(int lindex, int eindex, int horPositions[]) {
<span class="nc" id="L1647">    int sum=0;</span>
    
<span class="nc bnc" id="L1649" title="All 2 branches missed.">    for(int i=0; i&lt;nodeLevels[lindex-1].length; i++)</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">      if(graphMatrix[nodeLevels[lindex-1][i]][nodeLevels[lindex][eindex]]&gt;0)</span>
<span class="nc" id="L1651">        sum = sum + (horPositions[nodeLevels[lindex-1][i]]);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">    if(sum!=0) { // To avoid 0/0</span>
      //System.out.println(&quot;uBC Result: &quot;+sum+&quot;/&quot;+
      //                   uConnectivity(lindex,eindex)+
      //                   &quot; = &quot;+(sum/uConnectivity(lindex,eindex)) );
<span class="nc" id="L1656">      sum = sum/uConnectivity(lindex,eindex);</span>
    }
<span class="nc" id="L1658">    return sum;</span>
  }
  
  
  protected int lBCenter(int lindex, int eindex, int horPositions[]) {
<span class="nc" id="L1663">    int sum=0;</span>
    
<span class="nc bnc" id="L1665" title="All 2 branches missed.">    for(int i=0; i&lt;nodeLevels[lindex+1].length; i++)</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">      if(graphMatrix[nodeLevels[lindex][eindex]][nodeLevels[lindex+1][i]]&gt;0)</span>
<span class="nc" id="L1667">        sum = sum + (horPositions[nodeLevels[lindex+1][i]]);</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">    if(sum!=0)  // To avoid 0/0</span>
<span class="nc" id="L1669">      sum = sum/lConnectivity(lindex, eindex); //lConectivity;</span>
<span class="nc" id="L1670">    return sum;</span>
  }
  
  private void tempMethod(int horPositions[]) {
    
<span class="nc" id="L1675">    int minPosition = horPositions[0];</span>
    
<span class="nc bnc" id="L1677" title="All 2 branches missed.">    for(int i=0; i&lt;horPositions.length; i++)</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">      if(horPositions[i]&lt;minPosition)</span>
<span class="nc" id="L1679">        minPosition=horPositions[i];</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">    if(minPosition&lt;0) {</span>
<span class="nc" id="L1681">      minPosition = minPosition*-1;</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">      for(int i=0; i&lt;horPositions.length; i++){</span>
        //System.out.print(horPositions[i]);
<span class="nc" id="L1684">        horPositions[i]+=minPosition;</span>
        //System.out.println(&quot;&gt;&quot;+horPositions[i]);
      }
    }
    
    //int nodeHeight = m_nodeHeight*2; //m_fm.getHeight()*2;
<span class="nc bnc" id="L1690" title="All 2 branches missed.">    for(int i=0, temp=0; i&lt;nodeLevels.length; i++) {</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc" id="L1692">        temp=nodeLevels[i][j];</span>
        //horPositions[temp]=j;
<span class="nc" id="L1694">        GraphNode n = (GraphNode)m_nodes.elementAt(temp);</span>
<span class="nc" id="L1695">        n.x = horPositions[temp]*m_nodeWidth;</span>
<span class="nc" id="L1696">        n.y = i*3*m_nodeHeight;</span>
      }
    }
<span class="nc" id="L1699">  }</span>
  
  /**
   * This method lays out the vertices horizontally, in each level.
   * See Sugiyama et al. 1981 for full reference.
   */
  protected void priorityLayout1() {
    
<span class="nc" id="L1707">    int [] horPositions = new int[m_nodes.size()];</span>
<span class="nc" id="L1708">    int maxCount=0;</span>
    
<span class="nc bnc" id="L1710" title="All 2 branches missed.">    for(int i=0; i&lt;nodeLevels.length; i++) {</span>
<span class="nc" id="L1711">      int count=0;</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc" id="L1713">        horPositions[nodeLevels[i][j]]=j;</span>
<span class="nc" id="L1714">        count++;</span>
      }
<span class="nc bnc" id="L1716" title="All 2 branches missed.">      if(count&gt;maxCount)</span>
<span class="nc" id="L1717">        maxCount=count;</span>
    }
    //fireLayoutCompleteEvent( new LayoutCompleteEvent(this) );
    int priorities[], BC[];
    //System.out.println(&quot;********Going from 2 to n********&quot;);
<span class="nc bnc" id="L1722" title="All 2 branches missed.">    for(int i=1; i&lt;nodeLevels.length; i++) {</span>
<span class="nc" id="L1723">      priorities = new int[nodeLevels[i].length];</span>
<span class="nc" id="L1724">      BC = new int[nodeLevels[i].length];</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">        if(((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID.startsWith(&quot;S&quot;))</span>
<span class="nc" id="L1727">          priorities[j] = maxCount+1;</span>
        else
<span class="nc" id="L1729">          priorities[j] = uConnectivity(i, j);</span>
<span class="nc" id="L1730">        BC[j] = uBCenter(i, j, horPositions);</span>
      }
      //for(int j=0; j&lt;nodeLevels[i].length; j++)
      //  System.out.println(&quot;Level: &quot;+(i+1)+&quot; Node: &quot;
      //	+((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID
      //        +&quot; uConnectivity: &quot;+priorities[j]+&quot; uBC: &quot;+BC[j]+&quot; position: &quot;
      //	+horPositions[nodeLevels[i][j]]);
<span class="nc" id="L1737">      priorityLayout2(nodeLevels[i], priorities, BC, horPositions);</span>
      //repaint
      //try {
      //	tempMethod(horPositions);
      //	fireLayoutCompleteEvent( new LayoutCompleteEvent(this) );
      //	Thread.sleep(1000);
      //} catch(InterruptedException ie) { ie.printStackTrace(); }
      
      //for(int j=0; j&lt;nodeLevels[i].length; j++)
      //    System.out.println(&quot;Level: &quot;+(i+1)+&quot; Node: &quot;
      //	+((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID
      //	+&quot; uConnectivity: &quot;+priorities[j]+&quot; uBC: &quot;+BC[j]+&quot; position: &quot;
      //	+horPositions[nodeLevels[i][j]]);
    }
    
    //System.out.println(&quot;********Going from n-1 to 1********&quot;);
<span class="nc bnc" id="L1753" title="All 2 branches missed.">    for(int i=nodeLevels.length-2; i&gt;=0; i--) {</span>
<span class="nc" id="L1754">      priorities = new int[nodeLevels[i].length];</span>
<span class="nc" id="L1755">      BC = new int[nodeLevels[i].length];</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">        if(((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID.startsWith(&quot;S&quot;))</span>
<span class="nc" id="L1758">          priorities[j] = maxCount+1;</span>
        else
<span class="nc" id="L1760">          priorities[j] = lConnectivity(i, j);</span>
<span class="nc" id="L1761">        BC[j] = lBCenter(i, j, horPositions); //, priorities[j]);</span>
      }
<span class="nc" id="L1763">      priorityLayout2(nodeLevels[i], priorities, BC, horPositions);</span>
      //repaint();
      //try {
      //	tempMethod(horPositions);
      //	fireLayoutCompleteEvent( new LayoutCompleteEvent(this) );
      //	Thread.sleep(1000);
      //} catch(InterruptedException ie) { ie.printStackTrace(); }
      
      //for(int j=0; j&lt;nodeLevels[i].length; j++)
      //    System.out.println(&quot;Level: &quot;+(i+1)+&quot; Node: &quot;
      //	+((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID
      //	+&quot; lConnectivity: &quot;+priorities[j]+&quot; lBC: &quot;+BC[j]+&quot; position: &quot;
      //	+horPositions[nodeLevels[i][j]]);
    }
    
    //System.out.println(&quot;********Going from 2 to n again********&quot;);
<span class="nc bnc" id="L1779" title="All 2 branches missed.">    for(int i=2; i&lt;nodeLevels.length; i++) {</span>
<span class="nc" id="L1780">      priorities = new int[nodeLevels[i].length];</span>
<span class="nc" id="L1781">      BC = new int[nodeLevels[i].length];</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">        if(((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID.startsWith(&quot;S&quot;))</span>
<span class="nc" id="L1784">          priorities[j] = maxCount+1;</span>
        else
<span class="nc" id="L1786">          priorities[j] = uConnectivity(i, j);</span>
<span class="nc" id="L1787">        BC[j] = uBCenter(i, j, horPositions);</span>
      }
      //for(int j=0; j&lt;nodeLevels[i].length; j++)
      //    System.out.println(&quot;Level: &quot;+(i+1)+&quot; Node: &quot;
      //	+((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID
      //	+&quot; uConnectivity: &quot;+priorities[j]+&quot; uBC: &quot;+BC[j]+&quot; position: &quot;
      //	+horPositions[nodeLevels[i][j]]);
<span class="nc" id="L1794">      priorityLayout2(nodeLevels[i], priorities, BC, horPositions);</span>
      //repaint();
      //try {
      //	tempMethod(horPositions);
      //	fireLayoutCompleteEvent( new LayoutCompleteEvent(this) );
      //	Thread.sleep(1000);
      //} catch(InterruptedException ie) { ie.printStackTrace(); }
      //for(int j=0; j&lt;nodeLevels[i].length; j++)
      //    System.out.println(&quot;Level: &quot;+(i+1)+&quot; Node: &quot;
      //	+((GraphNode)m_nodes.elementAt(nodeLevels[i][j])).ID
      //	+&quot; uConnectivity: &quot;+priorities[j]+&quot; uBC: &quot;+BC[j]+&quot; position: &quot;
      //	+horPositions[nodeLevels[i][j]]);
    }
    
<span class="nc" id="L1808">    int minPosition = horPositions[0];</span>
    
<span class="nc bnc" id="L1810" title="All 2 branches missed.">    for(int i=0; i&lt;horPositions.length; i++)</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">      if(horPositions[i]&lt;minPosition)</span>
<span class="nc" id="L1812">        minPosition=horPositions[i];</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">    if(minPosition&lt;0) {</span>
<span class="nc" id="L1814">      minPosition = minPosition*-1;</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">      for(int i=0; i&lt;horPositions.length; i++){</span>
        //System.out.print(horPositions[i]);
<span class="nc" id="L1817">        horPositions[i]+=minPosition;</span>
        //System.out.println(&quot;&gt;&quot;+horPositions[i]);
      }
    }
    
    //int nodeHeight = m_nodeHeight*2; //m_fm.getHeight()*2;
<span class="nc bnc" id="L1823" title="All 2 branches missed.">    for(int i=0, temp=0; i&lt;nodeLevels.length; i++) {</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">      for(int j=0; j&lt;nodeLevels[i].length; j++) {</span>
<span class="nc" id="L1825">        temp=nodeLevels[i][j];</span>
        //horPositions[temp]=j;
<span class="nc" id="L1827">        GraphNode n = (GraphNode)m_nodes.elementAt(temp);</span>
<span class="nc" id="L1828">        n.x = horPositions[temp]*m_nodeWidth;</span>
<span class="nc" id="L1829">        n.y = i*3*m_nodeHeight;</span>
      }
    }
    //setAppropriateSize();
<span class="nc" id="L1833">  }</span>
  
  /**
   * This method is used by priorityLayout1(). It should
   * not be called directly.
   * This method does the actual moving of the vertices in each level
   * based on their priorities and barycenters.
   */
  private void priorityLayout2(int level[], int priorities[], 
                               int bCenters[], int horPositions[]) {
<span class="nc" id="L1843">    int descOrder[] = new int[priorities.length];</span>
    
    //Getting the indices of priorities in descending order
<span class="nc" id="L1846">    descOrder[0]=0;</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">    for(int i=0; i&lt;priorities.length-1; i++) {</span>
<span class="nc" id="L1848">      int j=i;</span>
<span class="nc" id="L1849">      int temp=i+1;</span>
      
<span class="nc bnc" id="L1851" title="All 4 branches missed.">      while( j&gt;-1 &amp;&amp; priorities[descOrder[j]]&lt;priorities[temp] ) {</span>
<span class="nc" id="L1852">        descOrder[j+1] = descOrder[j];</span>
<span class="nc" id="L1853">        j--;</span>
      }
<span class="nc" id="L1855">      j++;</span>
<span class="nc" id="L1856">      descOrder[j] = temp;</span>
    }
    
    //System.out.println(&quot;\nPriorities:&quot;);
    //for(int i=0; i&lt;priorities.length; i++)
    //    System.out.print(priorities[i]+&quot; &quot;);
    //System.out.println(&quot;\nDescOrder:&quot;);
    //for(int i=0; i&lt;descOrder.length; i++)
    //    System.out.print(descOrder[i]+&quot; &quot;);
    
<span class="nc bnc" id="L1866" title="All 2 branches missed.">    for(int k=0; k&lt;descOrder.length; k++)</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">      for(int i=0; i&lt;descOrder.length; i++) {</span>
        
<span class="nc" id="L1869">        int leftCount=0, rightCount=0, leftNodes[], rightNodes[];</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">        for(int j=0; j&lt;priorities.length; j++) {</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">          if( horPositions[level[descOrder[i]]] &gt; horPositions[level[j]] )</span>
<span class="nc" id="L1872">            leftCount++;</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">          else if( horPositions[level[descOrder[i]]] &lt; horPositions[level[j]] )</span>
<span class="nc" id="L1874">            rightCount++;</span>
        }
<span class="nc" id="L1876">        leftNodes = new int[leftCount];</span>
<span class="nc" id="L1877">        rightNodes = new int[rightCount];</span>
        
<span class="nc bnc" id="L1879" title="All 2 branches missed.">        for(int j=0, l=0, r=0; j&lt;priorities.length; j++)</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">          if( horPositions[level[descOrder[i]]] &gt; horPositions[level[j]] )</span>
<span class="nc" id="L1881">            leftNodes[l++]=j;</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">          else if( horPositions[level[descOrder[i]]] &lt; horPositions[level[j]] )</span>
<span class="nc" id="L1883">            rightNodes[r++]=j;</span>
        
        
        //****Moving left
<span class="nc" id="L1887">        while(Math.abs(horPositions[level[descOrder[i]]]-1</span>
<span class="nc" id="L1888">                                    -bCenters[descOrder[i]])  &lt;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">          Math.abs(horPositions[level[descOrder[i]]]-bCenters[descOrder[i]]) ) {</span>
          
          //****Checking if it can be moved to left
<span class="nc" id="L1892">          int temp = horPositions[level[descOrder[i]]];</span>
<span class="nc" id="L1893">          boolean cantMove=false;</span>
          
<span class="nc bnc" id="L1895" title="All 2 branches missed.">          for(int j=leftNodes.length-1; j&gt;=0; j--) {</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if(temp-horPositions[level[leftNodes[j]]] &gt; 1)</span>
<span class="nc" id="L1897">              break;</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">            else if(priorities[descOrder[i]]&lt;=priorities[leftNodes[j]])</span>
<span class="nc" id="L1899">            { cantMove=true; break; }</span>
            else
<span class="nc" id="L1901">              temp = horPositions[level[leftNodes[j]]];</span>
          }
          //if(horPositions[level[descOrder[i]]]-1==
          //   horPositions[level[leftNodes[j]]])
          //    cantMove = true;
<span class="nc bnc" id="L1906" title="All 2 branches missed.">          if(cantMove)</span>
<span class="nc" id="L1907">            break;</span>
          
<span class="nc" id="L1909">          temp = horPositions[level[descOrder[i]]]-1;</span>
          //****moving other vertices to left
<span class="nc bnc" id="L1911" title="All 2 branches missed.">          for(int j=leftNodes.length-1; j&gt;=0; j--) {</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">            if(temp==horPositions[level[leftNodes[j]]]) {</span>
              //System.out.println(&quot;Moving &quot;+
              //     ((Node)m_nodes.elementAt(level[leftNodes[j]])).ID+&quot; from &quot;
              //     +horPositions[level[leftNodes[j]]]+&quot; to &quot;
              //     +(horPositions[level[leftNodes[j]]]-1) );
<span class="nc" id="L1917">              horPositions[level[leftNodes[j]]] = </span>
<span class="nc" id="L1918">                                    temp = horPositions[level[leftNodes[j]]]-1; </span>
            }
            
          }
          //System.out.println(&quot;Moving main &quot;+
          //    ((GraphNode)m_nodes.elementAt(level[descOrder[i]])).ID+&quot; from &quot;
          //     +horPositions[level[descOrder[i]]]+&quot; to &quot;
          //     +(horPositions[level[descOrder[i]]]-1));
<span class="nc" id="L1926">          horPositions[level[descOrder[i]]]=horPositions[level[descOrder[i]]]-1;</span>
        }
        
        //****Moving right
<span class="nc" id="L1930">        while(Math.abs(horPositions[level[descOrder[i]]]+1</span>
<span class="nc" id="L1931">                                            -bCenters[descOrder[i]])  &lt;</span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">          Math.abs(horPositions[level[descOrder[i]]]-bCenters[descOrder[i]]) ) {</span>
          //****checking if the vertex can be moved
<span class="nc" id="L1934">          int temp = horPositions[level[descOrder[i]]];</span>
<span class="nc" id="L1935">          boolean cantMove=false;</span>
          
<span class="nc bnc" id="L1937" title="All 2 branches missed.">          for(int j=0; j&lt;rightNodes.length; j++) {</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">            if(horPositions[level[rightNodes[j]]]-temp &gt; 1)</span>
<span class="nc" id="L1939">              break;</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">            else if(priorities[descOrder[i]]&lt;=priorities[rightNodes[j]])</span>
<span class="nc" id="L1941">            { cantMove=true; break; }</span>
            else
<span class="nc" id="L1943">              temp = horPositions[level[rightNodes[j]]];</span>
          }
          //if(horPositions[level[descOrder[i]]]-1==
          //   horPositions[level[leftNodes[j]]])
          //    cantMove = true;
<span class="nc bnc" id="L1948" title="All 2 branches missed.">          if(cantMove)</span>
<span class="nc" id="L1949">            break;</span>
          
<span class="nc" id="L1951">          temp = horPositions[level[descOrder[i]]]+1;</span>
          //****moving other vertices to left
<span class="nc bnc" id="L1953" title="All 2 branches missed.">          for(int j=0; j&lt;rightNodes.length; j++) {</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">            if(temp==horPositions[level[rightNodes[j]]]) {</span>
              //System.out.println(&quot;Moving &quot;+
              //     (Node)m_nodes.elementAt(level[rightNodes[j]])).ID+&quot; from &quot;
              //     +horPositions[level[rightNodes[j]]]+&quot; to &quot;
              //     +(horPositions[level[rightNodes[j]]]+1) );
<span class="nc" id="L1959">              horPositions[level[rightNodes[j]]] = </span>
<span class="nc" id="L1960">                                    temp = horPositions[level[rightNodes[j]]]+1;</span>
            }
          }
          //System.out.println(&quot;Moving main &quot;+
          //    ((GraphNode)m_nodes.elementAt(level[descOrder[i]])).ID+&quot; from &quot;
          //    +horPositions[level[descOrder[i]]]+&quot; to &quot;
          //    +(horPositions[level[descOrder[i]]]+1));
<span class="nc" id="L1967">          horPositions[level[descOrder[i]]]=horPositions[level[descOrder[i]]]+1;</span>
        }
      }
<span class="nc" id="L1970">  }</span>
  
  
  /**
   * The following classes implement a double linked list to
   * be used in the crossings function.
   */
<span class="nc" id="L1977">  private class MyList {</span>
    int size;
<span class="nc" id="L1979">    MyListNode first=null;</span>
<span class="nc" id="L1980">    MyListNode last=null;</span>
    
    public void add(int i) {
<span class="nc bnc" id="L1983" title="All 2 branches missed.">      if(first==null)</span>
<span class="nc" id="L1984">        first = last = new MyListNode(i);</span>
      else
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        if(last.next==null) {</span>
<span class="nc" id="L1987">          last.next = new MyListNode(i);</span>
<span class="nc" id="L1988">          last.next.previous = last;</span>
<span class="nc" id="L1989">          last = last.next;</span>
        }
        else {
<span class="nc" id="L1992">          System.err.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MyList_Add_Error_Text_First&quot;)); </span>
<span class="nc" id="L1993">          size--;</span>
        }
<span class="nc" id="L1995">      size++;</span>
<span class="nc" id="L1996">    }</span>
    
    public void add(MyListNode n) {
<span class="nc bnc" id="L1999" title="All 2 branches missed.">      if(first==null)</span>
<span class="nc" id="L2000">        first = last = n;</span>
      else
<span class="nc bnc" id="L2002" title="All 2 branches missed.">        if(last.next==null) {</span>
<span class="nc" id="L2003">          last.next = n;</span>
<span class="nc" id="L2004">          last.next.previous = last;</span>
<span class="nc" id="L2005">          last = last.next;</span>
        }
        else {
<span class="nc" id="L2008">          System.err.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MyList_Add_Error_Text_Second&quot;)); </span>
<span class="nc" id="L2009">          size--; </span>
        }
      
<span class="nc" id="L2012">      size++;</span>
<span class="nc" id="L2013">    }</span>
    
    public void remove(MyListNode n) {
<span class="nc bnc" id="L2016" title="All 2 branches missed.">      if(n.previous!=null)</span>
<span class="nc" id="L2017">        n.previous.next = n.next;</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">      if(n.next!=null)</span>
<span class="nc" id="L2019">        n.next.previous = n.previous;</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">      if(last==n)</span>
<span class="nc" id="L2021">        last = n.previous;</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">      if(first==n)</span>
<span class="nc" id="L2023">        first = n.next;</span>
      
<span class="nc" id="L2025">      size--;</span>
<span class="nc" id="L2026">    }</span>
    
    public void remove(int i) {
<span class="nc" id="L2029">      MyListNode temp=first;</span>
<span class="nc bnc" id="L2030" title="All 4 branches missed.">      while(temp!=null &amp;&amp; temp.n!=i) temp=temp.next;</span>
      
<span class="nc bnc" id="L2032" title="All 2 branches missed.">      if(temp==null){ </span>
<span class="nc" id="L2033">        System.err.println(Messages.getInstance().getString(&quot;HierarchicalBCEngine_MyList_Remove_Error_Text_First&quot;) + i + Messages.getInstance().getString(&quot;HierarchicalBCEngine_MyList_Remove_Error_Text_Second&quot;));</span>
<span class="nc" id="L2034">        return;</span>
      }
      
<span class="nc bnc" id="L2037" title="All 2 branches missed.">      if(temp.previous!=null)</span>
<span class="nc" id="L2038">        temp.previous.next = temp.next;</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">      if(temp.next!=null)</span>
<span class="nc" id="L2040">        temp.next.previous = temp.previous;</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">      if(last==temp)</span>
<span class="nc" id="L2042">        last = temp.previous;</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">      if(first==temp)</span>
<span class="nc" id="L2044">        first = temp.next;</span>
      
<span class="nc" id="L2046">      size--;</span>
<span class="nc" id="L2047">    }</span>
    
    public int size() {
<span class="nc" id="L2050">      return size;</span>
    }
    
  }
  
  private class MyListNode {
    int n;
    MyListNode next, previous;
    
<span class="nc" id="L2059">    public MyListNode(int i) {</span>
<span class="nc" id="L2060">      n = i; next=null; previous=null;</span>
<span class="nc" id="L2061">    }</span>
  }
  
} // HierarchicalBCEngine
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>