<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MiddleOutConstructor.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core.neighboursearch.balltrees</a> &gt; <span class="el_source">MiddleOutConstructor.java</span></div><h1>MiddleOutConstructor.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * MiddleOutConstructor.java
 * Copyright (C) 2007 University of Waikato, Hamilton, New Zealand
 */

package weka.core.neighboursearch.balltrees;

import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.Randomizable;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * The class that builds a BallTree middle out.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see also:&lt;br/&gt;
 * &lt;br/&gt;
 * Andrew W. Moore: The Anchors Hierarchy: Using the Triangle Inequality to Survive High Dimensional Data. In: UAI '00: Proceedings of the 16th Conference on Uncertainty in Artificial Intelligence, San Francisco, CA, USA, 397-405, 2000.&lt;br/&gt;
 * &lt;br/&gt;
 * Ashraf Masood Kibriya (2007). Fast Algorithms for Nearest Neighbour Search. Hamilton, New Zealand.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Moore2000,
 *    address = {San Francisco, CA, USA},
 *    author = {Andrew W. Moore},
 *    booktitle = {UAI '00: Proceedings of the 16th Conference on Uncertainty in Artificial Intelligence},
 *    pages = {397-405},
 *    publisher = {Morgan Kaufmann Publishers Inc.},
 *    title = {The Anchors Hierarchy: Using the Triangle Inequality to Survive High Dimensional Data},
 *    year = {2000}
 * }
 * 
 * &amp;#64;mastersthesis{Kibriya2007,
 *    address = {Hamilton, New Zealand},
 *    author = {Ashraf Masood Kibriya},
 *    school = {Department of Computer Science, School of Computing and Mathematical Sciences, University of Waikato},
 *    title = {Fast Algorithms for Nearest Neighbour Search},
 *    year = {2007}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  The seed for the random number generator used
 *  in selecting random anchor.
 * (default: 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Use randomly chosen initial anchors.&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt; 
 * 
 * @author Ashraf M. Kibriya (amk14[at-the-rate]cs[dot]waikato[dot]ac[dot]nz)
 * @version $Revision: 1.3 $
 */
public class MiddleOutConstructor
  extends BallTreeConstructor
  implements Randomizable, TechnicalInformationHandler {

  /** for serialization. */
  private static final long serialVersionUID = -8523314263062524462L;

  /** Seed form random number generator. */
<span class="nc" id="L101">  protected int m_RSeed = 1;</span>
	
  /** 
   * The random number generator for selecting 
   * the first anchor point randomly 
   * (if selecting randomly).
   */
<span class="nc" id="L108">  protected Random rand = new Random(m_RSeed);</span>
 
  /**
   * The radius of the smallest ball enclosing all the data points.
   */
<span class="nc" id="L113">  private double rootRadius = -1;</span>
  
  /** 
   * True if the initial anchor is chosen randomly. False if it is the furthest
   * point from the mean/centroid.
   */
<span class="nc" id="L119">  protected boolean m_RandomInitialAnchor = true;</span>

  /**
   * Creates a new instance of MiddleOutConstructor.
   */
<span class="nc" id="L124">  public MiddleOutConstructor() {</span>
<span class="nc" id="L125">  }</span>

  /**
   * Returns a string describing this nearest neighbour search algorithm.
   * 
   * @return 		a description of the algorithm for displaying in the
   *         		explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L134">    return </span>
<span class="nc" id="L135">        &quot;The class that builds a BallTree middle out.\n\n&quot;</span>
      + &quot;For more information see also:\n\n&quot;
<span class="nc" id="L137">      + getTechnicalInformation().toString();</span>
  }
    
  /**
   * Returns an instance of a TechnicalInformation object, containing detailed
   * information about the technical background of this class, e.g., paper
   * reference or book this class is based on.
   * 
   * @return 		the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation result;
    TechnicalInformation additional;

<span class="nc" id="L151">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L152">    result.setValue(Field.AUTHOR, &quot;Andrew W. Moore&quot;);</span>
<span class="nc" id="L153">    result.setValue(Field.TITLE, &quot;The Anchors Hierarchy: Using the Triangle Inequality to Survive High Dimensional Data&quot;);</span>
<span class="nc" id="L154">    result.setValue(Field.YEAR, &quot;2000&quot;);</span>
<span class="nc" id="L155">    result.setValue(Field.BOOKTITLE, &quot;UAI '00: Proceedings of the 16th Conference on Uncertainty in Artificial Intelligence&quot;);</span>
<span class="nc" id="L156">    result.setValue(Field.PAGES, &quot;397-405&quot;);</span>
<span class="nc" id="L157">    result.setValue(Field.PUBLISHER, &quot;Morgan Kaufmann Publishers Inc.&quot;);</span>
<span class="nc" id="L158">    result.setValue(Field.ADDRESS, &quot;San Francisco, CA, USA&quot;);</span>

<span class="nc" id="L160">    additional = result.add(Type.MASTERSTHESIS);</span>
<span class="nc" id="L161">    additional.setValue(Field.AUTHOR, &quot;Ashraf Masood Kibriya&quot;);</span>
<span class="nc" id="L162">    additional.setValue(Field.TITLE, &quot;Fast Algorithms for Nearest Neighbour Search&quot;);</span>
<span class="nc" id="L163">    additional.setValue(Field.YEAR, &quot;2007&quot;);</span>
<span class="nc" id="L164">    additional.setValue(Field.SCHOOL, &quot;Department of Computer Science, School of Computing and Mathematical Sciences, University of Waikato&quot;);</span>
<span class="nc" id="L165">    additional.setValue(Field.ADDRESS, &quot;Hamilton, New Zealand&quot;);</span>
    
<span class="nc" id="L167">    return result;</span>
  }

  /**
   * Builds a ball tree middle out. 
   * @return The root node of the tree. 
   * @throws Exception If there is problem building
   * the tree.
   */
  public BallNode buildTree() throws Exception {
<span class="nc" id="L177">    m_NumNodes = m_MaxDepth = m_NumLeaves = 0;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">    if(rootRadius == -1) {</span>
<span class="nc" id="L179">      rootRadius = BallNode.calcRadius(m_InstList, m_Instances, </span>
<span class="nc" id="L180">                		BallNode.calcCentroidPivot(m_InstList, m_Instances),</span>
<span class="nc" id="L181">                		m_DistanceFunction);</span>
    }
<span class="nc" id="L183">    BallNode root = buildTreeMiddleOut(0, m_Instances.numInstances()-1);</span>
<span class="nc" id="L184">    return root;</span>
  }

  /** 
   * Builds a ball tree middle out from the 
   * portion of the master index array given
   * by supplied start and end index.
   * @param startIdx The start of the portion
   * in master index array.
   * @param endIdx the end of the portion in 
   * master index array.
   * @return The root node of the built tree.
   * @throws Exception If there is some 
   * problem building the tree. 
   */
  protected BallNode buildTreeMiddleOut(int startIdx, int endIdx) 
    throws Exception {
	
    Instance pivot;
    double radius;
    Vector anchors;
<span class="nc" id="L205">    int numInsts = endIdx - startIdx + 1;</span>
<span class="nc" id="L206">    int numAnchors = (int) Math.round(Math.sqrt(numInsts));</span>
    
    //create anchor's hierarchy
<span class="nc bnc" id="L209" title="All 2 branches missed.">    if (numAnchors &gt; 1) {</span>
<span class="nc" id="L210">      pivot = BallNode.calcCentroidPivot(startIdx, endIdx, m_InstList,m_Instances);</span>
<span class="nc" id="L211">      radius = BallNode.calcRadius(startIdx, endIdx, m_InstList, m_Instances, </span>
<span class="nc" id="L212">    	  						   pivot, m_DistanceFunction);      </span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">      if(numInsts &lt;= m_MaxInstancesInLeaf || </span>
<span class="nc bnc" id="L214" title="All 4 branches missed.">    	 (rootRadius==0 ? true : radius/rootRadius &lt; m_MaxRelLeafRadius)) { //just make a leaf don't make anchors hierarchy </span>
<span class="nc" id="L215">		BallNode node = new BallNode(startIdx, endIdx, m_NumNodes,pivot, radius);</span>
<span class="nc" id="L216">		return node;</span>
	  }
<span class="nc" id="L218">      anchors = new Vector(numAnchors);</span>
<span class="nc" id="L219">      createAnchorsHierarchy(anchors, numAnchors, startIdx, endIdx);</span>

<span class="nc" id="L221">      BallNode node = mergeNodes(anchors, startIdx, endIdx);</span>
      
<span class="nc" id="L223">      buildLeavesMiddleOut(node);</span>
      
<span class="nc" id="L225">      return node;</span>
    }// end anchors hierarchy
    else {
<span class="nc" id="L228">      BallNode node = new BallNode(startIdx, endIdx, m_NumNodes, </span>
<span class="nc" id="L229">                      (pivot=BallNode.calcCentroidPivot(startIdx, endIdx, </span>
<span class="nc" id="L230">                                                      m_InstList, m_Instances)), </span>
<span class="nc" id="L231">                      BallNode.calcRadius(startIdx, endIdx, m_InstList, </span>
<span class="nc" id="L232">                                          m_Instances, pivot, </span>
<span class="nc" id="L233">                                          m_DistanceFunction)</span>
                         );
<span class="nc" id="L235">      return node;</span>
    }        
  }
  
  /**
   * Creates an anchors hierarchy from a portion
   * of master index array.
   * 
   * @param anchors The vector for putting the anchors
   * into. 
   * @param numAnchors The number of anchors to create.
   * @param startIdx The start of the portion of master
   * index array.
   * @param endIdx The end of the portion of master 
   * index array.
   * @throws Exception If there is some problem in creating 
   * the hierarchy.
   */
  protected void createAnchorsHierarchy(Vector anchors, final int numAnchors, 
      final int startIdx, final int endIdx) 
    throws Exception {
    
<span class="nc bnc" id="L257" title="All 2 branches missed.">    TempNode anchr1 = m_RandomInitialAnchor ? </span>
<span class="nc" id="L258">            getRandomAnchor(startIdx, endIdx) : </span>
<span class="nc" id="L259">            getFurthestFromMeanAnchor(startIdx, endIdx);</span>
	              
<span class="nc" id="L261">    TempNode amax = anchr1; //double maxradius = anchr1.radius;</span>
    TempNode newAnchor;
<span class="nc" id="L263">    Vector anchorDistances = new Vector(numAnchors-1);</span>
<span class="nc" id="L264">    anchors.add(anchr1);</span>

    //creating anchors
<span class="nc bnc" id="L267" title="All 2 branches missed.">    while(anchors.size() &lt; numAnchors) {</span>
      //create new anchor
<span class="nc" id="L269">      newAnchor = new TempNode();</span>
<span class="nc" id="L270">      newAnchor.points = new MyIdxList();        </span>
<span class="nc" id="L271">      Instance newpivot = m_Instances.instance(((ListNode)amax.points.getFirst()).idx);</span>
<span class="nc" id="L272">      newAnchor.anchor = newpivot;</span>
<span class="nc" id="L273">      newAnchor.idx = ((ListNode)amax.points.getFirst()).idx;</span>

<span class="nc" id="L275">      setInterAnchorDistances(anchors, newAnchor, anchorDistances);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">      if(stealPoints(newAnchor, anchors, anchorDistances)) //if points stolen</span>
<span class="nc" id="L277">    	newAnchor.radius = ((ListNode)newAnchor.points.getFirst()).distance;</span>
      else
<span class="nc" id="L279">    	newAnchor.radius = 0.0;</span>
<span class="nc" id="L280">      anchors.add(newAnchor);</span>

      //find new amax        
<span class="nc" id="L283">      amax = (TempNode)anchors.elementAt(0);</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">      for(int i=1; i&lt;anchors.size(); i++) {</span>
<span class="nc" id="L285">        newAnchor = (TempNode)anchors.elementAt(i);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if(newAnchor.radius &gt; amax.radius)</span>
<span class="nc" id="L287">          amax = newAnchor;</span>
      }//end for
    }//end while
<span class="nc" id="L290">  }</span>
  
  /**
   * Applies the middle out build procedure to 
   * the leaves of the tree. The leaf nodes 
   * should be the ones that were created by 
   * createAnchorsHierarchy(). The process
   * continues recursively for the leaves 
   * created for each leaf of the given tree 
   * until for some leaf node &lt;= 
   * m_MaxInstancesInLeaf instances remain
   * in the leaf.
   * 
   * @param node The root of the tree.
   * @throws Exception If there is some problem
   * in building the tree leaves.
   */
  protected void buildLeavesMiddleOut(BallNode node) throws Exception {
<span class="nc bnc" id="L308" title="All 4 branches missed.">    if(node.m_Left!=null &amp;&amp; node.m_Right!=null) { //if an internal node</span>
<span class="nc" id="L309">      buildLeavesMiddleOut(node.m_Left);</span>
<span class="nc" id="L310">      buildLeavesMiddleOut(node.m_Right);</span>
    }
<span class="nc bnc" id="L312" title="All 4 branches missed.">    else if(node.m_Left!=null || node.m_Right!=null) {</span>
<span class="nc" id="L313">      throw new Exception(&quot;Invalid leaf assignment. Please check code&quot;);</span>
    }
    else { //if node is a leaf
<span class="nc" id="L316">      BallNode n2 = buildTreeMiddleOut(node.m_Start, node.m_End);</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">      if(n2.m_Left!=null &amp;&amp; n2.m_Right!=null) {</span>
<span class="nc" id="L318">        node.m_Left = n2.m_Left;</span>
<span class="nc" id="L319">        node.m_Right = n2.m_Right;</span>
<span class="nc" id="L320">        buildLeavesMiddleOut(node); </span>
        //the stopping condition in buildTreeMiddleOut will stop the recursion,
        //where it won't split a node at all, and we won't recurse here.
      }
<span class="nc bnc" id="L324" title="All 4 branches missed.">      else if(n2.m_Left!=null || n2.m_Right!=null)</span>
<span class="nc" id="L325">        throw new Exception(&quot;Invalid leaf assignment. Please check code&quot;);</span>
    }
<span class="nc" id="L327">  }</span>

  /**
   * Merges nodes created by createAnchorsHierarchy()
   * into one top node.
   * 
   * @param list List of anchor nodes.
   * @param startIdx The start of the portion of 
   * master index array containing these anchor 
   * nodes. 
   * @param endIdx The end of the portion of master 
   * index array containing these anchor nodes. 
   * @return The top/root node after merging 
   * the given anchor nodes.
   * @throws Exception IF there is some problem in
   * merging.
   */
  protected BallNode mergeNodes(Vector list, int startIdx, int endIdx)
    throws Exception {
    
<span class="nc bnc" id="L347" title="All 2 branches missed.">    for(int i=0; i&lt;list.size(); i++) {</span>
<span class="nc" id="L348">      TempNode n = (TempNode) list.get(i);</span>
<span class="nc" id="L349">      n.anchor = calcPivot(n.points, new MyIdxList(), m_Instances);</span>
<span class="nc" id="L350">      n.radius = calcRadius(n.points, new MyIdxList(), n.anchor, m_Instances);</span>
    }
    double minRadius, tmpRadius; //tmpVolume, minVolume;
<span class="nc" id="L353">    Instance pivot, minPivot=null;</span>
<span class="nc" id="L354">    TempNode parent; int min1=-1, min2=-1;    </span>
    
<span class="nc bnc" id="L356" title="All 2 branches missed.">    while(list.size() &gt; 1) { //main merging loop</span>
<span class="nc" id="L357">      minRadius=Double.POSITIVE_INFINITY;      </span>
      
<span class="nc bnc" id="L359" title="All 2 branches missed.">      for(int i=0; i&lt;list.size(); i++) {</span>
<span class="nc" id="L360">        TempNode first = (TempNode) list.get(i);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">        for(int j=i+1; j&lt;list.size(); j++) {</span>
<span class="nc" id="L362">          TempNode second = (TempNode) list.get(j);</span>
<span class="nc" id="L363">          pivot = calcPivot(first, second, m_Instances); </span>
<span class="nc" id="L364">          tmpRadius = calcRadius(first, second); //calcRadius(first.points, second.points, pivot, m_Instances);    </span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">          if(tmpRadius &lt; minRadius) { //(tmpVolume &lt; minVolume) {</span>
<span class="nc" id="L366">            minRadius = tmpRadius; //minVolume = tmpVolume; </span>
<span class="nc" id="L367">            minPivot = pivot; </span>
<span class="nc" id="L368">            min1=i; min2=j; </span>
            //minInstList = tmpInstList;
          }
        }//end for(j)
      }//end for(i)
<span class="nc" id="L373">      parent = new TempNode();</span>
<span class="nc" id="L374">      parent.left  = (TempNode) list.get(min1);</span>
<span class="nc" id="L375">      parent.right = (TempNode) list.get(min2);</span>
<span class="nc" id="L376">      parent.anchor = minPivot;</span>
<span class="nc" id="L377">      parent.radius = calcRadius(parent.left.points, parent.right.points, minPivot, m_Instances); //minRadius;</span>
<span class="nc" id="L378">      parent.points = parent.left.points.append(parent.left.points, parent.right.points);</span>
<span class="nc" id="L379">      list.remove(min1); list.remove(min2-1);</span>
<span class="nc" id="L380">      list.add(parent);</span>
    }//end while
<span class="nc" id="L382">    TempNode tmpRoot = (TempNode)list.get(list.size()-1);</span>
    
<span class="nc bnc" id="L384" title="All 2 branches missed.">    if((endIdx-startIdx+1)!= tmpRoot.points.length()) {</span>
<span class="nc" id="L385">      throw new Exception(&quot;Root nodes instance list is of irregular length. &quot; +</span>
                          &quot;Please check code. Length should &quot; +
<span class="nc" id="L387">                          &quot;be: &quot; + (endIdx-startIdx+1) + </span>
<span class="nc" id="L388">                          &quot; whereas it is found to be: &quot;+tmpRoot.points.length());</span>
    }
<span class="nc bnc" id="L390" title="All 2 branches missed.">    for(int i=0; i&lt;tmpRoot.points.length(); i++) {</span>
<span class="nc" id="L391">      m_InstList[startIdx+i] = ((ListNode)tmpRoot.points.get(i)).idx;</span>
    }
    
<span class="nc" id="L394">    BallNode node = makeBallTreeNodes(tmpRoot, startIdx, endIdx, 0);</span>
    
<span class="nc" id="L396">    return node;    </span>
  }
  
  /**
   * Makes BallTreeNodes out of TempNodes.
   *  
   * @param node The root TempNode
   * @param startidx The start of the portion of 
   * master index array the TempNodes 
   * are made from. 
   * @param endidx The end of the portion of 
   * master index array the TempNodes are 
   * made from. 
   * @param depth The depth in the tree where 
   * this root TempNode is made (needed when 
   * leaves of a tree deeper down are built 
   * middle out).
   * @return The root BallTreeNode.
   */
  protected BallNode makeBallTreeNodes(TempNode node, int startidx, 
      int endidx, int depth) {
<span class="nc" id="L417">    BallNode ball=null;</span>
    
<span class="nc bnc" id="L419" title="All 4 branches missed.">    if(node.left!=null &amp;&amp; node.right!=null) { //make an internal node</span>
<span class="nc" id="L420">      ball = new BallNode(</span>
<span class="nc" id="L421">      startidx, endidx, m_NumNodes, </span>
<span class="nc" id="L422">      node.anchor,</span>
<span class="nc" id="L423">      node.radius</span>
      );
<span class="nc" id="L425">      m_NumNodes += 1;</span>
<span class="nc" id="L426">      ball.m_Left = makeBallTreeNodes(node.left, startidx, startidx+node.left.points.length()-1, depth+1);</span>
<span class="nc" id="L427">      ball.m_Right= makeBallTreeNodes(node.right, startidx+node.left.points.length(), endidx, depth+1);</span>
<span class="nc" id="L428">      m_MaxDepth++;</span>
    }
    else { //make a leaf node
<span class="nc" id="L431">      ball = new BallNode(startidx, endidx, m_NumNodes,       </span>
<span class="nc" id="L432">      node.anchor, </span>
<span class="nc" id="L433">      node.radius </span>
                         );
<span class="nc" id="L435">      m_NumNodes += 1;      </span>
<span class="nc" id="L436">      m_NumLeaves += 1;</span>
    }
<span class="nc" id="L438">    return ball;</span>
  }
    
  /**
   * Returns an anchor point which is furthest from the
   * mean point for a given set of points (instances) 
   * (The anchor instance is chosen from the given
   * set of points).
   * 
   * @param startIdx The start index of the points
   * for which anchor point is required.
   * @param endIdx The end index of the points for
   * which anchor point is required.
   * @return The furthest point/instance from the mean 
   * of given set of points.
   */
  protected TempNode getFurthestFromMeanAnchor(int startIdx, int endIdx) {
<span class="nc" id="L455">    TempNode anchor = new TempNode();</span>
<span class="nc" id="L456">    Instance centroid = BallNode.calcCentroidPivot(startIdx, endIdx, m_InstList, </span>
<span class="nc" id="L457">                                                   m_Instances);</span>
    Instance temp;
    double tmpr;
<span class="nc" id="L460">    anchor.radius = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">    for(int i=startIdx; i&lt;=endIdx; i++) {</span>
<span class="nc" id="L462">      temp = m_Instances.instance(m_InstList[i]);</span>
<span class="nc" id="L463">      tmpr = m_DistanceFunction.distance(centroid, temp);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">      if(tmpr &gt; anchor.radius) {</span>
<span class="nc" id="L465">        anchor.idx = m_InstList[i];</span>
<span class="nc" id="L466">        anchor.anchor = temp;</span>
<span class="nc" id="L467">        anchor.radius = tmpr;</span>
      }
    }
    
<span class="nc" id="L471">    setPoints(anchor, startIdx, endIdx, m_InstList);</span>
<span class="nc" id="L472">    return anchor;</span>
  }
  
  /** 
   * Returns a random anchor point/instance from a 
   * given set of points/instances.
   * 
   * @param startIdx The start index of the points
   * for which anchor is required.
   * @param endIdx The end index of the points for
   * which anchor is required.
   * @return The random anchor point/instance
   * for the given set of 
   */
  protected TempNode getRandomAnchor(int startIdx, int endIdx) {
<span class="nc" id="L487">    TempNode anchr1 = new TempNode();</span>
<span class="nc" id="L488">    anchr1.idx = m_InstList[startIdx+rand.nextInt((endIdx-startIdx+1))];</span>
<span class="nc" id="L489">    anchr1.anchor = m_Instances.instance(anchr1.idx);</span>
<span class="nc" id="L490">    setPoints(anchr1, startIdx, endIdx, m_InstList);</span>
<span class="nc" id="L491">    anchr1.radius = ((ListNode)anchr1.points.getFirst()).distance;</span>
    
<span class="nc" id="L493">    return anchr1;</span>
  }
  
  /**
   * Sets the points of an anchor node. It takes the
   * indices of points from the given portion of 
   * an index array and stores those indices, together
   * with their distances to the given anchor node, 
   * in the point index list of the anchor node.
   *  
   * @param node The node in which the points are
   * needed to be set.
   * @param startIdx The start of the portion in 
   * the given index array (the master index
   * array).
   * @param endIdx The end of the portion in the
   * given index array. 
   * @param indices The index array.
   */
  public void setPoints(TempNode node, int startIdx, int endIdx, int[] indices) {
<span class="nc" id="L513">    node.points = new MyIdxList();    </span>
    Instance temp; double dist;
<span class="nc bnc" id="L515" title="All 2 branches missed.">    for(int i=startIdx; i&lt;=endIdx; i++) {</span>
<span class="nc" id="L516">      temp = m_Instances.instance(indices[i]);</span>
<span class="nc" id="L517">      dist = m_DistanceFunction.distance(node.anchor, temp);</span>
<span class="nc" id="L518">      node.points.insertReverseSorted(indices[i], dist);</span>
    }
<span class="nc" id="L520">  }</span>

  /**
   * Sets the distances of a supplied new
   * anchor to all the rest of the 
   * previous anchor points.
   * @param anchors The old anchor points.
   * @param newAnchor The new anchor point.
   * @param anchorDistances The vector to
   * store the distances of newAnchor to 
   * each of the old anchors.
   * @throws Exception If there is some 
   * problem in calculating the distances.
   */
  public void setInterAnchorDistances(Vector anchors, TempNode newAnchor,
                                      Vector anchorDistances) throws Exception {
<span class="nc" id="L536">    double[] distArray = new double[anchors.size()];</span>
    
<span class="nc bnc" id="L538" title="All 2 branches missed.">    for(int i=0; i&lt;anchors.size(); i++) {</span>
<span class="nc" id="L539">      Instance anchr = ((TempNode)anchors.elementAt(i)).anchor;</span>
<span class="nc" id="L540">      distArray[i] = m_DistanceFunction.distance(anchr, newAnchor.anchor);</span>
    }
<span class="nc" id="L542">    anchorDistances.add(distArray);</span>
<span class="nc" id="L543">  }</span>
  
  /**
   * Removes points from old anchors that
   * are nearer to the given new anchor and
   * adds them to the list of points of the
   * new anchor. 
   * @param newAnchor The new anchor.
   * @param anchors The old anchors.
   * @param anchorDistances The distances
   * of new anchor to each of the old 
   * anchors.
   * @return true if any points are removed
   * from the old anchors
   */
  public boolean stealPoints(TempNode newAnchor, Vector anchors, 
                          Vector anchorDistances) {
                            
<span class="nc" id="L561">    int maxIdx = -1; </span>
<span class="nc" id="L562">    double maxDist = Double.NEGATIVE_INFINITY;</span>
<span class="nc" id="L563">    double[] distArray = (double[])anchorDistances.lastElement();</span>
    
<span class="nc bnc" id="L565" title="All 2 branches missed.">    for(int i=0; i&lt;distArray.length; i++)</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">      if(maxDist &lt; distArray[i]) {</span>
<span class="nc" id="L567">        maxDist = distArray[i]; maxIdx = i;</span>
      }
    
<span class="nc" id="L570">    boolean anyPointsStolen=false, pointsStolen=false;</span>
    TempNode anchorI;
    double newDist, distI, interAnchMidDist;
<span class="nc" id="L573">    Instance newAnchInst = newAnchor.anchor, anchIInst;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">    for(int i=0; i&lt;anchors.size(); i++) {</span>
<span class="nc" id="L575">      anchorI = (TempNode)anchors.elementAt(i);</span>
<span class="nc" id="L576">      anchIInst = anchorI.anchor;</span>
      
<span class="nc" id="L578">      pointsStolen = false;</span>
<span class="nc" id="L579">      interAnchMidDist = m_DistanceFunction.distance(newAnchInst, anchIInst)/2D;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">      for(int j=0; j&lt;anchorI.points.length(); j++) {</span>
<span class="nc" id="L581">        ListNode tmp = (ListNode) anchorI.points.get(j);</span>
        //break if we reach a point whose distance is less than the midpoint
        //of inter anchor distance
<span class="nc bnc" id="L584" title="All 2 branches missed.">        if(tmp.distance &lt; interAnchMidDist)</span>
<span class="nc" id="L585">          break;</span>
        //else test if this point can be stolen by the new anchor
<span class="nc" id="L587">        newDist = m_DistanceFunction.distance(newAnchInst, </span>
<span class="nc" id="L588">                                              m_Instances.instance(tmp.idx));</span>
<span class="nc" id="L589">        distI = tmp.distance;</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if(newDist &lt; distI) {</span>
<span class="nc" id="L591">          newAnchor.points.insertReverseSorted(tmp.idx, newDist);</span>
<span class="nc" id="L592">          anchorI.points.remove(j);</span>
<span class="nc" id="L593">          anyPointsStolen=pointsStolen=true;</span>
        }
      }
<span class="nc bnc" id="L596" title="All 2 branches missed.">      if (pointsStolen)</span>
<span class="nc" id="L597">        anchorI.radius = ((ListNode)anchorI.points.getFirst()).distance;</span>
    }//end for
<span class="nc" id="L599">    return anyPointsStolen;</span>
  }//end stealPoints()

  /**
  /**
   * Calculates the centroid pivot of a node based on its
   * two child nodes (if merging two nodes).
   * @param node1 The first child.
   * @param node2 The second child.
   * @param insts The set of instances on which the tree 
   * is being built (as dataset header information is 
   * required). 
   * @return The centroid pivot of a node. 
   */
  public Instance calcPivot(TempNode node1, TempNode node2, Instances insts) {
<span class="nc" id="L614">    int classIdx = m_Instances.classIndex();</span>
<span class="nc" id="L615">    double[] attrVals = new double[insts.numAttributes()];</span>
    Instance temp;
<span class="nc" id="L617">    double anchr1Ratio = (double)node1.points.length() / </span>
<span class="nc" id="L618">                         (node1.points.length()+node2.points.length()),</span>
<span class="nc" id="L619">           anchr2Ratio = (double)node2.points.length() / </span>
<span class="nc" id="L620">                         (node1.points.length()+node2.points.length());                         ;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">    for(int k=0; k&lt;node1.anchor.numValues(); k++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">      if(node1.anchor.index(k)==classIdx)</span>
<span class="nc" id="L623">        continue;</span>
<span class="nc" id="L624">      attrVals[k] += node1.anchor.valueSparse(k)*anchr1Ratio;</span>
    }
<span class="nc bnc" id="L626" title="All 2 branches missed.">    for(int k=0; k&lt;node2.anchor.numValues(); k++) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">      if(node2.anchor.index(k)==classIdx)</span>
<span class="nc" id="L628">        continue;</span>
<span class="nc" id="L629">      attrVals[k] += node2.anchor.valueSparse(k)*anchr2Ratio;</span>
    }
<span class="nc" id="L631">    temp = new Instance(1.0, attrVals);</span>
<span class="nc" id="L632">    return temp;</span>
  }
  
  /**
   * Calculates the centroid pivot of a node based on 
   * the list of points that it  contains (tbe two 
   * lists of its children are provided).
   * @param list1 The point index list of first child.
   * @param list2 The point index list of second 
   * child.
   * @param insts The insts object on which the tree 
   * is being built (for header information). 
   * @return The centroid pivot of the node. 
   */
  public Instance calcPivot(MyIdxList list1, MyIdxList list2, Instances insts) {
<span class="nc" id="L647">    int classIdx = m_Instances.classIndex();</span>
<span class="nc" id="L648">    double[] attrVals = new double[insts.numAttributes()];</span>
    
    Instance temp;
<span class="nc bnc" id="L651" title="All 2 branches missed.">    for(int i=0; i&lt;list1.length(); i++) {</span>
<span class="nc" id="L652">      temp = insts.instance(((ListNode)list1.get(i)).idx);</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">      for(int k=0; k&lt;temp.numValues(); k++) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if(temp.index(k)==classIdx)</span>
<span class="nc" id="L655">          continue;</span>
<span class="nc" id="L656">        attrVals[k] += temp.valueSparse(k);</span>
      }
    }
<span class="nc bnc" id="L659" title="All 2 branches missed.">    for(int j=0; j&lt;list2.length(); j++) {</span>
<span class="nc" id="L660">      temp = insts.instance(((ListNode)list2.get(j)).idx);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      for(int k=0; k&lt;temp.numValues(); k++) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if(temp.index(k)==classIdx)</span>
<span class="nc" id="L663">          continue;</span>
<span class="nc" id="L664">        attrVals[k] += temp.valueSparse(k);</span>
      }
    }
<span class="nc" id="L667">    for(int j=0, numInsts=list1.length()+list2.length(); </span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">        j &lt; attrVals.length; j++) {</span>
<span class="nc" id="L669">      attrVals[j] /= numInsts;</span>
    }
<span class="nc" id="L671">    temp = new Instance(1.0, attrVals);</span>
<span class="nc" id="L672">    return temp;</span>
  }
  
  /** 
   * Calculates the radius of a node based on its two 
   * child nodes (if merging two nodes).
   * @param n1 The first child of the node.
   * @param n2 The second child of the node.
   * @return The radius of the node. 
   * @throws Exception
   */
  public double calcRadius(TempNode n1, TempNode n2) {
<span class="nc" id="L684">	  Instance p1 = n1.anchor, p2 = n2.anchor;</span>
<span class="nc" id="L685">	  double radius = n1.radius + m_DistanceFunction.distance(p1, p2) + n2.radius;</span>
<span class="nc" id="L686">	  return radius/2;</span>
  }
  
  /**
   * Calculates the radius of a node based on the
   * list of points that it contains (the two lists of 
   * its children are provided). 
   * @param list1 The point index list of first child.
   * @param list2 The point index list of second child.
   * @param pivot The centre/pivot of the node.
   * @param insts The instances on which the tree is 
   * being built (for header info). 
   * @return The radius of the node. 
   */
  public double calcRadius(MyIdxList list1, MyIdxList list2, 
                           Instance pivot, Instances insts) {
<span class="nc" id="L702">    double radius = Double.NEGATIVE_INFINITY;</span>
    
<span class="nc bnc" id="L704" title="All 2 branches missed.">    for(int i=0; i&lt;list1.length(); i++) {</span>
<span class="nc" id="L705">      double dist = m_DistanceFunction.distance(pivot, </span>
<span class="nc" id="L706">                                              insts.instance(((ListNode)list1.get(i)).idx));</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">      if(dist&gt;radius)</span>
<span class="nc" id="L708">        radius = dist;</span>
    }
<span class="nc bnc" id="L710" title="All 2 branches missed.">    for(int j=0; j&lt;list2.length(); j++) {</span>
<span class="nc" id="L711">      double dist = m_DistanceFunction.distance(pivot, </span>
<span class="nc" id="L712">                                              insts.instance(((ListNode)list2.get(j)).idx));</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">      if(dist&gt;radius)</span>
<span class="nc" id="L714">        radius = dist;</span>
    }
<span class="nc" id="L716">    return radius;</span>
  }
  
  /**
   * Adds an instance to the tree. This implementation of 
   * MiddleOutConstructor doesn't support addition of 
   * instances to already built tree, hence it always
   * throws an exception.
   * @param node The root of the tree to which the 
   * instance is to be added.
   * @param inst The instance to add to the tree.
   * @return The updated master index array after 
   * adding the instance.
   * @throws Exception Always as this implementation of
   * MiddleOutConstructor doesn't support addition of
   * instances after batch construction of the tree.
   */
  public int[] addInstance(BallNode node, Instance inst) throws Exception {
<span class="nc" id="L734">    throw new Exception(&quot;Addition of instances after the tree is built, not &quot; +</span>
                        &quot;possible with MiddleOutConstructor.&quot;);
  }

  /**
   * Sets the maximum number of instances allowed in a leaf.
   * @param num The maximum number of instances allowed in 
   * a leaf.
   * @throws Exception If the num is &lt; 2, as the method 
   * cannot work for &lt; 2 instances. 
   */ 
  public void setMaxInstancesInLeaf(int num) throws Exception {
<span class="nc bnc" id="L746" title="All 2 branches missed.">    if(num&lt;2)</span>
<span class="nc" id="L747">      throw new Exception(&quot;The maximum number of instances in a leaf for &quot; +</span>
                          &quot;using MiddleOutConstructor must be &gt;=2.&quot;);
<span class="nc" id="L749">    super.setMaxInstancesInLeaf(num);</span>
<span class="nc" id="L750">  }  </span>

  /**
   * Sets the instances on which the tree is to be built.
   * @param inst The instances on which to build the 
   * ball tree.
   */
  public void setInstances(Instances insts) {
<span class="nc" id="L758">    super.setInstances(insts);</span>
<span class="nc" id="L759">    rootRadius = -1; //this needs to be re-calculated by buildTree()</span>
<span class="nc" id="L760">  }</span>
  
  /**
   * Sets the master index array that points to 
   * instances in m_Instances, so that only this array
   * is manipulated, and m_Instances is left 
   * untouched.
   * @param instList The master index array.
   */
  public void setInstanceList(int[] instList) {
<span class="nc" id="L770">    super.setInstanceList(instList); </span>
<span class="nc" id="L771">    rootRadius = -1; //this needs to be re-calculated by buildTree()</span>
<span class="nc" id="L772">  }</span>
  
  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String initialAnchorRandomTipText() {
<span class="nc" id="L781">    return &quot;Whether the initial anchor is chosen randomly.&quot;;</span>
  }
  
  /** 
   * Gets whether if the initial anchor is chosen randomly.
   * @return true if the initial anchor is a random one. 
   */
  public boolean isInitialAnchorRandom() {
<span class="nc" id="L789">    return m_RandomInitialAnchor;</span>
  }
  
  /** 
   * Sets whether if the initial anchor is chosen randomly. If not 
   * then if it is the furthest point from the mean/centroid.
   * @param randomInitialAnchor Should be true if the first 
   * anchor is to be chosen randomly.
   */
  public void setInitialAnchorRandom(boolean randomInitialAnchor) {
<span class="nc" id="L799">    m_RandomInitialAnchor = randomInitialAnchor;</span>
<span class="nc" id="L800">  }</span>
  
  /**
   * Returns the tip text for this property.
   * 
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String seedTipText() {
<span class="nc" id="L809">    return &quot;The seed value for the random number generator.&quot;;</span>
  }

  /**
   * Returns the seed for random number generator.
   * @return The random number seed.
   */
  public int getSeed() {
<span class="nc" id="L817">    return m_RSeed;</span>
  }
  
  /**
   * Sets the seed for random number generator 
   * (that is used for selecting the first anchor 
   * point randomly).
   * @param seed The seed. 
   */
  public void setSeed(int seed) {
<span class="nc" id="L827">    m_RSeed = seed;</span>
<span class="nc" id="L828">  }</span>
  
  /**
   * Returns an enumeration describing the available options.
   * 
   * @return 		an enumeration of all the available options.
   */
  public Enumeration listOptions() {
<span class="nc" id="L836">    Vector newVector = new Vector();</span>
    
<span class="nc" id="L838">    newVector.addElement(new Option(</span>
<span class="nc" id="L839">	&quot;\tThe seed for the random number generator used\n&quot;</span>
	+ &quot;\tin selecting random anchor.\n&quot;
	+ &quot;(default: 1)&quot;, 
<span class="nc" id="L842">	&quot;S&quot;, 1, &quot;-S &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L844">    newVector.addElement(new Option(</span>
<span class="nc" id="L845">	&quot;\tUse randomly chosen initial anchors.&quot;,</span>
<span class="nc" id="L846">	&quot;R&quot;, 0, &quot;-R&quot;));</span>
    
<span class="nc" id="L848">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options.
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  The seed for the random number generator used
   *  in selecting random anchor.
   * (default: 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Use randomly chosen initial anchors.&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt; 
   * 
   * @param options 	the list of options as an array of strings
   * @throws Exception	if an option is not supported
   **/
  public void setOptions(String[] options)
    throws Exception {

<span class="nc" id="L873">    super.setOptions(options);</span>
   
<span class="nc" id="L875">    String temp = Utils.getOption('S', options);</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">    if(temp.length()&gt;0) {</span>
<span class="nc" id="L877">      setSeed(Integer.parseInt(temp));</span>
    }
    else {
<span class="nc" id="L880">      setSeed(1);</span>
    }
    
<span class="nc" id="L883">    setInitialAnchorRandom(Utils.getFlag('R', options));</span>
<span class="nc" id="L884">  }</span>

  /**
   * Gets the current settings of this BallTree MiddleOutConstructor.
   * 
   * @return 		an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector&lt;String&gt;	result;
    String[]		options;
    int			i;
    
<span class="nc" id="L896">    result = new Vector&lt;String&gt;();</span>
    
<span class="nc" id="L898">    options = super.getOptions();</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L900">      result.add(options[i]);</span>
    
<span class="nc" id="L902">    result.add(&quot;-S&quot;);</span>
<span class="nc" id="L903">    result.add(&quot;&quot; + getSeed());</span>
    
<span class="nc bnc" id="L905" title="All 2 branches missed.">    if(isInitialAnchorRandom())</span>
<span class="nc" id="L906">      result.add(&quot;-R&quot;);</span>
    
<span class="nc" id="L908">    return result.toArray(new String[result.size()]);</span>
  }
  
  /**
   * Checks whether if the points in an index list
   * are in some specified of the master index array. 
   * @param list The point list.
   * @param startidx The start of the portion in 
   * master index array. 
   * @param endidx The end of the portion in master
   * index array.
   * @throws Exception If some point in the point
   * list is not in the specified portion of master
   * index array. 
   */
  public void checkIndicesList(MyIdxList list, int startidx, int endidx) 
    throws Exception {
    
    boolean found;
    ListNode node;
<span class="nc bnc" id="L928" title="All 2 branches missed.">    for(int i=0; i&lt;list.size(); i++) {</span>
<span class="nc" id="L929">      node = (ListNode)list.elementAt(i);</span>
<span class="nc" id="L930">      found=false;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">      for(int j=startidx; j&lt;=endidx; j++) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">        if(node.idx==m_InstList[j]) {</span>
<span class="nc" id="L933">          found=true; </span>
<span class="nc" id="L934">          break;</span>
        }
      }
<span class="nc bnc" id="L937" title="All 2 branches missed.">      if(!found)</span>
<span class="nc" id="L938">        throw new Exception(&quot;Error: Element &quot;+node.idx+&quot; of the list not in &quot; +</span>
<span class="nc" id="L939">                            &quot;the array.&quot; +</span>
<span class="nc" id="L940">                            &quot;\nArray: &quot;+printInsts(startidx, endidx)+</span>
<span class="nc" id="L941">                            &quot;\nList: &quot;+printList(list));</span>
    }
<span class="nc" id="L943">  }</span>
  
  /**
   * For printing indices in some given portion
   * of the master index array. 
   * @param startIdx The start of the portion 
   * in master index array. 
   * @param endIdx The end of the portion in 
   * master index array.
   * @return The string containing the indices
   * in specified portion of the master index 
   * array. 
   */
  public String printInsts(int startIdx, int endIdx) {
<span class="nc" id="L957">    StringBuffer bf = new StringBuffer();</span>
    try {
<span class="nc" id="L959">      bf.append(&quot;i: &quot;);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">      for (int i = startIdx; i &lt;= endIdx; i++) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">        if (i == startIdx)</span>
<span class="nc" id="L962">          bf.append(&quot;&quot; + m_InstList[i]);</span>
        else
<span class="nc" id="L964">          bf.append(&quot;, &quot; + m_InstList[i]);</span>
      }
<span class="nc" id="L966">    } catch (Exception ex) {</span>
<span class="nc" id="L967">      ex.printStackTrace();</span>
    }
<span class="nc" id="L969">    return bf.toString();</span>
  }
  
  /**
   * For printing indices in a given point list.
   * @param points The point list.
   * @return String containing indices of the
   * points in the point list.
   */
  public String printList(MyIdxList points) {
<span class="nc bnc" id="L979" title="All 4 branches missed.">    if(points==null || points.length()==0) return &quot;&quot;;</span>
<span class="nc" id="L980">    StringBuffer bf = new StringBuffer();</span>
    try {
      ListNode temp;
<span class="nc bnc" id="L983" title="All 2 branches missed.">      for(int i=0; i&lt;points.size(); i++) {</span>
<span class="nc" id="L984">        temp = (ListNode) points.elementAt(i);</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if(i==0)</span>
<span class="nc" id="L986">          bf.append(&quot;&quot;+temp.idx);</span>
        else
<span class="nc" id="L988">          bf.append(&quot;, &quot;+temp.idx);</span>
      }
<span class="nc" id="L990">    } catch(Exception ex) { ex.printStackTrace(); }</span>
<span class="nc" id="L991">    return bf.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1000">    return RevisionUtils.extract(&quot;$Revision: 1.3 $&quot;);</span>
  }
  
  /** 
   * Temp class to represent either a leaf node or an internal node. Should only 
   * have two children (could be the case one child is an instance and the 
   * other another node). Primarily used for anchor nodes. It stores the
   * points contained in a node together with their distances to the 
   * node's centre/anchor point.
   * 
   * @author Ashraf M. Kibriya (amk14[at-the-rate]cs[dot]waikato[dot]ac[dot]nz)
   * @version $Revision: 1.3 $
   */
<span class="nc" id="L1013">  protected class TempNode</span>
    implements RevisionHandler {
    
    /** The anchor point of the node. */
    Instance anchor;
    
    /** The index of the anchor point. */
    int idx;
    
    /** The radius of the node. */
    double radius;
    
    /** The list of points inside the node. */
    MyIdxList points;
    
    /** Node's left child. */
    TempNode left;

    /** Node's right child. */
    TempNode right;
    
    /**
     * Returns a string represention of the node.
     * @return The string representation of the 
     * node.
     */
    public String toString() {
<span class="nc bnc" id="L1040" title="All 4 branches missed.">      if(points==null || points.length()==0) return idx+&quot;&quot;;</span>
<span class="nc" id="L1041">      StringBuffer bf = new StringBuffer();</span>
      try {
<span class="nc" id="L1043">        bf.append(idx+&quot; p: &quot;);</span>
        ListNode temp; 
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        for(int i=0; i&lt;points.size(); i++) {</span>
<span class="nc" id="L1046">          temp = (ListNode) points.elementAt(i);</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">          if(i==0)</span>
<span class="nc" id="L1048">            bf.append(&quot;&quot;+temp.idx);</span>
          else
<span class="nc" id="L1050">            bf.append(&quot;, &quot;+temp.idx);</span>
        }
<span class="nc" id="L1052">      } catch(Exception ex) { ex.printStackTrace(); }</span>
<span class="nc" id="L1053">      return bf.toString();</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1062">      return RevisionUtils.extract(&quot;$Revision: 1.3 $&quot;);</span>
    }
  }

  /**
   * An element of MyIdxList. It stores a points index, and 
   * its distance to some specific point (usually a node's
   * anchor point). 
   * 
   * @author Ashraf M. Kibriya (amk14[at-the-rate]cs[dot]waikato[dot]ac[dot]nz)
   * @version $Revision: 1.3 $
   */
  protected class ListNode
    implements RevisionHandler {
    
    /** The index of the point. */
<span class="nc" id="L1078">    int idx = -1;</span>
    
    /** The distance of the point to the anchor.*/
<span class="nc" id="L1081">    double distance = Double.NEGATIVE_INFINITY;</span>
    
    /**
     * Constructor. 
     * @param i The point's index. 
     * @param d The point's distance to the 
     * anchor.
     */
<span class="nc" id="L1089">    public ListNode(int i, double d) {</span>
<span class="nc" id="L1090">      idx = i;</span>
<span class="nc" id="L1091">      distance = d;</span>
<span class="nc" id="L1092">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1100">      return RevisionUtils.extract(&quot;$Revision: 1.3 $&quot;);</span>
    }
  }
  
  /**
   * Class implementing a list. It stores indices of 
   * instances/points, together with their distances to a nodes
   * centre/pivot/anchor, in a (reverse sorted) list.  
   * 
   * @author Ashraf M. Kibriya (amk14[at-the-rate]cs[dot]waikato[dot]ac[dot]nz)
   * @version $Revision: 1.3 $
   */
  protected class MyIdxList
    extends FastVector {
    
    /** for serialization. */
    private static final long serialVersionUID = -2283869109722934927L;    
    
    /** Constructor. */
    public MyIdxList() {
<span class="nc" id="L1120">      super();</span>
<span class="nc" id="L1121">    }</span>
    
    /**
     * Constructor.  
     * @param size The initial capacity of the list. 
     */
    public MyIdxList(int size) {
<span class="nc" id="L1128">      super(size);</span>
<span class="nc" id="L1129">    }</span>
    
    /**
     * Returns the first element in the list.
     * @return The list's first element.
     */
    public ListNode getFirst() {
<span class="nc" id="L1136">      return (ListNode) this.elementAt(0);</span>
    }
    
    /**
     * Inserts an element in reverse sorted order in 
     * the list.
     * @param idx The index of the point to insert.
     * @param distance The distance of the point to
     * a node's anchor (this would be used to 
     * determine the sort order).
     */
    public void insertReverseSorted(final int idx, final double distance) {
<span class="nc" id="L1148">      java.util.Enumeration en = this.elements();</span>
<span class="nc" id="L1149">      ListNode temp; int i=0;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">      while(en.hasMoreElements()) {</span>
<span class="nc" id="L1151">        temp = (ListNode) en.nextElement();</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        if(temp.distance &lt; distance)</span>
<span class="nc" id="L1153">          break;</span>
<span class="nc" id="L1154">        i++;</span>
      }
<span class="nc" id="L1156">      this.insertElementAt(new ListNode(idx, distance), i);</span>
<span class="nc" id="L1157">    }</span>
    
    /**
     * Returns an element at the specified index in 
     * the list. 
     * @param index The index of the element in the 
     * list.
     * @return The element at the given index.
     */
    public ListNode get(int index) {
<span class="nc" id="L1167">      return (ListNode) this.elementAt(index);</span>
    }
    
    /** 
     * Removes an element at the specified index 
     * from the list.
     * @param index The index of the element
     * in the list to remove.
     */
    public void remove(int index) {
<span class="nc" id="L1177">      this.removeElementAt(index);</span>
<span class="nc" id="L1178">    }</span>
    
    /**
     * Returns the size of the list.
     * @return The size of the list.
     */
    public int length() {
<span class="nc" id="L1185">      return super.size();</span>
    }
    
    /**
     * Appends one list at the end of the other. 
     * @param list1 The list to which the other
     * list would be appended.
     * @param list2 The list to append to the 
     * other list.
     * @return The new list with list2 appended 
     * to list1.
     */
    public MyIdxList append(MyIdxList list1, MyIdxList list2) {
<span class="nc" id="L1198">      MyIdxList temp = new MyIdxList(list1.size()+list2.size());</span>
<span class="nc" id="L1199">      temp.appendElements(list1);</span>
<span class="nc" id="L1200">      temp.appendElements(list2);</span>
<span class="nc" id="L1201">      return temp;</span>
    }
    
    /**
     * Checks the sorting of a list.
     * @param list The list whose sorting is
     * to be checked.
     * @throws Exception If the list is not
     * in (reverse) sorted order.
     */
    public void checkSorting(MyIdxList list) throws Exception {
<span class="nc" id="L1212">      java.util.Enumeration en = list.elements();</span>
<span class="nc" id="L1213">      ListNode first=null, second=null;</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">      while(en.hasMoreElements()) {</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if(first==null)</span>
<span class="nc" id="L1216">          first = (ListNode) en.nextElement();</span>
        else {
<span class="nc" id="L1218">          second = (ListNode)en.nextElement();</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">          if(first.distance &lt; second.distance)</span>
<span class="nc" id="L1220">            throw new Exception(&quot;List not sorted correctly.&quot; +</span>
<span class="nc" id="L1221">                                &quot; first.distance: &quot; + first.distance +</span>
<span class="nc" id="L1222">                                &quot; second.distance: &quot; + second.distance +</span>
<span class="nc" id="L1223">                                &quot; Please check code.&quot;);            </span>
        }
      }
<span class="nc" id="L1226">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1234">      return RevisionUtils.extract(&quot;$Revision: 1.3 $&quot;);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>