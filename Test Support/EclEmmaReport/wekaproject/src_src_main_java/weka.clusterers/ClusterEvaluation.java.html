<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>ClusterEvaluation.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.clusterers</a> &gt; <span class="el_source">ClusterEvaluation.java</span></div><h1>ClusterEvaluation.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    ClusterEvaluation.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package  weka.clusterers;

import weka.core.Drawable;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Range;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.converters.ConverterUtils.DataSource;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Remove;

import java.beans.BeanInfo;
import java.beans.Introspector;
import java.beans.MethodDescriptor;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 * Class for evaluating clustering models.&lt;p/&gt;
 *
 * Valid options are: &lt;p/&gt;
 *
 * -t name of the training file &lt;br/&gt;
 * Specify the training file. &lt;p/&gt;
 *
 * -T name of the test file &lt;br/&gt;
 * Specify the test file to apply clusterer to. &lt;p/&gt;
 *
 * -d name of file to save clustering model to &lt;br/&gt;
 * Specify output file. &lt;p/&gt;
 *
 * -l name of file to load clustering model from &lt;br/&gt;
 * Specifiy input file. &lt;p/&gt;
 *
 * -p attribute range &lt;br/&gt;
 * Output predictions. Predictions are for the training file if only the
 * training file is specified, otherwise they are for the test file. The range
 * specifies attribute values to be output with the predictions.
 * Use '-p 0' for none. &lt;p/&gt;
 *
 * -x num folds &lt;br/&gt;
 * Set the number of folds for a cross validation of the training data.
 * Cross validation can only be done for distribution clusterers and will
 * be performed if the test file is missing. &lt;p/&gt;
 * 
 * -s num &lt;br/&gt;
 * Sets the seed for randomizing the data for cross-validation. &lt;p/&gt;
 *
 * -c class &lt;br/&gt;
 * Set the class attribute. If set, then class based evaluation of clustering
 * is performed. &lt;p/&gt;
 * 
 * -g name of graph file &lt;br/&gt;
 * Outputs the graph representation of the clusterer to the file. Only for
 * clusterer that implemented the &lt;code&gt;weka.core.Drawable&lt;/code&gt; interface.
 * &lt;p/&gt;
 *
 * @author   Mark Hall (mhall@cs.waikato.ac.nz)
 * @version  $Revision: 7753 $
 * @see	     weka.core.Drawable
 */
public class ClusterEvaluation 
  implements Serializable, RevisionHandler {

  /** for serialization */
  static final long serialVersionUID = -830188327319128005L;
  
  /** the clusterer */
  private Clusterer m_Clusterer;

  /** holds a string describing the results of clustering the training data */
  private StringBuffer m_clusteringResults;

  /** holds the number of clusters found by the clusterer */
  private int m_numClusters;

  /** holds the assigments of instances to clusters for a particular testing
      dataset */
  private double[] m_clusterAssignments;

  /** holds the average log likelihood for a particular testing dataset
     if the clusterer is a DensityBasedClusterer */
  private double m_logL;

  /** will hold the mapping of classes to clusters (for class based 
      evaluation) */
<span class="fc" id="L118">  private int[] m_classToCluster = null;</span>

  /**
   * set the clusterer
   * @param clusterer the clusterer to use
   */
  public void setClusterer(Clusterer clusterer) {
<span class="fc" id="L125">    m_Clusterer = clusterer;</span>
<span class="fc" id="L126">  }</span>

  /**
   * return the results of clustering.
   * @return a string detailing the results of clustering a data set
   */
  public String clusterResultsToString() {
<span class="nc" id="L133">    return m_clusteringResults.toString();</span>
  }

  /**
   * Return the number of clusters found for the most recent call to
   * evaluateClusterer
   * @return the number of clusters found
   */
  public int getNumClusters() {
<span class="fc" id="L142">    return m_numClusters;</span>
  }

  /**
   * Return an array of cluster assignments corresponding to the most
   * recent set of instances clustered.
   * @return an array of cluster assignments
   */
  public double[] getClusterAssignments() {
<span class="fc" id="L151">    return m_clusterAssignments;</span>
  }

  /**
   * Return the array (ordered by cluster number) of minimum error class to
   * cluster mappings
   * @return an array of class to cluster mappings
   */
  public int[] getClassesToClusters() {
<span class="nc" id="L160">    return m_classToCluster;</span>
  }

  /**
   * Return the log likelihood corresponding to the most recent
   * set of instances clustered.
   *
   * @return a &lt;code&gt;double&lt;/code&gt; value
   */
  public double getLogLikelihood() {
<span class="nc" id="L170">    return m_logL;</span>
  }

  /**
   * Constructor. Sets defaults for each member variable. Default Clusterer
   * is EM.
   */
<span class="fc" id="L177">  public ClusterEvaluation () {</span>
<span class="fc" id="L178">    setClusterer(new SimpleKMeans());</span>
<span class="fc" id="L179">    m_clusteringResults = new StringBuffer();</span>
<span class="fc" id="L180">    m_clusterAssignments = null;</span>
<span class="fc" id="L181">  }</span>

  /**
   * Evaluate the clusterer on a set of instances. Calculates clustering
   * statistics and stores cluster assigments for the instances in
   * m_clusterAssignments
   * 
   * @param test the set of instances to cluster
   * @throws Exception if something goes wrong
   */
  public void evaluateClusterer(Instances test) throws Exception {
<span class="fc" id="L192">    evaluateClusterer(test, &quot;&quot;);</span>
<span class="fc" id="L193">  }</span>
  
  /**
   * Evaluate the clusterer on a set of instances. Calculates clustering
   * statistics and stores cluster assigments for the instances in
   * m_clusterAssignments
   * 
   * @param test the set of instances to cluster
   * @param testFileName the name of the test file for incremental testing, 
   * if &quot;&quot; or null then not used
   * 
   * @throws Exception if something goes wrong
   */
  public void evaluateClusterer(Instances test, String testFileName) 
    throws Exception {
<span class="fc" id="L208">    evaluateClusterer(test, testFileName, true);</span>
<span class="fc" id="L209">  }</span>

  /**
   * Evaluate the clusterer on a set of instances. Calculates clustering
   * statistics and stores cluster assigments for the instances in
   * m_clusterAssignments
   * 
   * @param test the set of instances to cluster
   * @param testFileName the name of the test file for incremental testing, 
   * if &quot;&quot; or null then not used
   * @param outputModel true if the clustering model is to be output as well
   * as the stats
   * 
   * @throws Exception if something goes wrong
   */
  public void evaluateClusterer(Instances test, String testFileName,
      boolean outputModel) throws Exception {
<span class="fc" id="L226">    int i = 0;</span>
    int cnum;
<span class="fc" id="L228">    double loglk = 0.0;</span>
<span class="fc" id="L229">    int cc = m_Clusterer.numberOfClusters();</span>
<span class="fc" id="L230">    m_numClusters = cc;</span>
<span class="fc" id="L231">    double[] instanceStats = new double[cc];</span>
<span class="fc" id="L232">    Instances testRaw = null;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">    boolean hasClass = (test.classIndex() &gt;= 0);</span>
<span class="fc" id="L234">    int unclusteredInstances = 0;</span>
<span class="fc" id="L235">    Vector&lt;Double&gt; clusterAssignments = new Vector&lt;Double&gt;();</span>
<span class="fc" id="L236">    Filter filter = null;</span>
<span class="fc" id="L237">    DataSource source = null;</span>
    Instance inst;

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    if (testFileName == null)</span>
<span class="nc" id="L241">      testFileName = &quot;&quot;;</span>
    
    // load data
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">    if (testFileName.length() != 0)</span>
<span class="nc" id="L245">      source = new DataSource(testFileName);</span>
    else
<span class="fc" id="L247">      source = new DataSource(test);</span>
<span class="fc" id="L248">    testRaw = source.getStructure(test.classIndex());</span>
    
    // If class is set then do class based evaluation as well
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (hasClass) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">      if (testRaw.classAttribute().isNumeric())</span>
<span class="nc" id="L253">	throw new Exception(&quot;ClusterEvaluation: Class must be nominal!&quot;);</span>

<span class="nc" id="L255">      filter = new Remove();</span>
<span class="nc" id="L256">      ((Remove) filter).setAttributeIndices(&quot;&quot; + (testRaw.classIndex() + 1));</span>
<span class="nc" id="L257">      ((Remove) filter).setInvertSelection(false);</span>
<span class="nc" id="L258">      filter.setInputFormat(testRaw);</span>
    }
    
<span class="fc" id="L261">    i = 0;</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">    while (source.hasMoreElements(testRaw)) {</span>
      // next instance
<span class="fc" id="L264">      inst = source.nextElement(testRaw);</span>
<span class="pc bpc" id="L265" title="1 of 2 branches missed.">      if (filter != null) {</span>
<span class="nc" id="L266">	filter.input(inst);</span>
<span class="nc" id="L267">	filter.batchFinished();</span>
<span class="nc" id="L268">	inst = filter.output();</span>
      }
      
<span class="fc" id="L271">      cnum = -1;</span>
      try {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">	if (m_Clusterer instanceof DensityBasedClusterer) {</span>
<span class="nc" id="L274">	  loglk += ((DensityBasedClusterer)m_Clusterer).</span>
<span class="nc" id="L275">	    logDensityForInstance(inst);</span>
<span class="nc" id="L276">	  cnum = m_Clusterer.clusterInstance(inst); </span>
<span class="nc" id="L277">	  clusterAssignments.add((double) cnum);</span>
	}
	else {
<span class="fc" id="L280">	  cnum = m_Clusterer.clusterInstance(inst);</span>
<span class="fc" id="L281">	  clusterAssignments.add((double) cnum);</span>
	}
      }
<span class="nc" id="L284">      catch (Exception e) {</span>
<span class="nc" id="L285">	clusterAssignments.add(-1.0);</span>
<span class="nc" id="L286">	unclusteredInstances++;</span>
      }
      
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">      if (cnum != -1) {</span>
<span class="fc" id="L290">	instanceStats[cnum]++;</span>
      }
    }
    
<span class="fc" id="L294">    double sum = Utils.sum(instanceStats);</span>
<span class="fc" id="L295">    loglk /= sum;</span>
<span class="fc" id="L296">    m_logL = loglk;</span>
<span class="fc" id="L297">    m_clusterAssignments = new double [clusterAssignments.size()];</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">    for (i = 0; i &lt; clusterAssignments.size(); i++)</span>
<span class="fc" id="L299">      m_clusterAssignments[i] = clusterAssignments.get(i);</span>
<span class="fc" id="L300">    int numInstFieldWidth = (int)((Math.log(clusterAssignments.size())/Math.log(10))+1);</span>
    
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">    if (outputModel) {</span>
<span class="fc" id="L303">      m_clusteringResults.append(m_Clusterer.toString());</span>
    }
<span class="fc" id="L305">    m_clusteringResults.append(&quot;Clustered Instances\n\n&quot;);</span>
<span class="fc" id="L306">    int clustFieldWidth = (int)((Math.log(cc)/Math.log(10))+1);</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">    for (i = 0; i &lt; cc; i++) {</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">      if (instanceStats[i] &gt; 0)</span>
<span class="fc" id="L309">	m_clusteringResults.append(Utils.doubleToString((double)i, </span>
<span class="fc" id="L310">							clustFieldWidth, 0) </span>
<span class="fc" id="L311">				   + &quot;      &quot; </span>
<span class="fc" id="L312">				   + Utils.doubleToString(instanceStats[i],</span>
<span class="fc" id="L313">							  numInstFieldWidth, 0) </span>
<span class="fc" id="L314">				   + &quot; (&quot; </span>
<span class="fc" id="L315">				   + Utils.doubleToString((instanceStats[i] / </span>
<span class="fc" id="L316">							   sum * 100.0)</span>
<span class="fc" id="L317">							  , 3, 0) + &quot;%)\n&quot;);</span>
    }
    
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    if (unclusteredInstances &gt; 0)</span>
<span class="nc" id="L321">      m_clusteringResults.append(&quot;\nUnclustered instances : &quot;</span>
<span class="nc" id="L322">				 +unclusteredInstances);</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">    if (m_Clusterer instanceof DensityBasedClusterer)</span>
<span class="nc" id="L325">      m_clusteringResults.append(&quot;\n\nLog likelihood: &quot; </span>
<span class="nc" id="L326">				 + Utils.doubleToString(loglk, 1, 5) </span>
<span class="nc" id="L327">				 + &quot;\n&quot;);</span>
    
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">    if (hasClass)</span>
<span class="nc" id="L330">      evaluateClustersWithRespectToClass(test, testFileName);</span>
<span class="fc" id="L331">  }</span>

  /**
   * Evaluates cluster assignments with respect to actual class labels.
   * Assumes that m_Clusterer has been trained and tested on 
   * inst (minus the class).
   * 
   * @param inst the instances (including class) to evaluate with respect to
   * @param fileName the name of the test file for incremental testing, 
   * if &quot;&quot; or null then not used
   * @throws Exception if something goes wrong
   */
  private void evaluateClustersWithRespectToClass(Instances inst, String fileName)
    throws Exception {
    
<span class="nc" id="L346">    int numClasses = inst.classAttribute().numValues();</span>
<span class="nc" id="L347">    int[][] counts = new int [m_numClusters][numClasses];</span>
<span class="nc" id="L348">    int[] clusterTotals = new int[m_numClusters];</span>
<span class="nc" id="L349">    double[] best = new double[m_numClusters+1];</span>
<span class="nc" id="L350">    double[] current = new double[m_numClusters+1];</span>
<span class="nc" id="L351">    DataSource source = null;</span>
<span class="nc" id="L352">    Instances instances = null;</span>
<span class="nc" id="L353">    Instance instance = null;</span>
    int i;
    int numInstances;

<span class="nc bnc" id="L357" title="All 2 branches missed.">    if (fileName == null)</span>
<span class="nc" id="L358">      fileName = &quot;&quot;;</span>
    
<span class="nc bnc" id="L360" title="All 2 branches missed.">    if (fileName.length() != 0)</span>
<span class="nc" id="L361">      source = new DataSource(fileName);</span>
    else
<span class="nc" id="L363">      source = new DataSource(inst);</span>
<span class="nc" id="L364">    instances = source.getStructure(inst.classIndex());</span>

<span class="nc" id="L366">    i = 0;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">    while (source.hasMoreElements(instances)) {</span>
<span class="nc" id="L368">      instance = source.nextElement(instances);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">      if (m_clusterAssignments[i] &gt;= 0) {</span>
<span class="nc" id="L370">        counts[(int)m_clusterAssignments[i]][(int)instance.classValue()]++;</span>
<span class="nc" id="L371">        clusterTotals[(int)m_clusterAssignments[i]]++;</span>
      }
<span class="nc" id="L373">      i++;</span>
    }
<span class="nc" id="L375">    numInstances = i;</span>
   
<span class="nc" id="L377">    best[m_numClusters] = Double.MAX_VALUE;</span>
<span class="nc" id="L378">    mapClasses(m_numClusters, 0, counts, clusterTotals, current, best, 0);</span>

<span class="nc" id="L380">    m_clusteringResults.append(&quot;\n\nClass attribute: &quot;</span>
<span class="nc" id="L381">			+inst.classAttribute().name()</span>
<span class="nc" id="L382">			+&quot;\n&quot;);</span>
<span class="nc" id="L383">    m_clusteringResults.append(&quot;Classes to Clusters:\n&quot;);</span>
<span class="nc" id="L384">    String matrixString = toMatrixString(counts, clusterTotals, new Instances(inst, 0));</span>
<span class="nc" id="L385">    m_clusteringResults.append(matrixString).append(&quot;\n&quot;);</span>

<span class="nc" id="L387">    int Cwidth = 1 + (int)(Math.log(m_numClusters) / Math.log(10));</span>
    // add the minimum error assignment
<span class="nc bnc" id="L389" title="All 2 branches missed.">    for (i = 0; i &lt; m_numClusters; i++) {</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">      if (clusterTotals[i] &gt; 0) {</span>
<span class="nc" id="L391">	m_clusteringResults.append(&quot;Cluster &quot;</span>
<span class="nc" id="L392">				   +Utils.doubleToString((double)i,Cwidth,0));</span>
<span class="nc" id="L393">	m_clusteringResults.append(&quot; &lt;-- &quot;);</span>
	
<span class="nc bnc" id="L395" title="All 2 branches missed.">	if (best[i] &lt; 0) {</span>
<span class="nc" id="L396">	  m_clusteringResults.append(&quot;No class\n&quot;);</span>
	} else {
<span class="nc" id="L398">	  m_clusteringResults.</span>
<span class="nc" id="L399">	    append(inst.classAttribute().value((int)best[i])).append(&quot;\n&quot;);</span>
	}
      }
    }
<span class="nc" id="L403">    m_clusteringResults.append(&quot;\nIncorrectly clustered instances :\t&quot;</span>
<span class="nc" id="L404">			       +best[m_numClusters]+&quot;\t&quot;</span>
<span class="nc" id="L405">			       +(Utils.doubleToString((best[m_numClusters] / </span>
<span class="nc" id="L406">						       numInstances * </span>
<span class="nc" id="L407">						       100.0), 8, 4))</span>
<span class="nc" id="L408">			       +&quot; %\n&quot;);</span>

    // copy the class assignments
<span class="nc" id="L411">    m_classToCluster = new int [m_numClusters];</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">    for (i = 0; i &lt; m_numClusters; i++) {</span>
<span class="nc" id="L413">      m_classToCluster[i] = (int)best[i];</span>
    }
<span class="nc" id="L415">  }</span>

  /**
   * Returns a &quot;confusion&quot; style matrix of classes to clusters assignments
   * @param counts the counts of classes for each cluster
   * @param clusterTotals total number of examples in each cluster
   * @param inst the training instances (with class)
   * @return the &quot;confusion&quot; style matrix as string
   * @throws Exception if matrix can't be generated
   */
  private String toMatrixString(int[][] counts, int[] clusterTotals,
				Instances inst) 
    throws Exception {
<span class="nc" id="L428">    StringBuffer ms = new StringBuffer();</span>

<span class="nc" id="L430">    int maxval = 0;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">    for (int i = 0; i &lt; m_numClusters; i++) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">      for (int j = 0; j &lt; counts[i].length; j++) {</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">	if (counts[i][j] &gt; maxval) {</span>
<span class="nc" id="L434">	  maxval = counts[i][j];</span>
	}
      }
    }

<span class="nc" id="L439">    int Cwidth = 1 + Math.max((int)(Math.log(maxval) / Math.log(10)),</span>
<span class="nc" id="L440">			      (int)(Math.log(m_numClusters) / Math.log(10)));</span>

<span class="nc" id="L442">    ms.append(&quot;\n&quot;);</span>
    
<span class="nc bnc" id="L444" title="All 2 branches missed.">    for (int i = 0; i &lt; m_numClusters; i++) {</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">      if (clusterTotals[i] &gt; 0) {</span>
<span class="nc" id="L446">	ms.append(&quot; &quot;).append(Utils.doubleToString((double)i, Cwidth, 0));</span>
      }
    }
<span class="nc" id="L449">    ms.append(&quot;  &lt;-- assigned to cluster\n&quot;);</span>
    
<span class="nc bnc" id="L451" title="All 2 branches missed.">    for (int i = 0; i&lt; counts[0].length; i++) {</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">      for (int j = 0; j &lt; m_numClusters; j++) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">	if (clusterTotals[j] &gt; 0) {</span>
<span class="nc" id="L455">	  ms.append(&quot; &quot;).append(Utils.doubleToString((double)counts[j][i], </span>
<span class="nc" id="L456">						     Cwidth, 0));</span>
	}
      }
<span class="nc" id="L459">      ms.append(&quot; | &quot;).append(inst.classAttribute().value(i)).append(&quot;\n&quot;);</span>
    }

<span class="nc" id="L462">    return ms.toString();</span>
  }

  /**
   * Finds the minimum error mapping of classes to clusters. Recursively
   * considers all possible class to cluster assignments.
   * 
   * @param numClusters the number of clusters
   * @param lev the cluster being processed
   * @param counts the counts of classes in clusters
   * @param clusterTotals the total number of examples in each cluster
   * @param current the current path through the class to cluster assignment
   * tree
   * @param best the best assignment path seen
   * @param error accumulates the error for a particular path
   */
  public static void mapClasses(int numClusters, int lev, int[][] counts, int[] clusterTotals,
			  double[] current, double[] best, int error) {
    // leaf
<span class="fc bfc" id="L481" title="All 2 branches covered.">    if (lev == numClusters) {</span>
<span class="fc bfc" id="L482" title="All 2 branches covered.">      if (error &lt; best[numClusters]) {</span>
<span class="fc" id="L483">	best[numClusters] = error;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">	for (int i = 0; i &lt; numClusters; i++) {</span>
<span class="fc" id="L485">	  best[i] = current[i];</span>
	}
      }
    } else {
      // empty cluster -- ignore
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">      if (clusterTotals[lev] == 0) {</span>
<span class="nc" id="L491">	current[lev] = -1; // cluster ignored</span>
<span class="nc" id="L492">	mapClasses(numClusters, lev+1, counts, clusterTotals, current, best,</span>
<span class="nc" id="L493">		   error);</span>
      } else {
	// first try no class assignment to this cluster
<span class="fc" id="L496">	current[lev] = -1; // cluster assigned no class (ie all errors)</span>
<span class="fc" id="L497">	mapClasses(numClusters, lev+1, counts, clusterTotals, current, best,</span>
<span class="fc" id="L498">		   error+clusterTotals[lev]);</span>
	// now loop through the classes in this cluster
<span class="fc bfc" id="L500" title="All 2 branches covered.">	for (int i = 0; i &lt; counts[0].length; i++) {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">	  if (counts[lev][i] &gt; 0) {</span>
<span class="fc" id="L502">	    boolean ok = true;</span>
	    // check to see if this class has already been assigned
<span class="fc bfc" id="L504" title="All 2 branches covered.">	    for (int j = 0; j &lt; lev; j++) {</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">	      if ((int)current[j] == i) {</span>
<span class="fc" id="L506">		ok = false;</span>
<span class="fc" id="L507">		break;</span>
	      }
	    }
<span class="fc bfc" id="L510" title="All 2 branches covered.">	    if (ok) {</span>
<span class="fc" id="L511">	      current[lev] = i;</span>
<span class="fc" id="L512">	      mapClasses(numClusters, lev+1, counts, clusterTotals, current, best, </span>
<span class="fc" id="L513">			 (error + (clusterTotals[lev] - counts[lev][i])));</span>
	    }
	  }
	}
      }
    }
<span class="fc" id="L519">  }</span>

  /**
   * Evaluates a clusterer with the options given in an array of
   * strings. It takes the string indicated by &quot;-t&quot; as training file, the
   * string indicated by &quot;-T&quot; as test file.
   * If the test file is missing, a stratified ten-fold
   * cross-validation is performed (distribution clusterers only).
   * Using &quot;-x&quot; you can change the number of
   * folds to be used, and using &quot;-s&quot; the random seed.
   * If the &quot;-p&quot; option is present it outputs the classification for
   * each test instance. If you provide the name of an object file using
   * &quot;-l&quot;, a clusterer will be loaded from the given file. If you provide the
   * name of an object file using &quot;-d&quot;, the clusterer built from the
   * training data will be saved to the given file.
   *
   * @param clusterer machine learning clusterer
   * @param options the array of string containing the options
   * @throws Exception if model could not be evaluated successfully
   * @return a string describing the results 
   */
  public static String evaluateClusterer(Clusterer clusterer, String[] options)
    throws Exception {
    
<span class="nc" id="L543">    int seed = 1, folds = 10;</span>
<span class="nc" id="L544">    boolean doXval = false;</span>
<span class="nc" id="L545">    Instances train = null;</span>
    Random random;
    String trainFileName, testFileName, seedString, foldsString;
    String objectInputFileName, objectOutputFileName, attributeRangeString;
    String graphFileName;
<span class="nc" id="L550">    String[] savedOptions = null;</span>
<span class="nc" id="L551">    boolean printClusterAssignments = false;</span>
<span class="nc" id="L552">    Range attributesToOutput = null;</span>
<span class="nc" id="L553">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L554">    int theClass = -1; // class based evaluation of clustering</span>
<span class="nc" id="L555">    boolean updateable = (clusterer instanceof UpdateableClusterer);</span>
<span class="nc" id="L556">    DataSource source = null;</span>
    Instance inst;

<span class="nc bnc" id="L559" title="All 4 branches missed.">    if (Utils.getFlag('h', options) || Utils.getFlag(&quot;help&quot;, options)) {</span>
      
      // global info requested as well?
<span class="nc bnc" id="L562" title="All 2 branches missed.">      boolean globalInfo = Utils.getFlag(&quot;synopsis&quot;, options) ||</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        Utils.getFlag(&quot;info&quot;, options);</span>
      
<span class="nc" id="L565">      throw  new Exception(&quot;Help requested.&quot; </span>
<span class="nc" id="L566">          + makeOptionString(clusterer, globalInfo));</span>
    }
    
    try {
      // Get basic options (options the same for all clusterers
      //printClusterAssignments = Utils.getFlag('p', options);
<span class="nc" id="L572">      objectInputFileName = Utils.getOption('l', options);</span>
<span class="nc" id="L573">      objectOutputFileName = Utils.getOption('d', options);</span>
<span class="nc" id="L574">      trainFileName = Utils.getOption('t', options);</span>
<span class="nc" id="L575">      testFileName = Utils.getOption('T', options);</span>
<span class="nc" id="L576">      graphFileName = Utils.getOption('g', options);</span>

      // Check -p option
      try {
<span class="nc" id="L580">	attributeRangeString = Utils.getOption('p', options);</span>
      }
<span class="nc" id="L582">      catch (Exception e) {</span>
<span class="nc" id="L583">	throw new Exception(e.getMessage() + &quot;\nNOTE: the -p option has changed. &quot; +</span>
<span class="nc" id="L584">			    &quot;It now expects a parameter specifying a range of attributes &quot; +</span>
<span class="nc" id="L585">			    &quot;to list with the predictions. Use '-p 0' for none.&quot;);</span>
      }
<span class="nc bnc" id="L587" title="All 2 branches missed.">      if (attributeRangeString.length() != 0) {</span>
<span class="nc" id="L588">	printClusterAssignments = true;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">	if (!attributeRangeString.equals(&quot;0&quot;)) </span>
<span class="nc" id="L590">	  attributesToOutput = new Range(attributeRangeString);</span>
      }

<span class="nc bnc" id="L593" title="All 2 branches missed.">      if (trainFileName.length() == 0) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (objectInputFileName.length() == 0) {</span>
<span class="nc" id="L595">          throw  new Exception(&quot;No training file and no object &quot; </span>
			       + &quot;input file given.&quot;);
        }

<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (testFileName.length() == 0) {</span>
<span class="nc" id="L600">          throw  new Exception(&quot;No training file and no test file given.&quot;);</span>
        }
      }
      else {
<span class="nc bnc" id="L604" title="All 2 branches missed.">	if ((objectInputFileName.length() != 0) </span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">	    &amp;&amp; (printClusterAssignments == false)) {</span>
<span class="nc" id="L606">	  throw  new Exception(&quot;Can't use both train and model file &quot; </span>
			       + &quot;unless -p specified.&quot;);
	}
      }

<span class="nc" id="L611">      seedString = Utils.getOption('s', options);</span>

<span class="nc bnc" id="L613" title="All 2 branches missed.">      if (seedString.length() != 0) {</span>
<span class="nc" id="L614">	seed = Integer.parseInt(seedString);</span>
      }

<span class="nc" id="L617">      foldsString = Utils.getOption('x', options);</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">      if (foldsString.length() != 0) {</span>
<span class="nc" id="L620">	folds = Integer.parseInt(foldsString);</span>
<span class="nc" id="L621">	doXval = true;</span>
      }
    }
<span class="nc" id="L624">    catch (Exception e) {</span>
<span class="nc" id="L625">      throw  new Exception('\n' + e.getMessage() </span>
<span class="nc" id="L626">			   + makeOptionString(clusterer, false));</span>
    }

    try {
<span class="nc bnc" id="L630" title="All 2 branches missed.">      if (trainFileName.length() != 0) {</span>
<span class="nc" id="L631">	source = new DataSource(trainFileName);</span>
<span class="nc" id="L632">	train  = source.getStructure();</span>

<span class="nc" id="L634">	String classString = Utils.getOption('c',options);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">	if (classString.length() != 0) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">	  if (classString.compareTo(&quot;last&quot;) == 0)</span>
<span class="nc" id="L637">	    theClass = train.numAttributes();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">	  else if (classString.compareTo(&quot;first&quot;) == 0)</span>
<span class="nc" id="L639">	    theClass = 1;</span>
	  else
<span class="nc" id="L641">	    theClass = Integer.parseInt(classString);</span>

<span class="nc bnc" id="L643" title="All 2 branches missed.">	  if (theClass != -1) {</span>
<span class="nc bnc" id="L644" title="All 4 branches missed.">	    if (doXval || testFileName.length() != 0)</span>
<span class="nc" id="L645">	      throw new Exception(&quot;Can only do class based evaluation on the &quot;</span>
		  +&quot;training data&quot;);

<span class="nc bnc" id="L648" title="All 2 branches missed.">	    if (objectInputFileName.length() != 0)</span>
<span class="nc" id="L649">	      throw new Exception(&quot;Can't load a clusterer and do class based &quot;</span>
		  +&quot;evaluation&quot;);

<span class="nc bnc" id="L652" title="All 2 branches missed.">	    if (objectOutputFileName.length() != 0)</span>
<span class="nc" id="L653">	      throw new Exception(</span>
<span class="nc" id="L654">		  &quot;Can't do class based evaluation and save clusterer&quot;);</span>
	  }
	}
	else {
	  // if the dataset defines a class attribute, use it
<span class="nc bnc" id="L659" title="All 2 branches missed.">	  if (train.classIndex() != -1) {</span>
<span class="nc" id="L660">	    theClass = train.classIndex() + 1;</span>
<span class="nc" id="L661">	    System.err.println(</span>
<span class="nc" id="L662">		&quot;Note: using class attribute from dataset, i.e., attribute #&quot; </span>
<span class="nc" id="L663">		+ theClass);</span>
	  }
	}

<span class="nc bnc" id="L667" title="All 2 branches missed.">	if (theClass != -1) {</span>
<span class="nc bnc" id="L668" title="All 4 branches missed.">	  if (theClass &lt; 1 || theClass &gt; train.numAttributes())</span>
<span class="nc" id="L669">	    throw new Exception(&quot;Class is out of range!&quot;);</span>

<span class="nc bnc" id="L671" title="All 2 branches missed.">	  if (!train.attribute(theClass - 1).isNominal())</span>
<span class="nc" id="L672">	    throw new Exception(&quot;Class must be nominal!&quot;);</span>
	  
<span class="nc" id="L674">	  train.setClassIndex(theClass - 1);</span>
	}
      }
    }
<span class="nc" id="L678">    catch (Exception e) {</span>
<span class="nc" id="L679">      throw  new Exception(&quot;ClusterEvaluation: &quot; + e.getMessage() + '.');</span>
    }

    // Save options
<span class="nc bnc" id="L683" title="All 2 branches missed.">    if (options != null) {</span>
<span class="nc" id="L684">      savedOptions = new String[options.length];</span>
<span class="nc" id="L685">      System.arraycopy(options, 0, savedOptions, 0, options.length);</span>
    }

<span class="nc bnc" id="L688" title="All 2 branches missed.">    if (objectInputFileName.length() != 0)</span>
<span class="nc" id="L689">      Utils.checkForRemainingOptions(options);</span>

    // Set options for clusterer
<span class="nc bnc" id="L692" title="All 2 branches missed.">    if (clusterer instanceof OptionHandler)</span>
<span class="nc" id="L693">      ((OptionHandler)clusterer).setOptions(options);</span>

<span class="nc" id="L695">    Utils.checkForRemainingOptions(options);</span>

<span class="nc" id="L697">    Instances trainHeader = train;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">    if (objectInputFileName.length() != 0) {</span>
      // Load the clusterer from file
      //      clusterer = (Clusterer) SerializationHelper.read(objectInputFileName);
<span class="nc" id="L701">      java.io.ObjectInputStream ois = </span>
<span class="nc" id="L702">        new java.io.ObjectInputStream(</span>
<span class="nc" id="L703">        new java.io.BufferedInputStream(</span>
<span class="nc" id="L704">        new java.io.FileInputStream(objectInputFileName)));</span>
<span class="nc" id="L705">      clusterer = (Clusterer) ois.readObject();</span>
      // try and get the training header
      try {
<span class="nc" id="L708">        trainHeader = (Instances) ois.readObject();</span>
<span class="nc" id="L709">      } catch (Exception ex) {</span>
        // don't moan if we cant
      }
    }
    else {
      // Build the clusterer if no object file provided
<span class="nc bnc" id="L715" title="All 2 branches missed.">      if (theClass == -1) {</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">	if (updateable) {</span>
<span class="nc" id="L717">	  clusterer.buildClusterer(source.getStructure());</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">	  while (source.hasMoreElements(train)) {</span>
<span class="nc" id="L719">	    inst = source.nextElement(train);</span>
<span class="nc" id="L720">	    ((UpdateableClusterer) clusterer).updateClusterer(inst);</span>
	  }
<span class="nc" id="L722">	  ((UpdateableClusterer) clusterer).updateFinished();</span>
	}
	else {
<span class="nc" id="L725">	  clusterer.buildClusterer(source.getDataSet());</span>
	}
      }
      else {
<span class="nc" id="L729">	Remove removeClass = new Remove();</span>
<span class="nc" id="L730">	removeClass.setAttributeIndices(&quot;&quot; + theClass);</span>
<span class="nc" id="L731">	removeClass.setInvertSelection(false);</span>
<span class="nc" id="L732">	removeClass.setInputFormat(train);</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">	if (updateable) {</span>
<span class="nc" id="L734">	  Instances clusterTrain = Filter.useFilter(train, removeClass);</span>
<span class="nc" id="L735">	  clusterer.buildClusterer(clusterTrain);</span>
<span class="nc" id="L736">          trainHeader = clusterTrain;</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">	  while (source.hasMoreElements(train)) {</span>
<span class="nc" id="L738">	    inst = source.nextElement(train);</span>
<span class="nc" id="L739">	    removeClass.input(inst);</span>
<span class="nc" id="L740">	    removeClass.batchFinished();</span>
<span class="nc" id="L741">	    Instance clusterTrainInst = removeClass.output();</span>
<span class="nc" id="L742">	    ((UpdateableClusterer) clusterer).updateClusterer(clusterTrainInst);</span>
	  }
<span class="nc" id="L744">	  ((UpdateableClusterer) clusterer).updateFinished();</span>
	}
	else {
<span class="nc" id="L747">	  Instances clusterTrain = Filter.useFilter(source.getDataSet(), removeClass);</span>
<span class="nc" id="L748">	  clusterer.buildClusterer(clusterTrain);</span>
<span class="nc" id="L749">          trainHeader = clusterTrain;</span>
	}
<span class="nc" id="L751">	ClusterEvaluation ce = new ClusterEvaluation();</span>
<span class="nc" id="L752">	ce.setClusterer(clusterer);</span>
<span class="nc" id="L753">	ce.evaluateClusterer(train, trainFileName);</span>
	
<span class="nc" id="L755">	return &quot;\n\n=== Clustering stats for training data ===\n\n&quot; +</span>
<span class="nc" id="L756">	  ce.clusterResultsToString();</span>
      }
    }

    /* Output cluster predictions only (for the test data if specified,
       otherwise for the training data */
<span class="nc bnc" id="L762" title="All 2 branches missed.">    if (printClusterAssignments) {</span>
<span class="nc" id="L763">      return printClusterings(clusterer, trainFileName, testFileName, attributesToOutput);</span>
    }

<span class="nc" id="L766">    text.append(clusterer.toString());</span>
<span class="nc" id="L767">    text.append(&quot;\n\n=== Clustering stats for training data ===\n\n&quot; </span>
<span class="nc" id="L768">		+ printClusterStats(clusterer, trainFileName));</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">    if (testFileName.length() != 0) {</span>
      // check header compatibility
<span class="nc" id="L772">      DataSource test = new DataSource(testFileName);</span>
<span class="nc" id="L773">      Instances testStructure = test.getStructure();</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">      if (!trainHeader.equalHeaders(testStructure)) {</span>
<span class="nc" id="L775">        throw new Exception(&quot;Training and testing data are not compatible&quot;);</span>
      }

<span class="nc" id="L778">      text.append(&quot;\n\n=== Clustering stats for testing data ===\n\n&quot; </span>
<span class="nc" id="L779">		  + printClusterStats(clusterer, testFileName));</span>
    }

<span class="nc bnc" id="L782" title="All 2 branches missed.">    if ((clusterer instanceof DensityBasedClusterer) &amp;&amp; </span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">	(doXval == true) &amp;&amp; </span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">	(testFileName.length() == 0) &amp;&amp; </span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">	(objectInputFileName.length() == 0)) {</span>
      // cross validate the log likelihood on the training data
<span class="nc" id="L787">      random = new Random(seed);</span>
<span class="nc" id="L788">      random.setSeed(seed);</span>
<span class="nc" id="L789">      train = source.getDataSet();</span>
<span class="nc" id="L790">      train.randomize(random);</span>
<span class="nc" id="L791">      text.append(</span>
<span class="nc" id="L792">	  crossValidateModel(</span>
<span class="nc" id="L793">	      clusterer.getClass().getName(), train, folds, savedOptions, random));</span>
    }

    // Save the clusterer if an object output file is provided
<span class="nc bnc" id="L797" title="All 2 branches missed.">    if (objectOutputFileName.length() != 0) {</span>
      //SerializationHelper.write(objectOutputFileName, clusterer);
<span class="nc" id="L799">      saveClusterer(objectOutputFileName, clusterer, trainHeader);</span>
    }

    // If classifier is drawable output string describing graph
<span class="nc bnc" id="L803" title="All 4 branches missed.">    if ((clusterer instanceof Drawable) &amp;&amp; (graphFileName.length() != 0)) {</span>
<span class="nc" id="L804">      BufferedWriter writer = new BufferedWriter(new FileWriter(graphFileName));</span>
<span class="nc" id="L805">      writer.write(((Drawable) clusterer).graph());</span>
<span class="nc" id="L806">      writer.newLine();</span>
<span class="nc" id="L807">      writer.flush();</span>
<span class="nc" id="L808">      writer.close();</span>
    }
    
<span class="nc" id="L811">    return  text.toString();</span>
  }

  private static void saveClusterer(String fileName, 
                             Clusterer clusterer, 
                             Instances header) throws Exception {
<span class="nc" id="L817">    java.io.ObjectOutputStream oos = </span>
<span class="nc" id="L818">      new java.io.ObjectOutputStream(</span>
<span class="nc" id="L819">      new java.io.BufferedOutputStream(</span>
<span class="nc" id="L820">      new java.io.FileOutputStream(fileName)));</span>

<span class="nc" id="L822">    oos.writeObject(clusterer);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">    if (header != null) {</span>
<span class="nc" id="L824">      oos.writeObject(header);</span>
    }
<span class="nc" id="L826">    oos.flush();</span>
<span class="nc" id="L827">    oos.close();</span>
<span class="nc" id="L828">  }</span>

  /**
   * Perform a cross-validation for DensityBasedClusterer on a set of instances.
   *
   * @param clusterer the clusterer to use
   * @param data the training data
   * @param numFolds number of folds of cross validation to perform
   * @param random random number seed for cross-validation
   * @return the cross-validated log-likelihood
   * @throws Exception if an error occurs
   */
  public static double crossValidateModel(DensityBasedClusterer clusterer,
					  Instances data,
					  int numFolds,
					  Random random) throws Exception {
    Instances train, test;
<span class="nc" id="L845">    double foldAv = 0;;</span>
<span class="nc" id="L846">    data = new Instances(data);</span>
<span class="nc" id="L847">    data.randomize(random);</span>
    //    double sumOW = 0;
<span class="nc bnc" id="L849" title="All 2 branches missed.">    for (int i = 0; i &lt; numFolds; i++) {</span>
      // Build and test clusterer
<span class="nc" id="L851">      train = data.trainCV(numFolds, i, random);</span>

<span class="nc" id="L853">      clusterer.buildClusterer(train);</span>

<span class="nc" id="L855">      test = data.testCV(numFolds, i);</span>
      
<span class="nc bnc" id="L857" title="All 2 branches missed.">      for (int j = 0; j &lt; test.numInstances(); j++) {</span>
	try {
<span class="nc" id="L859">	  foldAv += ((DensityBasedClusterer)clusterer).</span>
<span class="nc" id="L860">	    logDensityForInstance(test.instance(j));</span>
	  //	  sumOW += test.instance(j).weight();
	  //	double temp = Utils.sum(tempDist);
<span class="nc" id="L863">	} catch (Exception ex) {</span>
	  // unclustered instances
	}
      }
    }
   
    //    return foldAv / sumOW;
<span class="nc" id="L870">    return foldAv / data.numInstances();</span>
  }

  /**
   * Performs a cross-validation 
   * for a DensityBasedClusterer clusterer on a set of instances.
   *
   * @param clustererString a string naming the class of the clusterer
   * @param data the data on which the cross-validation is to be 
   * performed 
   * @param numFolds the number of folds for the cross-validation
   * @param options the options to the clusterer
   * @param random a random number generator
   * @return a string containing the cross validated log likelihood
   * @throws Exception if a clusterer could not be generated 
   */
  public static String crossValidateModel (String clustererString, 
					   Instances data, 
					   int numFolds, 
					   String[] options,
					   Random random)
    throws Exception {
<span class="nc" id="L892">    Clusterer clusterer = null;</span>
<span class="nc" id="L893">    String[] savedOptions = null;</span>
<span class="nc" id="L894">    double CvAv = 0.0;</span>
<span class="nc" id="L895">    StringBuffer CvString = new StringBuffer();</span>

<span class="nc bnc" id="L897" title="All 2 branches missed.">    if (options != null) {</span>
<span class="nc" id="L898">      savedOptions = new String[options.length];</span>
    }

<span class="nc" id="L901">    data = new Instances(data);</span>

    // create clusterer
    try {
<span class="nc" id="L905">      clusterer = (Clusterer)Class.forName(clustererString).newInstance();</span>
    }
<span class="nc" id="L907">    catch (Exception e) {</span>
<span class="nc" id="L908">      throw  new Exception(&quot;Can't find class with name &quot; </span>
<span class="nc" id="L909">			   + clustererString + '.');</span>
    }

<span class="nc bnc" id="L912" title="All 2 branches missed.">    if (!(clusterer instanceof DensityBasedClusterer)) {</span>
<span class="nc" id="L913">      throw  new Exception(clustererString </span>
<span class="nc" id="L914">			   + &quot; must be a distrinbution &quot; </span>
<span class="nc" id="L915">			   + &quot;clusterer.&quot;);</span>
    }

    // Save options
<span class="nc bnc" id="L919" title="All 2 branches missed.">    if (options != null) {</span>
<span class="nc" id="L920">      System.arraycopy(options, 0, savedOptions, 0, options.length);</span>
    }

    // Parse options
<span class="nc bnc" id="L924" title="All 2 branches missed.">    if (clusterer instanceof OptionHandler) {</span>
      try {
<span class="nc" id="L926">	((OptionHandler)clusterer).setOptions(savedOptions);</span>
<span class="nc" id="L927">	Utils.checkForRemainingOptions(savedOptions);</span>
      }
<span class="nc" id="L929">      catch (Exception e) {</span>
<span class="nc" id="L930">	throw  new Exception(&quot;Can't parse given options in &quot; </span>
			     + &quot;cross-validation!&quot;);
      }
    }
<span class="nc" id="L934">    CvAv = crossValidateModel((DensityBasedClusterer)clusterer, data, numFolds, random);</span>

<span class="nc" id="L936">    CvString.append(&quot;\n&quot; + numFolds </span>
<span class="nc" id="L937">		    + &quot; fold CV Log Likelihood: &quot; </span>
<span class="nc" id="L938">		    + Utils.doubleToString(CvAv, 6, 4) </span>
<span class="nc" id="L939">		    + &quot;\n&quot;);</span>
<span class="nc" id="L940">    return  CvString.toString();</span>
  }


  // ===============
  // Private methods
  // ===============
  /**
   * Print the cluster statistics for either the training
   * or the testing data.
   *
   * @param clusterer the clusterer to use for generating statistics.
   * @param fileName the file to load
   * @return a string containing cluster statistics.
   * @throws Exception if statistics can't be generated.
   */
  private static String printClusterStats (Clusterer clusterer, 
					   String fileName)
    throws Exception {
<span class="nc" id="L959">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L960">    int i = 0;</span>
    int cnum;
<span class="nc" id="L962">    double loglk = 0.0;</span>
<span class="nc" id="L963">    int cc = clusterer.numberOfClusters();</span>
<span class="nc" id="L964">    double[] instanceStats = new double[cc];</span>
<span class="nc" id="L965">    int unclusteredInstances = 0;</span>

<span class="nc bnc" id="L967" title="All 2 branches missed.">    if (fileName.length() != 0) {</span>
<span class="nc" id="L968">      DataSource source = new DataSource(fileName);</span>
<span class="nc" id="L969">      Instances structure = source.getStructure();</span>
      Instance inst;
<span class="nc bnc" id="L971" title="All 2 branches missed.">      while (source.hasMoreElements(structure)) {</span>
<span class="nc" id="L972">	inst = source.nextElement(structure);</span>
	try {
<span class="nc" id="L974">	  cnum = clusterer.clusterInstance(inst);</span>

<span class="nc bnc" id="L976" title="All 2 branches missed.">	  if (clusterer instanceof DensityBasedClusterer) {</span>
<span class="nc" id="L977">	    loglk += ((DensityBasedClusterer)clusterer).</span>
<span class="nc" id="L978">	      logDensityForInstance(inst);</span>
	    //	    temp = Utils.sum(dist);
	  }
<span class="nc" id="L981">	  instanceStats[cnum]++;</span>
	}
<span class="nc" id="L983">	catch (Exception e) {</span>
<span class="nc" id="L984">	  unclusteredInstances++;</span>
	}
<span class="nc" id="L986">	i++;</span>
      }

      /*
      // count the actual number of used clusters
      int count = 0;
      for (i = 0; i &lt; cc; i++) {
	if (instanceStats[i] &gt; 0) {
	  count++;
	}
      }
      if (count &gt; 0) {
	double[] tempStats = new double [count];
	count=0;
	for (i=0;i&lt;cc;i++) {
	  if (instanceStats[i] &gt; 0) {
	    tempStats[count++] = instanceStats[i];
	}
	}
	instanceStats = tempStats;
	cc = instanceStats.length;
	} */

<span class="nc" id="L1009">      int clustFieldWidth = (int)((Math.log(cc)/Math.log(10))+1);</span>
<span class="nc" id="L1010">      int numInstFieldWidth = (int)((Math.log(i)/Math.log(10))+1);</span>
<span class="nc" id="L1011">      double sum = Utils.sum(instanceStats);</span>
<span class="nc" id="L1012">      loglk /= sum;</span>
<span class="nc" id="L1013">      text.append(&quot;Clustered Instances\n&quot;);</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">      for (i = 0; i &lt; cc; i++) {</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">	if (instanceStats[i] &gt; 0) {</span>
<span class="nc" id="L1017">	  text.append(Utils.doubleToString((double)i, </span>
<span class="nc" id="L1018">					   clustFieldWidth, 0) </span>
<span class="nc" id="L1019">		      + &quot;      &quot; </span>
<span class="nc" id="L1020">		      + Utils.doubleToString(instanceStats[i], </span>
<span class="nc" id="L1021">					     numInstFieldWidth, 0) </span>
<span class="nc" id="L1022">		      + &quot; (&quot; </span>
<span class="nc" id="L1023">		    + Utils.doubleToString((instanceStats[i]/sum*100.0)</span>
<span class="nc" id="L1024">					   , 3, 0) + &quot;%)\n&quot;);</span>
	}
      }
<span class="nc bnc" id="L1027" title="All 2 branches missed.">      if (unclusteredInstances &gt; 0) {</span>
<span class="nc" id="L1028">	text.append(&quot;\nUnclustered Instances : &quot;+unclusteredInstances);</span>
      }

<span class="nc bnc" id="L1031" title="All 2 branches missed.">      if (clusterer instanceof DensityBasedClusterer) {</span>
<span class="nc" id="L1032">	text.append(&quot;\n\nLog likelihood: &quot; </span>
<span class="nc" id="L1033">		    + Utils.doubleToString(loglk, 1, 5) </span>
<span class="nc" id="L1034">		    + &quot;\n&quot;);</span>
      }
    }

<span class="nc" id="L1038">    return text.toString();</span>
  }


  /**
   * Print the cluster assignments for either the training
   * or the testing data.
   *
   * @param clusterer the clusterer to use for cluster assignments
   * @param trainFileName the train file
   * @param testFileName an optional test file
   * @param attributesToOutput the attributes to print
   * @return a string containing the instance indexes and cluster assigns.
   * @throws Exception if cluster assignments can't be printed
   */
  private static String printClusterings (Clusterer clusterer, String trainFileName,
					  String testFileName, Range attributesToOutput)
    throws Exception {

<span class="nc" id="L1057">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L1058">    int i = 0;</span>
    int cnum;
<span class="nc" id="L1060">    DataSource source = null;</span>
    Instance inst;
    Instances structure;
    
<span class="nc bnc" id="L1064" title="All 2 branches missed.">    if (testFileName.length() != 0)</span>
<span class="nc" id="L1065">      source = new DataSource(testFileName);</span>
    else
<span class="nc" id="L1067">      source = new DataSource(trainFileName);</span>
    
<span class="nc" id="L1069">    structure = source.getStructure();</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">    while (source.hasMoreElements(structure)) {</span>
<span class="nc" id="L1071">      inst = source.nextElement(structure);</span>
      try {
<span class="nc" id="L1073">	cnum = clusterer.clusterInstance(inst);</span>
	
<span class="nc" id="L1075">	text.append(i + &quot; &quot; + cnum + &quot; &quot;</span>
<span class="nc" id="L1076">	    + attributeValuesString(inst, attributesToOutput) + &quot;\n&quot;);</span>
      }
<span class="nc" id="L1078">      catch (Exception e) {</span>
	/*	  throw  new Exception('\n' + &quot;Unable to cluster instance\n&quot; 
	 + e.getMessage()); */
<span class="nc" id="L1081">	text.append(i + &quot; Unclustered &quot;</span>
<span class="nc" id="L1082">	    + attributeValuesString(inst, attributesToOutput) + &quot;\n&quot;);</span>
      }
<span class="nc" id="L1084">      i++;</span>
    }
    
<span class="nc" id="L1087">    return text.toString();</span>
  }

  /**
   * Builds a string listing the attribute values in a specified range of indices,
   * separated by commas and enclosed in brackets.
   *
   * @param instance the instance to print the values from
   * @param attRange the range of the attributes to list
   * @return a string listing values of the attributes in the range
   */
  private static String attributeValuesString(Instance instance, Range attRange) {
<span class="nc" id="L1099">    StringBuffer text = new StringBuffer();</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">    if (attRange != null) {</span>
<span class="nc" id="L1101">      boolean firstOutput = true;</span>
<span class="nc" id="L1102">      attRange.setUpper(instance.numAttributes() - 1);</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">      for (int i=0; i&lt;instance.numAttributes(); i++)</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">	if (attRange.isInRange(i)) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">	  if (firstOutput) text.append(&quot;(&quot;);</span>
<span class="nc" id="L1106">	  else text.append(&quot;,&quot;);</span>
<span class="nc" id="L1107">	  text.append(instance.toString(i));</span>
<span class="nc" id="L1108">	  firstOutput = false;</span>
	}
<span class="nc bnc" id="L1110" title="All 2 branches missed.">      if (!firstOutput) text.append(&quot;)&quot;);</span>
    }
<span class="nc" id="L1112">    return text.toString();</span>
  }

  /**
   * Make up the help string giving all the command line options
   *
   * @param clusterer the clusterer to include options for
   * @return a string detailing the valid command line options
   */
  private static String makeOptionString (Clusterer clusterer,
                                          boolean globalInfo) {
<span class="nc" id="L1123">    StringBuffer optionsText = new StringBuffer(&quot;&quot;);</span>
    // General options
<span class="nc" id="L1125">    optionsText.append(&quot;\n\nGeneral options:\n\n&quot;);</span>
<span class="nc" id="L1126">    optionsText.append(&quot;-h or -help\n&quot;);</span>
<span class="nc" id="L1127">    optionsText.append(&quot;\tOutput help information.\n&quot;);</span>
<span class="nc" id="L1128">    optionsText.append(&quot;-synopsis or -info\n&quot;);</span>
<span class="nc" id="L1129">    optionsText.append(&quot;\tOutput synopsis for clusterer (use in conjunction &quot;</span>
        + &quot; with -h)\n&quot;);
<span class="nc" id="L1131">    optionsText.append(&quot;-t &lt;name of training file&gt;\n&quot;);</span>
<span class="nc" id="L1132">    optionsText.append(&quot;\tSets training file.\n&quot;);</span>
<span class="nc" id="L1133">    optionsText.append(&quot;-T &lt;name of test file&gt;\n&quot;);</span>
<span class="nc" id="L1134">    optionsText.append(&quot;\tSets test file.\n&quot;);</span>
<span class="nc" id="L1135">    optionsText.append(&quot;-l &lt;name of input file&gt;\n&quot;);</span>
<span class="nc" id="L1136">    optionsText.append(&quot;\tSets model input file.\n&quot;);</span>
<span class="nc" id="L1137">    optionsText.append(&quot;-d &lt;name of output file&gt;\n&quot;);</span>
<span class="nc" id="L1138">    optionsText.append(&quot;\tSets model output file.\n&quot;);</span>
<span class="nc" id="L1139">    optionsText.append(&quot;-p &lt;attribute range&gt;\n&quot;);</span>
<span class="nc" id="L1140">    optionsText.append(&quot;\tOutput predictions. Predictions are for &quot; </span>
		       + &quot;training file&quot; 
		       + &quot;\n\tif only training file is specified,&quot; 
		       + &quot;\n\totherwise predictions are for the test file.&quot;
		       + &quot;\n\tThe range specifies attribute values to be output&quot;
		       + &quot;\n\twith the predictions. Use '-p 0' for none.\n&quot;);
<span class="nc" id="L1146">    optionsText.append(&quot;-x &lt;number of folds&gt;\n&quot;);</span>
<span class="nc" id="L1147">    optionsText.append(&quot;\tOnly Distribution Clusterers can be cross validated.\n&quot;);</span>
<span class="nc" id="L1148">    optionsText.append(&quot;-s &lt;random number seed&gt;\n&quot;);</span>
<span class="nc" id="L1149">    optionsText.append(&quot;\tSets the seed for randomizing the data in cross-validation\n&quot;);</span>
<span class="nc" id="L1150">    optionsText.append(&quot;-c &lt;class index&gt;\n&quot;);</span>
<span class="nc" id="L1151">    optionsText.append(&quot;\tSet class attribute. If supplied, class is ignored&quot;);</span>
<span class="nc" id="L1152">    optionsText.append(&quot;\n\tduring clustering but is used in a classes to&quot;);</span>
<span class="nc" id="L1153">    optionsText.append(&quot;\n\tclusters evaluation.\n&quot;);</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">    if (clusterer instanceof Drawable) {</span>
<span class="nc" id="L1155">      optionsText.append(&quot;-g &lt;name of graph file&gt;\n&quot;);</span>
<span class="nc" id="L1156">      optionsText.append(&quot;\tOutputs the graph representation of the clusterer to the file.\n&quot;);</span>
    }

    // Get scheme-specific options
<span class="nc bnc" id="L1160" title="All 2 branches missed.">    if (clusterer instanceof OptionHandler) {</span>
<span class="nc" id="L1161">      optionsText.append(&quot;\nOptions specific to &quot; </span>
<span class="nc" id="L1162">			 + clusterer.getClass().getName() + &quot;:\n\n&quot;);</span>
<span class="nc" id="L1163">      Enumeration enu = ((OptionHandler)clusterer).listOptions();</span>

<span class="nc bnc" id="L1165" title="All 2 branches missed.">      while (enu.hasMoreElements()) {</span>
<span class="nc" id="L1166">	Option option = (Option)enu.nextElement();</span>
<span class="nc" id="L1167">	optionsText.append(option.synopsis() + '\n');</span>
<span class="nc" id="L1168">	optionsText.append(option.description() + &quot;\n&quot;);</span>
      }
    }
    
    // Get global information (if available)
<span class="nc bnc" id="L1173" title="All 2 branches missed.">    if (globalInfo) {</span>
      try {
<span class="nc" id="L1175">        String gi = getGlobalInfo(clusterer);</span>
<span class="nc" id="L1176">        optionsText.append(gi);</span>
<span class="nc" id="L1177">      } catch (Exception ex) {</span>
        // quietly ignore
      }
    }

<span class="nc" id="L1182">    return  optionsText.toString();</span>
  }
  
  /**
   * Return the global info (if it exists) for the supplied clusterer
   * 
   * @param clusterer the clusterer to get the global info for
   * @return the global info (synopsis) for the clusterer
   * @throws Exception if there is a problem reflecting on the clusterer
   */
  protected static String getGlobalInfo(Clusterer clusterer) throws Exception {
<span class="nc" id="L1193">    BeanInfo bi = Introspector.getBeanInfo(clusterer.getClass());</span>
    MethodDescriptor[] methods;
<span class="nc" id="L1195">    methods = bi.getMethodDescriptors();</span>
<span class="nc" id="L1196">    Object[] args = {};</span>
<span class="nc" id="L1197">    String result = &quot;\nSynopsis for &quot; + clusterer.getClass().getName()</span>
<span class="nc" id="L1198">      + &quot;:\n\n&quot;;</span>
    
<span class="nc bnc" id="L1200" title="All 2 branches missed.">    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L1201">      String name = methods[i].getDisplayName();</span>
<span class="nc" id="L1202">      Method meth = methods[i].getMethod();</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">      if (name.equals(&quot;globalInfo&quot;)) {</span>
<span class="nc" id="L1204">        String globalInfo = (String)(meth.invoke(clusterer, args));</span>
<span class="nc" id="L1205">        result += globalInfo;</span>
<span class="nc" id="L1206">        break;</span>
      }
    }
    
<span class="nc" id="L1210">    return result;</span>
  }

  /**
   * Tests whether the current evaluation object is equal to another
   * evaluation object
   *
   * @param obj the object to compare against
   * @return true if the two objects are equal
   */
  public boolean equals(Object obj) {
<span class="nc bnc" id="L1221" title="All 4 branches missed.">    if ((obj == null) || !(obj.getClass().equals(this.getClass())))</span>
<span class="nc" id="L1222">      return false;</span>
    
<span class="nc" id="L1224">    ClusterEvaluation cmp = (ClusterEvaluation) obj;</span>
    
<span class="nc bnc" id="L1226" title="All 6 branches missed.">    if ((m_classToCluster != null) != (cmp.m_classToCluster != null)) return false;</span>
<span class="nc bnc" id="L1227" title="All 2 branches missed.">    if (m_classToCluster != null) {</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">      for (int i = 0; i &lt; m_classToCluster.length; i++) {</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (m_classToCluster[i] != cmp.m_classToCluster[i])</span>
<span class="nc" id="L1230">  	return false;</span>
      }
    }
    
<span class="nc bnc" id="L1234" title="All 6 branches missed.">    if ((m_clusterAssignments != null) != (cmp.m_clusterAssignments != null)) return false;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">    if (m_clusterAssignments != null) {</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">      for (int i = 0; i &lt; m_clusterAssignments.length; i++) {</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">        if (m_clusterAssignments[i] != cmp.m_clusterAssignments[i])</span>
<span class="nc" id="L1238">  	return false;</span>
      }
    }

<span class="nc bnc" id="L1242" title="All 2 branches missed.">    if (Double.isNaN(m_logL) != Double.isNaN(cmp.m_logL)) return false;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">    if (!Double.isNaN(m_logL)) {</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">      if (m_logL != cmp.m_logL) return false;</span>
    }
    
<span class="nc bnc" id="L1247" title="All 2 branches missed.">    if (m_numClusters != cmp.m_numClusters) return false;</span>
    
    // TODO: better comparison? via members?
<span class="nc" id="L1250">    String clusteringResults1 = m_clusteringResults.toString().replaceAll(&quot;Elapsed time.*&quot;, &quot;&quot;);</span>
<span class="nc" id="L1251">    String clusteringResults2 = cmp.m_clusteringResults.toString().replaceAll(&quot;Elapsed time.*&quot;, &quot;&quot;);</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">    if (!clusteringResults1.equals(clusteringResults2)) return false;</span>
    
<span class="nc" id="L1254">    return true;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1263">    return RevisionUtils.extract(&quot;$Revision: 7753 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param args the options
   */
  public static void main (String[] args) {
    try {
<span class="nc bnc" id="L1273" title="All 2 branches missed.">      if (args.length == 0) {</span>
<span class="nc" id="L1274">	throw  new Exception(&quot;The first argument must be the name of a &quot; </span>
			     + &quot;clusterer&quot;);
      }

<span class="nc" id="L1278">      String ClustererString = args[0];</span>
<span class="nc" id="L1279">      args[0] = &quot;&quot;;</span>
<span class="nc" id="L1280">      Clusterer newClusterer = AbstractClusterer.forName(ClustererString, null);</span>
<span class="nc" id="L1281">      System.out.println(evaluateClusterer(newClusterer, args));</span>
    }
<span class="nc" id="L1283">    catch (Exception e) {</span>
<span class="nc" id="L1284">      System.out.println(e.getMessage());</span>
    }
<span class="nc" id="L1286">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>