<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>EM.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.clusterers</a> &gt; <span class="el_source">EM.java</span></div><h1>EM.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    EM.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.clusterers;

import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Attribute;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.estimators.DiscreteEstimator;
import weka.estimators.Estimator;
import weka.filters.unsupervised.attribute.ReplaceMissingValues;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Simple EM (expectation maximisation) class.&lt;br/&gt;
 * &lt;br/&gt;
 * EM assigns a probability distribution to each instance which indicates the probability of it belonging to each of the clusters. EM can decide how many clusters to create by cross validation, or you may specify apriori how many clusters to generate.&lt;br/&gt;
 * &lt;br/&gt;
 * The cross validation performed to determine the number of clusters is done in the following steps:&lt;br/&gt;
 * 1. the number of clusters is set to 1&lt;br/&gt;
 * 2. the training set is split randomly into 10 folds.&lt;br/&gt;
 * 3. EM is performed 10 times using the 10 folds the usual CV way.&lt;br/&gt;
 * 4. the loglikelihood is averaged over all 10 results.&lt;br/&gt;
 * 5. if loglikelihood has increased the number of clusters is increased by 1 and the program continues at step 2. &lt;br/&gt;
 * &lt;br/&gt;
 * The number of folds is fixed to 10, as long as the number of instances in the training set is not smaller 10. If this is the case the number of folds is set equal to the number of instances.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;
 *  number of clusters. If omitted or -1 specified, then 
 *  cross validation is used to select the number of clusters.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;num&amp;gt;
 *  max iterations.
 * (default 100)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V
 *  verbose.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;num&amp;gt;
 *  minimum allowable standard deviation for normal density
 *  computation
 *  (default 1e-6)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O
 *  Display model in old format (good when there are many clusters)
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Random number seed.
 *  (default 100)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Mark Hall (mhall@cs.waikato.ac.nz)
 * @author Eibe Frank (eibe@cs.waikato.ac.nz)
 * @version $Revision: 6299 $
 */
<span class="fc" id="L91">public class EM</span>
  extends RandomizableDensityBasedClusterer
  implements NumberOfClustersRequestable, WeightedInstancesHandler {

  /** for serialization */
  static final long serialVersionUID = 8348181483812829475L;
  
  /** hold the discrete estimators for each cluster */
  private Estimator m_model[][];

  /** hold the normal estimators for each cluster */
  private double m_modelNormal[][][];

  /** default minimum standard deviation */
<span class="fc" id="L105">  private double m_minStdDev = 1e-6;</span>

  private double [] m_minStdDevPerAtt;

  /** hold the weights of each instance for each cluster */
  private double m_weights[][];

  /** the prior probabilities for clusters */
  private double m_priors[];

  /** the loglikelihood of the data */
  private double m_loglikely;

  /** training instances */
<span class="fc" id="L119">  private Instances m_theInstances = null;</span>

  /** number of clusters selected by the user or cross validation */
  private int m_num_clusters;

  /** the initial number of clusters requested by the user--- -1 if
      xval is to be used to find the number of clusters */
  private int m_initialNumClusters;

  /** number of attributes */
  private int m_num_attribs;

  /** number of training instances */
  private int m_num_instances;

  /** maximum iterations to perform */
  private int m_max_iterations;

  /** attribute min values */
  private double [] m_minValues;

  /** attribute max values */
  private double [] m_maxValues;

  /** random number generator */
  private Random m_rr;

  /** Verbose? */
  private boolean m_verbose;

 /** globally replace missing values */
  private ReplaceMissingValues m_replaceMissing;

  /** display model output in old-style format */
  private boolean m_displayModelInOldFormat;

  /**
   * Returns a string describing this clusterer
   * @return a description of the evaluator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L161">    return</span>
<span class="nc" id="L162">        &quot;Simple EM (expectation maximisation) class.\n\n&quot;</span>
      + &quot;EM assigns a probability distribution to each instance which &quot;
      + &quot;indicates the probability of it belonging to each of the clusters. &quot;
      + &quot;EM can decide how many clusters to create by cross validation, or you &quot;
      + &quot;may specify apriori how many clusters to generate.\n\n&quot;
      + &quot;The cross validation performed to determine the number of clusters &quot;
      + &quot;is done in the following steps:\n&quot;
      + &quot;1. the number of clusters is set to 1\n&quot;
      + &quot;2. the training set is split randomly into 10 folds.\n&quot;
      + &quot;3. EM is performed 10 times using the 10 folds the usual CV way.\n&quot;
      + &quot;4. the loglikelihood is averaged over all 10 results.\n&quot;
      + &quot;5. if loglikelihood has increased the number of clusters is increased &quot;
      + &quot;by 1 and the program continues at step 2. \n\n&quot;
      + &quot;The number of folds is fixed to 10, as long as the number of &quot;
      + &quot;instances in the training set is not smaller 10. If this is the case &quot;
      + &quot;the number of folds is set equal to the number of instances.&quot;;
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions () {
<span class="nc" id="L186">    Vector result = new Vector();</span>
    
<span class="nc" id="L188">    result.addElement(new Option(</span>
<span class="nc" id="L189">	&quot;\tnumber of clusters. If omitted or -1 specified, then \n&quot;</span>
	+ &quot;\tcross validation is used to select the number of clusters.&quot;, 
<span class="nc" id="L191">	&quot;N&quot;, 1, &quot;-N &lt;num&gt;&quot;));</span>

<span class="nc" id="L193">    result.addElement(new Option(</span>
<span class="nc" id="L194">	&quot;\tmax iterations.&quot;</span>
	+ &quot;\n(default 100)&quot;, 
<span class="nc" id="L196">	&quot;I&quot;, 1, &quot;-I &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L198">    result.addElement(new Option(</span>
<span class="nc" id="L199">	&quot;\tverbose.&quot;,</span>
<span class="nc" id="L200">	&quot;V&quot;, 0, &quot;-V&quot;));</span>
    
<span class="nc" id="L202">    result.addElement(new Option(</span>
<span class="nc" id="L203">	&quot;\tminimum allowable standard deviation for normal density\n&quot;</span>
	+ &quot;\tcomputation\n&quot;
	+ &quot;\t(default 1e-6)&quot;,
<span class="nc" id="L206">	&quot;M&quot;,1,&quot;-M &lt;num&gt;&quot;));</span>

<span class="nc" id="L208">    result.addElement(</span>
<span class="nc" id="L209">              new Option(&quot;\tDisplay model in old format (good when there are &quot;</span>
                         + &quot;many clusters)\n&quot;,
<span class="nc" id="L211">                         &quot;O&quot;, 0, &quot;-O&quot;));</span>

<span class="nc" id="L213">    Enumeration en = super.listOptions();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">    while (en.hasMoreElements())</span>
<span class="nc" id="L215">      result.addElement(en.nextElement());</span>
    
<span class="nc" id="L217">    return  result.elements();</span>
  }


  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;
   *  number of clusters. If omitted or -1 specified, then 
   *  cross validation is used to select the number of clusters.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;num&amp;gt;
   *  max iterations.
   * (default 100)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -V
   *  verbose.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;num&amp;gt;
   *  minimum allowable standard deviation for normal density
   *  computation
   *  (default 1e-6)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O
   *  Display model in old format (good when there are many clusters)
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Random number seed.
   *  (default 100)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   * 
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions (String[] options)
    throws Exception {
<span class="nc" id="L258">    resetOptions();</span>
<span class="nc" id="L259">    setDebug(Utils.getFlag('V', options));</span>
<span class="nc" id="L260">    String optionString = Utils.getOption('I', options);</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L263">      setMaxIterations(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L266">    optionString = Utils.getOption('N', options);</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L268">      setNumClusters(Integer.parseInt(optionString));</span>
    }

<span class="nc" id="L271">    optionString = Utils.getOption('M', options);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L273">      setMinStdDev((new Double(optionString)).doubleValue());</span>
    }

<span class="nc" id="L276">    setDisplayModelInOldFormat(Utils.getFlag('O', options));</span>
    
<span class="nc" id="L278">    super.setOptions(options);</span>
<span class="nc" id="L279">  }</span>

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String displayModelInOldFormatTipText() {
<span class="nc" id="L287">    return &quot;Use old format for model output. The old format is &quot;</span>
      + &quot;better when there are many clusters. The new format &quot;
      + &quot;is better when there are fewer clusters and many attributes.&quot;;
  }

  /**
   * Set whether to display model output in the old, original
   * format.
   *
   * @param d true if model ouput is to be shown in the old format
   */
  public void setDisplayModelInOldFormat(boolean d) {
<span class="nc" id="L299">    m_displayModelInOldFormat = d;</span>
<span class="nc" id="L300">  }</span>

  /**
   * Get whether to display model output in the old, original
   * format.
   *
   * @return true if model ouput is to be shown in the old format
   */
  public boolean getDisplayModelInOldFormat() {
<span class="nc" id="L309">    return m_displayModelInOldFormat;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String minStdDevTipText() {
<span class="nc" id="L318">    return &quot;set minimum allowable standard deviation&quot;;</span>
  }

  /**
   * Set the minimum value for standard deviation when calculating
   * normal density. Reducing this value can help prevent arithmetic
   * overflow resulting from multiplying large densities (arising from small
   * standard deviations) when there are many singleton or near singleton
   * values.
   * @param m minimum value for standard deviation
   */
  public void setMinStdDev(double m) {
<span class="nc" id="L330">    m_minStdDev = m;</span>
<span class="nc" id="L331">  }</span>

  public void setMinStdDevPerAtt(double [] m) {
<span class="nc" id="L334">    m_minStdDevPerAtt = m;</span>
<span class="nc" id="L335">  }</span>

  /**
   * Get the minimum allowable standard deviation.
   * @return the minumum allowable standard deviation
   */
  public double getMinStdDev() {
<span class="nc" id="L342">    return m_minStdDev;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numClustersTipText() {
<span class="nc" id="L351">    return &quot;set number of clusters. -1 to select number of clusters &quot;</span>
      +&quot;automatically by cross validation.&quot;;
  }

  /**
   * Set the number of clusters (-1 to select by CV).
   *
   * @param n the number of clusters
   * @throws Exception if n is 0
   */
  public void setNumClusters (int n)
    throws Exception {
    
<span class="nc bnc" id="L364" title="All 2 branches missed.">    if (n == 0) {</span>
<span class="nc" id="L365">      throw  new Exception(&quot;Number of clusters must be &gt; 0. (or -1 to &quot; </span>
			   + &quot;select by cross validation).&quot;);
    }

<span class="nc bnc" id="L369" title="All 2 branches missed.">    if (n &lt; 0) {</span>
<span class="nc" id="L370">      m_num_clusters = -1;</span>
<span class="nc" id="L371">      m_initialNumClusters = -1;</span>
    }
    else {
<span class="nc" id="L374">      m_num_clusters = n;</span>
<span class="nc" id="L375">      m_initialNumClusters = n;</span>
    }
<span class="nc" id="L377">  }</span>


  /**
   * Get the number of clusters
   *
   * @return the number of clusters.
   */
  public int getNumClusters () {
<span class="nc" id="L386">    return  m_initialNumClusters;</span>
  }

  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String maxIterationsTipText() {
<span class="nc" id="L395">    return &quot;maximum number of iterations&quot;;</span>
  }

  /**
   * Set the maximum number of iterations to perform
   *
   * @param i the number of iterations
   * @throws Exception if i is less than 1
   */
  public void setMaxIterations (int i)
    throws Exception {
<span class="nc bnc" id="L406" title="All 2 branches missed.">    if (i &lt; 1) {</span>
<span class="nc" id="L407">      throw  new Exception(&quot;Maximum number of iterations must be &gt; 0!&quot;);</span>
    }

<span class="nc" id="L410">    m_max_iterations = i;</span>
<span class="nc" id="L411">  }</span>


  /**
   * Get the maximum number of iterations
   *
   * @return the number of iterations
   */
  public int getMaxIterations () {
<span class="nc" id="L420">    return  m_max_iterations;</span>
  }

  
  /**
   * Returns the tip text for this property
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String debugTipText() {
<span class="nc" id="L430">    return &quot;If set to true, clusterer may output additional info to &quot; +</span>
      &quot;the console.&quot;;
  }


  /**
   * Set debug mode - verbose output
   *
   * @param v true for verbose output
   */
  public void setDebug (boolean v) {
<span class="nc" id="L441">    m_verbose = v;</span>
<span class="nc" id="L442">  }</span>


  /**
   * Get debug mode
   *
   * @return true if debug mode is set
   */
  public boolean getDebug () {
<span class="nc" id="L451">    return  m_verbose;</span>
  }


  /**
   * Gets the current settings of EM.
   *
   * @return an array of strings suitable for passing to setOptions()
   */
  public String[] getOptions () {
    int       	i;
    Vector    	result;
    String[]  	options;

<span class="nc" id="L465">    result = new Vector();</span>

<span class="nc" id="L467">    result.add(&quot;-I&quot;);</span>
<span class="nc" id="L468">    result.add(&quot;&quot; + m_max_iterations);</span>
<span class="nc" id="L469">    result.add(&quot;-N&quot;);</span>
<span class="nc" id="L470">    result.add(&quot;&quot; + getNumClusters());</span>
<span class="nc" id="L471">    result.add(&quot;-M&quot;);</span>
<span class="nc" id="L472">    result.add(&quot;&quot; + getMinStdDev());</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">    if (m_displayModelInOldFormat) {</span>
<span class="nc" id="L474">      result.add(&quot;-O&quot;);</span>
    }

<span class="nc" id="L477">    options = super.getOptions();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L479">      result.add(options[i]);</span>

<span class="nc" id="L481">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }

  /**
   * Initialise estimators and storage.
   *
   * @param inst the instances
   * @throws Exception if initialization fails
   **/
  private void EM_Init (Instances inst)
    throws Exception {
    int i, j, k;

    // run k means 10 times and choose best solution
<span class="nc" id="L495">    SimpleKMeans bestK = null;</span>
<span class="nc" id="L496">    double bestSqE = Double.MAX_VALUE;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">    for (i = 0; i &lt; 10; i++) {</span>
<span class="nc" id="L498">      SimpleKMeans sk = new SimpleKMeans();</span>
<span class="nc" id="L499">      sk.setSeed(m_rr.nextInt());</span>
<span class="nc" id="L500">      sk.setNumClusters(m_num_clusters);</span>
<span class="nc" id="L501">      sk.setDisplayStdDevs(true);</span>
<span class="nc" id="L502">      sk.buildClusterer(inst);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">      if (sk.getSquaredError() &lt; bestSqE) {</span>
<span class="nc" id="L504">	bestSqE = sk.getSquaredError();</span>
<span class="nc" id="L505">	bestK = sk;</span>
      }
    }
    
    // initialize with best k-means solution
<span class="nc" id="L510">    m_num_clusters = bestK.numberOfClusters();</span>
<span class="nc" id="L511">    m_weights = new double[inst.numInstances()][m_num_clusters];</span>
<span class="nc" id="L512">    m_model = new DiscreteEstimator[m_num_clusters][m_num_attribs];</span>
<span class="nc" id="L513">    m_modelNormal = new double[m_num_clusters][m_num_attribs][3];</span>
<span class="nc" id="L514">    m_priors = new double[m_num_clusters];</span>
<span class="nc" id="L515">    Instances centers = bestK.getClusterCentroids();</span>
<span class="nc" id="L516">    Instances stdD = bestK.getClusterStandardDevs();</span>
<span class="nc" id="L517">    int [][][] nominalCounts = bestK.getClusterNominalCounts();</span>
<span class="nc" id="L518">    int [] clusterSizes = bestK.getClusterSizes();</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">    for (i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc" id="L521">      Instance center = centers.instance(i);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">      for (j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">	if (inst.attribute(j).isNominal()) {</span>
<span class="nc" id="L524">	  m_model[i][j] = new DiscreteEstimator(m_theInstances.</span>
<span class="nc" id="L525">						attribute(j).numValues()</span>
<span class="nc" id="L526">						, true);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">	  for (k = 0; k &lt; inst.attribute(j).numValues(); k++) {</span>
<span class="nc" id="L528">	    m_model[i][j].addValue(k, nominalCounts[i][j][k]);</span>
	  }
	} else {
<span class="nc bnc" id="L531" title="All 2 branches missed.">	  double minStdD = (m_minStdDevPerAtt != null)</span>
<span class="nc" id="L532">	    ? m_minStdDevPerAtt[j]</span>
<span class="nc" id="L533">	    : m_minStdDev;</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">	  double mean = (center.isMissing(j))</span>
<span class="nc" id="L535">	    ? inst.meanOrMode(j)</span>
<span class="nc" id="L536">	    : center.value(j);</span>
<span class="nc" id="L537">	  m_modelNormal[i][j][0] = mean;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">	  double stdv = (stdD.instance(i).isMissing(j))</span>
<span class="nc" id="L539">	    ? ((m_maxValues[j] - m_minValues[j]) / (2 * m_num_clusters))</span>
<span class="nc" id="L540">	    : stdD.instance(i).value(j);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">	  if (stdv &lt; minStdD) {</span>
<span class="nc" id="L542">	    stdv = inst.attributeStats(j).numericStats.stdDev;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (Double.isInfinite(stdv)) {</span>
<span class="nc" id="L544">              stdv = minStdD;</span>
            }
<span class="nc bnc" id="L546" title="All 2 branches missed.">	    if (stdv &lt; minStdD) {</span>
<span class="nc" id="L547">	      stdv = minStdD;</span>
	    }
	  }
<span class="nc bnc" id="L550" title="All 2 branches missed.">	  if (stdv &lt;= 0) {</span>
<span class="nc" id="L551">	    stdv = m_minStdDev;</span>
	  }

<span class="nc" id="L554">	  m_modelNormal[i][j][1] = stdv;</span>
<span class="nc" id="L555">	  m_modelNormal[i][j][2] = 1.0;</span>
	}
      } 
    }    
    
    
<span class="nc bnc" id="L561" title="All 2 branches missed.">    for (j = 0; j &lt; m_num_clusters; j++) {</span>
      //      m_priors[j] += 1.0;
<span class="nc" id="L563">      m_priors[j] = clusterSizes[j];</span>
    }
<span class="nc" id="L565">    Utils.normalize(m_priors);</span>
<span class="nc" id="L566">  }</span>


  /**
   * calculate prior probabilites for the clusters
   *
   * @param inst the instances
   * @throws Exception if priors can't be calculated
   **/
  private void estimate_priors (Instances inst)
    throws Exception {

<span class="nc bnc" id="L578" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc" id="L579">      m_priors[i] = 0.0;</span>
    }

<span class="nc bnc" id="L582" title="All 2 branches missed.">    for (int i = 0; i &lt; inst.numInstances(); i++) {</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">      for (int j = 0; j &lt; m_num_clusters; j++) {</span>
<span class="nc" id="L584">        m_priors[j] += inst.instance(i).weight() * m_weights[i][j];</span>
      }
    }

<span class="nc" id="L588">    Utils.normalize(m_priors);</span>
<span class="nc" id="L589">  }</span>


  /** Constant for normal distribution. */
<span class="fc" id="L593">  private static double m_normConst = Math.log(Math.sqrt(2*Math.PI));</span>

  /**
   * Density function of normal distribution.
   * @param x input value
   * @param mean mean of distribution
   * @param stdDev standard deviation of distribution
   * @return the density
   */
  private double logNormalDens (double x, double mean, double stdDev) {

<span class="nc" id="L604">    double diff = x - mean;</span>
    //    System.err.println(&quot;x: &quot;+x+&quot; mean: &quot;+mean+&quot; diff: &quot;+diff+&quot; stdv: &quot;+stdDev);
    //    System.err.println(&quot;diff*diff/(2*stdv*stdv): &quot;+ (diff * diff / (2 * stdDev * stdDev)));
    
<span class="nc" id="L608">    return - (diff * diff / (2 * stdDev * stdDev))  - m_normConst - Math.log(stdDev);</span>
  }

  /**
   * New probability estimators for an iteration
   */
  private void new_estimators () {
<span class="nc bnc" id="L615" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">      for (int j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (m_theInstances.attribute(j).isNominal()) {</span>
<span class="nc" id="L618">          m_model[i][j] = new DiscreteEstimator(m_theInstances.</span>
<span class="nc" id="L619">						attribute(j).numValues()</span>
<span class="nc" id="L620">						, true);</span>
        }
        else {
<span class="nc" id="L623">          m_modelNormal[i][j][0] = m_modelNormal[i][j][1] = </span>
<span class="nc" id="L624">	    m_modelNormal[i][j][2] = 0.0;</span>
        }
      }
    }
<span class="nc" id="L628">  }</span>


  /**
   * The M step of the EM algorithm.
   * @param inst the training instances
   * @throws Exception if something goes wrong
   */
  private void M (Instances inst)
    throws Exception {

    int i, j, l;

<span class="nc" id="L641">    new_estimators();</span>
<span class="nc" id="L642">    estimate_priors(inst);</span>

<span class="nc bnc" id="L644" title="All 2 branches missed.">    for (i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">      for (j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">        for (l = 0; l &lt; inst.numInstances(); l++) {</span>
<span class="nc" id="L647">	  Instance in = inst.instance(l);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">          if (!in.isMissing(j)) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (inst.attribute(j).isNominal()) {</span>
<span class="nc" id="L650">              m_model[i][j].addValue(in.value(j), </span>
<span class="nc" id="L651">				     in.weight() * m_weights[l][i]);</span>
            }
            else {
<span class="nc" id="L654">              m_modelNormal[i][j][0] += (in.value(j) * in.weight() *</span>
<span class="nc" id="L655">					 m_weights[l][i]);</span>
<span class="nc" id="L656">              m_modelNormal[i][j][2] += in.weight() * m_weights[l][i];</span>
<span class="nc" id="L657">              m_modelNormal[i][j][1] += (in.value(j) * </span>
<span class="nc" id="L658">					 in.value(j) * in.weight() * m_weights[l][i]);</span>
            }
          }
        }
      }
    }
    
    // calcualte mean and std deviation for numeric attributes
<span class="nc bnc" id="L666" title="All 2 branches missed.">    for (j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">      if (!inst.attribute(j).isNominal()) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">        for (i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">          if (m_modelNormal[i][j][2] &lt;= 0) {</span>
<span class="nc" id="L670">            m_modelNormal[i][j][1] = Double.MAX_VALUE;</span>
	    //	    m_modelNormal[i][j][0] = 0;
<span class="nc" id="L672">	    m_modelNormal[i][j][0] = m_minStdDev;</span>
          } else {
	      
	    // variance
<span class="nc" id="L676">	    m_modelNormal[i][j][1] = (m_modelNormal[i][j][1] - </span>
<span class="nc" id="L677">				      (m_modelNormal[i][j][0] * </span>
<span class="nc" id="L678">				       m_modelNormal[i][j][0] / </span>
<span class="nc" id="L679">				       m_modelNormal[i][j][2])) / </span>
<span class="nc" id="L680">	      (m_modelNormal[i][j][2]);</span>
	    
<span class="nc bnc" id="L682" title="All 2 branches missed.">	    if (m_modelNormal[i][j][1] &lt; 0) {</span>
<span class="nc" id="L683">	      m_modelNormal[i][j][1] = 0;</span>
	    }
	    
	    // std dev      
<span class="nc bnc" id="L687" title="All 2 branches missed.">	    double minStdD = (m_minStdDevPerAtt != null)</span>
<span class="nc" id="L688">	    ? m_minStdDevPerAtt[j]</span>
<span class="nc" id="L689">	    : m_minStdDev;</span>

<span class="nc" id="L691">	    m_modelNormal[i][j][1] = Math.sqrt(m_modelNormal[i][j][1]);              </span>

<span class="nc bnc" id="L693" title="All 2 branches missed.">	    if ((m_modelNormal[i][j][1] &lt;= minStdD)) {</span>
<span class="nc" id="L694">	      m_modelNormal[i][j][1] = inst.attributeStats(j).numericStats.stdDev;</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">	      if ((m_modelNormal[i][j][1] &lt;= minStdD)) {</span>
<span class="nc" id="L696">		m_modelNormal[i][j][1] = minStdD;</span>
	      }
	    }
<span class="nc bnc" id="L699" title="All 2 branches missed.">	    if ((m_modelNormal[i][j][1] &lt;= 0)) {</span>
<span class="nc" id="L700">	      m_modelNormal[i][j][1] = m_minStdDev;</span>
	    }
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (Double.isInfinite(m_modelNormal[i][j][1])) {</span>
<span class="nc" id="L703">              m_modelNormal[i][j][1] = m_minStdDev;</span>
            }
	    
	    // mean
<span class="nc" id="L707">	    m_modelNormal[i][j][0] /= m_modelNormal[i][j][2];</span>
	  }
        }
      }
    }
<span class="nc" id="L712">  }</span>

  /**
   * The E step of the EM algorithm. Estimate cluster membership 
   * probabilities.
   *
   * @param inst the training instances
   * @param change_weights whether to change the weights
   * @return the average log likelihood
   * @throws Exception if computation fails
   */
  private double E (Instances inst, boolean change_weights)
    throws Exception {

<span class="nc" id="L726">    double loglk = 0.0, sOW = 0.0;</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">    for (int l = 0; l &lt; inst.numInstances(); l++) {</span>

<span class="nc" id="L730">      Instance in = inst.instance(l);</span>

<span class="nc" id="L732">      loglk += in.weight() * logDensityForInstance(in);</span>
<span class="nc" id="L733">      sOW += in.weight();</span>

<span class="nc bnc" id="L735" title="All 2 branches missed.">      if (change_weights) {</span>
<span class="nc" id="L736">	m_weights[l] = distributionForInstance(in);</span>
      }
    }
    
    // reestimate priors
    /*if (change_weights) {
      estimate_priors(inst);
    } */
<span class="nc" id="L744">    return  loglk / sOW;</span>
  }
  
  
  /**
   * Constructor.
   *
   **/
  public EM () {
<span class="fc" id="L753">    super();</span>
    
<span class="fc" id="L755">    m_SeedDefault = 100;</span>
<span class="fc" id="L756">    resetOptions();</span>
<span class="fc" id="L757">  }</span>


  /**
   * Reset to default options
   */
  protected void resetOptions () {
<span class="fc" id="L764">    m_minStdDev = 1e-6;</span>
<span class="fc" id="L765">    m_max_iterations = 100;</span>
<span class="fc" id="L766">    m_Seed = m_SeedDefault;</span>
<span class="fc" id="L767">    m_num_clusters = -1;</span>
<span class="fc" id="L768">    m_initialNumClusters = -1;</span>
<span class="fc" id="L769">    m_verbose = false;</span>
<span class="fc" id="L770">  }</span>

  /**
   * Return the normal distributions for the cluster models
   *
   * @return a &lt;code&gt;double[][][]&lt;/code&gt; value
   */
  public double [][][] getClusterModelsNumericAtts() {
<span class="nc" id="L778">    return m_modelNormal;</span>
  }

  /**
   * Return the priors for the clusters
   *
   * @return a &lt;code&gt;double[]&lt;/code&gt; value
   */
  public double [] getClusterPriors() {
<span class="nc" id="L787">    return m_priors;</span>
  }

  /**
   * Outputs the generated clusters into a string.
   * 
   * @return the clusterer in string representation
   */
  public String toString() {
<span class="nc bnc" id="L796" title="All 2 branches missed.">    if (m_displayModelInOldFormat) {</span>
<span class="nc" id="L797">      return toStringOriginal();</span>
    }

<span class="nc bnc" id="L800" title="All 2 branches missed.">    if (m_priors == null) {</span>
<span class="nc" id="L801">      return &quot;No clusterer built yet!&quot;;</span>
    }
<span class="nc" id="L803">    StringBuffer temp = new StringBuffer();</span>
<span class="nc" id="L804">    temp.append(&quot;\nEM\n==\n&quot;);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">    if (m_initialNumClusters == -1) {</span>
<span class="nc" id="L806">      temp.append(&quot;\nNumber of clusters selected by cross validation: &quot;</span>
<span class="nc" id="L807">		  +m_num_clusters+&quot;\n&quot;);</span>
    } else {
<span class="nc" id="L809">      temp.append(&quot;\nNumber of clusters: &quot; + m_num_clusters + &quot;\n&quot;);</span>
    }

<span class="nc" id="L812">    int maxWidth = 0;</span>
<span class="nc" id="L813">    int maxAttWidth = 0;</span>
<span class="nc" id="L814">    boolean containsKernel = false;</span>
    
    // set up max widths
    // attributes
<span class="nc bnc" id="L818" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_attribs; i++) {</span>
<span class="nc" id="L819">      Attribute a = m_theInstances.attribute(i);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">      if (a.name().length() &gt; maxAttWidth) {</span>
<span class="nc" id="L821">        maxAttWidth = m_theInstances.attribute(i).name().length();</span>
      }
<span class="nc bnc" id="L823" title="All 2 branches missed.">      if (a.isNominal()) {</span>
        // check values
<span class="nc bnc" id="L825" title="All 2 branches missed.">        for (int j = 0; j &lt; a.numValues(); j++) {</span>
<span class="nc" id="L826">          String val = a.value(j) + &quot;  &quot;;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">          if (val.length() &gt; maxAttWidth) {</span>
<span class="nc" id="L828">            maxAttWidth = val.length();</span>
          }
        }
      }
    }

<span class="nc bnc" id="L834" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">      for (int j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (m_theInstances.attribute(j).isNumeric()) {</span>
          // check mean and std. dev. against maxWidth
<span class="nc" id="L838">          double mean = Math.log(Math.abs(m_modelNormal[i][j][0])) / Math.log(10.0);</span>
<span class="nc" id="L839">          double stdD = Math.log(Math.abs(m_modelNormal[i][j][1])) / Math.log(10.0);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">          double width = (mean &gt; stdD)</span>
<span class="nc" id="L841">            ? mean</span>
<span class="nc" id="L842">            : stdD;</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">          if (width &lt; 0) {</span>
<span class="nc" id="L844">            width = 1;</span>
          }
          // decimal + # decimal places + 1
<span class="nc" id="L847">          width += 6.0;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">          if ((int)width &gt; maxWidth) {</span>
<span class="nc" id="L849">            maxWidth = (int)width;</span>
          }
        } else {
          // nominal distributions
<span class="nc" id="L853">          DiscreteEstimator d = (DiscreteEstimator)m_model[i][j];</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">          for (int k = 0; k &lt; d.getNumSymbols(); k++) {</span>
<span class="nc" id="L855">            String size = Utils.doubleToString(d.getCount(k), maxWidth, 4).trim();</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (size.length() &gt; maxWidth) {</span>
<span class="nc" id="L857">              maxWidth = size.length();</span>
            }
          }
<span class="nc" id="L860">          int sum = </span>
<span class="nc" id="L861">            Utils.doubleToString(d.getSumOfCounts(), maxWidth, 4).trim().length();</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">          if (sum &gt; maxWidth) {</span>
<span class="nc" id="L863">            maxWidth = sum;</span>
          }
        }
      }
    }

<span class="nc bnc" id="L869" title="All 2 branches missed.">    if (maxAttWidth &lt; &quot;Attribute&quot;.length()) {</span>
<span class="nc" id="L870">      maxAttWidth = &quot;Attribute&quot;.length();</span>
    }    
    
<span class="nc" id="L873">    maxAttWidth += 2;</span>

<span class="nc" id="L875">    temp.append(&quot;\n\n&quot;);</span>
<span class="nc" id="L876">    temp.append(pad(&quot;Cluster&quot;, &quot; &quot;, </span>
<span class="nc" id="L877">                    (maxAttWidth + maxWidth + 1) - &quot;Cluster&quot;.length(), </span>
<span class="nc" id="L878">                    true));</span>
    
<span class="nc" id="L880">    temp.append(&quot;\n&quot;);</span>
<span class="nc" id="L881">    temp.append(pad(&quot;Attribute&quot;, &quot; &quot;, maxAttWidth - &quot;Attribute&quot;.length(), false));</span>

    // cluster #'s
<span class="nc bnc" id="L884" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc" id="L885">      String classL = &quot;&quot; + i;</span>
<span class="nc" id="L886">      temp.append(pad(classL, &quot; &quot;, maxWidth + 1 - classL.length(), true));</span>
    }
<span class="nc" id="L888">    temp.append(&quot;\n&quot;);</span>

    // cluster priors
<span class="nc" id="L891">    temp.append(pad(&quot;&quot;, &quot; &quot;, maxAttWidth, true));</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_clusters; i++) {</span>
<span class="nc" id="L893">      String priorP = Utils.doubleToString(m_priors[i], maxWidth, 2).trim();</span>
<span class="nc" id="L894">      priorP = &quot;(&quot; + priorP + &quot;)&quot;;</span>
<span class="nc" id="L895">      temp.append(pad(priorP, &quot; &quot;, maxWidth + 1 - priorP.length(), true));</span>
    }

<span class="nc" id="L898">    temp.append(&quot;\n&quot;);</span>
<span class="nc" id="L899">    temp.append(pad(&quot;&quot;, &quot;=&quot;, maxAttWidth + </span>
<span class="nc" id="L900">                    (maxWidth * m_num_clusters)</span>
<span class="nc" id="L901">                    + m_num_clusters + 1, true));</span>
<span class="nc" id="L902">    temp.append(&quot;\n&quot;);</span>

<span class="nc bnc" id="L904" title="All 2 branches missed.">    for (int i = 0; i &lt; m_num_attribs; i++) {</span>
<span class="nc" id="L905">      String attName = m_theInstances.attribute(i).name();</span>
<span class="nc" id="L906">      temp.append(attName + &quot;\n&quot;);</span>

<span class="nc bnc" id="L908" title="All 2 branches missed.">      if (m_theInstances.attribute(i).isNumeric()) {</span>
<span class="nc" id="L909">        String meanL = &quot;  mean&quot;;</span>
<span class="nc" id="L910">        temp.append(pad(meanL, &quot; &quot;, maxAttWidth + 1 - meanL.length(), false));</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        for (int j = 0; j &lt; m_num_clusters; j++) {</span>
          // means
<span class="nc" id="L913">          String mean = </span>
<span class="nc" id="L914">            Utils.doubleToString(m_modelNormal[j][i][0], maxWidth, 4).trim();</span>
<span class="nc" id="L915">          temp.append(pad(mean, &quot; &quot;, maxWidth + 1 - mean.length(), true));</span>
        }
<span class="nc" id="L917">        temp.append(&quot;\n&quot;);            </span>
        // now do std deviations
<span class="nc" id="L919">        String stdDevL = &quot;  std. dev.&quot;;</span>
<span class="nc" id="L920">        temp.append(pad(stdDevL, &quot; &quot;, maxAttWidth + 1 - stdDevL.length(), false));</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        for (int j = 0; j &lt; m_num_clusters; j++) {</span>
<span class="nc" id="L922">          String stdDev = </span>
<span class="nc" id="L923">            Utils.doubleToString(m_modelNormal[j][i][1], maxWidth, 4).trim();</span>
<span class="nc" id="L924">          temp.append(pad(stdDev, &quot; &quot;, maxWidth + 1 - stdDev.length(), true));</span>
        }
<span class="nc" id="L926">        temp.append(&quot;\n\n&quot;);</span>
      } else {
<span class="nc" id="L928">        Attribute a = m_theInstances.attribute(i);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (int j = 0; j &lt; a.numValues(); j++) {</span>
<span class="nc" id="L930">          String val = &quot;  &quot; + a.value(j);</span>
<span class="nc" id="L931">          temp.append(pad(val, &quot; &quot;, maxAttWidth + 1 - val.length(), false));</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">          for (int k = 0; k &lt; m_num_clusters; k++) {</span>
<span class="nc" id="L933">            DiscreteEstimator d = (DiscreteEstimator)m_model[k][i];</span>
<span class="nc" id="L934">            String count = Utils.doubleToString(d.getCount(j), maxWidth, 4).trim();</span>
<span class="nc" id="L935">            temp.append(pad(count, &quot; &quot;, maxWidth + 1 - count.length(), true));</span>
          }
<span class="nc" id="L937">          temp.append(&quot;\n&quot;);</span>
        }
        // do the totals
<span class="nc" id="L940">        String total = &quot;  [total]&quot;;</span>
<span class="nc" id="L941">        temp.append(pad(total, &quot; &quot;, maxAttWidth + 1 - total.length(), false));</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        for (int k = 0; k &lt; m_num_clusters; k++) {</span>
<span class="nc" id="L943">          DiscreteEstimator d = (DiscreteEstimator)m_model[k][i];</span>
<span class="nc" id="L944">          String count = </span>
<span class="nc" id="L945">            Utils.doubleToString(d.getSumOfCounts(), maxWidth, 4).trim();</span>
<span class="nc" id="L946">            temp.append(pad(count, &quot; &quot;, maxWidth + 1 - count.length(), true));</span>
        }
<span class="nc" id="L948">        temp.append(&quot;\n&quot;);        </span>
      }
    }

<span class="nc" id="L952">    return temp.toString();</span>
  }

  private String pad(String source, String padChar, 
                     int length, boolean leftPad) {
<span class="nc" id="L957">    StringBuffer temp = new StringBuffer();</span>

<span class="nc bnc" id="L959" title="All 2 branches missed.">    if (leftPad) {</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">      for (int i = 0; i&lt; length; i++) {</span>
<span class="nc" id="L961">        temp.append(padChar);</span>
      }
<span class="nc" id="L963">      temp.append(source);</span>
    } else {
<span class="nc" id="L965">      temp.append(source);</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">      for (int i = 0; i&lt; length; i++) {</span>
<span class="nc" id="L967">        temp.append(padChar);</span>
      }
    }
<span class="nc" id="L970">    return temp.toString();</span>
  }

  /**
   * Outputs the generated clusters into a string.
   * 
   * @return the clusterer in string representation
   */
  protected String toStringOriginal () {
<span class="nc bnc" id="L979" title="All 2 branches missed.">    if (m_priors == null) {</span>
<span class="nc" id="L980">      return &quot;No clusterer built yet!&quot;;</span>
    }
<span class="nc" id="L982">    StringBuffer temp = new StringBuffer();</span>
<span class="nc" id="L983">    temp.append(&quot;\nEM\n==\n&quot;);</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">    if (m_initialNumClusters == -1) {</span>
<span class="nc" id="L985">      temp.append(&quot;\nNumber of clusters selected by cross validation: &quot;</span>
<span class="nc" id="L986">		  +m_num_clusters+&quot;\n&quot;);</span>
    } else {
<span class="nc" id="L988">      temp.append(&quot;\nNumber of clusters: &quot; + m_num_clusters + &quot;\n&quot;);</span>
    }

<span class="nc bnc" id="L991" title="All 2 branches missed.">    for (int j = 0; j &lt; m_num_clusters; j++) {</span>
<span class="nc" id="L992">      temp.append(&quot;\nCluster: &quot; + j + &quot; Prior probability: &quot; </span>
<span class="nc" id="L993">		  + Utils.doubleToString(m_priors[j], 4) + &quot;\n\n&quot;);</span>

<span class="nc bnc" id="L995" title="All 2 branches missed.">      for (int i = 0; i &lt; m_num_attribs; i++) {</span>
<span class="nc" id="L996">        temp.append(&quot;Attribute: &quot; + m_theInstances.attribute(i).name() + &quot;\n&quot;);</span>

<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (m_theInstances.attribute(i).isNominal()) {</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">          if (m_model[j][i] != null) {</span>
<span class="nc" id="L1000">            temp.append(m_model[j][i].toString());</span>
          }
        }
        else {
<span class="nc" id="L1004">          temp.append(&quot;Normal Distribution. Mean = &quot; </span>
<span class="nc" id="L1005">		      + Utils.doubleToString(m_modelNormal[j][i][0], 4) </span>
<span class="nc" id="L1006">		      + &quot; StdDev = &quot; </span>
<span class="nc" id="L1007">		      + Utils.doubleToString(m_modelNormal[j][i][1], 4) </span>
<span class="nc" id="L1008">		      + &quot;\n&quot;);</span>
        }
      }
    }

<span class="nc" id="L1013">    return  temp.toString();</span>
  }


  /**
   * verbose output for debugging
   * @param inst the training instances
   */
  private void EM_Report (Instances inst) {
    int i, j, l, m;
<span class="nc" id="L1023">    System.out.println(&quot;======================================&quot;);</span>

<span class="nc bnc" id="L1025" title="All 2 branches missed.">    for (j = 0; j &lt; m_num_clusters; j++) {</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">      for (i = 0; i &lt; m_num_attribs; i++) {</span>
<span class="nc" id="L1027">	System.out.println(&quot;Clust: &quot; + j + &quot; att: &quot; + i + &quot;\n&quot;);</span>

<span class="nc bnc" id="L1029" title="All 2 branches missed.">	if (m_theInstances.attribute(i).isNominal()) {</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">	  if (m_model[j][i] != null) {</span>
<span class="nc" id="L1031">	    System.out.println(m_model[j][i].toString());</span>
	  }
	}
	else {
<span class="nc" id="L1035">	  System.out.println(&quot;Normal Distribution. Mean = &quot; </span>
<span class="nc" id="L1036">			     + Utils.doubleToString(m_modelNormal[j][i][0]</span>
<span class="nc" id="L1037">						    , 8, 4) </span>
<span class="nc" id="L1038">			     + &quot; StandardDev = &quot; </span>
<span class="nc" id="L1039">			     + Utils.doubleToString(m_modelNormal[j][i][1]</span>
<span class="nc" id="L1040">						    , 8, 4) </span>
<span class="nc" id="L1041">			     + &quot; WeightSum = &quot; </span>
<span class="nc" id="L1042">			     + Utils.doubleToString(m_modelNormal[j][i][2]</span>
<span class="nc" id="L1043">						    , 8, 4));</span>
	}
      }
    }
    
<span class="nc bnc" id="L1048" title="All 2 branches missed.">    for (l = 0; l &lt; inst.numInstances(); l++) {</span>
<span class="nc" id="L1049">      m = Utils.maxIndex(m_weights[l]);</span>
<span class="nc" id="L1050">      System.out.print(&quot;Inst &quot; + Utils.doubleToString((double)l, 5, 0) </span>
<span class="nc" id="L1051">		       + &quot; Class &quot; + m + &quot;\t&quot;);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">      for (j = 0; j &lt; m_num_clusters; j++) {</span>
<span class="nc" id="L1053">	System.out.print(Utils.doubleToString(m_weights[l][j], 7, 5) + &quot;  &quot;);</span>
      }
<span class="nc" id="L1055">      System.out.println();</span>
    }
<span class="nc" id="L1057">  }</span>


  /**
   * estimate the number of clusters by cross validation on the training
   * data.
   *
   * @throws Exception if something goes wrong
   */
  private void CVClusters ()
    throws Exception {
<span class="nc" id="L1068">    double CVLogLikely = -Double.MAX_VALUE;</span>
    double templl, tll;
<span class="nc" id="L1070">    boolean CVincreased = true;</span>
<span class="nc" id="L1071">    m_num_clusters = 1;</span>
<span class="nc" id="L1072">    int num_clusters = m_num_clusters;</span>
    int i;
    Random cvr;
    Instances trainCopy;
<span class="nc bnc" id="L1076" title="All 2 branches missed.">    int numFolds = (m_theInstances.numInstances() &lt; 10) </span>
<span class="nc" id="L1077">      ? m_theInstances.numInstances() </span>
<span class="nc" id="L1078">      : 10;</span>

<span class="nc" id="L1080">    boolean ok = true;</span>
<span class="nc" id="L1081">    int seed = getSeed();</span>
<span class="nc" id="L1082">    int restartCount = 0;</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">    CLUSTER_SEARCH: while (CVincreased) {</span>
      // theInstances.stratify(10);
        
<span class="nc" id="L1086">      CVincreased = false;</span>
<span class="nc" id="L1087">      cvr = new Random(getSeed());</span>
<span class="nc" id="L1088">      trainCopy = new Instances(m_theInstances);</span>
<span class="nc" id="L1089">      trainCopy.randomize(cvr);</span>
<span class="nc" id="L1090">      templl = 0.0;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">      for (i = 0; i &lt; numFolds; i++) {</span>
<span class="nc" id="L1092">	Instances cvTrain = trainCopy.trainCV(numFolds, i, cvr);</span>
<span class="nc bnc" id="L1093" title="All 2 branches missed.">	if (num_clusters &gt; cvTrain.numInstances()) {</span>
<span class="nc" id="L1094">	  break CLUSTER_SEARCH;</span>
	}
<span class="nc" id="L1096">	Instances cvTest = trainCopy.testCV(numFolds, i);</span>
<span class="nc" id="L1097">	m_rr = new Random(seed);</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        for (int z=0; z&lt;10; z++) m_rr.nextDouble();</span>
<span class="nc" id="L1099">	m_num_clusters = num_clusters;</span>
<span class="nc" id="L1100">	EM_Init(cvTrain);</span>
	try {
<span class="nc" id="L1102">	  iterate(cvTrain, false);</span>
<span class="nc" id="L1103">	} catch (Exception ex) {</span>
	  // catch any problems - i.e. empty clusters occuring
<span class="nc" id="L1105">	  ex.printStackTrace();</span>
          //          System.err.println(&quot;Restarting after CV training failure (&quot;+num_clusters+&quot; clusters&quot;);
<span class="nc" id="L1107">          seed++;</span>
<span class="nc" id="L1108">          restartCount++;</span>
<span class="nc" id="L1109">          ok = false;</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">          if (restartCount &gt; 5) {</span>
<span class="nc" id="L1111">            break CLUSTER_SEARCH;</span>
          }
	  break;
	}
        try {
<span class="nc" id="L1116">          tll = E(cvTest, false);</span>
<span class="nc" id="L1117">        } catch (Exception ex) {</span>
          // catch any problems - i.e. empty clusters occuring
          //          ex.printStackTrace();
<span class="nc" id="L1120">          ex.printStackTrace();</span>
          //          System.err.println(&quot;Restarting after CV testing failure (&quot;+num_clusters+&quot; clusters&quot;);
          //          throw new Exception(ex); 
<span class="nc" id="L1123">          seed++;</span>
<span class="nc" id="L1124">          restartCount++;</span>
<span class="nc" id="L1125">          ok = false;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">          if (restartCount &gt; 5) {</span>
<span class="nc" id="L1127">            break CLUSTER_SEARCH;</span>
          }
          break;
        }

<span class="nc bnc" id="L1132" title="All 2 branches missed.">	if (m_verbose) {</span>
<span class="nc" id="L1133">	  System.out.println(&quot;# clust: &quot; + num_clusters + &quot; Fold: &quot; + i </span>
<span class="nc" id="L1134">			     + &quot; Loglikely: &quot; + tll);</span>
	}
<span class="nc" id="L1136">	templl += tll;</span>
      }

<span class="nc bnc" id="L1139" title="All 2 branches missed.">      if (ok) {</span>
<span class="nc" id="L1140">        restartCount = 0;</span>
<span class="nc" id="L1141">        seed = getSeed();</span>
<span class="nc" id="L1142">        templl /= (double)numFolds;</span>
        
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (m_verbose) {</span>
<span class="nc" id="L1145">          System.out.println(&quot;===================================&quot; </span>
                             + &quot;==============\n# clust: &quot; 
<span class="nc" id="L1147">                             + num_clusters </span>
<span class="nc" id="L1148">                             + &quot; Mean Loglikely: &quot; </span>
<span class="nc" id="L1149">                             + templl </span>
<span class="nc" id="L1150">                             + &quot;\n================================&quot; </span>
<span class="nc" id="L1151">                             + &quot;=================&quot;);</span>
        }
        
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (templl &gt; CVLogLikely) {</span>
<span class="nc" id="L1155">          CVLogLikely = templl;</span>
<span class="nc" id="L1156">          CVincreased = true;</span>
<span class="nc" id="L1157">          num_clusters++;</span>
        }
      }
    }

<span class="nc bnc" id="L1162" title="All 2 branches missed.">    if (m_verbose) {</span>
<span class="nc" id="L1163">      System.out.println(&quot;Number of clusters: &quot; + (num_clusters - 1));</span>
    }

<span class="nc" id="L1166">    m_num_clusters = num_clusters - 1;</span>
<span class="nc" id="L1167">  }</span>


  /**
   * Returns the number of clusters.
   *
   * @return the number of clusters generated for a training dataset.
   * @throws Exception if number of clusters could not be returned
   * successfully
   */
  public int numberOfClusters ()
    throws Exception {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">    if (m_num_clusters == -1) {</span>
<span class="nc" id="L1180">      throw  new Exception(&quot;Haven't generated any clusters!&quot;);</span>
    }

<span class="nc" id="L1183">    return  m_num_clusters;</span>
  }

 /**
  * Updates the minimum and maximum values for all the attributes
  * based on a new instance.
  *
  * @param instance the new instance
  */
  private void updateMinMax(Instance instance) {
    
<span class="nc bnc" id="L1194" title="All 2 branches missed.">    for (int j = 0; j &lt; m_theInstances.numAttributes(); j++) {</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">      if (!instance.isMissing(j)) {</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">	if (Double.isNaN(m_minValues[j])) {</span>
<span class="nc" id="L1197">	  m_minValues[j] = instance.value(j);</span>
<span class="nc" id="L1198">	  m_maxValues[j] = instance.value(j);</span>
	} else {
<span class="nc bnc" id="L1200" title="All 2 branches missed.">	  if (instance.value(j) &lt; m_minValues[j]) {</span>
<span class="nc" id="L1201">	    m_minValues[j] = instance.value(j);</span>
	  } else {
<span class="nc bnc" id="L1203" title="All 2 branches missed.">	    if (instance.value(j) &gt; m_maxValues[j]) {</span>
<span class="nc" id="L1204">	      m_maxValues[j] = instance.value(j);</span>
	    }
	  }
	}
      }
    }
<span class="nc" id="L1210">  }</span>

  /**
   * Returns default capabilities of the clusterer (i.e., the ones of 
   * SimpleKMeans).
   *
   * @return      the capabilities of this clusterer
   */
  public Capabilities getCapabilities() {
<span class="nc" id="L1219">    Capabilities result = new SimpleKMeans().getCapabilities();</span>
<span class="nc" id="L1220">    result.setOwner(this);</span>
<span class="nc" id="L1221">    return result;</span>
  }
  
  /**
   * Generates a clusterer. Has to initialize all fields of the clusterer
   * that are not being set via options.
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the clusterer has not been 
   * generated successfully
   */
  public void buildClusterer (Instances data)
    throws Exception {
    
    // can clusterer handle the data?
<span class="nc" id="L1236">    getCapabilities().testWithFail(data);</span>

<span class="nc" id="L1238">    m_replaceMissing = new ReplaceMissingValues();</span>
<span class="nc" id="L1239">    Instances instances = new Instances(data);</span>
<span class="nc" id="L1240">    instances.setClassIndex(-1);</span>
<span class="nc" id="L1241">    m_replaceMissing.setInputFormat(instances);</span>
<span class="nc" id="L1242">    data = weka.filters.Filter.useFilter(instances, m_replaceMissing);</span>
<span class="nc" id="L1243">    instances = null;</span>
    
<span class="nc" id="L1245">    m_theInstances = data;</span>

    // calculate min and max values for attributes
<span class="nc" id="L1248">    m_minValues = new double [m_theInstances.numAttributes()];</span>
<span class="nc" id="L1249">    m_maxValues = new double [m_theInstances.numAttributes()];</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">    for (int i = 0; i &lt; m_theInstances.numAttributes(); i++) {</span>
<span class="nc" id="L1251">      m_minValues[i] = m_maxValues[i] = Double.NaN;</span>
    }
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    for (int i = 0; i &lt; m_theInstances.numInstances(); i++) {</span>
<span class="nc" id="L1254">      updateMinMax(m_theInstances.instance(i));</span>
    }

<span class="nc" id="L1257">    doEM();</span>
    
    // save memory
<span class="nc" id="L1260">    m_theInstances = new Instances(m_theInstances,0);</span>
<span class="nc" id="L1261">  }</span>

  /**
   * Returns the cluster priors.
   * 
   * @return the cluster priors
   */
  public double[] clusterPriors() {

<span class="nc" id="L1270">    double[] n = new double[m_priors.length];</span>
  
<span class="nc" id="L1272">    System.arraycopy(m_priors, 0, n, 0, n.length);</span>
<span class="nc" id="L1273">    return n;</span>
  }

  /**
   * Computes the log of the conditional density (per cluster) for a given instance.
   * 
   * @param inst the instance to compute the density for
   * @return an array containing the estimated densities
   * @throws Exception if the density could not be computed
   * successfully
   */
  public double[] logDensityPerClusterForInstance(Instance inst) throws Exception {

    int i, j;
    double logprob;
<span class="nc" id="L1288">    double[] wghts = new double[m_num_clusters];</span>
    
<span class="nc" id="L1290">    m_replaceMissing.input(inst);</span>
<span class="nc" id="L1291">    inst = m_replaceMissing.output();</span>

<span class="nc bnc" id="L1293" title="All 2 branches missed.">    for (i = 0; i &lt; m_num_clusters; i++) {</span>
      //      System.err.println(&quot;Cluster : &quot;+i);
<span class="nc" id="L1295">      logprob = 0.0;</span>

<span class="nc bnc" id="L1297" title="All 2 branches missed.">      for (j = 0; j &lt; m_num_attribs; j++) {</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">	if (!inst.isMissing(j)) {</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">	  if (inst.attribute(j).isNominal()) {</span>
<span class="nc" id="L1300">	    logprob += Math.log(m_model[i][j].getProbability(inst.value(j)));</span>
	  }
	  else { // numeric attribute
<span class="nc" id="L1303">	    logprob += logNormalDens(inst.value(j), </span>
<span class="nc" id="L1304">				     m_modelNormal[i][j][0], </span>
<span class="nc" id="L1305">				     m_modelNormal[i][j][1]);</span>
	    /*	    System.err.println(logNormalDens(inst.value(j), 
				     m_modelNormal[i][j][0], 
				     m_modelNormal[i][j][1]) + &quot; &quot;); */
	  }
	}
      }
      //      System.err.println(&quot;&quot;);

<span class="nc" id="L1314">      wghts[i] = logprob;</span>
    }
<span class="nc" id="L1316">    return  wghts;</span>
  }


  /**
   * Perform the EM algorithm
   * 
   * @throws Exception if something goes wrong
   */
  private void doEM ()
    throws Exception {
    
<span class="nc bnc" id="L1328" title="All 2 branches missed.">    if (m_verbose) {</span>
<span class="nc" id="L1329">      System.out.println(&quot;Seed: &quot; + getSeed());</span>
    }

<span class="nc" id="L1332">    m_rr = new Random(getSeed());</span>

    // throw away numbers to avoid problem of similar initial numbers
    // from a similar seed
<span class="nc bnc" id="L1336" title="All 2 branches missed.">    for (int i=0; i&lt;10; i++) m_rr.nextDouble();</span>

<span class="nc" id="L1338">    m_num_instances = m_theInstances.numInstances();</span>
<span class="nc" id="L1339">    m_num_attribs = m_theInstances.numAttributes();</span>

<span class="nc bnc" id="L1341" title="All 2 branches missed.">    if (m_verbose) {</span>
<span class="nc" id="L1342">      System.out.println(&quot;Number of instances: &quot; </span>
<span class="nc" id="L1343">			 + m_num_instances </span>
<span class="nc" id="L1344">			 + &quot;\nNumber of atts: &quot; </span>
<span class="nc" id="L1345">			 + m_num_attribs </span>
<span class="nc" id="L1346">			 + &quot;\n&quot;);</span>
    }

    // setDefaultStdDevs(theInstances);
    // cross validate to determine number of clusters?
<span class="nc bnc" id="L1351" title="All 2 branches missed.">    if (m_initialNumClusters == -1) {</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">      if (m_theInstances.numInstances() &gt; 9) {</span>
<span class="nc" id="L1353">	CVClusters();</span>
<span class="nc" id="L1354">	m_rr = new Random(getSeed());</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">	for (int i=0; i&lt;10; i++) m_rr.nextDouble();</span>
      } else {
<span class="nc" id="L1357">	m_num_clusters = 1;</span>
      }
    }

    // fit full training set
<span class="nc" id="L1362">    EM_Init(m_theInstances);</span>
<span class="nc" id="L1363">    m_loglikely = iterate(m_theInstances, m_verbose);</span>
<span class="nc" id="L1364">  }</span>


  /**
   * iterates the E and M steps until the log likelihood of the data
   * converges.
   *
   * @param inst the training instances.
   * @param report be verbose.
   * @return the log likelihood of the data
   * @throws Exception if something goes wrong
   */
  private double iterate (Instances inst, boolean report)
    throws Exception {
    
    int i;
<span class="nc" id="L1380">    double llkold = 0.0;</span>
<span class="nc" id="L1381">    double llk = 0.0;</span>

<span class="nc bnc" id="L1383" title="All 2 branches missed.">    if (report) {</span>
<span class="nc" id="L1384">      EM_Report(inst);</span>
    }

<span class="nc" id="L1387">    boolean ok = false;</span>
<span class="nc" id="L1388">    int seed = getSeed();</span>
<span class="nc" id="L1389">    int restartCount = 0;</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">    while (!ok) {</span>
      try {
<span class="nc bnc" id="L1392" title="All 2 branches missed.">        for (i = 0; i &lt; m_max_iterations; i++) {</span>
<span class="nc" id="L1393">          llkold = llk;</span>
<span class="nc" id="L1394">          llk = E(inst, true);</span>
          
<span class="nc bnc" id="L1396" title="All 2 branches missed.">          if (report) {</span>
<span class="nc" id="L1397">            System.out.println(&quot;Loglikely: &quot; + llk);</span>
          }
          
<span class="nc bnc" id="L1400" title="All 2 branches missed.">          if (i &gt; 0) {</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">            if ((llk - llkold) &lt; 1e-6) {</span>
<span class="nc" id="L1402">              break;</span>
            }
          }
<span class="nc" id="L1405">          M(inst);</span>
        }
<span class="nc" id="L1407">        ok = true;</span>
<span class="nc" id="L1408">      } catch (Exception ex) {</span>
        //        System.err.println(&quot;Restarting after training failure&quot;);
<span class="nc" id="L1410">        ex.printStackTrace();</span>
<span class="nc" id="L1411">        seed++;</span>
<span class="nc" id="L1412">        restartCount++;</span>
<span class="nc" id="L1413">        m_rr = new Random(seed);</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">        for (int z = 0; z &lt; 10; z++) {</span>
<span class="nc" id="L1415">          m_rr.nextDouble(); m_rr.nextInt();</span>
        }
<span class="nc bnc" id="L1417" title="All 2 branches missed.">        if (restartCount &gt; 5) {</span>
          //          System.err.println(&quot;Reducing the number of clusters&quot;);
<span class="nc" id="L1419">          m_num_clusters--;</span>
<span class="nc" id="L1420">          restartCount = 0;</span>
        }
<span class="nc" id="L1422">        EM_Init(m_theInstances);</span>
      }
    }
      
<span class="nc bnc" id="L1426" title="All 2 branches missed.">    if (report) {</span>
<span class="nc" id="L1427">      EM_Report(inst);</span>
    }

<span class="nc" id="L1430">    return  llk;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1439">    return RevisionUtils.extract(&quot;$Revision: 6299 $&quot;);</span>
  }

  // ============
  // Test method.
  // ============
  /**
   * Main method for testing this class.
   *
   * @param argv should contain the following arguments: &lt;p&gt;
   * -t training file [-T test file] [-N number of clusters] [-S random seed]
   */
  public static void main (String[] argv) {
<span class="nc" id="L1452">    runClusterer(new EM(), argv);</span>
<span class="nc" id="L1453">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>