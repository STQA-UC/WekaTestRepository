<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>XMeans.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.clusterers</a> &gt; <span class="el_source">XMeans.java</span></div><h1>XMeans.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    XMeans.java
 *    Copyright (C) 2000 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.clusterers;

import weka.core.AlgVector;
import weka.core.Capabilities;
import weka.core.DistanceFunction;
import weka.core.EuclideanDistance;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.RevisionUtils;
import weka.core.neighboursearch.KDTree;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.ReplaceMissingValues;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Cluster data using the X-means algorithm.&lt;br/&gt;
 * &lt;br/&gt;
 * X-Means is K-Means extended by an Improve-Structure part In this part of the algorithm the centers are attempted to be split in its region. The decision between the children of each center and itself is done comparing the BIC-values of the two structures.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Dan Pelleg, Andrew W. Moore: X-means: Extending K-means with Efficient Estimation of the Number of Clusters. In: Seventeenth International Conference on Machine Learning, 727-734, 2000.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Pelleg2000,
 *    author = {Dan Pelleg and Andrew W. Moore},
 *    booktitle = {Seventeenth International Conference on Machine Learning},
 *    pages = {727-734},
 *    publisher = {Morgan Kaufmann},
 *    title = {X-means: Extending K-means with Efficient Estimation of the Number of Clusters},
 *    year = {2000}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -I &amp;lt;num&amp;gt;
 *  maximum number of overall iterations
 *  (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;num&amp;gt;
 *  maximum number of iterations in the kMeans loop in
 *  the Improve-Parameter part 
 *  (default 1000).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -J &amp;lt;num&amp;gt;
 *  maximum number of iterations in the kMeans loop
 *  for the splitted centroids in the Improve-Structure part 
 *  (default 1000).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L &amp;lt;num&amp;gt;
 *  minimum number of clusters
 *  (default 2).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H &amp;lt;num&amp;gt;
 *  maximum number of clusters
 *  (default 4).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -B &amp;lt;value&amp;gt;
 *  distance value for binary attributes
 *  (default 1.0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -use-kdtree
 *  Uses the KDTree internally
 *  (default no).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -K &amp;lt;KDTree class specification&amp;gt;
 *  Full class name of KDTree class to use, followed
 *  by scheme options.
 *  eg: &quot;weka.core.neighboursearch.kdtrees.KDTree -P&quot;
 *  (default no KDTree class used).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;value&amp;gt;
 *  cutoff factor, takes the given percentage of the splitted 
 *  centroids if none of the children win
 *  (default 0.0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D &amp;lt;distance function class specification&amp;gt;
 *  Full class name of Distance function class to use, followed
 *  by scheme options.
 *  (default weka.core.EuclideanDistance).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;file name&amp;gt;
 *  file to read starting centers from (ARFF format).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -O &amp;lt;file name&amp;gt;
 *  file to write centers to (ARFF format).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -U &amp;lt;int&amp;gt;
 *  The debug level.
 *  (default 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -Y &amp;lt;file name&amp;gt;
 *  The debug vectors file.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;num&amp;gt;
 *  Random number seed.
 *  (default 10)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Gabi Schmidberger (gabi@cs.waikato.ac.nz)
 * @author Mark Hall (mhall@cs.waikato.ac.nz)
 * @author Malcolm Ware (mfw4@cs.waikato.ac.nz)
 * @version $Revision: 7135 $
 * @see RandomizableClusterer
 */
<span class="fc" id="L155">public class XMeans </span>
  extends RandomizableClusterer
  implements TechnicalInformationHandler {

  /*
   * major TODOS:
   *
   * make BIC-Score replaceable by other scores
   */

  /** for serialization. */
  private static final long serialVersionUID = -7941793078404132616L;
  
  /** training instances. */
<span class="nc" id="L169">  protected Instances m_Instances = null;</span>

  /** model information, should increase readability. */
<span class="nc" id="L172">  protected Instances m_Model = null;</span>
  
  /** replace missing values in training instances. */
  protected ReplaceMissingValues m_ReplaceMissingFilter;

  /**
   * Distance value between true and false of binary attributes and 
   * &quot;same&quot; and &quot;different&quot; of nominal attributes (default = 1.0).
   */
<span class="nc" id="L181">  protected double m_BinValue = 1.0;</span>

  /** BIC-Score of the current model. */
<span class="nc" id="L184">  protected double m_Bic = Double.MIN_VALUE;</span>

  /** Distortion.  */
<span class="nc" id="L187">  protected double[] m_Mle = null;</span>

  /** maximum overall iterations. */
<span class="nc" id="L190">  protected int m_MaxIterations = 1;</span>

  /**
   * maximum iterations to perform Kmeans part 
   * if negative, iterations are not checked.
   */
<span class="nc" id="L196">  protected int m_MaxKMeans = 1000;</span>

  /** see above, but for kMeans of splitted clusters.
   */
<span class="nc" id="L200">  protected int m_MaxKMeansForChildren = 1000;</span>

  /** The actual number of clusters. */
<span class="nc" id="L203">  protected int m_NumClusters = 2;</span>

  /** min number of clusters to generate. */
<span class="nc" id="L206">  protected int m_MinNumClusters = 2;</span>

  /** max number of clusters to generate. */
<span class="nc" id="L209">  protected int m_MaxNumClusters = 4;</span>

  /** the distance function used. */
<span class="nc" id="L212">  protected DistanceFunction m_DistanceF = new EuclideanDistance();</span>

  /** cluster centers. */
  protected Instances m_ClusterCenters;

  /** file name of the output file for the cluster centers. */
<span class="nc" id="L218">  protected File m_InputCenterFile = new File(System.getProperty(&quot;user.dir&quot;));</span>

  /* --&gt; DebugVectors - USED FOR DEBUGGING */
  /** input file for the random vectors --&gt; USED FOR DEBUGGING. */
<span class="nc" id="L222">  protected Reader m_DebugVectorsInput = null;</span>
  /** the index for the current debug vector. */
<span class="nc" id="L224">  protected int m_DebugVectorsIndex = 0;</span>
  /** all the debug vectors. */
<span class="nc" id="L226">  protected Instances m_DebugVectors = null;</span>

  /** file name of the input file for the random vectors. */
<span class="nc" id="L229">  protected File m_DebugVectorsFile = new File(System.getProperty(&quot;user.dir&quot;));</span>

  /** input file for the cluster centers. */
<span class="nc" id="L232">  protected Reader m_CenterInput = null;</span>
    
  /** file name of the output file for the cluster centers. */
<span class="nc" id="L235">  protected File m_OutputCenterFile = new File(System.getProperty(&quot;user.dir&quot;));</span>
  
  /** output file for the cluster centers. */
<span class="nc" id="L238">  protected PrintWriter m_CenterOutput = null;</span>
    
  /**
   * temporary variable holding cluster assignments while iterating.
   */
  protected int[] m_ClusterAssignments;

  /** cutoff factor - percentage of splits done in Improve-Structure part
     only relevant, if all children lost. */ 
<span class="nc" id="L247">  protected double m_CutOffFactor = 0.5;</span>

  /** Index in ranges for LOW. */
<span class="fc" id="L250">  public static int R_LOW = 0;</span>
  /** Index in ranges for HIGH. */
<span class="fc" id="L252">  public static int R_HIGH = 1;</span>
  /** Index in ranges for WIDTH. */
<span class="fc" id="L254">  public static int R_WIDTH = 2;</span>

  /**
   * KDTrees class if KDTrees are used.
   */
<span class="nc" id="L259">  protected KDTree m_KDTree = new KDTree();</span>
  
  /** whether to use the KDTree (the KDTree is only initialized to be 
   * configurable from the GUI). */
<span class="nc" id="L263">  protected boolean m_UseKDTree = false;</span>

  /** counts iterations done in main loop. */
<span class="nc" id="L266">  protected int m_IterationCount = 0;</span>

  /** counter to say how often kMeans was stopped by loop counter. */
<span class="nc" id="L269">  protected int m_KMeansStopped = 0;</span>

  /** Number of splits prepared. */
<span class="nc" id="L272">  protected int m_NumSplits = 0;</span>

  /** Number of splits accepted (including cutoff factor decisions). */
<span class="nc" id="L275">  protected int m_NumSplitsDone = 0;</span>

  /** Number of splits accepted just because of cutoff factor. */
<span class="nc" id="L278">  protected int m_NumSplitsStillDone = 0;</span>

  /**
   * level of debug output, 0 is no output.
   */
<span class="nc" id="L283">  protected int m_DebugLevel = 0;</span>
  
  /** print the centers. */
<span class="fc" id="L286">  public static int D_PRINTCENTERS = 1;</span>
  /** follows the splitting of the centers. */
<span class="fc" id="L288">  public static int D_FOLLOWSPLIT = 2;</span>
  /** have a closer look at converge children. */
<span class="fc" id="L290">  public static int D_CONVCHCLOSER = 3;</span>
  /** check on random vectors. */
<span class="fc" id="L292">  public static int D_RANDOMVECTOR = 4;</span>
  /** check on kdtree. */
<span class="fc" id="L294">  public static int D_KDTREE = 5;</span>
  /** follow iterations. */
<span class="fc" id="L296">  public static int D_ITERCOUNT = 6;</span>
  /** functions were maybe misused.  */
<span class="fc" id="L298">  public static int D_METH_MISUSE = 80; </span>
  /** for current debug.  */
<span class="fc" id="L300">  public static int D_CURR = 88;</span>
  /** general debugging. */
<span class="fc" id="L302">  public static int D_GENERAL = 99;</span>

  /** Flag: I'm debugging. */
<span class="nc" id="L305">  public boolean m_CurrDebugFlag = true;</span>

  /**
   * the default constructor.
   */
  public XMeans() {
<span class="nc" id="L311">    super();</span>
    
<span class="nc" id="L313">    m_SeedDefault = 10;</span>
<span class="nc" id="L314">    setSeed(m_SeedDefault);</span>
<span class="nc" id="L315">  }</span>
  
  /**
   * Returns a string describing this clusterer.
   * @return a description of the evaluator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L323">    return </span>
<span class="nc" id="L324">        &quot;Cluster data using the X-means algorithm.\n\n&quot; </span>
      + &quot;X-Means is K-Means extended by an Improve-Structure part In this &quot;
      + &quot;part of the algorithm the centers are attempted to be split in &quot;
      + &quot;its region. The decision between the children of each center and &quot;
      + &quot;itself is done comparing the BIC-values of the two structures.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L330">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L343">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L344">    result.setValue(Field.AUTHOR, &quot;Dan Pelleg and Andrew W. Moore&quot;);</span>
<span class="nc" id="L345">    result.setValue(Field.TITLE, &quot;X-means: Extending K-means with Efficient Estimation of the Number of Clusters&quot;);</span>
<span class="nc" id="L346">    result.setValue(Field.BOOKTITLE, &quot;Seventeenth International Conference on Machine Learning&quot;);</span>
<span class="nc" id="L347">    result.setValue(Field.YEAR, &quot;2000&quot;);</span>
<span class="nc" id="L348">    result.setValue(Field.PAGES, &quot;727-734&quot;);</span>
<span class="nc" id="L349">    result.setValue(Field.PUBLISHER, &quot;Morgan Kaufmann&quot;);</span>
    
<span class="nc" id="L351">    return result;</span>
  }

  /**
   * Returns default capabilities of the clusterer.
   *
   * @return      the capabilities of this clusterer
   */
  public Capabilities getCapabilities() {
<span class="nc" id="L360">    Capabilities result = super.getCapabilities();</span>
<span class="nc" id="L361">    result.disableAll();</span>
<span class="nc" id="L362">    result.enable(Capability.NO_CLASS);</span>

    // attributes
<span class="nc" id="L365">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="nc" id="L366">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="nc" id="L367">    result.enable(Capability.MISSING_VALUES);</span>

<span class="nc" id="L369">    return result;</span>
  }
 
  /**
   * Generates the X-Means clusterer. 
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the clusterer has not been 
   * generated successfully
   */
  public void buildClusterer(Instances data) throws Exception {

    // can clusterer handle the data?
<span class="nc" id="L382">    getCapabilities().testWithFail(data);</span>
    
<span class="nc bnc" id="L384" title="All 2 branches missed.">    if (m_MinNumClusters &gt; m_MaxNumClusters) {</span>
<span class="nc" id="L385">      throw new Exception(&quot;XMeans: min number of clusters &quot;</span>
          + &quot;can't be greater than max number of clusters!&quot;);
    }

<span class="nc" id="L389">    m_NumSplits = 0;</span>
<span class="nc" id="L390">    m_NumSplitsDone = 0;</span>
<span class="nc" id="L391">    m_NumSplitsStillDone = 0;</span>

    // replace missing values
<span class="nc" id="L394">    m_ReplaceMissingFilter = new ReplaceMissingValues();</span>
<span class="nc" id="L395">    m_ReplaceMissingFilter.setInputFormat(data);</span>
<span class="nc" id="L396">    m_Instances = Filter.useFilter(data, m_ReplaceMissingFilter);</span>
    
    // initialize random function
<span class="nc" id="L399">    Random random0 = new Random(m_Seed);</span>

    // num of clusters to start with
<span class="nc" id="L402">    m_NumClusters =  m_MinNumClusters;</span>

    // set distance function to default
<span class="nc bnc" id="L405" title="All 2 branches missed.">    if (m_DistanceF == null) {</span>
<span class="nc" id="L406">      m_DistanceF = new EuclideanDistance();</span>
    }

<span class="nc" id="L409">    m_DistanceF.setInstances(m_Instances);</span>
<span class="nc" id="L410">    checkInstances();</span>

<span class="nc bnc" id="L412" title="All 4 branches missed.">    if (m_DebugVectorsFile.exists() &amp;&amp; m_DebugVectorsFile.isFile())</span>
<span class="nc" id="L413">      initDebugVectorsInput();</span>

    // make list of indexes for m_Instances
<span class="nc" id="L416">    int[] allInstList = new int[m_Instances.numInstances()]; </span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">    for (int i = 0; i &lt; m_Instances.numInstances(); i++) {</span>
<span class="nc" id="L418">      allInstList[i] = i;</span>
    }
    
    // set model used (just for convenience)
<span class="nc" id="L422">    m_Model = new Instances(m_Instances, 0);</span>

    // produce the starting centers
<span class="nc bnc" id="L425" title="All 2 branches missed.">    if (m_CenterInput != null) {</span>
      // read centers from file
<span class="nc" id="L427">      m_ClusterCenters = new Instances(m_CenterInput);</span>
<span class="nc" id="L428">      m_NumClusters = m_ClusterCenters.numInstances();</span>
    }
    else
      // makes the first centers randomly
<span class="nc" id="L432">      m_ClusterCenters = makeCentersRandomly(random0,</span>
<span class="nc" id="L433">					     m_Instances, m_NumClusters);</span>
<span class="nc" id="L434">    PFD(D_FOLLOWSPLIT, &quot;\n*** Starting centers &quot;);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">    for (int k = 0; k &lt; m_ClusterCenters.numInstances(); k++) {</span>
<span class="nc" id="L436">      PFD(D_FOLLOWSPLIT, &quot;Center &quot; + k + &quot;: &quot; + m_ClusterCenters.instance(k));</span>
    }

<span class="nc" id="L439">    PrCentersFD(D_PRINTCENTERS);</span>

<span class="nc" id="L441">    boolean finished = false;</span>
    Instances children; 

    // builds up a KDTree
<span class="nc bnc" id="L445" title="All 2 branches missed.">    if (m_UseKDTree)</span>
<span class="nc" id="L446">      m_KDTree.setInstances(m_Instances);</span>
  
    // loop counter of main loop
<span class="nc" id="L449">    m_IterationCount = 0;</span>

    /**
     * &quot;finished&quot; does get true as soon as:
     * 1. number of clusters gets &gt;= m_MaxClusters, 
     * 2. in the last round, none of the centers have been split
     * 
     * if number of clusters is already &gt;= m_MaxClusters 
     * part 1 (= Improve-Params) is done at least once.
     */
<span class="nc bnc" id="L459" title="All 4 branches missed.">    while (!finished &amp;&amp;</span>
<span class="nc" id="L460">           !stopIteration(m_IterationCount, m_MaxIterations)) {</span>
      
      /* ====================================================================
       * 1. Improve-Params                  
       *    conventional K-means
       */


<span class="nc" id="L468">      PFD(D_FOLLOWSPLIT, &quot;\nBeginning of main loop - centers:&quot;);</span>
<span class="nc" id="L469">      PrCentersFD(D_FOLLOWSPLIT);</span>

<span class="nc" id="L471">      PFD(D_ITERCOUNT, &quot;\n*** 1. Improve-Params &quot; + m_IterationCount + </span>
<span class="nc" id="L472">	  &quot;. time&quot;);</span>
<span class="nc" id="L473">      m_IterationCount++;</span>

      // prepare to converge
<span class="nc" id="L476">      boolean converged = false;</span>

      // initialize assignments to -1
<span class="nc" id="L479">      m_ClusterAssignments = initAssignments(m_Instances.numInstances());</span>
      // stores a list of indexes of instances belonging to each center
<span class="nc" id="L481">      int[][] instOfCent = new int[m_ClusterCenters.numInstances()][];</span>

      // KMeans loop counter
<span class="nc" id="L484">      int kMeansIteration = 0;</span>

      // converge in conventional K-means ----------------------------------
<span class="nc" id="L487">      PFD(D_FOLLOWSPLIT, &quot;\nConverge in K-Means:&quot;);</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">      while (!converged &amp;&amp; </span>
<span class="nc" id="L489">	     !stopKMeansIteration(kMeansIteration, m_MaxKMeans)) {</span>
	
<span class="nc" id="L491">	kMeansIteration++;</span>
<span class="nc" id="L492">	converged = true;</span>
	
        // assign instances to centers -------------------------------------
<span class="nc bnc" id="L495" title="All 2 branches missed.">        converged = assignToCenters(m_UseKDTree ? m_KDTree : null,</span>
<span class="nc" id="L496">				    m_ClusterCenters, </span>
<span class="nc" id="L497">				    instOfCent,</span>
<span class="nc" id="L498">				    allInstList, </span>
<span class="nc" id="L499">				    m_ClusterAssignments,</span>
<span class="nc" id="L500">				    kMeansIteration);</span>
	
<span class="nc" id="L502">	PFD(D_FOLLOWSPLIT, &quot;\nMain loop - Assign - centers:&quot;);</span>
<span class="nc" id="L503">	PrCentersFD(D_FOLLOWSPLIT);</span>
	// compute new centers = centers of mass of points
<span class="nc" id="L505">        converged = recomputeCenters(m_ClusterCenters, // clusters</span>
<span class="nc" id="L506">				     instOfCent,       // their instances</span>
<span class="nc" id="L507">				     m_Model);         // model information</span>
<span class="nc" id="L508">      PFD(D_FOLLOWSPLIT, &quot;\nMain loop - Recompute - centers:&quot;);</span>
<span class="nc" id="L509">      PrCentersFD(D_FOLLOWSPLIT);</span>
      }
<span class="nc" id="L511">      PFD(D_FOLLOWSPLIT, &quot;&quot;);</span>
<span class="nc" id="L512">      PFD(D_FOLLOWSPLIT, &quot;End of Part: 1. Improve-Params - conventional K-means&quot;);</span>

      /** =====================================================================
       * 2. Improve-Structur
       */

      // BIC before split distortioning the centres
<span class="nc" id="L519">      m_Mle = distortion(instOfCent, m_ClusterCenters);</span>
<span class="nc" id="L520">      m_Bic = calculateBIC(instOfCent, m_ClusterCenters, m_Mle);</span>
<span class="nc" id="L521">      PFD(D_FOLLOWSPLIT, &quot;m_Bic &quot; + m_Bic);</span>

<span class="nc" id="L523">      int currNumCent = m_ClusterCenters.numInstances();</span>
<span class="nc" id="L524">      Instances splitCenters = new Instances(m_ClusterCenters, </span>
<span class="nc" id="L525">					     currNumCent * 2);</span>
      
      // store BIC values of parent and children
<span class="nc" id="L528">      double[] pbic = new double [currNumCent];</span>
<span class="nc" id="L529">      double[] cbic = new double [currNumCent];</span>
            
      // split each center
<span class="nc bnc" id="L532" title="All 2 branches missed.">      for (int i = 0; i &lt; currNumCent </span>
	   // this could help to optimize the algorithm
	   //	     &amp;&amp; currNumCent + numSplits &lt;= m_MaxNumClusters
           ; 
<span class="nc" id="L536">	   i++) {</span>
	
<span class="nc" id="L538">	PFD(D_FOLLOWSPLIT, &quot;\nsplit center &quot; + i +</span>
<span class="nc" id="L539">		      &quot; &quot; + m_ClusterCenters.instance(i));</span>
<span class="nc" id="L540">	Instance currCenter = m_ClusterCenters.instance(i);</span>
<span class="nc" id="L541">	int[] currInstList = instOfCent[i];</span>
<span class="nc" id="L542">	int currNumInst = instOfCent[i].length;</span>
	
	// not enough instances; than continue with next
<span class="nc bnc" id="L545" title="All 2 branches missed.">	if (currNumInst &lt;= 2) {</span>
<span class="nc" id="L546">	  pbic[i] = Double.MAX_VALUE;</span>
<span class="nc" id="L547">	  cbic[i] = 0.0;</span>
	  // add center itself as dummy
<span class="nc" id="L549">	  splitCenters.add(currCenter);</span>
<span class="nc" id="L550">	  splitCenters.add(currCenter);</span>
<span class="nc" id="L551">	  continue;</span>
	}
	
	// split centers  ----------------------------------------------
<span class="nc" id="L555">	double variance = m_Mle[i] / (double)currNumInst;</span>
<span class="nc" id="L556">	children = splitCenter(random0, currCenter, variance, m_Model);</span>
	
	// initialize assignments to -1
<span class="nc" id="L559">	int[] oneCentAssignments = initAssignments(currNumInst);</span>
<span class="nc" id="L560">	int[][] instOfChCent = new int [2][]; // todo maybe split didn't work</span>
	
	// converge the children  --------------------------------------
<span class="nc" id="L563">	converged = false;</span>
<span class="nc" id="L564">	int kMeansForChildrenIteration = 0;</span>
<span class="nc" id="L565">	PFD(D_FOLLOWSPLIT, &quot;\nConverge, K-Means for children: &quot; + i);</span>
<span class="nc bnc" id="L566" title="All 4 branches missed.">	while (!converged &amp;&amp; </span>
<span class="nc" id="L567">          !stopKMeansIteration(kMeansForChildrenIteration, </span>
<span class="nc" id="L568">			       m_MaxKMeansForChildren)) {</span>
<span class="nc" id="L569">	  kMeansForChildrenIteration++;</span>
	  
<span class="nc" id="L571">	  converged =</span>
<span class="nc" id="L572">	    assignToCenters(children, instOfChCent,</span>
<span class="nc" id="L573">			    currInstList, oneCentAssignments);</span>

<span class="nc bnc" id="L575" title="All 2 branches missed.">	  if (!converged) {       </span>
<span class="nc" id="L576">	    recomputeCentersFast(children, instOfChCent, m_Model);</span>
	  }
	} 

	// store new centers for later decision if they are taken
<span class="nc" id="L581">	splitCenters.add(children.instance(0));</span>
<span class="nc" id="L582">	splitCenters.add(children.instance(1));</span>

<span class="nc" id="L584">	PFD(D_FOLLOWSPLIT, &quot;\nconverged cildren &quot;);</span>
<span class="nc" id="L585">	PFD(D_FOLLOWSPLIT, &quot; &quot; + children.instance(0));</span>
<span class="nc" id="L586">	PFD(D_FOLLOWSPLIT, &quot; &quot; + children.instance(1));</span>

	// compare parent and children model by their BIC-value
<span class="nc" id="L589">	pbic[i] = calculateBIC(currInstList, currCenter,  m_Mle[i], m_Model);</span>
<span class="nc" id="L590">	double[] chMLE = distortion(instOfChCent, children);</span>
<span class="nc" id="L591">	cbic[i] = calculateBIC(instOfChCent, children, chMLE);</span>

      } // end of loop over clusters

      // decide which one to split and make new list of cluster centers
<span class="nc" id="L596">      Instances newClusterCenters = null;</span>
<span class="nc" id="L597">      newClusterCenters = newCentersAfterSplit(pbic, cbic, m_CutOffFactor,</span>
<span class="nc" id="L598">                                                 splitCenters);</span>
      /**
       * Compare with before Improve-Structure
       */
<span class="nc" id="L602">      int newNumClusters = newClusterCenters.numInstances();</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">      if (newNumClusters != m_NumClusters) {</span>
	
<span class="nc" id="L605">	PFD(D_FOLLOWSPLIT, &quot;Compare with non-split&quot;);</span>

	// initialize assignments to -1
<span class="nc" id="L608">	int[] newClusterAssignments = </span>
<span class="nc" id="L609">	  initAssignments(m_Instances.numInstances());</span>
	
	// stores a list of indexes of instances belonging to each center
<span class="nc" id="L612">	int[][] newInstOfCent = new int[newClusterCenters.numInstances()][];</span>
	
	// assign instances to centers -------------------------------------
<span class="nc bnc" id="L615" title="All 2 branches missed.">	converged = assignToCenters(m_UseKDTree ? m_KDTree : null,</span>
<span class="nc" id="L616">				    newClusterCenters, </span>
<span class="nc" id="L617">				    newInstOfCent,</span>
<span class="nc" id="L618">				    allInstList, </span>
<span class="nc" id="L619">				    newClusterAssignments,</span>
<span class="nc" id="L620">				    m_IterationCount);</span>
	
<span class="nc" id="L622">	double[] newMle = distortion(newInstOfCent, newClusterCenters);</span>
<span class="nc" id="L623">	double newBic = calculateBIC(newInstOfCent, newClusterCenters, newMle);</span>
<span class="nc" id="L624">	PFD(D_FOLLOWSPLIT, &quot;newBic &quot; + newBic);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">	if (newBic &gt; m_Bic) {</span>
<span class="nc" id="L626">          PFD(D_FOLLOWSPLIT, &quot;*** decide for new clusters&quot;);</span>
<span class="nc" id="L627">	  m_Bic = newBic;</span>
<span class="nc" id="L628">	  m_ClusterCenters = newClusterCenters;</span>
<span class="nc" id="L629">	  m_ClusterAssignments = newClusterAssignments;</span>
	} else {
<span class="nc" id="L631">          PFD(D_FOLLOWSPLIT, &quot;*** keep old clusters&quot;);</span>
        }
      }

<span class="nc" id="L635">      newNumClusters = m_ClusterCenters.numInstances();</span>
      // decide if finished: max num cluster reached 
      // or last centers where not split at all 
<span class="nc bnc" id="L638" title="All 2 branches missed.">      if ((newNumClusters &gt;= m_MaxNumClusters) </span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">	  || (newNumClusters == m_NumClusters)) {</span>
<span class="nc" id="L640">	finished = true;</span>
      }
<span class="nc" id="L642">      m_NumClusters = newNumClusters;</span>
    }
<span class="nc" id="L644">  }</span>

  /**
   * Checks for nominal attributes in the dataset.
   * Class attribute is ignored.
   * @param data the data to check
   * @return false if no nominal attributes are present
   */
  public boolean checkForNominalAttributes(Instances data) {

<span class="nc" id="L654">    int i = 0;</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">    while (i &lt; data.numAttributes()) {</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">      if ((i != data.classIndex()) &amp;&amp; data.attribute(i++).isNominal()) {</span>
<span class="nc" id="L657">	return true;</span>
      }
    }
<span class="nc" id="L660">    return false;</span>
  }

  /**
   * Set array of int, used to store assignments, to -1.
   * @param ass integer array used for storing assignments
   * @return integer array used for storing assignments
   */
  protected int[] initAssignments(int[] ass) {
<span class="nc bnc" id="L669" title="All 2 branches missed.">    for (int i = 0; i &lt; ass.length; i++)</span>
<span class="nc" id="L670">      ass[i] = -1;</span>
<span class="nc" id="L671">    return ass;</span>
  }    
 
  /**
   * Creates and initializes integer array, used to store assignments.
   * @param numInstances length of array used for assignments
   * @return integer array used for storing assignments
   */
  protected int[] initAssignments(int numInstances) {
<span class="nc" id="L680">    int[] ass = new int[numInstances];</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">    for (int i = 0; i &lt; numInstances; i++)</span>
<span class="nc" id="L682">      ass[i] = -1;</span>
<span class="nc" id="L683">    return ass;</span>
  }    
  
  /**
   * Creates and initializes boolean array.
   * @param len length of new array
   * @return the new array
   */
  boolean[] initBoolArray(int len) {
<span class="nc" id="L692">    boolean[] boolArray = new boolean [len];</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">    for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L694">      boolArray[i] = false;</span>
    }
<span class="nc" id="L696">    return boolArray;</span>
  }

  /**
   * Returns new center list.
   *
   * The following steps 1. and 2. both take care that the number of centers
   * does not exceed maxCenters.
   *
   * 1. Compare BIC values of parent and children and takes the one as
   * new centers which do win (= BIC-value is smaller).
   *
   * 2. If in 1. none of the children are chosen 
   *    &amp;&amp; and cutoff factor is &gt; 0
   * cutoff factor is taken as the percentage of &quot;best&quot; centers that are
   * still taken.
   * @param pbic array of parents BIC-values
   * @param cbic array of childrens BIC-values
   * @param cutoffFactor cutoff factor 
   * @param splitCenters all children 
   * @return the new centers
   */
  protected Instances newCentersAfterSplit(double[] pbic, 
					 double[] cbic,
					 double cutoffFactor,
					 Instances splitCenters) {

    // store if split won
<span class="nc" id="L724">    boolean splitPerCutoff = false;</span>
<span class="nc" id="L725">    boolean takeSomeAway = false;</span>
<span class="nc" id="L726">    boolean[] splitWon = initBoolArray(m_ClusterCenters.numInstances());</span>
<span class="nc" id="L727">    int numToSplit = 0;</span>
<span class="nc" id="L728">    Instances newCenters = null;</span>
    
    // how many would be split, because the children have a better bic value
<span class="nc bnc" id="L731" title="All 2 branches missed.">    for (int i = 0; i &lt; cbic.length; i++) {</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">      if (cbic[i] &gt; pbic[i]) {</span>
	// decide for splitting ----------------------------------------
<span class="nc" id="L734">	splitWon[i] = true; numToSplit++;</span>
<span class="nc" id="L735">	PFD(D_FOLLOWSPLIT, &quot;Center &quot; + i + &quot; decide for children&quot;);</span>
      }
      else {
	// decide for parents and finished stays true  -----------------
<span class="nc" id="L739">	PFD(D_FOLLOWSPLIT, &quot;Center &quot; + i + &quot; decide for parent&quot;);</span>
      }
    }

    // no splits yet so split per cutoff factor
<span class="nc bnc" id="L744" title="All 4 branches missed.">    if ((numToSplit == 0) &amp;&amp; (cutoffFactor &gt; 0)) {</span>
<span class="nc" id="L745">      splitPerCutoff = true;</span>
      
      // how many to split per cutoff factor
<span class="nc" id="L748">      numToSplit = (int) </span>
<span class="nc" id="L749">        ((double) m_ClusterCenters.numInstances() * m_CutOffFactor); </span>
    }

    // prepare indexes of values in ascending order  
<span class="nc" id="L753">    double[] diff = new double [m_NumClusters];</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">    for (int j = 0; j &lt; diff.length; j++) {</span>
<span class="nc" id="L755">      diff[j] = pbic[j] - cbic[j];</span>
    }    
<span class="nc" id="L757">    int[] sortOrder = Utils.sort(diff);</span>
    
    // check if maxNumClusters would be exceeded
<span class="nc" id="L760">    int possibleToSplit = m_MaxNumClusters - m_NumClusters; </span>

<span class="nc bnc" id="L762" title="All 2 branches missed.">    if (possibleToSplit &gt; numToSplit) {</span>
      // still enough possible, do the whole amount
<span class="nc" id="L764">      possibleToSplit = numToSplit;</span>
    }
    else
<span class="nc" id="L767">      takeSomeAway = true;</span>

    // prepare for splitting the one that are supposed to be split
<span class="nc bnc" id="L770" title="All 2 branches missed.">    if (splitPerCutoff) {</span>
<span class="nc bnc" id="L771" title="All 4 branches missed.">      for (int j = 0; (j &lt; possibleToSplit) &amp;&amp; (cbic[sortOrder[j]] &gt; 0.0);</span>
<span class="nc" id="L772">	   j++) {</span>
<span class="nc" id="L773">	splitWon[sortOrder[j]] = true;</span>
      }
<span class="nc" id="L775">      m_NumSplitsStillDone += possibleToSplit;</span>
    } 
    else {
      // take some splits away if max number of clusters would be exceeded
<span class="nc bnc" id="L779" title="All 2 branches missed.">      if (takeSomeAway) {</span>
<span class="nc" id="L780">	int count = 0;</span>
<span class="nc" id="L781">	int j = 0;</span>
<span class="nc bnc" id="L782" title="All 4 branches missed.">	for (;j &lt; splitWon.length &amp;&amp; count &lt; possibleToSplit; j++){</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">	  if (splitWon[sortOrder[j]] == true) count++;</span>
	}
	
<span class="nc bnc" id="L786" title="All 2 branches missed.">	while (j &lt; splitWon.length) {</span>
<span class="nc" id="L787">	  splitWon[sortOrder[j]] = false;</span>
<span class="nc" id="L788">	  j++;</span>
	}
      }
    }
   
    // finally split
<span class="nc bnc" id="L794" title="All 2 branches missed.">    if (possibleToSplit &gt; 0) </span>
<span class="nc" id="L795">      newCenters = newCentersAfterSplit(splitWon, splitCenters);</span>
    else
<span class="nc" id="L797">      newCenters = m_ClusterCenters;</span>
<span class="nc" id="L798">    return newCenters;</span>
  }

  /**
   * Returns new centers. Depending on splitWon: if true takes children, if
   * false takes parent = current center.
   * 
   * @param splitWon
   *          array of boolean to indicate to take split or not
   * @param splitCenters
   *          list of splitted centers
   * @return the new centers
   */
  protected Instances newCentersAfterSplit(boolean[] splitWon,
      Instances splitCenters) {
<span class="nc" id="L813">    Instances newCenters = new Instances(splitCenters, 0);</span>

<span class="nc" id="L815">    int sIndex = 0;</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">    for (int i = 0; i &lt; splitWon.length; i++) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">      if (splitWon[i]) {</span>
<span class="nc" id="L818">        m_NumSplitsDone++;</span>
<span class="nc" id="L819">        newCenters.add(splitCenters.instance(sIndex++));</span>
<span class="nc" id="L820">        newCenters.add(splitCenters.instance(sIndex++));</span>
      } else {
<span class="nc" id="L822">        sIndex++;</span>
<span class="nc" id="L823">        sIndex++;</span>
<span class="nc" id="L824">        newCenters.add(m_ClusterCenters.instance(i));</span>
      }
    }
<span class="nc" id="L827">    return newCenters;</span>
  }

  /**
   * Controls that counter does not exceed max iteration value. Special function
   * for kmeans iterations.
   * 
   * @param iterationCount
   *          current value of counter
   * @param max
   *          maximum value for counter
   * @return true if iteration should be stopped
   */ 
  protected boolean stopKMeansIteration(int iterationCount, int max) {
<span class="nc" id="L841">    boolean stopIterate = false;</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">    if (max &gt;= 0) </span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">      stopIterate = (iterationCount &gt;= max);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">    if (stopIterate) </span>
<span class="nc" id="L845">      m_KMeansStopped++;</span>
<span class="nc" id="L846">    return stopIterate;</span>
  }

  /**
   * Checks if iterationCount has to be checked and if yes
   * (this means max is &gt; 0) compares it with max.
   * 
   * @param iterationCount the current iteration count
   * @param max the maximum number of iterations
   * @return true if maximum has been reached
   */ 
  protected boolean stopIteration(int iterationCount, int max) {
<span class="nc" id="L858">    boolean stopIterate = false;</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">    if (max &gt;= 0) </span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">      stopIterate = (iterationCount &gt;= max);</span>
<span class="nc" id="L861">    return stopIterate;</span>
  }

  /**
   * Recompute the new centers. New cluster center is center of mass of its 
   * instances. Returns true if cluster stays the same.
   * @param centers the input and output centers
   * @param instOfCent the instances to the centers 
   * @param model data model information
   * @return true if converged.
   */
   protected boolean recomputeCenters(Instances centers,          
				   int[][] instOfCent, 
				   Instances model) {
<span class="nc" id="L875">    boolean converged = true;</span>
    
<span class="nc bnc" id="L877" title="All 2 branches missed.">    for (int i = 0; i &lt; centers.numInstances(); i++) {</span>
      double val;
<span class="nc bnc" id="L879" title="All 2 branches missed.">      for (int j = 0; j &lt; model.numAttributes(); j++) {</span>
<span class="nc" id="L880">	val = meanOrMode(m_Instances, instOfCent[i], j);</span>

<span class="nc bnc" id="L882" title="All 2 branches missed.">	for (int k = 0; k &lt; instOfCent[i].length; k++)</span>

<span class="nc bnc" id="L884" title="All 4 branches missed.">	if (converged &amp;&amp; m_ClusterCenters.instance(i).value(j) != val) </span>
<span class="nc" id="L885">	  converged = false;</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">	if (!converged)</span>
<span class="nc" id="L887">	  m_ClusterCenters.instance(i).setValue(j, val);</span>
      }
    }
<span class="nc" id="L890">    return converged;</span>
  }

  /**
   * Recompute the new centers - 2nd version 
   * Same as recomputeCenters, but does not check if center stays the same.
   * 
   * @param centers the input center and output centers
   * @param instOfCentIndexes the indexes of the instances to the centers 
   * @param model data model information
   */
  protected void recomputeCentersFast(Instances centers,          
				    int[][] instOfCentIndexes, 
				    Instances model   
				    ) {
<span class="nc bnc" id="L905" title="All 2 branches missed.">    for (int i = 0; i &lt; centers.numInstances(); i++) {</span>
      double val;
<span class="nc bnc" id="L907" title="All 2 branches missed.">      for (int j = 0; j &lt; model.numAttributes(); j++) {</span>
<span class="nc" id="L908">	val = meanOrMode(m_Instances, instOfCentIndexes[i], j);</span>
<span class="nc" id="L909">	centers.instance(i).setValue(j, val);</span>
      }
    }
<span class="nc" id="L912">  }</span>

  /**
   * Computes Mean Or Mode of one attribute on a subset of m_Instances. 
   * The subset is defined by an index list.
   * @param instances all instances
   * @param instList the indexes of the instances the mean is computed from
   * @param attIndex the index of the attribute
   * @return mean value
   */
  protected double meanOrMode(Instances instances, 
			    int[] instList, 
			    int attIndex) {
    double result, found;
    int[] counts;
<span class="nc" id="L927">    int numInst = instList.length;</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">    if (instances.attribute(attIndex).isNumeric()) {</span>
<span class="nc" id="L930">      result = found = 0;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">      for (int j = 0; j &lt; numInst; j++) {</span>
<span class="nc" id="L932">	Instance currInst = instances.instance(instList[j]);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">	if (!currInst.isMissing(attIndex)) {</span>
<span class="nc" id="L934">	  found += currInst.weight();</span>
<span class="nc" id="L935">	  result += currInst.weight() * </span>
<span class="nc" id="L936">	    currInst.value(attIndex);</span>
	}
      }
<span class="nc bnc" id="L939" title="All 2 branches missed.">      if (Utils.eq(found, 0)) {</span>
<span class="nc" id="L940">	return 0;</span>
      } else {
<span class="nc" id="L942">	return result / found;</span>
      }
<span class="nc bnc" id="L944" title="All 2 branches missed.">    } else if (instances.attribute(attIndex).isNominal()) {</span>
<span class="nc" id="L945">      counts = new int[instances.attribute(attIndex).numValues()];</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">      for (int j = 0; j &lt; numInst; j++) {</span>
<span class="nc" id="L947">	Instance currInst = instances.instance(instList[j]);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">	if (!currInst.isMissing(attIndex)) {</span>
<span class="nc" id="L949">	  counts[(int) currInst.value(attIndex)] += currInst.weight();</span>
	}
      }
<span class="nc" id="L952">      return (double)Utils.maxIndex(counts);</span>
    } else {
<span class="nc" id="L954">      return 0;</span>
    }
  }

 
  /**
   * Assigns instances to centers.
   *
   * @param tree KDTree on all instances
   * @param centers all the input centers
   * @param instOfCent the instances to each center
   * @param allInstList list of all instances
   * @param assignments assignments of instances to centers
   * @param iterationCount the number of iteration 
   * @return true if converged
   * @throws Exception is something goes wrong
   */
  protected boolean assignToCenters(KDTree tree,
                                  Instances centers, 
				  int[][] instOfCent, 
                                  int[] allInstList,
				  int[] assignments,
                                  int iterationCount) throws Exception {
    
<span class="nc" id="L978">    boolean converged = true;</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">    if (tree != null) {</span>
      // using KDTree structure for assigning
<span class="nc" id="L981">      converged = assignToCenters(tree,</span>
<span class="nc" id="L982">				  centers, </span>
<span class="nc" id="L983">				  instOfCent,</span>
<span class="nc" id="L984">				  assignments,</span>
<span class="nc" id="L985">				  iterationCount);</span>
    } else {
<span class="nc" id="L987">      converged = assignToCenters(centers, </span>
<span class="nc" id="L988">				  instOfCent,</span>
<span class="nc" id="L989">				  allInstList, </span>
<span class="nc" id="L990">				  assignments);</span>
    }
<span class="nc" id="L992">    return converged;</span>
  }

  /**
   * Assign instances to centers using KDtree.
   * First part of conventionell K-Means, returns true if new assignment
   * is the same as the last one.
   *
   * @param kdtree KDTree on all instances
   * @param centers all the input centers
   * @param instOfCent the instances to each center
   * @param assignments assignments of instances to centers
   * @param iterationCount the number of iteration 
   * @return true if converged
   * @throws Exception in case instances are not assigned to cluster
   */
  protected boolean assignToCenters(KDTree kdtree,
				  Instances centers, 
				  int[][] instOfCent, 
				  int[] assignments,
                                  int iterationCount) throws Exception {

<span class="nc" id="L1014">    int numCent = centers.numInstances();</span>
<span class="nc" id="L1015">    int numInst = m_Instances.numInstances(); </span>
<span class="nc" id="L1016">    int[] oldAssignments = new int[numInst];</span>
    
    // WARNING:  assignments is &quot;input/output-parameter&quot;
    // should not be null
<span class="nc bnc" id="L1020" title="All 2 branches missed.">    if (assignments == null) {</span>
<span class="nc" id="L1021">      assignments = new int[numInst];</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">      for (int i = 0; i &lt; numInst; i++) {</span>
<span class="nc" id="L1023">	assignments[0] = -1;</span>
      }
    }
    
    // WARNING:  instOfCent is &quot;input/output-parameter&quot;
    // should not be null
<span class="nc bnc" id="L1029" title="All 2 branches missed.">    if (instOfCent == null) {</span>
<span class="nc" id="L1030">      instOfCent = new int [numCent][];</span>
    }
    
    // save old assignments
<span class="nc bnc" id="L1034" title="All 2 branches missed.">    for (int i = 0; i &lt; assignments.length; i++) {</span>
<span class="nc" id="L1035">      oldAssignments[i] = assignments[i];</span>
    }
    
    // use tree to get new assignments
<span class="nc" id="L1039">    kdtree.centerInstances(centers, assignments,</span>
<span class="nc" id="L1040">			   Math.pow(.8, iterationCount));	</span>
<span class="nc" id="L1041">    boolean converged = true;</span>
  
    // compare with previous assignment
<span class="nc bnc" id="L1044" title="All 4 branches missed.">    for (int i = 0; converged &amp;&amp; (i &lt; assignments.length); i++) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">      converged = (oldAssignments[i] == assignments[i]);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">      if (assignments[i] == -1) </span>
<span class="nc" id="L1047">	throw new Exception(&quot;Instance &quot; + i + </span>
<span class="nc" id="L1048">			    &quot; has not been assigned to cluster.&quot;);</span>
    }

<span class="nc bnc" id="L1051" title="All 2 branches missed.">    if (!converged) {</span>
<span class="nc" id="L1052">      int[] numInstOfCent = new int[numCent];</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">      for (int i = 0; i &lt; numCent; i++)</span>
<span class="nc" id="L1054">	numInstOfCent[i] = 0;</span>

      // count num of assignments per center
<span class="nc bnc" id="L1057" title="All 2 branches missed.">      for (int i = 0; i &lt; numInst; i++)</span>
<span class="nc" id="L1058">	numInstOfCent[assignments[i]]++;</span>
      
      // prepare instancelists per center
<span class="nc bnc" id="L1061" title="All 2 branches missed.">      for (int i = 0; i &lt; numCent; i++){</span>
<span class="nc" id="L1062">	instOfCent[i] = new int[numInstOfCent[i]];</span>
      }
      // write instance lists per center
<span class="nc bnc" id="L1065" title="All 2 branches missed.">      for (int i = 0; i &lt; numCent; i++) {</span>
<span class="nc" id="L1066">	int index = -1;   </span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">	for (int j = 0; j &lt; numInstOfCent[i]; j++) {</span>
<span class="nc" id="L1068">	  index = nextAssignedOne(i, index, assignments);</span>
<span class="nc" id="L1069">	  instOfCent[i][j] = index;</span>
	}
      }
    }
  
<span class="nc" id="L1074">    return converged;</span>
  }

  /**
   * Assign instances to centers.
   * Part of conventionell K-Means, returns true if new assignment
   * is the same as the last one.
   *
   * @param centers all the input centers
   * @param instOfCent the instances to each center
   * @param allInstList list of all indexes
   * @param assignments assignments of instances to centers
   * @return true if converged
   * @throws Exception if something goes wrong
   */
  protected boolean assignToCenters(Instances centers, 
				  int[][] instOfCent,
				  int[] allInstList,
				  int[] assignments) 
    throws Exception {
    
    // todo: undecided situations
<span class="nc" id="L1096">    boolean converged = true; // true if new assignment is the same </span>
                              // as the old one

<span class="nc" id="L1099">    int numInst = allInstList.length; </span>
<span class="nc" id="L1100">    int numCent = centers.numInstances();</span>
<span class="nc" id="L1101">    int[] numInstOfCent = new int [numCent];</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">    for (int i = 0; i &lt; numCent; i++) numInstOfCent[i] = 0;</span>

    // WARNING:  assignments is &quot;input/output-parameter&quot;
    // should not be null
<span class="nc bnc" id="L1106" title="All 2 branches missed.">    if (assignments == null) {</span>
<span class="nc" id="L1107">      assignments = new int[numInst];</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">      for (int i = 0; i &lt; numInst; i++) {</span>
<span class="nc" id="L1109">	assignments[i] = -1;</span>
      }
    }

    // WARNING: instOfCent is &quot;input/output-parameter&quot;
    // should not be null
<span class="nc bnc" id="L1115" title="All 2 branches missed.">    if (instOfCent == null) {</span>
<span class="nc" id="L1116">      instOfCent = new int [numCent][];</span>
    }

    // set assignments
<span class="nc bnc" id="L1120" title="All 2 branches missed.">    for (int i = 0; i &lt; numInst; i++) {</span>
<span class="nc" id="L1121">      Instance inst = m_Instances.instance(allInstList[i]);</span>
<span class="nc" id="L1122">      int newC = clusterProcessedInstance(inst, centers);</span>
      
<span class="nc bnc" id="L1124" title="All 4 branches missed.">      if (converged &amp;&amp; newC != assignments[i]) {</span>
<span class="nc" id="L1125">	converged = false;</span>
      }

<span class="nc" id="L1128">      numInstOfCent[newC]++; </span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">      if (!converged)</span>
<span class="nc" id="L1130">	assignments[i] = newC;</span>
    }

    // the following is only done
    // if assignments are not the same, because too much effort
<span class="nc bnc" id="L1135" title="All 2 branches missed.">    if (!converged) {</span>
<span class="nc" id="L1136">      PFD(D_FOLLOWSPLIT, &quot;assignToCenters -&gt; it has NOT converged&quot;);</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">      for (int i = 0; i &lt; numCent; i++) {</span>
<span class="nc" id="L1138">	instOfCent[i] = new int [numInstOfCent[i]];</span>
      }

<span class="nc bnc" id="L1141" title="All 2 branches missed.">      for (int i = 0; i &lt; numCent; i++) {</span>
<span class="nc" id="L1142">	int index = -1;   </span>
<span class="nc bnc" id="L1143" title="All 2 branches missed.">	for (int j = 0; j &lt; numInstOfCent[i]; j++) {</span>
<span class="nc" id="L1144">	  index = nextAssignedOne(i, index, assignments);</span>
<span class="nc" id="L1145">	  instOfCent[i][j] = allInstList[index];</span>
	}
      }
    }
    else
<span class="nc" id="L1150">      PFD(D_FOLLOWSPLIT, &quot;assignToCenters -&gt; it has converged&quot;);</span>

<span class="nc" id="L1152">    return converged;</span>
  }

  /**
   * Searches along the assignment array for the next entry of the center 
   * in question.
   * @param cent index of the center 
   * @param lastIndex index to start searching
   * @param assignments assignments
   * @return index of the instance the center cent is assigned to
   */
  protected int nextAssignedOne(int cent, int lastIndex, 
			      int[] assignments) {
<span class="nc" id="L1165">    int len = assignments.length;</span>
<span class="nc" id="L1166">    int index = lastIndex + 1;</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">    while (index &lt; len) {</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">      if (assignments[index] == cent) {</span>
<span class="nc" id="L1169">	return (index);</span>
      }
<span class="nc" id="L1171">      index++;</span>
    }
<span class="nc" id="L1173">    return (-1);</span>
  }

  /**
   * Split centers in their region. Generates random vector of 
   * length = variance and
   * adds and substractsx to cluster vector to get two new clusters.
   * 
   * @param random random function
   * @param center the center that is split here
   * @param variance variance of the cluster 
   * @param model data model valid
   * @return a pair of new centers
   * @throws Exception something in AlgVector goes wrong
   */
  protected Instances splitCenter(Random random,
			        Instance center,
			        double variance,
			        Instances model) throws Exception {
<span class="nc" id="L1192">    m_NumSplits++;</span>
<span class="nc" id="L1193">    AlgVector r = null;</span>
<span class="nc" id="L1194">    Instances children = new Instances(model, 2);</span>

<span class="nc bnc" id="L1196" title="All 4 branches missed.">    if (m_DebugVectorsFile.exists() &amp;&amp; m_DebugVectorsFile.isFile()) {</span>
<span class="nc" id="L1197">      Instance nextVector = getNextDebugVectorsInstance(model);</span>
<span class="nc" id="L1198">      PFD(D_RANDOMVECTOR, &quot;Random Vector from File &quot; + nextVector);</span>
<span class="nc" id="L1199">      r = new AlgVector(nextVector);</span>
    }
    else {
      // random vector of length = variance
<span class="nc" id="L1203">      r = new AlgVector(model, random);</span>
    }
<span class="nc" id="L1205">    r.changeLength(Math.pow(variance, 0.5));</span>
<span class="nc" id="L1206">    PFD(D_RANDOMVECTOR, &quot;random vector *variance &quot;+ r);</span>
    
    // add random vector to center
<span class="nc" id="L1209">    AlgVector c = new AlgVector(center);</span>
<span class="nc" id="L1210">    AlgVector c2 = (AlgVector) c.clone();</span>
<span class="nc" id="L1211">    c = c.add(r);</span>
<span class="nc" id="L1212">    Instance newCenter = c.getAsInstance(model, random);</span>
<span class="nc" id="L1213">    children.add(newCenter);</span>
<span class="nc" id="L1214">    PFD(D_FOLLOWSPLIT, &quot;first child &quot;+ newCenter);</span>
    
    // substract random vector to center
<span class="nc" id="L1217">    c2 = c2.substract(r);</span>
<span class="nc" id="L1218">    newCenter = c2.getAsInstance(model, random);</span>
<span class="nc" id="L1219">    children.add(newCenter);</span>
<span class="nc" id="L1220">    PFD(D_FOLLOWSPLIT, &quot;second child &quot;+ newCenter);</span>

<span class="nc" id="L1222">    return children;</span>
  }

  /**
   * Split centers in their region.
   * (*Alternative version of splitCenter()*) 
   * 
   * @param random the random number generator
   * @param instances of the region
   * @param model the model for the centers 
   * (should be the same as that of instances)
   * @return a pair of new centers
   */
  protected Instances splitCenters(Random random,
				 Instances instances,
				 Instances model) {
<span class="nc" id="L1238">    Instances children = new Instances(model, 2);</span>
<span class="nc" id="L1239">    int instIndex = Math.abs(random.nextInt()) % instances.numInstances();</span>
<span class="nc" id="L1240">    children.add(instances.instance(instIndex));</span>
<span class="nc" id="L1241">    int instIndex2 = instIndex;</span>
<span class="nc" id="L1242">    int count = 0;</span>
<span class="nc bnc" id="L1243" title="All 4 branches missed.">    while ((instIndex2 == instIndex) &amp;&amp; count &lt; 10) {</span>
<span class="nc" id="L1244">      count++;</span>
<span class="nc" id="L1245">      instIndex2 = Math.abs(random.nextInt()) % instances.numInstances();</span>
    }
<span class="nc" id="L1247">    children.add(instances.instance(instIndex2));</span>
    
<span class="nc" id="L1249">    return children;</span>
  }

  /**
   * Generates new centers randomly. Used for starting centers.
   *
   * @param random0 random number generator
   * @param model data model of the instances
   * @param numClusters number of clusters
   * @return new centers
   */
  protected Instances makeCentersRandomly(Random random0,
					Instances model,
					int numClusters) {
<span class="nc" id="L1263">    Instances clusterCenters = new Instances(model, numClusters);</span>
<span class="nc" id="L1264">    m_NumClusters = numClusters;</span>

    // makes the new centers randomly
<span class="nc bnc" id="L1267" title="All 2 branches missed.">    for (int i = 0; i &lt; numClusters; i++) {</span>
<span class="nc" id="L1268">      int instIndex = Math.abs(random0.nextInt()) % m_Instances.numInstances();</span>
<span class="nc" id="L1269">      clusterCenters.add(m_Instances.instance(instIndex));</span>
    }
<span class="nc" id="L1271">    return clusterCenters;</span>
  }

  /**
   * Returns the BIC-value for the given center and instances.
   * @param instList The indices of the instances that belong to the center
   * @param center the center.
   * @param mle maximum likelihood
   * @param model the data model
   * @return the BIC value 
   */   
  protected double calculateBIC(int[] instList, Instance center,
			      double mle, Instances model) {
<span class="nc" id="L1284">    int[][] w1 = new int[1][instList.length];</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">    for (int i = 0; i &lt; instList.length; i++) {</span>
<span class="nc" id="L1286">      w1[0][i] = instList[i];</span>
    }
<span class="nc" id="L1288">    double[] m = {mle};</span>
<span class="nc" id="L1289">    Instances w2 = new Instances(model, 1);</span>
<span class="nc" id="L1290">    w2.add(center);</span>
<span class="nc" id="L1291">    return calculateBIC(w1, w2, m);</span>
    }
  
  /**
   * Calculates the BIC for the given set of centers and instances.
   * @param instOfCent The instances that belong to their respective centers
   * @param centers the centers
   * @param mle maximum likelihood
   * @return The BIC for the input.
   */
  protected double calculateBIC(int[][] instOfCent, Instances centers,
			      double[] mle) {
<span class="nc" id="L1303">    double loglike = 0.0;</span>
<span class="nc" id="L1304">    int numInstTotal = 0;</span>
<span class="nc" id="L1305">    int numCenters = centers.numInstances();</span>
<span class="nc" id="L1306">    int numDimensions = centers.numAttributes();</span>
<span class="nc" id="L1307">    int numParameters = (numCenters - 1) + //probabilities</span>
<span class="nc" id="L1308">      numCenters * numDimensions + //means</span>
<span class="nc" id="L1309">      numCenters; // variance params</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">    for (int i = 0; i &lt; centers.numInstances(); i++) {</span>
<span class="nc" id="L1311">      loglike += logLikelihoodEstimate(instOfCent[i].length, centers.instance(i),</span>
<span class="nc" id="L1312">				       mle[i], centers.numInstances() * 2);</span>
<span class="nc" id="L1313">      numInstTotal += instOfCent[i].length;</span>
    }
    /* diff
       thats how we did it
    loglike -= ((centers.numAttributes() + 1.0) * centers.numInstances() * 1)
      * Math.log(count);
      */
<span class="nc" id="L1320">    loglike -= numInstTotal * Math.log(numInstTotal);</span>
    //System.out.println (&quot;numInstTotal &quot; + numInstTotal +
    //                    &quot;calculateBIC res &quot; + loglike);
<span class="nc" id="L1323">    loglike -= (numParameters / 2.0) * Math.log(numInstTotal);</span>
    //System.out.println (&quot;numParam &quot; +
    //                     + numParameters +
    //			&quot; calculateBIC res &quot; + loglike);
<span class="nc" id="L1327">    return loglike;</span>
  }
  
  /**
   * Calculates the log-likelihood of the data for the given model, taken
   * at the maximum likelihood point.
   *
   * @param numInst number of instances that belong to the center
   * @param center the center
   * @param distortion distortion 
   * @param numCent number of centers 
   * @return the likelihood estimate
   */
  protected double logLikelihoodEstimate(int numInst, 
				       Instance center, 
				       double distortion, 
				       int numCent) {
    // R(n) num of instances of the center -&gt; numInst
    // K num of centers -&gt; not used
    //
    //todo take the diff comments away
<span class="nc" id="L1348">    double loglike = 0;</span>
    /* if is new */
<span class="nc bnc" id="L1350" title="All 2 branches missed.">    if (numInst &gt; 1) {</span>
      /* diff variance is new */
      //
      // distortion = Sum over instances x of the center(x-center)
      // different to paper; sum should be squared
      //
      // (Sum of distances to center) / R(n) - 1.0
      // different to paper; should be R(n)-K
<span class="nc" id="L1358">      double variance =  distortion / (numInst - 1.0); </span>
  
      //
      //  -R(n)/2 * log(pi*2)
      //
<span class="nc" id="L1363">      double p1 = - (numInst / 2.0) * Math.log(Math.PI * 2.0);</span>
      /* diff
	 thats how we had it
	 double p2 = -((ni * center.numAttributes()) / 2) * distortion;
      */
      //
      // -(R(n)*M)/2 * log(variance) 
      //
<span class="nc" id="L1371">      double p2 = - (numInst * center.numAttributes()) / 2 * Math.log(variance);</span>
      
      /* diff
	 thats how we had it, the difference is a bug in x-means
	 double p3 = - (numInst - numCent) / 2;
      */
      //
      // -(R(n)-1)/2
      //
<span class="nc" id="L1380">      double p3 = - (numInst - 1.0) / 2.0;</span>
      
      //
      // R(n)*log(R(n))
      //
<span class="nc" id="L1385">      double p4 = numInst * Math.log(numInst);</span>
      
      /* diff x-means doesn't have this part 
	 double p5 = - numInst * Math.log(numInstTotal);
      */
      
      /*
	loglike = -(ni / 2) * Math.log(Math.PI * 2) 
	- (ni * center.numAttributes()) / 2.0) * logdistortion
	- (ni - k) / 2.0 
	+ ni * Math.log(ni) 
	- ni * Math.log(r);
      */
<span class="nc" id="L1398">      loglike = p1 + p2 + p3 + p4; // diff + p5;</span>
      //the log(r) is something that can be reused.
      //as is the log(2 PI), these could provide extra speed up later on.
      //since distortion is so expensive to compute, I only do that once.
    }
<span class="nc" id="L1403">    return loglike;</span>
  }
  
  /**
   * Calculates the maximum likelihood estimate for the variance.
   * @param instOfCent indices of instances to each center
   * @param centers the centers
   * @return the list of distortions distortion.
   */
  protected double[] distortion(int[][] instOfCent, Instances centers) {
<span class="nc" id="L1413">    double[] distortion = new double[centers.numInstances()];</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">    for (int i = 0; i &lt; centers.numInstances(); i++) {</span>
<span class="nc" id="L1415">      distortion[i] = 0.0;</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">      for (int j = 0; j &lt; instOfCent[i].length; j++) {</span>
<span class="nc" id="L1417">        distortion[i] += m_DistanceF.distance(m_Instances</span>
<span class="nc" id="L1418">            .instance(instOfCent[i][j]), centers.instance(i));</span>
      }
    }
    /*
     * diff not done in x-means res *= 1.0 / (count - centers.numInstances());
     */
<span class="nc" id="L1424">    return distortion;</span>
  }
  
  /**
   * Clusters an instance.
   * 
   * @param instance
   *          the instance to assign a cluster to.
   * @param centers
   *          the centers to cluster the instance to.
   * @return a cluster index.
   */
  protected int clusterProcessedInstance(Instance instance, Instances centers) {
    
<span class="nc" id="L1438">    double minDist = Integer.MAX_VALUE;</span>
<span class="nc" id="L1439">    int bestCluster = 0;</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">    for (int i = 0; i &lt; centers.numInstances(); i++) {</span>
<span class="nc" id="L1441">      double dist = m_DistanceF.distance(instance, centers.instance(i));</span>

<span class="nc bnc" id="L1443" title="All 2 branches missed.">      if (dist &lt; minDist) {</span>
<span class="nc" id="L1444">        minDist = dist;</span>
<span class="nc" id="L1445">        bestCluster = i;</span>
      }
    }
    ;
<span class="nc" id="L1449">    return bestCluster;</span>
  }
  
  /**
   * Clusters an instance that has been through the filters.
   * 
   * @param instance
   *          the instance to assign a cluster to
   * @return a cluster number
   */
  protected int clusterProcessedInstance(Instance instance) {
<span class="nc" id="L1460">    double minDist = Integer.MAX_VALUE;</span>
<span class="nc" id="L1461">    int bestCluster = 0;</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">    for (int i = 0; i &lt; m_NumClusters; i++) {</span>
<span class="nc" id="L1463">      double dist = m_DistanceF</span>
<span class="nc" id="L1464">          .distance(instance, m_ClusterCenters.instance(i));</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">      if (dist &lt; minDist) {</span>
<span class="nc" id="L1466">        minDist = dist;</span>
<span class="nc" id="L1467">        bestCluster = i;</span>
      }
    }
<span class="nc" id="L1470">    return bestCluster;</span>
  }

  /**
   * Classifies a given instance.
   *
   * @param instance the instance to be assigned to a cluster
   * @return the number of the assigned cluster as an integer
   * if the class is enumerated, otherwise the predicted value
   * @throws Exception if instance could not be classified
   * successfully
   */
  public int clusterInstance(Instance instance) throws Exception {
<span class="nc" id="L1483">    m_ReplaceMissingFilter.input(instance);</span>
<span class="nc" id="L1484">    Instance inst = m_ReplaceMissingFilter.output();</span>

<span class="nc" id="L1486">    return clusterProcessedInstance(inst);</span>
  }


  /**
   * Returns the number of clusters.
   *
   * @return the number of clusters generated for a training dataset.
   */
  public int numberOfClusters() {
<span class="nc" id="L1496">    return m_NumClusters;</span>
  }


  /**
   * Returns an enumeration describing the available options. 
   * @return an enumeration of all the available options
   **/
  public Enumeration listOptions() {
<span class="nc" id="L1505">    Vector result = new Vector();</span>
    
<span class="nc" id="L1507">    result.addElement(new Option(</span>
<span class="nc" id="L1508">	&quot;\tmaximum number of overall iterations\n&quot;</span>
	+ &quot;\t(default 1).&quot;, 
<span class="nc" id="L1510">	&quot;I&quot;, 1, &quot;-I &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L1512">    result.addElement(new Option(</span>
<span class="nc" id="L1513">	&quot;\tmaximum number of iterations in the kMeans loop in\n&quot;</span>
	+ &quot;\tthe Improve-Parameter part \n&quot;
	+ &quot;\t(default 1000).&quot;, 
<span class="nc" id="L1516">	&quot;M&quot;, 1, &quot;-M &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L1518">    result.addElement(new Option(</span>
<span class="nc" id="L1519">	&quot;\tmaximum number of iterations in the kMeans loop\n&quot;</span>
	+ &quot;\tfor the splitted centroids in the Improve-Structure part \n&quot;
	+ &quot;\t(default 1000).&quot;,
<span class="nc" id="L1522">	&quot;J&quot;, 1, &quot;-J &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L1524">    result.addElement(new Option(</span>
<span class="nc" id="L1525">	&quot;\tminimum number of clusters\n&quot;</span>
	+ &quot;\t(default 2).&quot;, 
<span class="nc" id="L1527">	&quot;L&quot;, 1, &quot;-L &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L1529">    result.addElement(new Option(</span>
<span class="nc" id="L1530">	&quot;\tmaximum number of clusters\n&quot;</span>
	+ &quot;\t(default 4).&quot;,
<span class="nc" id="L1532">	&quot;H&quot;, 1, &quot;-H &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L1534">    result.addElement(new Option(</span>
<span class="nc" id="L1535">	&quot;\tdistance value for binary attributes\n&quot;</span>
	+ &quot;\t(default 1.0).&quot;,
<span class="nc" id="L1537">	&quot;B&quot;, 1, &quot;-B &lt;value&gt;&quot;));</span>
    
<span class="nc" id="L1539">    result.addElement(new Option(</span>
<span class="nc" id="L1540">	&quot;\tUses the KDTree internally\n&quot;</span>
	+ &quot;\t(default no).&quot;,
<span class="nc" id="L1542">	&quot;use-kdtree&quot;, 0, &quot;-use-kdtree&quot;));</span>
    
<span class="nc" id="L1544">    result.addElement(new Option(</span>
<span class="nc" id="L1545">	&quot;\tFull class name of KDTree class to use, followed\n&quot;</span>
	+ &quot;\tby scheme options.\n&quot;
	+ &quot;\teg: \&quot;weka.core.neighboursearch.kdtrees.KDTree -P\&quot;\n&quot;
	+ &quot;\t(default no KDTree class used).&quot;,
<span class="nc" id="L1549">	&quot;K&quot;, 1, &quot;-K &lt;KDTree class specification&gt;&quot;));</span>
    
<span class="nc" id="L1551">    result.addElement(new Option(</span>
<span class="nc" id="L1552">	&quot;\tcutoff factor, takes the given percentage of the splitted \n&quot;</span>
	+ &quot;\tcentroids if none of the children win\n&quot;
	+ &quot;\t(default 0.0).&quot;,
<span class="nc" id="L1555">	&quot;C&quot;, 1, &quot;-C &lt;value&gt;&quot;));</span>
    
<span class="nc" id="L1557">    result.addElement(new Option(</span>
<span class="nc" id="L1558">	&quot;\tFull class name of Distance function class to use, followed\n&quot;</span>
	+ &quot;\tby scheme options.\n&quot; +
	&quot;\t(default weka.core.EuclideanDistance).&quot;,
<span class="nc" id="L1561">	&quot;D&quot;, 1, &quot;-D &lt;distance function class specification&gt;&quot;));</span>
    
<span class="nc" id="L1563">    result.addElement(new Option(</span>
<span class="nc" id="L1564">	&quot;\tfile to read starting centers from (ARFF format).&quot;,</span>
<span class="nc" id="L1565">	&quot;N&quot;, 1, &quot;-N &lt;file name&gt;&quot;));</span>
    
<span class="nc" id="L1567">    result.addElement(new Option(</span>
<span class="nc" id="L1568">	&quot;\tfile to write centers to (ARFF format).&quot;,</span>
<span class="nc" id="L1569">	&quot;O&quot;, 1, &quot;-O &lt;file name&gt;&quot;));</span>
    
<span class="nc" id="L1571">    result.addElement(new Option(</span>
<span class="nc" id="L1572">	&quot;\tThe debug level.\n&quot;</span>
	+ &quot;\t(default 0)&quot;,
<span class="nc" id="L1574">	&quot;U&quot;, 1, &quot;-U &lt;int&gt;&quot;));</span>
    
<span class="nc" id="L1576">    result.addElement(new Option(</span>
<span class="nc" id="L1577">	&quot;\tThe debug vectors file.&quot;,</span>
<span class="nc" id="L1578">	&quot;Y&quot;, 1, &quot;-Y &lt;file name&gt;&quot;));</span>
    
<span class="nc" id="L1580">    Enumeration en = super.listOptions();</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">    while (en.hasMoreElements())</span>
<span class="nc" id="L1582">      result.addElement(en.nextElement());</span>
    
<span class="nc" id="L1584">    return result.elements();</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String minNumClustersTipText() {
<span class="nc" id="L1592">    return &quot;set minimum number of clusters&quot;;</span>
  }

  /**
   * Sets the minimum number of clusters to generate.
   *
   * @param n the minimum number of clusters to generate
   */
  public void setMinNumClusters(int n) {
<span class="nc" id="L1601">    m_MinNumClusters = n;</span>
<span class="nc" id="L1602">  }</span>

  /**
   * Gets the minimum number of clusters to generate.
   * @return the minimum number of clusters to generate
   */
  public int getMinNumClusters() {
<span class="nc" id="L1609">    return m_MinNumClusters;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String maxNumClustersTipText() {
<span class="nc" id="L1617">    return &quot;set maximum number of clusters&quot;;</span>
  }

  /**
   * Sets the maximum number of clusters to generate.
   * @param n the maximum number of clusters to generate
   */
  public void setMaxNumClusters(int n) {
<span class="nc bnc" id="L1625" title="All 2 branches missed.">    if (n &gt;= m_MinNumClusters) {</span>
<span class="nc" id="L1626">      m_MaxNumClusters = n;</span>
    }
<span class="nc" id="L1628">  }</span>
  
  /**
   * Gets the maximum number of clusters to generate.
   * @return the maximum number of clusters to generate
   */
  public int getMaxNumClusters() {
<span class="nc" id="L1635">    return m_MaxNumClusters;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String maxIterationsTipText() {
<span class="nc" id="L1643">    return &quot;the maximum number of iterations to perform&quot;;</span>
  }

  /**
   * Sets the maximum number of iterations to perform.
   * @param i the number of iterations
   * @throws Exception if i is less than 1
   */
  public void setMaxIterations(int i) throws Exception {
<span class="nc bnc" id="L1652" title="All 2 branches missed.">    if (i &lt; 0) </span>
<span class="nc" id="L1653">      throw new Exception(&quot;Only positive values for iteration number&quot; +</span>
                           &quot; allowed (Option I).&quot;); 
<span class="nc" id="L1655">    m_MaxIterations = i;</span>
<span class="nc" id="L1656">  }</span>

  /**
   * Gets the maximum number of iterations.
   * @return the number of iterations
   */
  public int getMaxIterations() {
<span class="nc" id="L1663">    return  m_MaxIterations;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String maxKMeansTipText() {
<span class="nc" id="L1671">    return &quot;the maximum number of iterations to perform in KMeans&quot;;</span>
  }

  /**
   * Set the maximum number of iterations to perform in KMeans.
   * @param i the number of iterations
   */
  public void setMaxKMeans(int i) {
<span class="nc" id="L1679">    m_MaxKMeans = i;</span>
<span class="nc" id="L1680">    m_MaxKMeansForChildren = i;</span>
<span class="nc" id="L1681">  }</span>

  /**
   * Gets the maximum number of iterations in KMeans.
   * @return the number of iterations
   */
  public int getMaxKMeans() {
<span class="nc" id="L1688">    return  m_MaxKMeans;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String maxKMeansForChildrenTipText() {
<span class="nc" id="L1696">    return &quot;the maximum number of iterations KMeans that is performed on the child centers&quot;;</span>
  }

  /**
   * Sets the maximum number of iterations KMeans that is performed 
   * on the child centers.
   * @param i the number of iterations
   */
  public void setMaxKMeansForChildren(int i) {
<span class="nc" id="L1705">    m_MaxKMeansForChildren = i;</span>
<span class="nc" id="L1706">  }</span>

  /**
   * Gets the maximum number of iterations in KMeans.
   * @return the number of iterations
   */
  public int getMaxKMeansForChildren() {
<span class="nc" id="L1713">    return  m_MaxKMeansForChildren;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property 
   */
  public String cutOffFactorTipText() {
<span class="nc" id="L1721">    return &quot;the cut-off factor to use&quot;;</span>
  }

  /**
   * Sets a new cutoff factor.
   * @param i the new cutoff factor
   */
  public void setCutOffFactor(double i) {
<span class="nc" id="L1729">    m_CutOffFactor = i;</span>
<span class="nc" id="L1730">  }</span>

  /**
   * Gets the cutoff factor.
   * @return the cutoff factor
   */
  public double getCutOffFactor() {
<span class="nc" id="L1737">    return  m_CutOffFactor;</span>
  }

  /**
   * Returns the tip text for this property.
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String binValueTipText() {
<span class="nc" id="L1746">    return &quot;Set the value that represents true in the new attributes.&quot;;</span>
  }
  
  /**
   * Gets value that represents true in a new numeric attribute.
   * (False is always represented by 0.0.)
   * @return the value that represents true in a new numeric attribute
   */
  public double getBinValue() {
<span class="nc" id="L1755">    return m_BinValue;</span>
  }

  /**
   * Sets the distance value between true and false of binary attributes.
   * and  &quot;same&quot; and &quot;different&quot; of nominal attributes    
   * @param value the distance
   */
  public void setBinValue(double value) {
<span class="nc" id="L1764">    m_BinValue = value;</span>
<span class="nc" id="L1765">  }</span>

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String distanceFTipText() {
<span class="nc" id="L1774">    return &quot;The distance function to use.&quot;;</span>
  }

  /**
   * gets the &quot;binary&quot; distance value.
   * @param distanceF the distance function with all options set
   */
  public void setDistanceF(DistanceFunction distanceF) {
<span class="nc" id="L1782">    m_DistanceF = distanceF;</span>
<span class="nc" id="L1783">  }</span>

  /**
   * Gets the distance function.
   * @return the distance function
   */
  public DistanceFunction getDistanceF() {
<span class="nc" id="L1790">    return m_DistanceF;</span>
  }

  /**
   * Gets the distance function specification string, which contains the 
   * class name of the distance function class and any options to it.
   *
   * @return the distance function specification string
   */
  protected String getDistanceFSpec() {
    
<span class="nc" id="L1801">    DistanceFunction d = getDistanceF();</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">    if (d instanceof OptionHandler) {</span>
<span class="nc" id="L1803">      return d.getClass().getName() + &quot; &quot;</span>
<span class="nc" id="L1804">	+ Utils.joinOptions(((OptionHandler) d).getOptions());</span>
    }
<span class="nc" id="L1806">    return d.getClass().getName();</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String debugVectorsFileTipText() {
<span class="nc" id="L1816">    return &quot;The file containing the debug vectors (only for debugging!).&quot;;</span>
  }
  
  /**
   * Sets the file that has the random vectors stored.
   * Only used for debugging reasons.
   * @param value the file to read the random vectors from
   */
  public void setDebugVectorsFile(File value) {
<span class="nc" id="L1825">    m_DebugVectorsFile = value;</span>
<span class="nc" id="L1826">  }</span>

  /**
   * Gets the file name for a file that has the random vectors stored.
   * Only used for debugging purposes.
   * @return the file to read the vectors from
   */
  public File getDebugVectorsFile() {
<span class="nc" id="L1834">    return m_DebugVectorsFile;</span>
  }
  
  /**
   * Initialises the debug vector input.
   * @throws Exception if there is error 
   * opening the debug input file.
   */
  public void initDebugVectorsInput() throws Exception {
<span class="nc" id="L1843">    m_DebugVectorsInput = </span>
<span class="nc" id="L1844">      new BufferedReader(new FileReader(m_DebugVectorsFile));</span>
<span class="nc" id="L1845">    m_DebugVectors = new Instances(m_DebugVectorsInput);</span>
<span class="nc" id="L1846">    m_DebugVectorsIndex = 0;</span>
<span class="nc" id="L1847">  }</span>

  /**
   * Read an instance from debug vectors file.
   * @param model the data model for the instance.
   * @throws Exception if there are no debug vector 
   * in m_DebugVectors.
   * @return the next debug vector.
   */
  public Instance getNextDebugVectorsInstance(Instances model) 
    throws Exception {
<span class="nc bnc" id="L1858" title="All 2 branches missed.">    if (m_DebugVectorsIndex &gt;= m_DebugVectors.numInstances())</span>
<span class="nc" id="L1859">      throw new Exception(&quot;no more prefabricated Vectors&quot;);</span>
<span class="nc" id="L1860">    Instance nex = m_DebugVectors.instance(m_DebugVectorsIndex);</span>
<span class="nc" id="L1861">    nex.setDataset(model);</span>
<span class="nc" id="L1862">    m_DebugVectorsIndex++;</span>
<span class="nc" id="L1863">    return nex;</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String inputCenterFileTipText() {
<span class="nc" id="L1873">    return &quot;The file to read the list of centers from.&quot;;</span>
  }

  /**
   * Sets the file to read the list of centers from.
   *
   * @param value the file to read centers from
   */
  public void setInputCenterFile(File value) {
<span class="nc" id="L1882">    m_InputCenterFile = value;</span>
<span class="nc" id="L1883">  }</span>
  
  /**
   * Gets the file to read the list of centers from.
   *
   * @return the file to read the centers from
   */
  public File getInputCenterFile() {
<span class="nc" id="L1891">    return m_InputCenterFile;</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String outputCenterFileTipText() {
<span class="nc" id="L1901">    return &quot;The file to write the list of centers to.&quot;;</span>
  }
    
  /**
   * Sets file to write the list of centers to. 
   *
   * @param value file to write centers to
   */
  public void setOutputCenterFile(File value) {
<span class="nc" id="L1910">    m_OutputCenterFile = value;</span>
<span class="nc" id="L1911">  }</span>

  /**
   * Gets the file to write the list of centers to. 
   * 
   * @return filename of the file to write centers to
   */
  public File getOutputCenterFile() {
<span class="nc" id="L1919">    return m_OutputCenterFile;</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String KDTreeTipText() {
<span class="nc" id="L1929">    return &quot;The KDTree to use.&quot;;</span>
  }
    
  /**
   * Sets the KDTree class.
   * @param k a KDTree object with all options set
   */
  public void setKDTree(KDTree k) {
<span class="nc" id="L1937">    m_KDTree = k;</span>
<span class="nc" id="L1938">  }</span>

  /**
   * Gets the KDTree class.
   * 
   * @return the configured KDTree
   */
  public KDTree getKDTree() {
<span class="nc" id="L1946">    return m_KDTree;</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String useKDTreeTipText() {
<span class="nc" id="L1956">    return &quot;Whether to use the KDTree.&quot;;</span>
  }
    
  /**
   * Sets whether to use the KDTree or not.
   * 
   * @param value	if true the KDTree is used
   */
  public void setUseKDTree(boolean value) {
<span class="nc" id="L1965">    m_UseKDTree = value;</span>
<span class="nc" id="L1966">  }</span>

  /**
   * Gets whether the KDTree is used or not.
   * 
   * @return 		true if KDTrees are used
   */
  public boolean getUseKDTree() {
<span class="nc" id="L1974">    return m_UseKDTree;</span>
  }

  /**
   * Gets the KDTree specification string, which contains the class name of
   * the KDTree class and any options to the KDTree.
   *
   * @return the KDTree string.
   */
  protected String getKDTreeSpec() {
    
<span class="nc" id="L1985">    KDTree c = getKDTree();</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">    if (c instanceof OptionHandler) {</span>
<span class="nc" id="L1987">      return c.getClass().getName() + &quot; &quot;</span>
<span class="nc" id="L1988">	+ Utils.joinOptions(((OptionHandler)c).getOptions());</span>
    }
<span class="nc" id="L1990">    return c.getClass().getName();</span>
  }

  /**
   * Returns the tip text for this property.
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String debugLevelTipText() {
<span class="nc" id="L2000">    return &quot;The debug level to use.&quot;;</span>
  }

  /**
   * Sets the debug level.
   * debug level = 0, means no output
   * @param d debuglevel
   */
  public void setDebugLevel(int d) {
<span class="nc" id="L2009">    m_DebugLevel = d;</span>
<span class="nc" id="L2010">  }</span>

  /**
   * Gets the debug level.
   * @return debug level
   */
  public int getDebugLevel() {
<span class="nc" id="L2017">    return m_DebugLevel;</span>
  }

  /**
   * Checks the instances.
   * No checks in this KDTree but it calls the check of the distance function.
   */
  protected void checkInstances () {
    
   // m_DistanceF.checkInstances();
<span class="nc" id="L2027">  }</span>
  
  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -I &amp;lt;num&amp;gt;
   *  maximum number of overall iterations
   *  (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;num&amp;gt;
   *  maximum number of iterations in the kMeans loop in
   *  the Improve-Parameter part 
   *  (default 1000).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -J &amp;lt;num&amp;gt;
   *  maximum number of iterations in the kMeans loop
   *  for the splitted centroids in the Improve-Structure part 
   *  (default 1000).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L &amp;lt;num&amp;gt;
   *  minimum number of clusters
   *  (default 2).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -H &amp;lt;num&amp;gt;
   *  maximum number of clusters
   *  (default 4).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -B &amp;lt;value&amp;gt;
   *  distance value for binary attributes
   *  (default 1.0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -use-kdtree
   *  Uses the KDTree internally
   *  (default no).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -K &amp;lt;KDTree class specification&amp;gt;
   *  Full class name of KDTree class to use, followed
   *  by scheme options.
   *  eg: &quot;weka.core.neighboursearch.kdtrees.KDTree -P&quot;
   *  (default no KDTree class used).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;value&amp;gt;
   *  cutoff factor, takes the given percentage of the splitted 
   *  centroids if none of the children win
   *  (default 0.0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D &amp;lt;distance function class specification&amp;gt;
   *  Full class name of Distance function class to use, followed
   *  by scheme options.
   *  (default weka.core.EuclideanDistance).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;file name&amp;gt;
   *  file to read starting centers from (ARFF format).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -O &amp;lt;file name&amp;gt;
   *  file to write centers to (ARFF format).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -U &amp;lt;int&amp;gt;
   *  The debug level.
   *  (default 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -Y &amp;lt;file name&amp;gt;
   *  The debug vectors file.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;num&amp;gt;
   *  Random number seed.
   *  (default 10)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   * 
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options)
    throws Exception {
    
    String 	optionString;
    String 	funcString;

<span class="nc" id="L2109">    optionString = Utils.getOption('I', options);</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2111">      setMaxIterations(Integer.parseInt(optionString));</span>
    else
<span class="nc" id="L2113">      setMaxIterations(1);</span>
    
<span class="nc" id="L2115">    optionString = Utils.getOption('M', options);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2117">      setMaxKMeans(Integer.parseInt(optionString));</span>
    else
<span class="nc" id="L2119">      setMaxKMeans(1000);</span>
    
<span class="nc" id="L2121">    optionString = Utils.getOption('J', options);</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2123">      setMaxKMeansForChildren(Integer.parseInt(optionString));</span>
    else
<span class="nc" id="L2125">      setMaxKMeansForChildren(1000);</span>
      
<span class="nc" id="L2127">    optionString = Utils.getOption('L', options);</span>
<span class="nc bnc" id="L2128" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2129">      setMinNumClusters(Integer.parseInt(optionString));</span>
    else
<span class="nc" id="L2131">      setMinNumClusters(2);</span>
      
<span class="nc" id="L2133">    optionString = Utils.getOption('H', options);</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2135">      setMaxNumClusters(Integer.parseInt(optionString));</span>
    else
<span class="nc" id="L2137">      setMaxNumClusters(4);</span>
    
<span class="nc" id="L2139">    optionString = Utils.getOption('B', options);</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2141">      setBinValue(Double.parseDouble(optionString));</span>
    else
<span class="nc" id="L2143">      setBinValue(1.0);</span>

<span class="nc" id="L2145">    setUseKDTree(Utils.getFlag(&quot;use-kdtree&quot;, options));</span>
    
<span class="nc bnc" id="L2147" title="All 2 branches missed.">    if (getUseKDTree()) {</span>
<span class="nc" id="L2148">      funcString = Utils.getOption('K', options);</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">      if (funcString.length() != 0) {</span>
<span class="nc" id="L2150">	String[] funcSpec = Utils.splitOptions(funcString);</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">	if (funcSpec.length == 0) {</span>
<span class="nc" id="L2152">	  throw new Exception(&quot;Invalid function specification string&quot;);</span>
	}
<span class="nc" id="L2154">	String funcName = funcSpec[0];</span>
<span class="nc" id="L2155">	funcSpec[0] = &quot;&quot;;</span>
<span class="nc" id="L2156">	setKDTree((KDTree) Utils.forName(KDTree.class, funcName, funcSpec));</span>
      }
      else {
<span class="nc" id="L2159">	setKDTree(new KDTree());</span>
      }
    }
    else {
<span class="nc" id="L2163">      setKDTree(new KDTree());</span>
    }

<span class="nc" id="L2166">    optionString = Utils.getOption('C', options);</span>
<span class="nc bnc" id="L2167" title="All 2 branches missed.">    if (optionString.length() != 0)</span>
<span class="nc" id="L2168">      setCutOffFactor(Double.parseDouble(optionString));</span>
    else
<span class="nc" id="L2170">      setCutOffFactor(0.0);</span>
    
<span class="nc" id="L2172">    funcString = Utils.getOption('D', options);</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">    if (funcString.length() != 0) {</span>
<span class="nc" id="L2174">      String[] funcSpec = Utils.splitOptions(funcString);</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">      if (funcSpec.length == 0) {</span>
<span class="nc" id="L2176">	throw new Exception(&quot;Invalid function specification string&quot;);</span>
      }
<span class="nc" id="L2178">      String funcName = funcSpec[0];</span>
<span class="nc" id="L2179">      funcSpec[0] = &quot;&quot;;</span>
<span class="nc" id="L2180">      setDistanceF((DistanceFunction) Utils.forName(DistanceFunction.class,</span>
<span class="nc" id="L2181">						    funcName, funcSpec));</span>
    }
    else {
<span class="nc" id="L2184">      setDistanceF(new EuclideanDistance());</span>
    }

<span class="nc" id="L2187">    optionString  = Utils.getOption('N', options);</span>
<span class="nc bnc" id="L2188" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L2189">      setInputCenterFile(new File(optionString));</span>
<span class="nc" id="L2190">      m_CenterInput = </span>
<span class="nc" id="L2191">	new BufferedReader(new FileReader(optionString));</span>
    }
    else {
<span class="nc" id="L2194">      setInputCenterFile(new File(System.getProperty(&quot;user.dir&quot;)));</span>
<span class="nc" id="L2195">      m_CenterInput = null;</span>
    }

<span class="nc" id="L2198">    optionString  = Utils.getOption('O', options);</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L2200">      setOutputCenterFile(new File(optionString));</span>
<span class="nc" id="L2201">      m_CenterOutput = new PrintWriter(new FileOutputStream(optionString));</span>
    }
    else {
<span class="nc" id="L2204">      setOutputCenterFile(new File(System.getProperty(&quot;user.dir&quot;)));</span>
<span class="nc" id="L2205">      m_CenterOutput = null;</span>
    }

<span class="nc" id="L2208">    optionString = Utils.getOption('U', options);</span>
<span class="nc" id="L2209">    int debugLevel = 0;</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
      try {
<span class="nc" id="L2212">	debugLevel = Integer.parseInt(optionString);</span>
<span class="nc" id="L2213">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L2214">	throw new Exception(optionString +</span>
<span class="nc" id="L2215">                            &quot;is an illegal value for option -U&quot;); </span>
      }
    }
<span class="nc" id="L2218">    setDebugLevel(debugLevel);</span>

<span class="nc" id="L2220">    optionString  = Utils.getOption('Y', options);</span>
<span class="nc bnc" id="L2221" title="All 2 branches missed.">    if (optionString.length() != 0) {</span>
<span class="nc" id="L2222">      setDebugVectorsFile(new File(optionString));</span>
    }
    else {
<span class="nc" id="L2225">      setDebugVectorsFile(new File(System.getProperty(&quot;user.dir&quot;)));</span>
<span class="nc" id="L2226">      m_DebugVectorsInput = null;</span>
<span class="nc" id="L2227">      m_DebugVectors      = null;</span>
    }
    
<span class="nc" id="L2230">    super.setOptions(options);</span>
<span class="nc" id="L2231">  }</span>
  
  /**
   * Gets the current settings of SimpleKMeans.
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    int       	i;
    Vector    	result;
    String[]  	options;

<span class="nc" id="L2242">    result = new Vector();</span>

<span class="nc" id="L2244">    result.add(&quot;-I&quot;);</span>
<span class="nc" id="L2245">    result.add(&quot;&quot; + getMaxIterations());</span>
    
<span class="nc" id="L2247">    result.add(&quot;-M&quot;);</span>
<span class="nc" id="L2248">    result.add(&quot;&quot; + getMaxKMeans());</span>
    
<span class="nc" id="L2250">    result.add(&quot;-J&quot;);</span>
<span class="nc" id="L2251">    result.add(&quot;&quot; + getMaxKMeansForChildren());</span>
    
<span class="nc" id="L2253">    result.add(&quot;-L&quot;);</span>
<span class="nc" id="L2254">    result.add(&quot;&quot; + getMinNumClusters());</span>
    
<span class="nc" id="L2256">    result.add(&quot;-H&quot;);</span>
<span class="nc" id="L2257">    result.add(&quot;&quot; + getMaxNumClusters());</span>
    
<span class="nc" id="L2259">    result.add(&quot;-B&quot;);</span>
<span class="nc" id="L2260">    result.add(&quot;&quot; + getBinValue());</span>
    
<span class="nc bnc" id="L2262" title="All 2 branches missed.">    if (getUseKDTree()) {</span>
<span class="nc" id="L2263">      result.add(&quot;-use-kdtree&quot;);</span>
<span class="nc" id="L2264">      result.add(&quot;-K&quot;);</span>
<span class="nc" id="L2265">      result.add(&quot;&quot; + getKDTreeSpec());</span>
    }
    
<span class="nc" id="L2268">    result.add(&quot;-C&quot;);</span>
<span class="nc" id="L2269">    result.add(&quot;&quot; + getCutOffFactor());</span>
    
<span class="nc bnc" id="L2271" title="All 2 branches missed.">    if (getDistanceF() != null) {</span>
<span class="nc" id="L2272">      result.add(&quot;-D&quot;);</span>
<span class="nc" id="L2273">      result.add(&quot;&quot; + getDistanceFSpec());</span>
    }
    
<span class="nc bnc" id="L2276" title="All 4 branches missed.">    if (getInputCenterFile().exists() &amp;&amp; getInputCenterFile().isFile()) {</span>
<span class="nc" id="L2277">      result.add(&quot;-N&quot;);</span>
<span class="nc" id="L2278">      result.add(&quot;&quot; + getInputCenterFile());</span>
    }
    
<span class="nc bnc" id="L2281" title="All 4 branches missed.">    if (getOutputCenterFile().exists() &amp;&amp; getOutputCenterFile().isFile()) {</span>
<span class="nc" id="L2282">      result.add(&quot;-O&quot;);</span>
<span class="nc" id="L2283">      result.add(&quot;&quot; + getOutputCenterFile());</span>
    }
    
<span class="nc" id="L2286">    int dL = getDebugLevel();</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">    if (dL &gt; 0) {</span>
<span class="nc" id="L2288">      result.add(&quot;-U&quot;);</span>
<span class="nc" id="L2289">      result.add(&quot;&quot; + getDebugLevel());</span>
    }

<span class="nc bnc" id="L2292" title="All 4 branches missed.">    if (getDebugVectorsFile().exists() &amp;&amp; getDebugVectorsFile().isFile()) {</span>
<span class="nc" id="L2293">      result.add(&quot;-Y&quot;);</span>
<span class="nc" id="L2294">      result.add(&quot;&quot; + getDebugVectorsFile());</span>
    }
    
<span class="nc" id="L2297">    options = super.getOptions();</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L2299">      result.add(options[i]);</span>

<span class="nc" id="L2301">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }

  /**
   * Return a string describing this clusterer.
   * @return a description of the clusterer as a string
   */
  public String toString() {
<span class="nc" id="L2309">    StringBuffer temp = new StringBuffer();</span>

<span class="nc" id="L2311">    temp.append(&quot;\nXMeans\n======\n&quot;);</span>

<span class="nc" id="L2313">    temp.append(&quot;Requested iterations            : &quot; + m_MaxIterations + &quot;\n&quot;);</span>
<span class="nc" id="L2314">    temp.append(&quot;Iterations performed            : &quot; + m_IterationCount+ &quot;\n&quot;);</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">    if (m_KMeansStopped &gt; 0) {</span>
<span class="nc" id="L2316">      temp.append(&quot;kMeans did not converge\n&quot;);</span>
<span class="nc" id="L2317">      temp.append(&quot;  but was stopped by max-loops &quot; </span>
<span class="nc" id="L2318">	  + m_KMeansStopped + &quot; times (max kMeans-iter)\n&quot;);</span>
    }
<span class="nc" id="L2320">    temp.append(&quot;Splits prepared                 : &quot; + m_NumSplits + &quot;\n&quot;);</span>
<span class="nc" id="L2321">    temp.append(&quot;Splits performed                : &quot; + m_NumSplitsDone + &quot;\n&quot;);</span>
<span class="nc" id="L2322">    temp.append(&quot;Cutoff factor                   : &quot; + m_CutOffFactor + &quot;\n&quot;);</span>
    double perc;
<span class="nc bnc" id="L2324" title="All 2 branches missed.">    if (m_NumSplitsDone &gt; 0)</span>
<span class="nc" id="L2325">      perc = (((double)m_NumSplitsStillDone)/((double) m_NumSplitsDone))</span>
<span class="nc" id="L2326">             * 100.0;</span>
    else
<span class="nc" id="L2328">      perc = 0.0;</span>
<span class="nc" id="L2329">    temp.append(&quot;Percentage of splits accepted \n&quot; +</span>
                &quot;by cutoff factor                : &quot; 
<span class="nc" id="L2331">		+ Utils.doubleToString(perc,2) + &quot; %\n&quot;);</span>
<span class="nc" id="L2332">    temp.append(&quot;------\n&quot;);</span>

<span class="nc" id="L2334">    temp.append(&quot;Cutoff factor                   : &quot; + m_CutOffFactor + &quot;\n&quot;);</span>
<span class="nc" id="L2335">    temp.append(&quot;------\n&quot;);</span>
<span class="nc" id="L2336">    temp.append(&quot;\nCluster centers                 : &quot; + m_NumClusters + &quot; centers\n&quot;);</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">    for (int i = 0; i &lt; m_NumClusters; i++) {</span>
<span class="nc" id="L2338">      temp.append(&quot;\nCluster &quot;+i+&quot;\n           &quot;);</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">      for (int j = 0; j &lt; m_ClusterCenters.numAttributes(); j++) {</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">	if (m_ClusterCenters.attribute(j).isNominal()) {</span>
<span class="nc" id="L2341">	  temp.append(&quot; &quot;+m_ClusterCenters.attribute(j).</span>
<span class="nc" id="L2342">		      value((int)m_ClusterCenters.instance(i).value(j)));</span>
	} else {
<span class="nc" id="L2344">	  temp.append(&quot; &quot;+m_ClusterCenters.instance(i).value(j));</span>
	}
      }
    }
<span class="nc bnc" id="L2348" title="All 2 branches missed.">    if (m_Mle != null)</span>
<span class="nc" id="L2349">      temp.append(&quot;\n\nDistortion: &quot; + </span>
<span class="nc" id="L2350">		  Utils.doubleToString(Utils.sum(m_Mle),6) + &quot;\n&quot;);</span>
<span class="nc" id="L2351">    temp.append(&quot;BIC-Value : &quot; + Utils.doubleToString(m_Bic,6) + &quot;\n&quot;);</span>
<span class="nc" id="L2352">    return temp.toString();</span>
  }
  
  /**
   * Return the centers of the clusters as an Instances object
   * 
   * @return the cluster centers.
   */
  public Instances getClusterCenters() {
<span class="nc" id="L2361">    return m_ClusterCenters;</span>
  }

  /**
   * Print centers for debug.
   * @param debugLevel level that gives according messages
   */
  protected void PrCentersFD(int debugLevel) {
<span class="nc bnc" id="L2369" title="All 2 branches missed.">    if (debugLevel == m_DebugLevel) {</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">      for (int i = 0; i &lt; m_ClusterCenters.numInstances(); i++) {</span>
<span class="nc" id="L2371">	System.out.println(m_ClusterCenters.instance(i));</span>
      }
    }
<span class="nc" id="L2374">  }</span>

  /**
   * Tests on debug status.
   * @param debugLevel level that gives according messages
   * @return true if debug level is set
   */
  protected boolean TFD(int debugLevel) {
<span class="nc bnc" id="L2382" title="All 2 branches missed.">    return (debugLevel == m_DebugLevel);</span>
  }

  /**
   * Does debug printouts.
   * @param debugLevel level that gives according messages
   * @param output string that is printed
   */
  protected void PFD(int debugLevel, String output) {
<span class="nc bnc" id="L2391" title="All 2 branches missed.">    if (debugLevel == m_DebugLevel)</span>
<span class="nc" id="L2392">      System.out.println(output);</span>
<span class="nc" id="L2393">  }</span>
  /**
   * Does debug printouts.
   * @param output string that is printed
   */
  protected void PFD_CURR(String output) {
<span class="nc bnc" id="L2399" title="All 2 branches missed.">    if (m_CurrDebugFlag)</span>
<span class="nc" id="L2400">      System.out.println(output);</span>
<span class="nc" id="L2401">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L2409">    return RevisionUtils.extract(&quot;$Revision: 7135 $&quot;);</span>
  }

  /**
   * Main method for testing this class.
   * @param argv should contain options 
   */
  public static void main(String[] argv) {
<span class="nc" id="L2417">    runClusterer(new XMeans(), argv);</span>
<span class="nc" id="L2418">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>