<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>C45PruneableClassifierTreeG.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.trees.j48</a> &gt; <span class="el_source">C45PruneableClassifierTreeG.java</span></div><h1>C45PruneableClassifierTreeG.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    C45PruneableClassifierTreeG.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *    Copyright (C) 2007 Geoff Webb &amp; Janice Boughton
 *
 */

package weka.classifiers.trees.j48;

import weka.core.Capabilities;
import weka.core.Instances;
import weka.core.Instance;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import java.util.ArrayList;
import java.util.Collections;

/**
 * Class for handling a tree structure that can
 * be pruned using C4.5 procedures and have nodes grafted on.
 *
 * @author Janice Boughton (based on code by Eibe Frank)
 * @version $Revision: 5535 $
 */

public class C45PruneableClassifierTreeG extends ClassifierTree{

  /** for serialization */
  static final long serialVersionUID = 66981207374331964L;

  /** True if the tree is to be pruned. */
<span class="pc" id="L49">  boolean m_pruneTheTree = false;</span>

  /** The confidence factor for pruning. */
<span class="pc" id="L52">  float m_CF = 0.25f;</span>

  /** Is subtree raising to be performed? */
<span class="pc" id="L55">  boolean m_subtreeRaising = true;</span>

  /** Cleanup after the tree has been built. */
<span class="pc" id="L58">  boolean m_cleanup = true;</span>

  /** flag for using relabelling when grafting */
<span class="pc" id="L61">  boolean m_relabel = false;</span>

  /** binomial probability critical value */
<span class="pc" id="L64">  double m_BiProbCrit = 1.64;</span>

<span class="pc" id="L66">  boolean m_Debug = false;</span>

  /**
   * Constructor for pruneable tree structure. Stores reference
   * to associated training data at each node.
   *
   * @param toSelectLocModel selection method for local splitting model
   * @param pruneTree true if the tree is to be pruned
   * @param cf the confidence factor for pruning
   * @param raiseTree
   * @param cleanup
   * @throws Exception if something goes wrong
   */
  public C45PruneableClassifierTreeG(ModelSelection toSelectLocModel,
				    boolean pruneTree,float cf,
				    boolean raiseTree,
				    boolean relabel, boolean cleanup)
       throws Exception {

<span class="fc" id="L85">    super(toSelectLocModel);</span>

<span class="fc" id="L87">    m_pruneTheTree = pruneTree;</span>
<span class="fc" id="L88">    m_CF = cf;</span>
<span class="fc" id="L89">    m_subtreeRaising = raiseTree;</span>
<span class="fc" id="L90">    m_cleanup = cleanup;</span>
<span class="fc" id="L91">    m_relabel = relabel;</span>
<span class="fc" id="L92">  }</span>


  /**
   * Returns default capabilities of the classifier tree.
   *
   * @return      the capabilities of this classifier tree
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L101">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L102">    result.disableAll();</span>

    // attributes
<span class="fc" id="L105">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L106">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L107">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L110">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L111">    result.enable(Capability.MISSING_CLASS_VALUES);</span>

    // instances
<span class="fc" id="L114">    result.setMinimumNumberInstances(0);</span>

<span class="fc" id="L116">    return result;</span>
  }

  /**
   * Constructor for pruneable tree structure. Used to create new nodes
   * in the tree during grafting.
   *
   * @param toSelectLocModel selection method for local splitting model
   * @param data the dta used to produce split model
   * @param gs the split model
   * @param prune true if the tree is to be pruned
   * @param cf the confidence factor for pruning
   * @param raise
   * @param isLeaf if this node is a leaf or not
   * @param relabel whether relabeling occured
   * @param cleanup
   * @throws Exception if something goes wrong
   */
  public C45PruneableClassifierTreeG(ModelSelection toSelectLocModel, 
                                    Instances data, ClassifierSplitModel gs, 
                                    boolean prune, float cf, boolean raise,
                                    boolean isLeaf, boolean relabel, 
                                    boolean cleanup) {

<span class="nc" id="L140">    super(toSelectLocModel);</span>
<span class="nc" id="L141">    m_relabel = relabel;</span>
<span class="nc" id="L142">    m_cleanup = cleanup;</span>
<span class="nc" id="L143">    m_localModel = gs;</span>
<span class="nc" id="L144">    m_train = data;</span>
<span class="nc" id="L145">    m_test = null;</span>
<span class="nc" id="L146">    m_isLeaf = isLeaf;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">    if(gs.distribution().total() &gt; 0)</span>
<span class="nc" id="L148">       m_isEmpty = false;</span>
    else
<span class="nc" id="L150">       m_isEmpty = true;</span>

<span class="nc" id="L152">    m_pruneTheTree = prune;</span>
<span class="nc" id="L153">    m_CF = cf;</span>
<span class="nc" id="L154">    m_subtreeRaising = raise;</span>
<span class="nc" id="L155">  }</span>

  /**
   * Method for building a pruneable classifier tree.
   *
   * @param datathe data for building the tree
   * @throws Exception if something goes wrong
   */
  public void buildClassifier(Instances data) throws Exception {

    // can classifier tree handle the data?
<span class="fc" id="L166">    getCapabilities().testWithFail(data);</span>

    // remove instances with missing class
<span class="fc" id="L169">    data = new Instances(data);</span>
<span class="fc" id="L170">    data.deleteWithMissingClass();</span>

<span class="fc" id="L172">    buildTree(data, m_subtreeRaising);</span>
<span class="fc" id="L173">    collapse();</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">    if (m_pruneTheTree) {</span>
<span class="fc" id="L175">      prune();</span>
    }
<span class="fc" id="L177">    doGrafting(data);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">    if (m_cleanup) {</span>
<span class="fc" id="L179">      cleanup(new Instances(data, 0));</span>
    }
<span class="fc" id="L181">  }</span>


  /**
   * Collapses a tree to a node if training error doesn't increase.
   */
  public final void collapse(){

    double errorsOfSubtree;
    double errorsOfTree;
    int i;

<span class="fc bfc" id="L193" title="All 2 branches covered.">    if (!m_isLeaf){</span>
<span class="fc" id="L194">      errorsOfSubtree = getTrainingErrors();</span>
<span class="fc" id="L195">      errorsOfTree = localModel().distribution().numIncorrect();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">      if (errorsOfSubtree &gt;= errorsOfTree-1E-3){</span>

	// Free adjacent trees
<span class="fc" id="L199">	m_sons = null;</span>
<span class="fc" id="L200">	m_isLeaf = true;</span>
			
	// Get NoSplit Model for tree.
<span class="fc" id="L203">	m_localModel = new NoSplit(localModel().distribution());</span>
      }else
<span class="fc bfc" id="L205" title="All 2 branches covered.">	for (i=0;i&lt;m_sons.length;i++)</span>
<span class="fc" id="L206">	  son(i).collapse();</span>
    }
<span class="fc" id="L208">  }</span>

  /**
   * Prunes a tree using C4.5's pruning procedure.
   *
   * @throws Exception if something goes wrong
   */
  public void prune() throws Exception {

    double errorsLargestBranch;
    double errorsLeaf;
    double errorsTree;
    int indexOfLargestBranch;
    C45PruneableClassifierTreeG largestBranch;
    int i;

<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (!m_isLeaf){</span>

      // Prune all subtrees.
<span class="fc bfc" id="L227" title="All 2 branches covered.">      for (i=0;i&lt;m_sons.length;i++)</span>
<span class="fc" id="L228">	son(i).prune();</span>

      // Compute error for largest branch
<span class="fc" id="L231">      indexOfLargestBranch = localModel().distribution().maxBag();</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">      if (m_subtreeRaising) {</span>
<span class="fc" id="L233">	errorsLargestBranch = son(indexOfLargestBranch).</span>
<span class="fc" id="L234">	  getEstimatedErrorsForBranch((Instances)m_train);</span>
      } else {
<span class="nc" id="L236">	errorsLargestBranch = Double.MAX_VALUE;</span>
      }

      // Compute error if this Tree would be leaf
<span class="fc" id="L240">      errorsLeaf = </span>
<span class="fc" id="L241">	getEstimatedErrorsForDistribution(localModel().distribution());</span>

      // Compute error for the whole subtree
<span class="fc" id="L244">      errorsTree = getEstimatedErrors();</span>

      // Decide if leaf is best choice.
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">      if (Utils.smOrEq(errorsLeaf,errorsTree+0.1) &amp;&amp;</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">	  Utils.smOrEq(errorsLeaf,errorsLargestBranch+0.1)){</span>

	// Free son Trees
<span class="nc" id="L251">	m_sons = null;</span>
<span class="nc" id="L252">	m_isLeaf = true;</span>
		
	// Get NoSplit Model for node.
<span class="nc" id="L255">	m_localModel = new NoSplit(localModel().distribution());</span>
<span class="nc" id="L256">	return;</span>
      }

      // Decide if largest branch is better choice
      // than whole subtree.
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">      if (Utils.smOrEq(errorsLargestBranch,errorsTree+0.1)){</span>
<span class="nc" id="L262">	largestBranch = son(indexOfLargestBranch);</span>
<span class="nc" id="L263">	m_sons = largestBranch.m_sons;</span>
<span class="nc" id="L264">	m_localModel = largestBranch.localModel();</span>
<span class="nc" id="L265">	m_isLeaf = largestBranch.m_isLeaf;</span>
<span class="nc" id="L266">	newDistribution(m_train);</span>
<span class="nc" id="L267">	prune();</span>
      }
    }
<span class="fc" id="L270">  }</span>

  /**
   * Returns a newly created tree.
   *
   * @param data the data to work with
   * @return the new tree
   * @throws Exception if something goes wrong
   */
  protected ClassifierTree getNewTree(Instances data) throws Exception {
    
<span class="fc" id="L281">    C45PruneableClassifierTreeG newTree = </span>
<span class="fc" id="L282">      new C45PruneableClassifierTreeG(m_toSelectModel, m_pruneTheTree, m_CF,</span>
<span class="fc" id="L283">	     m_subtreeRaising, m_relabel, m_cleanup);</span>
	// ATBOP Modification     // m_subtreeRaising, m_cleanup);

<span class="fc" id="L286">    newTree.buildTree((Instances)data, m_subtreeRaising);</span>

<span class="fc" id="L288">    return newTree;</span>
  }

  /**
   * Computes estimated errors for tree.
   *
   * @return the estimated errors
   */
  private double getEstimatedErrors(){

<span class="fc" id="L298">    double errors = 0;</span>
    int i;

<span class="fc bfc" id="L301" title="All 2 branches covered.">    if (m_isLeaf)</span>
<span class="fc" id="L302">      return getEstimatedErrorsForDistribution(localModel().distribution());</span>
    else{
<span class="fc bfc" id="L304" title="All 2 branches covered.">      for (i=0;i&lt;m_sons.length;i++)</span>
<span class="fc" id="L305">	errors = errors+son(i).getEstimatedErrors();</span>
<span class="fc" id="L306">      return errors;</span>
    }
  }
  
  /**
   * Computes estimated errors for one branch.
   *
   * @param data the data to work with
   * @return the estimated errors
   * @throws Exception if something goes wrong
   */
  private double getEstimatedErrorsForBranch(Instances data) 
       throws Exception {

    Instances [] localInstances;
<span class="fc" id="L321">    double errors = 0;</span>
    int i;

<span class="fc bfc" id="L324" title="All 2 branches covered.">    if (m_isLeaf)</span>
<span class="fc" id="L325">      return getEstimatedErrorsForDistribution(new Distribution(data));</span>
    else{
<span class="fc" id="L327">      Distribution savedDist = localModel().m_distribution;</span>
<span class="fc" id="L328">      localModel().resetDistribution(data);</span>
<span class="fc" id="L329">      localInstances = (Instances[])localModel().split(data);</span>
<span class="fc" id="L330">      localModel().m_distribution = savedDist;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">      for (i=0;i&lt;m_sons.length;i++)</span>
<span class="fc" id="L332">	errors = errors+</span>
<span class="fc" id="L333">	  son(i).getEstimatedErrorsForBranch(localInstances[i]);</span>
<span class="fc" id="L334">      return errors;</span>
    }
  }

  /**
   * Computes estimated errors for leaf.
   *
   * @param theDistribution the distribution to use
   * @return the estimated errors
   */
  private double getEstimatedErrorsForDistribution(Distribution 
						   theDistribution){

<span class="pc bpc" id="L347" title="1 of 2 branches missed.">    if (Utils.eq(theDistribution.total(),0))</span>
<span class="nc" id="L348">      return 0;</span>
    else
<span class="fc" id="L350">      return theDistribution.numIncorrect()+</span>
<span class="fc" id="L351">	Stats.addErrs(theDistribution.total(),</span>
<span class="fc" id="L352">		      theDistribution.numIncorrect(),m_CF);</span>
  }

  /**
   * Computes errors of tree on training data.
   *
   * @return the training errors
   */
  private double getTrainingErrors(){

<span class="fc" id="L362">    double errors = 0;</span>
    int i;

<span class="fc bfc" id="L365" title="All 2 branches covered.">    if (m_isLeaf)</span>
<span class="fc" id="L366">      return localModel().distribution().numIncorrect();</span>
    else{
<span class="fc bfc" id="L368" title="All 2 branches covered.">      for (i=0;i&lt;m_sons.length;i++)</span>
<span class="fc" id="L369">	errors = errors+son(i).getTrainingErrors();</span>
<span class="fc" id="L370">      return errors;</span>
    }
  }

  /**
   * Method just exists to make program easier to read.
   *
   * @return the local split model
   */
  private ClassifierSplitModel localModel(){
    
<span class="fc" id="L381">    return (ClassifierSplitModel)m_localModel;</span>
  }

  /**
   * Computes new distributions of instances for nodes
   * in tree.
   *
   * @param data the data to compute the distributions for
   * @throws Exception if something goes wrong
   */
  private void newDistribution(Instances data) throws Exception {

    Instances [] localInstances;

<span class="nc" id="L395">    localModel().resetDistribution(data);</span>
<span class="nc" id="L396">    m_train = data;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">    if (!m_isLeaf){</span>
<span class="nc" id="L398">      localInstances = </span>
<span class="nc" id="L399">	(Instances [])localModel().split(data);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">      for (int i = 0; i &lt; m_sons.length; i++)</span>
<span class="nc" id="L401">	son(i).newDistribution(localInstances[i]);</span>
    } else {

      // Check whether there are some instances at the leaf now!
<span class="nc bnc" id="L405" title="All 2 branches missed.">      if (!Utils.eq(data.sumOfWeights(), 0)) {</span>
<span class="nc" id="L406">	m_isEmpty = false;</span>
      }
    }
<span class="nc" id="L409">  }</span>

  /**
   * Method just exists to make program easier to read.
   */
  private C45PruneableClassifierTreeG son(int index){
<span class="fc" id="L415">    return (C45PruneableClassifierTreeG)m_sons[index];</span>
  }


  /**
   * Initializes variables for grafting.
   * sets up limits array (for numeric attributes) and calls 
   * the recursive function traverseTree.
   *
   * @param data the data for the tree
   * @throws Exception if anything goes wrong
   */
  public void doGrafting(Instances data) throws Exception {

    // 2d array for the limits
<span class="fc" id="L430">    double [][] limits = new double[data.numAttributes()][2];</span>
    // 2nd dimension: index 0 == lower limit, index 1 == upper limit
    // initialise to no limit
<span class="fc bfc" id="L433" title="All 2 branches covered.">    for(int i = 0; i &lt; data.numAttributes(); i++) {</span>
<span class="fc" id="L434">       limits[i][0] = Double.NEGATIVE_INFINITY;</span>
<span class="fc" id="L435">       limits[i][1] = Double.POSITIVE_INFINITY;</span>
    }

    // use an index instead of creating new Insances objects all the time
    // instanceIndex[0] == array for weights at leaf
    // instanceIndex[1] == array for weights in atbop
<span class="fc" id="L441">    double [][] instanceIndex = new double[2][data.numInstances()];</span>
    // initialize the weight for each instance
<span class="fc bfc" id="L443" title="All 2 branches covered.">    for(int x = 0; x &lt; data.numInstances(); x++) {</span>
<span class="fc" id="L444">        instanceIndex[0][x] = 1;</span>
<span class="fc" id="L445">        instanceIndex[1][x] = 1;  // leaf instances are in atbop</span>
    }

    // first call to graft
<span class="fc" id="L449">    traverseTree(data, instanceIndex, limits, this, 0, -1);</span>
<span class="fc" id="L450">  }</span>


  /**
   * recursive function.
   * if this node is a leaf then calls findGraft, otherwise sorts 
   * the two sets of instances (tracked in iindex array) and calls
   * sortInstances for each of the child nodes (which then calls
   * this method).
   *
   * @param fulldata all instances
   * @param iindex array the tracks the weight of each instance in
   *        the atbop and at the leaf (0.0 if not present)
   * @param limits array specifying current upper/lower limits for numeric atts
   * @param parent the node immediately before the current one
   * @param pL laplace for node, as calculated by parent (in case leaf is empty)
   * @param nodeClass class of node, determined by parent (in case leaf empty)
   */
  private void traverseTree(Instances fulldata, double [][] iindex, 
     double[][] limits, C45PruneableClassifierTreeG parent, 
     double pL, int nodeClass) throws Exception {
    
<span class="fc bfc" id="L472" title="All 2 branches covered.">    if(m_isLeaf) {</span>

<span class="fc" id="L474">       findGraft(fulldata, iindex, limits, </span>
<span class="fc" id="L475">                 (ClassifierTree)parent, pL, nodeClass);</span>

    } else {

       // traverse each branch
<span class="fc bfc" id="L480" title="All 2 branches covered.">       for(int i = 0; i &lt; localModel().numSubsets(); i++) {</span>

<span class="fc" id="L482">          double [][] newiindex = new double[2][fulldata.numInstances()];</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">          for(int x = 0; x &lt; 2; x++)</span>
<span class="fc" id="L484">             System.arraycopy(iindex[x], 0, newiindex[x], 0, iindex[x].length);</span>
<span class="fc" id="L485">          sortInstances(fulldata, newiindex, limits, i);</span>
       }
    }
<span class="fc" id="L488">  }</span>

  /**
   * sorts/deletes instances into/from node and atbop according to 
   * the test for subset, then calls traverseTree for subset's node.
   *
   * @param fulldata all instances
   * @param iindex array the tracks the weight of each instance in
   *        the atbop and at the leaf (0.0 if not present)
   * @param limits array specifying current upper/lower limits for numeric atts
   * @param subset the subset for which to sort instances into inode &amp; iatbop
   */
  private void sortInstances(Instances fulldata, double [][] iindex, 
                   double [][] limits, int subset) throws Exception {

<span class="fc" id="L503">    C45Split test = (C45Split)localModel();</span>

    // update the instances index for subset
<span class="fc" id="L506">    double knownCases = 0;</span>
<span class="fc" id="L507">    double thisSubsetCount = 0;</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">    for(int x = 0; x &lt; iindex[0].length; x++) {</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">       if(iindex[0][x] == 0 &amp;&amp; iindex[1][x] == 0) // skip &quot;discarded&quot; instances</span>
<span class="nc" id="L510">          continue;</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">       if(!fulldata.instance(x).isMissing(test.attIndex())) {</span>
<span class="fc" id="L512">          knownCases += iindex[0][x];</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">          if(test.whichSubset(fulldata.instance(x)) != subset) {</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">             if(iindex[0][x] &gt; 0) {</span>
                // move to atbop, delete from leaf
<span class="fc" id="L516">                iindex[1][x] = iindex[0][x];</span>
<span class="fc" id="L517">                iindex[0][x] = 0;</span>
             } else {
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                if(iindex[1][x] &gt; 0) {</span>
                   // instance is now &quot;discarded&quot;
<span class="fc" id="L521">                   iindex[1][x] = 0;</span>
                }
             }
          } else {
<span class="fc" id="L525">             thisSubsetCount += iindex[0][x];</span>
          }
       }
    }

    // work out proportions of weight for missing values for leaf and atbop
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">    double lprop = (knownCases == 0) ? (1.0 / (double)test.numSubsets()) </span>
<span class="fc" id="L532">                                : (thisSubsetCount / (double)knownCases);</span>

    // add in the instances that have missing value for attIndex 
<span class="fc bfc" id="L535" title="All 2 branches covered.">    for(int x = 0; x &lt; iindex[0].length; x++) {</span>
<span class="fc bfc" id="L536" title="All 4 branches covered.">       if(iindex[0][x] == 0 &amp;&amp; iindex[1][x] == 0)</span>
<span class="fc" id="L537">          continue;     // skip &quot;discarded&quot; instances</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">       if(fulldata.instance(x).isMissing(test.attIndex())) {</span>
<span class="fc" id="L539">          iindex[1][x] -= (iindex[1][x] - iindex[0][x]) * (1-lprop);</span>
<span class="fc" id="L540">          iindex[0][x] *= lprop;</span>
       }
    }

<span class="fc" id="L544">    int nodeClass = localModel().distribution().maxClass(subset);</span>
<span class="fc" id="L545">    double pL = (localModel().distribution().perClass(nodeClass) + 1.0)</span>
<span class="fc" id="L546">               / (localModel().distribution().total() + 2.0);</span>

    // call traerseTree method for the child node
<span class="fc" id="L549">    son(subset).traverseTree(fulldata, iindex,</span>
<span class="fc" id="L550">          test.minsAndMaxs(fulldata, limits, subset), this, pL, nodeClass);</span>
<span class="fc" id="L551">  }</span>

  /**
   * finds new nodes that improve accuracy and grafts them onto the tree
   *
   * @param fulldata the instances in whole trainset
   * @param iindex records num tests each instance has failed up to this node
   * @param limits the upper/lower limits for numeric attributes
   * @param parent the node immediately before the current one
   * @param pLaplace laplace for leaf, calculated by parent (in case leaf empty)
   * @param pLeafClass class of leaf, determined by parent (in case leaf empty)
   */
  private void findGraft(Instances fulldata, double [][] iindex, 
   double [][] limits, ClassifierTree parent, double pLaplace, 
   int pLeafClass) throws Exception {

    // get the class for this leaf
<span class="fc bfc" id="L568" title="All 2 branches covered.">    int leafClass = (m_isEmpty)</span>
<span class="fc" id="L569">                       ? pLeafClass</span>
<span class="fc" id="L570">                       :  localModel().distribution().maxClass();</span>

    // get the laplace value for this leaf
<span class="fc bfc" id="L573" title="All 2 branches covered.">    double leafLaplace = (m_isEmpty)</span>
<span class="fc" id="L574">                            ? pLaplace</span>
<span class="fc" id="L575">                            : laplaceLeaf(leafClass);</span>

    // sort the instances into those at the leaf, those in atbop, and discarded
<span class="fc" id="L578">    Instances l = new Instances(fulldata, fulldata.numInstances());</span>
<span class="fc" id="L579">    Instances n = new Instances(fulldata, fulldata.numInstances());</span>
<span class="fc" id="L580">    int lcount = 0;</span>
<span class="fc" id="L581">    int acount = 0;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">    for(int x = 0; x &lt; fulldata.numInstances(); x++) {</span>
<span class="fc bfc" id="L583" title="All 4 branches covered.">       if(iindex[0][x] &lt;= 0 &amp;&amp; iindex[1][x] &lt;= 0)</span>
<span class="fc" id="L584">          continue;</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">       if(iindex[0][x] != 0) {</span>
<span class="fc" id="L586">          l.add(fulldata.instance(x));</span>
<span class="fc" id="L587">          l.instance(lcount).setWeight(iindex[0][x]);</span>
          // move instance's weight in iindex to same index as in l
<span class="fc" id="L589">          iindex[0][lcount++] = iindex[0][x];</span>
       }
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">       if(iindex[1][x] &gt; 0) {</span>
<span class="fc" id="L592">          n.add(fulldata.instance(x));</span>
<span class="fc" id="L593">          n.instance(acount).setWeight(iindex[1][x]);</span>
          // move instance's weight in iindex to same index as in n
<span class="fc" id="L595">          iindex[1][acount++] = iindex[1][x];</span>
       }
    }

<span class="fc" id="L599">    boolean graftPossible = false;</span>
<span class="fc" id="L600">    double [] classDist = new double[n.numClasses()];</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">    for(int x = 0; x &lt; n.numInstances(); x++) {</span>
<span class="pc bpc" id="L602" title="2 of 4 branches missed.">       if(iindex[1][x] &gt; 0 &amp;&amp; !n.instance(x).classIsMissing())</span>
<span class="fc" id="L603">          classDist[(int)n.instance(x).classValue()] += iindex[1][x];</span>
    }

<span class="fc bfc" id="L606" title="All 2 branches covered.">    for(int cVal = 0; cVal &lt; n.numClasses(); cVal++) {</span>
<span class="fc" id="L607">       double theLaplace = (classDist[cVal] + 1.0) / (classDist[cVal] + 2.0);</span>
<span class="fc bfc" id="L608" title="All 4 branches covered.">       if(cVal != leafClass &amp;&amp; (theLaplace &gt; leafLaplace) &amp;&amp; </span>
<span class="fc" id="L609">        (biprob(classDist[cVal], classDist[cVal], leafLaplace)</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">         &gt; m_BiProbCrit)) {</span>
<span class="fc" id="L611">          graftPossible = true;</span>
<span class="fc" id="L612">          break;</span>
       }
    }

<span class="fc bfc" id="L616" title="All 2 branches covered.">    if(!graftPossible) {</span>
<span class="fc" id="L617">       return;</span>
    }

    // 1. Initialize to {} a set of tuples t containing potential tests
<span class="fc" id="L621">    ArrayList t = new ArrayList();</span>

    // go through each attribute
<span class="fc bfc" id="L624" title="All 2 branches covered.">    for(int a = 0; a &lt; n.numAttributes(); a++) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">       if(a == n.classIndex())</span>
<span class="fc" id="L626">          continue;   // skip the class</span>

       // sort instances in atbop by $a
<span class="fc" id="L629">       int [] sorted = sortByAttribute(n, a);</span>

       // 2. For each continuous attribute $a:
<span class="fc bfc" id="L632" title="All 2 branches covered.">       if(n.attribute(a).isNumeric()) {</span>

          // find min and max values for this attribute at the leaf
<span class="fc" id="L635">          boolean prohibited = false;</span>
<span class="fc" id="L636">          double minLeaf = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L637">          double maxLeaf = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">          for(int i = 0; i &lt; l.numInstances(); i++) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">             if(l.instance(i).isMissing(a)) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if(l.instance(i).classValue() == leafClass) {</span>
<span class="fc" id="L641">                   prohibited = true;</span>
<span class="fc" id="L642">                   break;</span>
                }
             }
<span class="fc" id="L645">             double value = l.instance(i).value(a);</span>
<span class="pc bpc" id="L646" title="3 of 4 branches missed.">             if(!m_relabel || l.instance(i).classValue() == leafClass) {</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">                if(value &lt; minLeaf)</span>
<span class="fc" id="L648">                   minLeaf = value;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                if(value &gt; maxLeaf)</span>
<span class="fc" id="L650">                   maxLeaf = value;</span>
             }
          }
<span class="fc bfc" id="L653" title="All 2 branches covered.">          if(prohibited) {</span>
<span class="fc" id="L654">             continue;</span>
	  }

          // (a) find values of
          //    $n: instances in atbop (already have that, actually)
          //    $v: a value for $a that exists for a case in the atbop, where
          //       $v is &lt; the min value for $a for a case at the leaf which
          //       has the class $c, and $v is &gt; the lowerlimit of $a at
          //       the leaf.
          //       (note: error in original paper stated that $v must be
          //       smaller OR EQUAL TO the min value).
          //    $k: $k is a class
          //  that maximize L' = Laplace({$x: $x contained in cases($n)
          //    &amp; value($a,$x) &lt;= $v &amp; value($a,$x) &gt; lowerlim($l,$a)}, $k).
<span class="fc" id="L668">          double minBestClass = Double.NaN;</span>
<span class="fc" id="L669">          double minBestLaplace = leafLaplace;</span>
<span class="fc" id="L670">          double minBestVal = Double.NaN;</span>
<span class="fc" id="L671">          double minBestPos = Double.NaN;</span>
<span class="fc" id="L672">          double minBestTotal = Double.NaN;</span>
<span class="fc" id="L673">          double [][] minBestCounts = null;</span>
<span class="fc" id="L674">          double [][] counts = new double[2][n.numClasses()];</span>
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">          for(int x = 0; x &lt; n.numInstances(); x++) {</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">             if(n.instance(sorted[x]).isMissing(a))</span>
<span class="nc" id="L677">                break;   // missing are sorted to end: no more valid vals</span>

<span class="fc" id="L679">             double theval = n.instance(sorted[x]).value(a);</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">             if(m_Debug)</span>
<span class="nc" id="L681">                System.out.println(&quot;\t &quot; + theval);</span>

<span class="pc bpc" id="L683" title="1 of 2 branches missed.">             if(theval &lt;= limits[a][0]) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if(m_Debug)</span>
<span class="nc" id="L685">                   System.out.println(&quot;\t  &lt;= lowerlim: continuing...&quot;);</span>
<span class="nc" id="L686">                continue;</span>
             }
             // note: error in paper would have this read &quot;theVal &gt; minLeaf)
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">             if(theval &gt;= minLeaf) {</span>
<span class="pc bpc" id="L690" title="1 of 2 branches missed.">                if(m_Debug)</span>
<span class="nc" id="L691">                   System.out.println(&quot;\t  &gt;= minLeaf; breaking...&quot;);</span>
<span class="nc" id="L692">                break;</span>
             }
<span class="nc" id="L694">             counts[0][(int)n.instance(sorted[x]).classValue()]</span>
<span class="nc" id="L695">                += iindex[1][sorted[x]];</span>

<span class="nc bnc" id="L697" title="All 2 branches missed.">             if(x != n.numInstances() - 1) {</span>
<span class="nc" id="L698">                int z = x + 1;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                while(z &lt; n.numInstances()</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                 &amp;&amp; n.instance(sorted[z]).value(a) == theval) {</span>
<span class="nc" id="L701">                   z++; x++;</span>
<span class="nc" id="L702">                   counts[0][(int)n.instance(sorted[x]).classValue()] </span>
<span class="nc" id="L703">                    += iindex[1][sorted[x]];</span>
                }
             }

             // work out the best laplace/class (for &lt;= theval)
<span class="nc" id="L708">             double total = Utils.sum(counts[0]);</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">             for(int c = 0; c &lt; n.numClasses(); c++) {</span>
<span class="nc" id="L710">                double temp = (counts[0][c]+1.0)/(total+2.0);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                if(temp &gt; minBestLaplace) {</span>
<span class="nc" id="L712">                   minBestPos = counts[0][c];</span>
<span class="nc" id="L713">                   minBestTotal = total;</span>
<span class="nc" id="L714">                   minBestLaplace = temp;</span>
<span class="nc" id="L715">                   minBestClass = c;</span>
<span class="nc" id="L716">                   minBestCounts = copyCounts(counts);</span>

<span class="nc bnc" id="L718" title="All 2 branches missed.">                   minBestVal = (x == n.numInstances()-1) </span>
<span class="nc" id="L719">                      ? theval</span>
<span class="nc" id="L720">                      : ((theval + n.instance(sorted[x+1]).value(a)) / 2.0);</span>
                }
             }
          }

          // (b) add to t tuple &lt;n,a,v,k,L',&quot;&lt;=&quot;&gt;
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">          if(!Double.isNaN(minBestVal)</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">             &amp;&amp; biprob(minBestPos, minBestTotal, leafLaplace) &gt; m_BiProbCrit) {</span>
<span class="nc" id="L728">             GraftSplit gsplit = null;</span>
             try {
<span class="nc" id="L730">                gsplit = new GraftSplit(a, minBestVal, 0,</span>
<span class="nc" id="L731">                                        leafClass, minBestCounts);</span>
<span class="nc" id="L732">             } catch (Exception e) {</span>
<span class="nc" id="L733">                System.err.println(&quot;graftsplit error: &quot;+e.getMessage());</span>
<span class="nc" id="L734">                System.exit(1);</span>
             }
<span class="nc" id="L736">             t.add(gsplit);</span>
	  }
          // free space
<span class="fc" id="L739">          minBestCounts = null;</span>

          // (c) find values of
          //    n: instances in atbop (already have that, actually)
          //    $v: a value for $a that exists for a case in the atbop, where
          //       $v is &gt; the max value for $a for a case at the leaf which
          //       has the class $c, and $v is &lt;= the upperlimit of $a at
          //       the leaf.
          //    k: k is a class
          //   that maximize L' = Laplace({x: x contained in cases(n)
          //       &amp; value(a,x) &gt; v &amp; value(a,x) &lt;= upperlim(l,a)}, k).
<span class="fc" id="L750">          double maxBestClass = -1;</span>
<span class="fc" id="L751">          double maxBestLaplace = leafLaplace;</span>
<span class="fc" id="L752">          double maxBestVal = Double.NaN;</span>
<span class="fc" id="L753">          double maxBestPos = Double.NaN;</span>
<span class="fc" id="L754">          double maxBestTotal = Double.NaN;</span>
<span class="fc" id="L755">          double [][] maxBestCounts = null;</span>
<span class="fc bfc" id="L756" title="All 2 branches covered.">          for(int c = 0; c &lt; n.numClasses(); c++) {  // zero the counts</span>
<span class="fc" id="L757">             counts[0][c] = 0;</span>
<span class="fc" id="L758">             counts[1][c] = 0;  // shouldn't need to do this ...</span>
          }

          // check smallest val for a in atbop is &lt; upper limit
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">          if(n.numInstances() &gt;= 1</span>
<span class="pc bpc" id="L763" title="1 of 2 branches missed.">           &amp;&amp; n.instance(sorted[0]).value(a) &lt; limits[a][1]) {</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">             for(int x = n.numInstances() - 1; x &gt;= 0; x--) {</span>
<span class="pc bpc" id="L765" title="1 of 2 branches missed.">                if(n.instance(sorted[x]).isMissing(a))</span>
<span class="nc" id="L766">                   continue;</span>

<span class="fc" id="L768">                double theval = n.instance(sorted[x]).value(a);</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">                if(m_Debug)</span>
<span class="nc" id="L770">                   System.out.println(&quot;\t &quot; + theval);</span>

<span class="pc bpc" id="L772" title="1 of 2 branches missed.">                if(theval &gt; limits[a][1]) {</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                   if(m_Debug)</span>
<span class="nc" id="L774">                      System.out.println(&quot;\t  &gt;= upperlim; continuing...&quot;);</span>
<span class="nc" id="L775">                   continue;</span>
                }
<span class="fc bfc" id="L777" title="All 2 branches covered.">                if(theval &lt;= maxLeaf) {</span>
<span class="pc bpc" id="L778" title="1 of 2 branches missed.">                   if(m_Debug)</span>
<span class="nc" id="L779">                      System.out.println(&quot;\t  &lt; maxLeaf; breaking...&quot;);</span>
<span class="nc" id="L780">                   break;</span>
                }

                // increment counts
<span class="fc" id="L784">                counts[1][(int)n.instance(sorted[x]).classValue()] </span>
<span class="fc" id="L785">                   += iindex[1][sorted[x]];</span>

<span class="pc bpc" id="L787" title="2 of 4 branches missed.">                if(x != 0 &amp;&amp; !n.instance(sorted[x-1]).isMissing(a)) {</span>
<span class="fc" id="L788">                   int z = x - 1;</span>
<span class="pc bpc" id="L789" title="2 of 4 branches missed.">                   while(z &gt;= 0 &amp;&amp; n.instance(sorted[z]).value(a) == theval) {</span>
<span class="nc" id="L790">                      z--; x--;</span>
<span class="nc" id="L791">                      counts[1][(int)n.instance(sorted[x]).classValue()]</span>
<span class="nc" id="L792">                         += iindex[1][sorted[x]];</span>
                   }
                }

                // work out best laplace for &gt; theval
<span class="fc" id="L797">                double total = Utils.sum(counts[1]);</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">                for(int c = 0; c &lt; n.numClasses(); c++) {</span>
<span class="fc" id="L799">                   double temp = (counts[1][c]+1.0)/(total+2.0);</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">                   if(temp &gt; maxBestLaplace ) {</span>
<span class="fc" id="L801">                      maxBestPos = counts[1][c];</span>
<span class="fc" id="L802">                      maxBestTotal = total;</span>
<span class="fc" id="L803">                      maxBestLaplace = temp;</span>
<span class="fc" id="L804">                      maxBestClass = c;</span>
<span class="fc" id="L805">                      maxBestCounts = copyCounts(counts);</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                      maxBestVal = (x == 0) </span>
<span class="nc" id="L807">                        ? theval</span>
<span class="fc" id="L808">                        : ((theval + n.instance(sorted[x-1]).value(a)) / 2.0);</span>
                   }
                }
             }

             // (d) add to t tuple &lt;n,a,v,k,L',&quot;&gt;&quot;&gt;
<span class="pc bpc" id="L814" title="1 of 2 branches missed.">             if(!Double.isNaN(maxBestVal)</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">               &amp;&amp; biprob(maxBestPos,maxBestTotal,leafLaplace) &gt; m_BiProbCrit) {</span>
<span class="nc" id="L816">                GraftSplit gsplit = null;</span>
                try {
<span class="nc" id="L818">                   gsplit = new GraftSplit(a, maxBestVal, 1,</span>
<span class="nc" id="L819">                      leafClass, maxBestCounts);</span>
<span class="nc" id="L820">                } catch (Exception e) {</span>
<span class="nc" id="L821">                   System.err.println(&quot;graftsplit error:&quot; + e.getMessage());</span>
<span class="nc" id="L822">                   System.exit(1);</span>
                }
<span class="nc" id="L824">                t.add(gsplit);</span>
             }
          }
       } else {    // must be a nominal attribute

          // 3. for each discrete attribute a for which there is no
          //    test at an ancestor of l

          // skip if this attribute has already been used
<span class="fc bfc" id="L833" title="All 2 branches covered.">          if(limits[a][1] == 1) {</span>
<span class="fc" id="L834">             continue;</span>
          }

<span class="fc" id="L837">          boolean [] prohibit = new boolean[l.attribute(a).numValues()];</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">          for(int aval = 0; aval &lt; n.attribute(a).numValues(); aval++) {</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">             for(int x = 0; x &lt; l.numInstances(); x++) {</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">                if((l.instance(x).isMissing(a)</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">                    || l.instance(x).value(a) == aval) </span>
<span class="pc bpc" id="L842" title="3 of 4 branches missed.">                 &amp;&amp; (!m_relabel || (l.instance(x).classValue() == leafClass))) {</span>
<span class="fc" id="L843">                   prohibit[aval] = true;</span>
<span class="fc" id="L844">                   break;</span>
                }
             }
          }

          // (a) find values of
          //       $n: instances in atbop (already have that, actually)
          //       $v: $v is a value for $a
          //       $k: $k is a class
          //     that maximize L' = Laplace({$x: $x contained in cases($n)
          //           &amp; value($a,$x) = $v}, $k).
<span class="fc" id="L855">          double bestVal = Double.NaN;</span>
<span class="fc" id="L856">          double bestClass = Double.NaN;</span>
<span class="fc" id="L857">          double bestLaplace = leafLaplace;</span>
<span class="fc" id="L858">          double [][] bestCounts = null;</span>
<span class="fc" id="L859">          double [][] counts = new double[2][n.numClasses()];</span>

<span class="fc bfc" id="L861" title="All 2 branches covered.">          for(int x = 0; x &lt; n.numInstances(); x++) {</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">             if(n.instance(sorted[x]).isMissing(a))</span>
<span class="fc" id="L863">                continue;</span>

             // zero the counts
<span class="fc bfc" id="L866" title="All 2 branches covered.">             for(int c = 0; c &lt; n.numClasses(); c++)</span>
<span class="fc" id="L867">                counts[0][c] = 0;</span>

<span class="fc" id="L869">             double theval = n.instance(sorted[x]).value(a);</span>
<span class="fc" id="L870">             counts[0][(int)n.instance(sorted[x]).classValue()] </span>
<span class="fc" id="L871">               += iindex[1][sorted[x]];</span>

<span class="pc bpc" id="L873" title="1 of 2 branches missed.">             if(x != n.numInstances() - 1) {</span>
<span class="fc" id="L874">                int z = x + 1;</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">                while(z &lt; n.numInstances() </span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">                 &amp;&amp; n.instance(sorted[z]).value(a) == theval) {</span>
<span class="fc" id="L877">                   z++; x++;</span>
<span class="fc" id="L878">                   counts[0][(int)n.instance(sorted[x]).classValue()]</span>
<span class="fc" id="L879">                      += iindex[1][sorted[x]];</span>
                }
             }

<span class="pc bpc" id="L883" title="1 of 2 branches missed.">             if(!prohibit[(int)theval]) {</span>
                // work out best laplace for &gt; theval
<span class="nc" id="L885">                double total = Utils.sum(counts[0]);</span>
<span class="nc" id="L886">                bestLaplace = leafLaplace;</span>
<span class="nc" id="L887">                bestClass = Double.NaN;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                for(int c = 0; c &lt; n.numClasses(); c++) {</span>
<span class="nc" id="L889">                   double temp = (counts[0][c]+1.0)/(total+2.0);</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                   if(temp &gt; bestLaplace</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                    &amp;&amp; biprob(counts[0][c],total,leafLaplace) &gt; m_BiProbCrit) {</span>
<span class="nc" id="L892">                      bestLaplace = temp;</span>
<span class="nc" id="L893">                      bestClass = c;</span>
<span class="nc" id="L894">                      bestVal = theval;</span>
<span class="nc" id="L895">                      bestCounts = copyCounts(counts);</span>
                   }
                }
		// add to graft list
<span class="nc bnc" id="L899" title="All 2 branches missed.">                if(!Double.isNaN(bestClass)) {</span>
<span class="nc" id="L900">                   GraftSplit gsplit = null;</span>
                   try {
<span class="nc" id="L902">                      gsplit = new GraftSplit(a, bestVal, 2,</span>
<span class="nc" id="L903">                         leafClass, bestCounts);</span>
<span class="nc" id="L904">                   } catch (Exception e) {</span>
<span class="nc" id="L905">                     System.err.println(&quot;graftsplit error: &quot;+e.getMessage());</span>
<span class="nc" id="L906">                     System.exit(1);</span>
                   }
<span class="nc" id="L908">                   t.add(gsplit);</span>
                }
             }
          }
          // (b) add to t tuple &lt;n,a,v,k,L',&quot;=&quot;&gt;
          // done this already
       }
    }

    // 4. remove from t all tuples &lt;n,a,v,c,L,x&gt; such that L &lt;=
    //    Laplace(cases(l),c) or prob(x,n,Laplace(cases(l),c) &lt;= 0.05
    //      -- checked this constraint prior to adding a tuple --

    // *** step six done before step five for efficiency ***
    // 6. for each &lt;n,a,v,k,L,x&gt; in t ordered on L from highest to lowest
    // order the tuples from highest to lowest laplace
    // (this actually orders lowest to highest)
<span class="fc" id="L925">    Collections.sort(t);</span>

    // 5. remove from t all tuples &lt;n,a,v,c,L,x&gt; such that there is
    //    no tuple &lt;n',a',v',k',L',x'&gt; such that k' != c &amp; L' &lt; L.
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">    for(int x = 0; x &lt; t.size(); x++) {</span>
<span class="nc" id="L930">       GraftSplit gs = (GraftSplit)t.get(x);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">       if(gs.maxClassForSubsetOfInterest() != leafClass) {</span>
<span class="nc" id="L932">          break; // reached a graft with class != leafClass, so stop deleting</span>
       } else {
<span class="nc" id="L934">          t.remove(x);</span>
<span class="nc" id="L935">          x--;</span>
       }
    }

    // if no potential grafts were found, do nothing and return
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">    if(t.size() &lt; 1) {</span>
<span class="fc" id="L941">       return;</span>
    }

    // create the distributions for each graft
<span class="nc bnc" id="L945" title="All 2 branches missed.">    for(int x = t.size()-1; x &gt;= 0; x--) {</span>
<span class="nc" id="L946">       GraftSplit gs = (GraftSplit)t.get(x);</span>
       try {
<span class="nc" id="L948">          gs.buildClassifier(l);</span>
<span class="nc" id="L949">          gs.deleteGraftedCases(l); // so they don't go down the other branch</span>
<span class="nc" id="L950">       } catch (Exception e) {</span>
<span class="nc" id="L951">          System.err.println(&quot;graftsplit build error: &quot; + e.getMessage());</span>
       }
    }

    // add this stuff to the tree
<span class="nc" id="L956">    ((C45PruneableClassifierTreeG)parent).setDescendents(t, this);</span>
<span class="nc" id="L957">  }</span>

  /**
   * sorts the int array in ascending order by attribute indexed 
   * by a in dataset data.  
   * @param the data the indices represent
   * @param the index of the attribute to sort by
   * @return array of sorted indicies
   */
  private int [] sortByAttribute(Instances data, int a) {

<span class="fc" id="L968">    double [] attList = data.attributeToDoubleArray(a);</span>
<span class="fc" id="L969">    int [] temp = Utils.sort(attList);</span>
<span class="fc" id="L970">    return temp;</span>
  }

  /**
   * deep copy the 2d array of counts
   *
   * @param src the array to copy
   * @return a copy of src
   */
  private double [][] copyCounts(double [][] src) {

<span class="fc" id="L981">    double [][] newArr = new double[src.length][0];</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">    for(int x = 0; x &lt; src.length; x++) {</span>
<span class="fc" id="L983">       newArr[x] = new double[src[x].length];</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">       for(int y = 0; y &lt; src[x].length; y++) {</span>
<span class="fc" id="L985">          newArr[x][y] = src[x][y];</span>
       }
    }
<span class="fc" id="L988">    return newArr;</span>
  }
  

  /**
   * Help method for computing class probabilities of
   * a given instance.
   *
   * @throws Exception if something goes wrong
   */
  private double getProbsLaplace(int classIndex, Instance instance, double weight)
       throws Exception {

    double [] weights;
<span class="nc" id="L1002">    double prob = 0;</span>
    int treeIndex;
    int i,j;

<span class="nc bnc" id="L1006" title="All 2 branches missed.">    if (m_isLeaf) {</span>
<span class="nc" id="L1007">       return weight * localModel().classProbLaplace(classIndex, instance, -1);</span>
    } else {
<span class="nc" id="L1009">       treeIndex = localModel().whichSubset(instance);</span>

<span class="nc bnc" id="L1011" title="All 2 branches missed.">       if (treeIndex == -1) {</span>
<span class="nc" id="L1012">          weights = localModel().weights(instance);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">          for (i = 0; i &lt; m_sons.length; i++) {</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">             if (!son(i).m_isEmpty) {</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                if (!son(i).m_isLeaf) {</span>
<span class="nc" id="L1016">                   prob += son(i).getProbsLaplace(classIndex, instance,</span>
<span class="nc" id="L1017">                                                  weights[i] * weight);</span>
                } else {
<span class="nc" id="L1019">                   prob += weight * weights[i] *</span>
<span class="nc" id="L1020">                     localModel().classProbLaplace(classIndex, instance, i);</span>
                }
             }
          }
<span class="nc" id="L1024">          return prob;</span>
       } else {

<span class="nc bnc" id="L1027" title="All 2 branches missed.">          if (son(treeIndex).m_isLeaf) {</span>
<span class="nc" id="L1028">             return weight * localModel().classProbLaplace(classIndex, instance,</span>
<span class="nc" id="L1029">                                                           treeIndex);</span>
          } else {
<span class="nc" id="L1031">             return son(treeIndex).getProbsLaplace(classIndex,instance,weight);</span>
          }
       }
    }
  }


  /**
   * Help method for computing class probabilities of
   * a given instance.
   *
   * @throws Exception if something goes wrong
   */
  private double getProbs(int classIndex, Instance instance, double weight)
      throws Exception {

    double [] weights;
<span class="nc" id="L1048">    double prob = 0;</span>
    int treeIndex;
    int i,j;

<span class="nc bnc" id="L1052" title="All 2 branches missed.">    if (m_isLeaf) {</span>
<span class="nc" id="L1053">       return weight * localModel().classProb(classIndex, instance, -1);</span>
    } else {
<span class="nc" id="L1055">       treeIndex = localModel().whichSubset(instance);</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">       if (treeIndex == -1) {</span>
<span class="nc" id="L1057">          weights = localModel().weights(instance);</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">          for (i = 0; i &lt; m_sons.length; i++) {</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">             if (!son(i).m_isEmpty) {</span>
<span class="nc" id="L1060">                prob += son(i).getProbs(classIndex, instance,</span>
<span class="nc" id="L1061">                                 weights[i] * weight);</span>
             }
          }
<span class="nc" id="L1064">          return prob;</span>
       } else {

<span class="nc bnc" id="L1067" title="All 2 branches missed.">          if (son(treeIndex).m_isEmpty) {</span>
<span class="nc" id="L1068">             return weight * localModel().classProb(classIndex, instance,</span>
<span class="nc" id="L1069">                                                    treeIndex);</span>
          } else {
<span class="nc" id="L1071">             return son(treeIndex).getProbs(classIndex, instance, weight);</span>
          }
       }
    }
  }



  /**
   * add the grafted nodes at originalLeaf's position in tree.
   * a recursive function that terminates when t is empty.
   * 
   * @param t the list of nodes to graft
   * @param originalLeaf the leaf that the grafts are replacing
   */
  public void setDescendents(ArrayList t, 
                             C45PruneableClassifierTreeG originalLeaf) {

<span class="nc" id="L1089">    Instances headerInfo = new Instances(m_train, 0);</span>

<span class="nc" id="L1091">    boolean end = false;</span>
<span class="nc" id="L1092">    ClassifierSplitModel splitmod = null;</span>
    C45PruneableClassifierTreeG newNode;
<span class="nc bnc" id="L1094" title="All 2 branches missed.">    if(t.size() &gt; 0) {</span>
<span class="nc" id="L1095">       splitmod = (ClassifierSplitModel)t.remove(t.size() - 1);</span>
<span class="nc" id="L1096">       newNode = new C45PruneableClassifierTreeG(m_toSelectModel, headerInfo,</span>
<span class="nc" id="L1097">                           splitmod, m_pruneTheTree, m_CF, m_subtreeRaising,</span>
<span class="nc" id="L1098">                           false, m_relabel, m_cleanup);</span>
    } else {
       // get the leaf for one of newNode's children
<span class="nc" id="L1101">       NoSplit kLeaf = ((GraftSplit)localModel()).getOtherLeaf();</span>
<span class="nc" id="L1102">       newNode = </span>
<span class="nc" id="L1103">             new C45PruneableClassifierTreeG(m_toSelectModel, headerInfo,</span>
<span class="nc" id="L1104">                           kLeaf, m_pruneTheTree, m_CF, m_subtreeRaising,</span>
<span class="nc" id="L1105">                           true, m_relabel, m_cleanup);</span>
<span class="nc" id="L1106">       end = true;</span>
    }

    // behave differently for parent of original leaf, since we don't
    // want to destroy any of its other branches
<span class="nc bnc" id="L1111" title="All 2 branches missed.">    if(m_sons != null) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">       for(int x = 0; x &lt; m_sons.length; x++) {</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">          if(son(x).equals(originalLeaf)) {</span>
<span class="nc" id="L1114">             m_sons[x] = newNode;  // replace originalLeaf with newNode</span>
          }
       }
    } else {

       // allocate space for the children
<span class="nc" id="L1120">       m_sons = new C45PruneableClassifierTreeG[localModel().numSubsets()];</span>
 
       // get the leaf for one of newNode's children
<span class="nc" id="L1123">       NoSplit kLeaf = ((GraftSplit)localModel()).getLeaf();</span>
<span class="nc" id="L1124">       C45PruneableClassifierTreeG kNode = </span>
<span class="nc" id="L1125">                 new C45PruneableClassifierTreeG(m_toSelectModel, headerInfo,</span>
<span class="nc" id="L1126">                               kLeaf, m_pruneTheTree, m_CF, m_subtreeRaising,</span>
<span class="nc" id="L1127">                               true, m_relabel, m_cleanup);</span>
 
       // figure where to put the new node
<span class="nc bnc" id="L1130" title="All 2 branches missed.">       if(((GraftSplit)localModel()).subsetOfInterest() == 0) {</span>
<span class="nc" id="L1131">          m_sons[0] = kNode;</span>
<span class="nc" id="L1132">          m_sons[1] = newNode;</span>
       } else {
<span class="nc" id="L1134">          m_sons[0] = newNode;</span>
<span class="nc" id="L1135">          m_sons[1] = kNode;</span>
       }
    }
<span class="nc bnc" id="L1138" title="All 2 branches missed.">    if(!end)</span>
<span class="nc" id="L1139">       ((C45PruneableClassifierTreeG)newNode).setDescendents</span>
<span class="nc" id="L1140">                  (t, (C45PruneableClassifierTreeG)originalLeaf);</span>
<span class="nc" id="L1141">  }</span>


  /**
   *  class prob with laplace correction (assumes binary class)
   */
  private double laplaceLeaf(double classIndex) {
<span class="fc" id="L1148">    double l =  (localModel().distribution().perClass((int)classIndex) + 1.0)</span>
<span class="fc" id="L1149">               / (localModel().distribution().total() + 2.0);</span>
<span class="fc" id="L1150">    return l;</span>
  }


  /**
   * Significance test
   * @param double  x, double  n, double r.
   * @return returns the probability of obtaining x or MORE out of n
   * if r proportion of n are positive.
   *
   * z for normal estimation of binomial probability of obtaining x 
   * or more out of n, if r proportion of n are positive
   */
  public double biprob(double x, double n, double r) throws Exception {

<span class="fc" id="L1165">    return ((((x) - 0.5) - (n) * (r)) / Math.sqrt((n) * (r) * (1.0 - (r))));</span>
  }

  /**
   * Prints tree structure.
   */
  public String toString() {

    try {
<span class="nc" id="L1174">       StringBuffer text = new StringBuffer();</span>

<span class="nc bnc" id="L1176" title="All 2 branches missed.">       if(m_isLeaf) {</span>
<span class="nc" id="L1177">          text.append(&quot;: &quot;);</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">          if(m_localModel instanceof GraftSplit)</span>
<span class="nc" id="L1179">             text.append(((GraftSplit)m_localModel).dumpLabelG(0,m_train));</span>
          else
<span class="nc" id="L1181">             text.append(m_localModel.dumpLabel(0,m_train));</span>
       } else
<span class="nc" id="L1183">          dumpTree(0,text);</span>
<span class="nc" id="L1184">       text.append(&quot;\n\nNumber of Leaves  : \t&quot;+numLeaves()+&quot;\n&quot;);</span>
<span class="nc" id="L1185">       text.append(&quot;\nSize of the tree : \t&quot;+numNodes()+&quot;\n&quot;);</span>

<span class="nc" id="L1187">       return text.toString();</span>
<span class="nc" id="L1188">    } catch (Exception e) {</span>
<span class="nc" id="L1189">       return &quot;Can't print classification tree.&quot;;</span>
    }
  }

  /**
   * Help method for printing tree structure.
   *
   * @throws Exception if something goes wrong
   */
  protected void dumpTree(int depth,StringBuffer text) throws Exception {

    int i,j;

<span class="nc bnc" id="L1202" title="All 2 branches missed.">    for(i=0;i&lt;m_sons.length;i++) {</span>
<span class="nc" id="L1203">       text.append(&quot;\n&quot;);;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">       for(j=0;j&lt;depth;j++)</span>
<span class="nc" id="L1205">          text.append(&quot;|   &quot;);</span>
<span class="nc" id="L1206">       text.append(m_localModel.leftSide(m_train));</span>
<span class="nc" id="L1207">       text.append(m_localModel.rightSide(i, m_train));</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">       if(m_sons[i].m_isLeaf) {</span>
<span class="nc" id="L1209">          text.append(&quot;: &quot;);</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">          if(m_localModel instanceof GraftSplit)</span>
<span class="nc" id="L1211">             text.append(((GraftSplit)m_localModel).dumpLabelG(i,m_train));</span>
          else
<span class="nc" id="L1213">             text.append(m_localModel.dumpLabel(i,m_train));</span>
       } else
<span class="nc" id="L1215">          ((C45PruneableClassifierTreeG)m_sons[i]).dumpTree(depth+1,text);</span>
     }
<span class="nc" id="L1217">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1225">    return RevisionUtils.extract(&quot;$Revision: 5535 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>