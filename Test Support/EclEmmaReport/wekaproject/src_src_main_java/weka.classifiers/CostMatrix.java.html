<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CostMatrix.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers</a> &gt; <span class="el_source">CostMatrix.java</span></div><h1>CostMatrix.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    CostMatrix.java
 *    Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers;

import java.io.LineNumberReader;
import java.io.Reader;
import java.io.Serializable;
import java.io.StreamTokenizer;
import java.io.Writer;
import java.util.Random;
import java.util.StringTokenizer;

import weka.core.AttributeExpression;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;

/**
 * Class for storing and manipulating a misclassification cost matrix. The
 * element at position i,j in the matrix is the penalty for classifying an
 * instance of class j as class i. Cost values can be fixed or computed on a
 * per-instance basis (cost sensitive evaluation only) from the value of an
 * attribute or an expression involving attribute(s).
 * 
 * @author Mark Hall
 * @author Richard Kirkby (rkirkby@cs.waikato.ac.nz)
 * @version $Revision: 9048 $
 */
<span class="fc" id="L51">public class CostMatrix implements Serializable, RevisionHandler {</span>

  /** for serialization */
  private static final long serialVersionUID = -1973792250544554965L;

  private int m_size;

  /** [rows][columns] */
  protected Object[][] m_matrix;

  /** The deafult file extension for cost matrix files */
<span class="fc" id="L62">  public static String FILE_EXTENSION = &quot;.cost&quot;;</span>

  /**
   * Creates a default cost matrix of a particular size. All diagonal values
   * will be 0 and all non-diagonal values 1.
   * 
   * @param numOfClasses the number of classes that the cost matrix holds.
   */
<span class="fc" id="L70">  public CostMatrix(int numOfClasses) {</span>
<span class="fc" id="L71">    m_size = numOfClasses;</span>
<span class="fc" id="L72">    initialize();</span>
<span class="fc" id="L73">  }</span>

  /**
   * Creates a cost matrix that is a copy of another.
   * 
   * @param toCopy the matrix to copy.
   */
  public CostMatrix(CostMatrix toCopy) {
<span class="nc" id="L81">    this(toCopy.size());</span>

<span class="nc bnc" id="L83" title="All 2 branches missed.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      for (int j = 0; j &lt; m_size; j++) {</span>
<span class="nc" id="L85">        setCell(i, j, toCopy.getCell(i, j));</span>
      }
    }
<span class="nc" id="L88">  }</span>

  /**
   * Initializes the matrix
   */
  public void initialize() {
<span class="fc" id="L94">    m_matrix = new Object[m_size][m_size];</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">      for (int j = 0; j &lt; m_size; j++) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        setCell(i, j, i == j ? new Double(0.0) : new Double(1.0));</span>
      }
    }
<span class="fc" id="L100">  }</span>

  /**
   * The number of rows (and columns)
   * 
   * @return the size of the matrix
   */
  public int size() {
<span class="fc" id="L108">    return m_size;</span>
  }

  /**
   * Same as size
   * 
   * @return the number of columns
   */
  public int numColumns() {
<span class="nc" id="L117">    return size();</span>
  }

  /**
   * Same as size
   * 
   * @return the number of rows
   */
  public int numRows() {
<span class="fc" id="L126">    return size();</span>
  }

  private boolean replaceStrings() throws Exception {
<span class="fc" id="L130">    boolean nonDouble = false;</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">      for (int j = 0; j &lt; m_size; j++) {</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (getCell(i, j) instanceof String) {</span>
<span class="nc" id="L135">          AttributeExpression temp = new AttributeExpression();</span>
<span class="nc" id="L136">          temp.convertInfixToPostfix((String) getCell(i, j));</span>
<span class="nc" id="L137">          setCell(i, j, temp);</span>
<span class="nc" id="L138">          nonDouble = true;</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        } else if (getCell(i, j) instanceof AttributeExpression) {</span>
<span class="nc" id="L140">          nonDouble = true;</span>
        }
      }
    }

<span class="fc" id="L145">    return nonDouble;</span>
  }

  /**
   * Applies the cost matrix to a set of instances. If a random number generator
   * is supplied the instances will be resampled, otherwise they will be
   * rewighted. Adapted from code once sitting in Instances.java
   * 
   * @param data the instances to reweight.
   * @param random a random number generator for resampling, if null then
   *          instances are rewighted.
   * @return a new dataset reflecting the cost of misclassification.
   * @exception Exception if the data has no class or the matrix in
   *              inappropriate.
   */
  public Instances applyCostMatrix(Instances data, Random random)
      throws Exception {

<span class="fc" id="L163">    double sumOfWeightFactors = 0, sumOfMissClassWeights, sumOfWeights;</span>
    double[] weightOfInstancesInClass, weightFactor, weightOfInstances;
    Instances newData;

<span class="pc bpc" id="L167" title="1 of 2 branches missed.">    if (data.classIndex() &lt; 0) {</span>
<span class="nc" id="L168">      throw new Exception(&quot;Class index is not set!&quot;);</span>
    }

<span class="pc bpc" id="L171" title="1 of 2 branches missed.">    if (size() != data.numClasses()) {</span>
<span class="nc" id="L172">      throw new Exception(&quot;Misclassification cost matrix has &quot;</span>
          + &quot;wrong format!&quot;);
    }

    // are there any non-fixed, per-instance costs defined in the matrix?
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">    if (replaceStrings()) {</span>
      // could reweight in the two class case
<span class="nc bnc" id="L179" title="All 2 branches missed.">      if (data.classAttribute().numValues() &gt; 2) {</span>
<span class="nc" id="L180">        throw new Exception(&quot;Can't resample/reweight instances using &quot;</span>
            + &quot;non-fixed cost values when there are more &quot;
            + &quot;than two classes!&quot;);
      } else {
        // Store new weights
<span class="nc" id="L185">        weightOfInstances = new double[data.numInstances()];</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L187">          Instance inst = data.instance(i);</span>
<span class="nc" id="L188">          int classValIndex = (int) inst.classValue();</span>
<span class="nc" id="L189">          double factor = 1.0;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">          Object element = (classValIndex == 0) ? getCell(classValIndex, 1)</span>
<span class="nc" id="L191">              : getCell(classValIndex, 0);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">          if (element instanceof Double) {</span>
<span class="nc" id="L193">            factor = ((Double) element).doubleValue();</span>
          } else {
<span class="nc" id="L195">            factor = ((AttributeExpression) element).evaluateExpression(inst);</span>
          }
<span class="nc" id="L197">          weightOfInstances[i] = inst.weight() * factor;</span>
          /*
           * System.err.println(&quot;Multiplying &quot; +
           * inst.classAttribute().value((int)inst.classValue()) +&quot; by factor &quot;
           * + factor);
           */
        }

        // Change instances weight or do resampling
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (random != null) {</span>
<span class="nc" id="L207">          return data.resampleWithWeights(random, weightOfInstances);</span>
        } else {
<span class="nc" id="L209">          Instances instances = new Instances(data);</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">          for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L211">            instances.instance(i).setWeight(weightOfInstances[i]);</span>
          }
<span class="nc" id="L213">          return instances;</span>
        }
      }
    }

<span class="fc" id="L218">    weightFactor = new double[data.numClasses()];</span>
<span class="fc" id="L219">    weightOfInstancesInClass = new double[data.numClasses()];</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">    for (int j = 0; j &lt; data.numInstances(); j++) {</span>
<span class="fc" id="L221">      weightOfInstancesInClass[(int) data.instance(j).classValue()] += data</span>
<span class="fc" id="L222">          .instance(j).weight();</span>
    }
<span class="fc" id="L224">    sumOfWeights = Utils.sum(weightOfInstancesInClass);</span>

    // normalize the matrix if not already
<span class="fc bfc" id="L227" title="All 2 branches covered.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">      if (!Utils.eq(((Double) getCell(i, i)).doubleValue(), 0)) {</span>
<span class="nc" id="L229">        CostMatrix normMatrix = new CostMatrix(this);</span>
<span class="nc" id="L230">        normMatrix.normalize();</span>
<span class="nc" id="L231">        return normMatrix.applyCostMatrix(data, random);</span>
      }
    }

<span class="fc bfc" id="L235" title="All 2 branches covered.">    for (int i = 0; i &lt; data.numClasses(); i++) {</span>
      // Using Kai Ming Ting's formula for deriving weights for
      // the classes and Breiman's heuristic for multiclass
      // problems.

<span class="fc" id="L240">      sumOfMissClassWeights = 0;</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">      for (int j = 0; j &lt; data.numClasses(); j++) {</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (Utils.sm(((Double) getCell(i, j)).doubleValue(), 0)) {</span>
<span class="nc" id="L243">          throw new Exception(&quot;Neg. weights in misclassification &quot;</span>
              + &quot;cost matrix!&quot;);
        }
<span class="fc" id="L246">        sumOfMissClassWeights += ((Double) getCell(i, j)).doubleValue();</span>
      }
<span class="fc" id="L248">      weightFactor[i] = sumOfMissClassWeights * sumOfWeights;</span>
<span class="fc" id="L249">      sumOfWeightFactors += sumOfMissClassWeights * weightOfInstancesInClass[i];</span>
    }
<span class="fc bfc" id="L251" title="All 2 branches covered.">    for (int i = 0; i &lt; data.numClasses(); i++) {</span>
<span class="fc" id="L252">      weightFactor[i] /= sumOfWeightFactors;</span>
    }

    // Store new weights
<span class="fc" id="L256">    weightOfInstances = new double[data.numInstances()];</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc" id="L258">      weightOfInstances[i] = data.instance(i).weight()</span>
<span class="fc" id="L259">          * weightFactor[(int) data.instance(i).classValue()];</span>
    }

    // Change instances weight or do resampling
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">    if (random != null) {</span>
<span class="nc" id="L264">      return data.resampleWithWeights(random, weightOfInstances);</span>
    } else {
<span class="fc" id="L266">      Instances instances = new Instances(data);</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">      for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="fc" id="L268">        instances.instance(i).setWeight(weightOfInstances[i]);</span>
      }
<span class="fc" id="L270">      return instances;</span>
    }
  }

  /**
   * Calculates the expected misclassification cost for each possible class
   * value, given class probability estimates.
   * 
   * @param classProbs the class probability estimates.
   * @return the expected costs.
   * @exception Exception if the wrong number of class probabilities is
   *              supplied.
   */
  public double[] expectedCosts(double[] classProbs) throws Exception {

<span class="pc bpc" id="L285" title="1 of 2 branches missed.">    if (classProbs.length != m_size) {</span>
<span class="nc" id="L286">      throw new Exception(&quot;Length of probability estimates don't &quot;</span>
          + &quot;match cost matrix&quot;);
    }

<span class="fc" id="L290">    double[] costs = new double[m_size];</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">    for (int x = 0; x &lt; m_size; x++) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">      for (int y = 0; y &lt; m_size; y++) {</span>
<span class="fc" id="L294">        Object element = getCell(y, x);</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (!(element instanceof Double)) {</span>
<span class="nc" id="L296">          throw new Exception(&quot;Can't use non-fixed costs in &quot;</span>
              + &quot;computing expected costs.&quot;);
        }
<span class="fc" id="L299">        costs[x] += classProbs[y] * ((Double) element).doubleValue();</span>
      }
    }

<span class="fc" id="L303">    return costs;</span>
  }

  /**
   * Calculates the expected misclassification cost for each possible class
   * value, given class probability estimates.
   * 
   * @param classProbs the class probability estimates.
   * @param inst the current instance for which the class probabilites apply. Is
   *          used for computing any non-fixed cost values.
   * @return the expected costs.
   * @exception Exception if something goes wrong
   */
  public double[] expectedCosts(double[] classProbs, Instance inst)
      throws Exception {

<span class="nc bnc" id="L319" title="All 2 branches missed.">    if (classProbs.length != m_size) {</span>
<span class="nc" id="L320">      throw new Exception(&quot;Length of probability estimates don't &quot;</span>
          + &quot;match cost matrix&quot;);
    }

<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (!replaceStrings()) {</span>
<span class="nc" id="L325">      return expectedCosts(classProbs);</span>
    }

<span class="nc" id="L328">    double[] costs = new double[m_size];</span>

<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int x = 0; x &lt; m_size; x++) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      for (int y = 0; y &lt; m_size; y++) {</span>
<span class="nc" id="L332">        Object element = getCell(y, x);</span>
        double costVal;
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (!(element instanceof Double)) {</span>
<span class="nc" id="L335">          costVal = ((AttributeExpression) element).evaluateExpression(inst);</span>
        } else {
<span class="nc" id="L337">          costVal = ((Double) element).doubleValue();</span>
        }
<span class="nc" id="L339">        costs[x] += classProbs[y] * costVal;</span>
      }
    }

<span class="nc" id="L343">    return costs;</span>
  }

  /**
   * Gets the maximum cost for a particular class value.
   * 
   * @param classVal the class value.
   * @return the maximum cost.
   * @exception Exception if cost matrix contains non-fixed costs
   */
  public double getMaxCost(int classVal) throws Exception {

<span class="nc" id="L355">    double maxCost = Double.NEGATIVE_INFINITY;</span>

<span class="nc bnc" id="L357" title="All 2 branches missed.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="nc" id="L358">      Object element = getCell(classVal, i);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">      if (!(element instanceof Double)) {</span>
<span class="nc" id="L360">        throw new Exception(&quot;Can't use non-fixed costs when &quot;</span>
            + &quot;getting max cost.&quot;);
      }
<span class="nc" id="L363">      double cost = ((Double) element).doubleValue();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">      if (cost &gt; maxCost)</span>
<span class="nc" id="L365">        maxCost = cost;</span>
    }

<span class="nc" id="L368">    return maxCost;</span>
  }

  /**
   * Gets the maximum cost for a particular class value.
   * 
   * @param classVal the class value.
   * @return the maximum cost.
   * @exception Exception if cost matrix contains non-fixed costs
   */
  public double getMaxCost(int classVal, Instance inst) throws Exception {

<span class="nc bnc" id="L380" title="All 2 branches missed.">    if (!replaceStrings()) {</span>
<span class="nc" id="L381">      return getMaxCost(classVal);</span>
    }

<span class="nc" id="L384">    double maxCost = Double.NEGATIVE_INFINITY;</span>
    double cost;
<span class="nc bnc" id="L386" title="All 2 branches missed.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="nc" id="L387">      Object element = getCell(classVal, i);</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">      if (!(element instanceof Double)) {</span>
<span class="nc" id="L389">        cost = ((AttributeExpression) element).evaluateExpression(inst);</span>
      } else {
<span class="nc" id="L391">        cost = ((Double) element).doubleValue();</span>
      }
<span class="nc bnc" id="L393" title="All 2 branches missed.">      if (cost &gt; maxCost)</span>
<span class="nc" id="L394">        maxCost = cost;</span>
    }

<span class="nc" id="L397">    return maxCost;</span>
  }

  /**
   * Normalizes the matrix so that the diagonal contains zeros.
   * 
   */
  public void normalize() {

<span class="nc bnc" id="L406" title="All 2 branches missed.">    for (int y = 0; y &lt; m_size; y++) {</span>
<span class="nc" id="L407">      double diag = ((Double) getCell(y, y)).doubleValue();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">      for (int x = 0; x &lt; m_size; x++) {</span>
<span class="nc" id="L409">        setCell(x, y, new Double(((Double) getCell(x, y)).doubleValue() - diag));</span>
      }
    }
<span class="nc" id="L412">  }</span>

  /**
   * Loads a cost matrix in the old format from a reader. Adapted from code once
   * sitting in Instances.java
   * 
   * @param reader the reader to get the values from.
   * @exception Exception if the matrix cannot be read correctly.
   */
  public void readOldFormat(Reader reader) throws Exception {

    StreamTokenizer tokenizer;
    int currentToken;
    double firstIndex, secondIndex, weight;

<span class="nc" id="L427">    tokenizer = new StreamTokenizer(reader);</span>

<span class="nc" id="L429">    initialize();</span>

<span class="nc" id="L431">    tokenizer.commentChar('%');</span>
<span class="nc" id="L432">    tokenizer.eolIsSignificant(true);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">    while (StreamTokenizer.TT_EOF != (currentToken = tokenizer.nextToken())) {</span>

      // Skip empty lines
<span class="nc bnc" id="L436" title="All 2 branches missed.">      if (currentToken == StreamTokenizer.TT_EOL) {</span>
<span class="nc" id="L437">        continue;</span>
      }

      // Get index of first class.
<span class="nc bnc" id="L441" title="All 2 branches missed.">      if (currentToken != StreamTokenizer.TT_NUMBER) {</span>
<span class="nc" id="L442">        throw new Exception(&quot;Only numbers and comments allowed &quot;</span>
            + &quot;in cost file!&quot;);
      }
<span class="nc" id="L445">      firstIndex = tokenizer.nval;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">      if (!Utils.eq((int) firstIndex, firstIndex)) {</span>
<span class="nc" id="L447">        throw new Exception(&quot;First number in line has to be &quot;</span>
            + &quot;index of a class!&quot;);
      }
<span class="nc bnc" id="L450" title="All 2 branches missed.">      if ((int) firstIndex &gt;= size()) {</span>
<span class="nc" id="L451">        throw new Exception(&quot;Class index out of range!&quot;);</span>
      }

      // Get index of second class.
<span class="nc bnc" id="L455" title="All 2 branches missed.">      if (StreamTokenizer.TT_EOF == (currentToken = tokenizer.nextToken())) {</span>
<span class="nc" id="L456">        throw new Exception(&quot;Premature end of file!&quot;);</span>
      }
<span class="nc bnc" id="L458" title="All 2 branches missed.">      if (currentToken == StreamTokenizer.TT_EOL) {</span>
<span class="nc" id="L459">        throw new Exception(&quot;Premature end of line!&quot;);</span>
      }
<span class="nc bnc" id="L461" title="All 2 branches missed.">      if (currentToken != StreamTokenizer.TT_NUMBER) {</span>
<span class="nc" id="L462">        throw new Exception(&quot;Only numbers and comments allowed &quot;</span>
            + &quot;in cost file!&quot;);
      }
<span class="nc" id="L465">      secondIndex = tokenizer.nval;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">      if (!Utils.eq((int) secondIndex, secondIndex)) {</span>
<span class="nc" id="L467">        throw new Exception(&quot;Second number in line has to be &quot;</span>
            + &quot;index of a class!&quot;);
      }
<span class="nc bnc" id="L470" title="All 2 branches missed.">      if ((int) secondIndex &gt;= size()) {</span>
<span class="nc" id="L471">        throw new Exception(&quot;Class index out of range!&quot;);</span>
      }
<span class="nc bnc" id="L473" title="All 2 branches missed.">      if ((int) secondIndex == (int) firstIndex) {</span>
<span class="nc" id="L474">        throw new Exception(&quot;Diagonal of cost matrix non-zero!&quot;);</span>
      }

      // Get cost factor.
<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (StreamTokenizer.TT_EOF == (currentToken = tokenizer.nextToken())) {</span>
<span class="nc" id="L479">        throw new Exception(&quot;Premature end of file!&quot;);</span>
      }
<span class="nc bnc" id="L481" title="All 2 branches missed.">      if (currentToken == StreamTokenizer.TT_EOL) {</span>
<span class="nc" id="L482">        throw new Exception(&quot;Premature end of line!&quot;);</span>
      }
<span class="nc bnc" id="L484" title="All 2 branches missed.">      if (currentToken != StreamTokenizer.TT_NUMBER) {</span>
<span class="nc" id="L485">        throw new Exception(&quot;Only numbers and comments allowed &quot;</span>
            + &quot;in cost file!&quot;);
      }
<span class="nc" id="L488">      weight = tokenizer.nval;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">      if (!Utils.gr(weight, 0)) {</span>
<span class="nc" id="L490">        throw new Exception(&quot;Only positive weights allowed!&quot;);</span>
      }
<span class="nc" id="L492">      setCell((int) firstIndex, (int) secondIndex, new Double(weight));</span>
    }
<span class="nc" id="L494">  }</span>

  /**
   * Reads a matrix from a reader. The first line in the file should contain the
   * number of rows and columns. Subsequent lines contain elements of the
   * matrix. (FracPete: taken from old weka.core.Matrix class)
   * 
   * @param reader the reader containing the matrix
   * @throws Exception if an error occurs
   * @see #write(Writer)
   */
<span class="fc" id="L505">  public CostMatrix(Reader reader) throws Exception {</span>
<span class="fc" id="L506">    LineNumberReader lnr = new LineNumberReader(reader);</span>
    String line;
<span class="fc" id="L508">    int currentRow = -1;</span>

<span class="fc bfc" id="L510" title="All 2 branches covered.">    while ((line = lnr.readLine()) != null) {</span>

      // Comments
<span class="fc bfc" id="L513" title="All 2 branches covered.">      if (line.startsWith(&quot;%&quot;)) {</span>
<span class="fc" id="L514">        continue;</span>
      }

<span class="fc" id="L517">      StringTokenizer st = new StringTokenizer(line);</span>
      // Ignore blank lines
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">      if (!st.hasMoreTokens()) {</span>
<span class="nc" id="L520">        continue;</span>
      }

<span class="fc bfc" id="L523" title="All 2 branches covered.">      if (currentRow &lt; 0) {</span>
<span class="fc" id="L524">        int rows = Integer.parseInt(st.nextToken());</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">        if (!st.hasMoreTokens()) {</span>
<span class="nc" id="L526">          throw new Exception(&quot;Line &quot; + lnr.getLineNumber()</span>
<span class="nc" id="L527">              + &quot;: expected number of columns&quot;);</span>
        }

<span class="fc" id="L530">        int cols = Integer.parseInt(st.nextToken());</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">        if (rows != cols) {</span>
<span class="nc" id="L532">          throw new Exception(&quot;Trying to create a non-square cost &quot; + &quot;matrix&quot;);</span>
        }
        // m_matrix = new Object[rows][cols];
<span class="fc" id="L535">        m_size = rows;</span>
<span class="fc" id="L536">        initialize();</span>
<span class="fc" id="L537">        currentRow++;</span>
<span class="fc" id="L538">        continue;</span>

      } else {
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">        if (currentRow == m_size) {</span>
<span class="nc" id="L542">          throw new Exception(&quot;Line &quot; + lnr.getLineNumber()</span>
<span class="nc" id="L543">              + &quot;: too many rows provided&quot;);</span>
        }

<span class="fc bfc" id="L546" title="All 2 branches covered.">        for (int i = 0; i &lt; m_size; i++) {</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">          if (!st.hasMoreTokens()) {</span>
<span class="nc" id="L548">            throw new Exception(&quot;Line &quot; + lnr.getLineNumber()</span>
<span class="nc" id="L549">                + &quot;: too few matrix elements provided&quot;);</span>
          }

<span class="fc" id="L552">          String nextTok = st.nextToken();</span>
          // try to parse as a double first
<span class="fc" id="L554">          Double val = null;</span>
          try {
<span class="fc" id="L556">            val = new Double(nextTok);</span>
<span class="fc" id="L557">            double value = val.doubleValue();</span>
<span class="nc" id="L558">          } catch (Exception ex) {</span>
<span class="nc" id="L559">            val = null;</span>
          }
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">          if (val == null) {</span>
<span class="nc" id="L562">            setCell(currentRow, i, nextTok);</span>
          } else {
<span class="fc" id="L564">            setCell(currentRow, i, val);</span>
          }
        }
<span class="fc" id="L567">        currentRow++;</span>
      }
    }

<span class="pc bpc" id="L571" title="1 of 2 branches missed.">    if (currentRow == -1) {</span>
<span class="nc" id="L572">      throw new Exception(&quot;Line &quot; + lnr.getLineNumber()</span>
<span class="nc" id="L573">          + &quot;: expected number of rows&quot;);</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">    } else if (currentRow != m_size) {</span>
<span class="nc" id="L575">      throw new Exception(&quot;Line &quot; + lnr.getLineNumber()</span>
<span class="nc" id="L576">          + &quot;: too few rows provided&quot;);</span>
    }
<span class="fc" id="L578">  }</span>

  /**
   * Writes out a matrix. The format can be read via the CostMatrix(Reader)
   * constructor. (FracPete: taken from old weka.core.Matrix class)
   * 
   * @param w the output Writer
   * @throws Exception if an error occurs
   */
  public void write(Writer w) throws Exception {
<span class="nc" id="L588">    w.write(&quot;% Rows\tColumns\n&quot;);</span>
<span class="nc" id="L589">    w.write(&quot;&quot; + m_size + &quot;\t&quot; + m_size + &quot;\n&quot;);</span>
<span class="nc" id="L590">    w.write(&quot;% Matrix elements\n&quot;);</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">    for (int i = 0; i &lt; m_size; i++) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">      for (int j = 0; j &lt; m_size; j++) {</span>
<span class="nc" id="L593">        w.write(&quot;&quot; + getCell(i, j) + &quot;\t&quot;);</span>
      }
<span class="nc" id="L595">      w.write(&quot;\n&quot;);</span>
    }
<span class="nc" id="L597">    w.flush();</span>
<span class="nc" id="L598">  }</span>

  /**
   * converts the Matrix into a single line Matlab string: matrix is enclosed by
   * parentheses, rows are separated by semicolon and single cells by blanks,
   * e.g., [1 2; 3 4].
   * 
   * @return the matrix in Matlab single line format
   */
  public String toMatlab() {
    StringBuffer result;
    int i;
    int n;

<span class="nc" id="L612">    result = new StringBuffer();</span>

<span class="nc" id="L614">    result.append(&quot;[&quot;);</span>

<span class="nc bnc" id="L616" title="All 2 branches missed.">    for (i = 0; i &lt; m_size; i++) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">      if (i &gt; 0) {</span>
<span class="nc" id="L618">        result.append(&quot;; &quot;);</span>
      }

<span class="nc bnc" id="L621" title="All 2 branches missed.">      for (n = 0; n &lt; m_size; n++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc" id="L623">          result.append(&quot; &quot;);</span>
        }
<span class="nc" id="L625">        result.append(getCell(i, n));</span>
      }
    }

<span class="nc" id="L629">    result.append(&quot;]&quot;);</span>

<span class="nc" id="L631">    return result.toString();</span>
  }

  /**
   * Set the value of a particular cell in the matrix
   * 
   * @param rowIndex the row
   * @param columnIndex the column
   * @param value the value to set
   */
  public final void setCell(int rowIndex, int columnIndex, Object value) {
<span class="fc" id="L642">    m_matrix[rowIndex][columnIndex] = value;</span>
<span class="fc" id="L643">  }</span>

  /**
   * Return the contents of a particular cell. Note: this method returns the
   * Object stored at a particular cell.
   * 
   * @param rowIndex the row
   * @param columnIndex the column
   * @return the value at the cell
   */
  public final Object getCell(int rowIndex, int columnIndex) {
<span class="fc" id="L654">    return m_matrix[rowIndex][columnIndex];</span>
  }

  /**
   * Return the value of a cell as a double (for legacy code)
   * 
   * @param rowIndex the row
   * @param columnIndex the column
   * @return the value at a particular cell as a double
   * @exception Exception if the value is not a double
   */
  public final double getElement(int rowIndex, int columnIndex)
      throws Exception {
<span class="nc bnc" id="L667" title="All 2 branches missed.">    if (!(m_matrix[rowIndex][columnIndex] instanceof Double)) {</span>
<span class="nc" id="L668">      throw new Exception(&quot;Cost matrix contains non-fixed costs!&quot;);</span>
    }
<span class="nc" id="L670">    return ((Double) m_matrix[rowIndex][columnIndex]).doubleValue();</span>
  }

  /**
   * Return the value of a cell as a double. Computes the value for non-fixed
   * costs using the supplied Instance
   * 
   * @param rowIndex the row
   * @param columnIndex the column
   * @return the value from a particular cell
   * @exception Exception if something goes wrong
   */
  public final double getElement(int rowIndex, int columnIndex, Instance inst)
      throws Exception {

<span class="nc bnc" id="L685" title="All 2 branches missed.">    if (m_matrix[rowIndex][columnIndex] instanceof Double) {</span>
<span class="nc" id="L686">      return ((Double) m_matrix[rowIndex][columnIndex]).doubleValue();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">    } else if (m_matrix[rowIndex][columnIndex] instanceof String) {</span>
<span class="nc" id="L688">      replaceStrings();</span>
    }

<span class="nc" id="L691">    return ((AttributeExpression) m_matrix[rowIndex][columnIndex])</span>
<span class="nc" id="L692">        .evaluateExpression(inst);</span>
  }

  /**
   * Set the value of a cell as a double
   * 
   * @param rowIndex the row
   * @param columnIndex the column
   * @param value the value (double) to set
   */
  public final void setElement(int rowIndex, int columnIndex, double value) {
<span class="nc" id="L703">    m_matrix[rowIndex][columnIndex] = new Double(value);</span>
<span class="nc" id="L704">  }</span>

  /**
   * creates a matrix from the given Matlab string.
   * 
   * @param matlab the matrix in matlab format
   * @return the matrix represented by the given string
   * @see #toMatlab()
   */
  public static CostMatrix parseMatlab(String matlab) throws Exception {
    StringTokenizer tokRow;
    StringTokenizer tokCol;
    int rows;
    int cols;
    CostMatrix result;
    String cells;

    // get content
<span class="nc" id="L722">    cells = matlab.substring(matlab.indexOf(&quot;[&quot;) + 1, matlab.indexOf(&quot;]&quot;))</span>
<span class="nc" id="L723">        .trim();</span>

    // determine dimenions
<span class="nc" id="L726">    tokRow = new StringTokenizer(cells, &quot;;&quot;);</span>
<span class="nc" id="L727">    rows = tokRow.countTokens();</span>
<span class="nc" id="L728">    tokCol = new StringTokenizer(tokRow.nextToken(), &quot; &quot;);</span>
<span class="nc" id="L729">    cols = tokCol.countTokens();</span>

    // fill matrix
<span class="nc" id="L732">    result = new CostMatrix(rows);</span>
<span class="nc" id="L733">    tokRow = new StringTokenizer(cells, &quot;;&quot;);</span>
<span class="nc" id="L734">    rows = 0;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">    while (tokRow.hasMoreTokens()) {</span>
<span class="nc" id="L736">      tokCol = new StringTokenizer(tokRow.nextToken(), &quot; &quot;);</span>
<span class="nc" id="L737">      cols = 0;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">      while (tokCol.hasMoreTokens()) {</span>
        // is it a number
<span class="nc" id="L740">        String current = tokCol.nextToken();</span>
        try {
<span class="nc" id="L742">          double val = Double.parseDouble(current);</span>
<span class="nc" id="L743">          result.setCell(rows, cols, new Double(val));</span>
<span class="nc" id="L744">        } catch (NumberFormatException e) {</span>
          // must be an expression
<span class="nc" id="L746">          result.setCell(rows, cols, current);</span>
        }
<span class="nc" id="L748">        cols++;</span>
      }
<span class="nc" id="L750">      rows++;</span>
    }

<span class="nc" id="L753">    return result;</span>
  }

  /**
   * Converts a matrix to a string. (FracPete: taken from old weka.core.Matrix
   * class)
   * 
   * @return the converted string
   */
  @Override
  public String toString() {
    // Determine the width required for the maximum element,
    // and check for fractional display requirement.
<span class="fc" id="L766">    double maxval = 0;</span>
<span class="fc" id="L767">    boolean fractional = false;</span>
<span class="fc" id="L768">    Object element = null;</span>
<span class="fc" id="L769">    int widthNumber = 0;</span>
<span class="fc" id="L770">    int widthExpression = 0;</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">    for (int i = 0; i &lt; size(); i++) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">      for (int j = 0; j &lt; size(); j++) {</span>
<span class="fc" id="L773">        element = getCell(i, j);</span>
<span class="pc bpc" id="L774" title="1 of 2 branches missed.">        if (element instanceof Double) {</span>
<span class="fc" id="L775">          double current = ((Double) element).doubleValue();</span>

<span class="pc bpc" id="L777" title="1 of 2 branches missed.">          if (current &lt; 0)</span>
<span class="nc" id="L778">            current *= -11;</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">          if (current &gt; maxval)</span>
<span class="nc" id="L780">            maxval = current;</span>
<span class="fc" id="L781">          double fract = Math.abs(current - Math.rint(current));</span>
<span class="pc bpc" id="L782" title="2 of 4 branches missed.">          if (!fractional &amp;&amp; ((Math.log(fract) / Math.log(10)) &gt;= -2)) {</span>
<span class="nc" id="L783">            fractional = true;</span>
          }
        } else {
<span class="nc bnc" id="L786" title="All 2 branches missed.">          if (element.toString().length() &gt; widthExpression) {</span>
<span class="nc" id="L787">            widthExpression = element.toString().length();</span>
          }
        }
      }
    }
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">    if (maxval &gt; 0) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">      widthNumber = (int) (Math.log(maxval) / Math.log(10) + (fractional ? 4</span>
<span class="nc" id="L794">          : 1));</span>
    }

<span class="pc bpc" id="L797" title="1 of 2 branches missed.">    int width = (widthNumber &gt; widthExpression) ? widthNumber : widthExpression;</span>

<span class="fc" id="L799">    StringBuffer text = new StringBuffer();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">    for (int i = 0; i &lt; size(); i++) {</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">      for (int j = 0; j &lt; size(); j++) {</span>
<span class="fc" id="L802">        element = getCell(i, j);</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if (element instanceof Double) {</span>
<span class="fc" id="L804">          text.append(&quot; &quot;).append(</span>
<span class="fc" id="L805">              Utils.doubleToString(((Double) element).doubleValue(), width,</span>
<span class="pc bpc" id="L806" title="1 of 2 branches missed.">                  (fractional ? 2 : 0)));</span>
        } else {
<span class="nc" id="L808">          int diff = width - element.toString().length();</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">          if (diff &gt; 0) {</span>
<span class="nc" id="L810">            int left = diff % 2;</span>
<span class="nc" id="L811">            left += diff / 2;</span>
<span class="nc" id="L812">            String temp = Utils.padLeft(element.toString(), element.toString()</span>
<span class="nc" id="L813">                .length() + left);</span>
<span class="nc" id="L814">            temp = Utils.padRight(temp, width);</span>
<span class="nc" id="L815">            text.append(&quot; &quot;).append(temp);</span>
          } else {
<span class="nc" id="L817">            text.append(&quot; &quot;).append(element.toString());</span>
          }
        }
      }
<span class="fc" id="L821">      text.append(&quot;\n&quot;);</span>
    }

<span class="fc" id="L824">    return text.toString();</span>
  }

  /**
   * Returns the revision string.
   * 
   * @return the revision
   */
  public String getRevision() {
<span class="nc" id="L833">    return RevisionUtils.extract(&quot;$Revision: 9048 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>