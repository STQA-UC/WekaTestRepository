<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CheckClassifier.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers</a> &gt; <span class="el_source">CheckClassifier.java</span></div><h1>CheckClassifier.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    CheckClassifier.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers;

import weka.core.Attribute;
import weka.core.CheckScheme;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.MultiInstanceCapabilitiesHandler;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.SerializationHelper;
import weka.core.TestInstances;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 * Class for examining the capabilities and finding problems with 
 * classifiers. If you implement a classifier using the WEKA.libraries,
 * you should run the checks on it to ensure robustness and correct
 * operation. Passing all the tests of this object does not mean
 * bugs in the classifier don't exist, but this will help find some
 * common ones. &lt;p/&gt;
 * 
 * Typical usage: &lt;p/&gt;
 * &lt;code&gt;java weka.classifiers.CheckClassifier -W classifier_name 
 * classifier_options &lt;/code&gt;&lt;p/&gt;
 * 
 * CheckClassifier reports on the following:
 * &lt;ul&gt;
 *    &lt;li&gt; Classifier abilities 
 *      &lt;ul&gt;
 *         &lt;li&gt; Possible command line options to the classifier &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can predict nominal, numeric, string, 
 *              date or relational class attributes. Warnings will be displayed if 
 *              performance is worse than ZeroR &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can be trained incrementally &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle numeric predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle nominal predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle string predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle date predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle relational predictor attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle multi-instance data &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle missing predictor values &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle missing class values &lt;/li&gt;
 *         &lt;li&gt; Whether a nominal classifier only handles 2 class problems &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier can handle instance weights &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Correct functioning 
 *      &lt;ul&gt;
 *         &lt;li&gt; Correct initialisation during buildClassifier (i.e. no result
 *              changes when buildClassifier called repeatedly) &lt;/li&gt;
 *         &lt;li&gt; Whether incremental training produces the same results
 *              as during non-incremental training (which may or may not 
 *              be OK) &lt;/li&gt;
 *         &lt;li&gt; Whether the classifier alters the data pased to it 
 *              (number of instances, instance order, instance weights, etc) &lt;/li&gt;
 *         &lt;li&gt; Whether the toString() method works correctly before the 
 *              classifier has been built. &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Degenerate cases 
 *      &lt;ul&gt;
 *         &lt;li&gt; building classifier with zero training instances &lt;/li&gt;
 *         &lt;li&gt; all but one predictor attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all predictor attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all but one class values missing &lt;/li&gt;
 *         &lt;li&gt; all class values missing &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 * &lt;/ul&gt;
 * Running CheckClassifier with the debug option set will output the 
 * training and test datasets for any failed tests.&lt;p/&gt;
 *
 * The &lt;code&gt;weka.classifiers.AbstractClassifierTest&lt;/code&gt; uses this
 * class to test all the classifiers. Any changes here, have to be 
 * checked in that abstract test class, too. &lt;p/&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  Turn on debugging output.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;
 *  The number of instances in the datasets (default 20).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -nominal &amp;lt;num&amp;gt;
 *  The number of nominal attributes (default 2).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -nominal-values &amp;lt;num&amp;gt;
 *  The number of values for nominal attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -numeric &amp;lt;num&amp;gt;
 *  The number of numeric attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -string &amp;lt;num&amp;gt;
 *  The number of string attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -date &amp;lt;num&amp;gt;
 *  The number of date attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -relational &amp;lt;num&amp;gt;
 *  The number of relational attributes (default 1).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -num-instances-relational &amp;lt;num&amp;gt;
 *  The number of instances in relational/bag attributes (default 10).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -words &amp;lt;comma-separated-list&amp;gt;
 *  The words to use in string attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -word-separators &amp;lt;chars&amp;gt;
 *  The word separators to use in string attributes.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W
 *  Full name of the classifier analysed.
 *  eg: weka.classifiers.bayes.NaiveBayes
 *  (default weka.classifiers.rules.ZeroR)&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to classifier weka.classifiers.rules.ZeroR:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * Options after -- are passed to the designated classifier.&lt;p/&gt;
 *
 * @author Len Trigg (trigg@cs.waikato.ac.nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.33 $
 * @see TestInstances
 */
<span class="fc" id="L167">public class CheckClassifier</span>
  extends CheckScheme {

  /*
   * Note about test methods:
   * - methods return array of booleans
   * - first index: success or not
   * - second index: acceptable or not (e.g., Exception is OK)
   * - in case the performance is worse than that of ZeroR both indices are true
   *
   * FracPete (fracpete at waikato dot ac dot nz)
   */
  
  /*** The classifier to be examined */
<span class="fc" id="L181">  protected Classifier m_Classifier = new weka.classifiers.rules.ZeroR();</span>
  
  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {
<span class="nc" id="L189">    Vector result = new Vector();</span>
    
<span class="nc" id="L191">    Enumeration en = super.listOptions();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    while (en.hasMoreElements())</span>
<span class="nc" id="L193">      result.addElement(en.nextElement());</span>
    
<span class="nc" id="L195">    result.addElement(new Option(</span>
<span class="nc" id="L196">        &quot;\tFull name of the classifier analysed.\n&quot;</span>
        +&quot;\teg: weka.classifiers.bayes.NaiveBayes\n&quot;
        + &quot;\t(default weka.classifiers.rules.ZeroR)&quot;,
<span class="nc" id="L199">        &quot;W&quot;, 1, &quot;-W&quot;));</span>
    
<span class="nc bnc" id="L201" title="All 2 branches missed.">    if ((m_Classifier != null) </span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        &amp;&amp; (m_Classifier instanceof OptionHandler)) {</span>
<span class="nc" id="L203">      result.addElement(new Option(&quot;&quot;, &quot;&quot;, 0, </span>
<span class="nc" id="L204">          &quot;\nOptions specific to classifier &quot;</span>
<span class="nc" id="L205">          + m_Classifier.getClass().getName()</span>
<span class="nc" id="L206">          + &quot;:&quot;));</span>
<span class="nc" id="L207">      Enumeration enu = ((OptionHandler)m_Classifier).listOptions();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">      while (enu.hasMoreElements())</span>
<span class="nc" id="L209">        result.addElement(enu.nextElement());</span>
    }
    
<span class="nc" id="L212">    return result.elements();</span>
  }
  
  /**
   * Parses a given list of options. 
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -D
   *  Turn on debugging output.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;
   *  The number of instances in the datasets (default 20).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -nominal &amp;lt;num&amp;gt;
   *  The number of nominal attributes (default 2).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -nominal-values &amp;lt;num&amp;gt;
   *  The number of values for nominal attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -numeric &amp;lt;num&amp;gt;
   *  The number of numeric attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -string &amp;lt;num&amp;gt;
   *  The number of string attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -date &amp;lt;num&amp;gt;
   *  The number of date attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -relational &amp;lt;num&amp;gt;
   *  The number of relational attributes (default 1).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -num-instances-relational &amp;lt;num&amp;gt;
   *  The number of instances in relational/bag attributes (default 10).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -words &amp;lt;comma-separated-list&amp;gt;
   *  The words to use in string attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -word-separators &amp;lt;chars&amp;gt;
   *  The word separators to use in string attributes.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W
   *  Full name of the classifier analysed.
   *  eg: weka.classifiers.bayes.NaiveBayes
   *  (default weka.classifiers.rules.ZeroR)&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to classifier weka.classifiers.rules.ZeroR:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, classifier is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String      tmpStr;
    
<span class="nc" id="L278">    super.setOptions(options);</span>
    
<span class="nc" id="L280">    tmpStr = Utils.getOption('W', options);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">    if (tmpStr.length() == 0)</span>
<span class="nc" id="L282">      tmpStr = weka.classifiers.rules.ZeroR.class.getName();</span>
<span class="nc" id="L283">    setClassifier(</span>
<span class="nc" id="L284">	(Classifier) forName(</span>
<span class="nc" id="L285">	    &quot;weka.classifiers&quot;, </span>
<span class="nc" id="L286">	    Classifier.class, </span>
<span class="nc" id="L287">	    tmpStr, </span>
<span class="nc" id="L288">	    Utils.partitionOptions(options)));</span>
<span class="nc" id="L289">  }</span>
  
  /**
   * Gets the current settings of the CheckClassifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    String[]      options;
    int           i;
    
<span class="nc" id="L301">    result = new Vector();</span>
    
<span class="nc" id="L303">    options = super.getOptions();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L305">      result.add(options[i]);</span>
    
<span class="nc bnc" id="L307" title="All 2 branches missed.">    if (getClassifier() != null) {</span>
<span class="nc" id="L308">      result.add(&quot;-W&quot;);</span>
<span class="nc" id="L309">      result.add(getClassifier().getClass().getName());</span>
    }
    
<span class="nc bnc" id="L312" title="All 4 branches missed.">    if ((m_Classifier != null) &amp;&amp; (m_Classifier instanceof OptionHandler))</span>
<span class="nc" id="L313">      options = ((OptionHandler) m_Classifier).getOptions();</span>
    else
<span class="nc" id="L315">      options = new String[0];</span>
    
<span class="nc bnc" id="L317" title="All 2 branches missed.">    if (options.length &gt; 0) {</span>
<span class="nc" id="L318">      result.add(&quot;--&quot;);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">      for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L320">        result.add(options[i]);</span>
    }
    
<span class="nc" id="L323">    return (String[]) result.toArray(new String[result.size()]);</span>
  }
  
  /**
   * Begin the tests, reporting results to System.out
   */
  public void doTests() {
    
<span class="nc bnc" id="L331" title="All 2 branches missed.">    if (getClassifier() == null) {</span>
<span class="nc" id="L332">      println(&quot;\n=== No classifier set ===&quot;);</span>
<span class="nc" id="L333">      return;</span>
    }
<span class="nc" id="L335">    println(&quot;\n=== Check on Classifier: &quot;</span>
<span class="nc" id="L336">        + getClassifier().getClass().getName()</span>
<span class="nc" id="L337">        + &quot; ===\n&quot;);</span>
    
    // Start tests
<span class="nc" id="L340">    m_ClasspathProblems = false;</span>
<span class="nc" id="L341">    println(&quot;--&gt; Checking for interfaces&quot;);</span>
<span class="nc" id="L342">    canTakeOptions();</span>
<span class="nc" id="L343">    boolean updateableClassifier = updateableClassifier()[0];</span>
<span class="nc" id="L344">    boolean weightedInstancesHandler = weightedInstancesHandler()[0];</span>
<span class="nc" id="L345">    boolean multiInstanceHandler = multiInstanceHandler()[0];</span>
<span class="nc" id="L346">    println(&quot;--&gt; Classifier tests&quot;);</span>
<span class="nc" id="L347">    declaresSerialVersionUID();</span>
<span class="nc" id="L348">    testToString();</span>
<span class="nc" id="L349">    testsPerClassType(Attribute.NOMINAL,    updateableClassifier, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L350">    testsPerClassType(Attribute.NUMERIC,    updateableClassifier, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L351">    testsPerClassType(Attribute.DATE,       updateableClassifier, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L352">    testsPerClassType(Attribute.STRING,     updateableClassifier, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L353">    testsPerClassType(Attribute.RELATIONAL, updateableClassifier, weightedInstancesHandler, multiInstanceHandler);</span>
<span class="nc" id="L354">  }</span>
  
  /**
   * Set the classifier for boosting. 
   *
   * @param newClassifier the Classifier to use.
   */
  public void setClassifier(Classifier newClassifier) {
<span class="fc" id="L362">    m_Classifier = newClassifier;</span>
<span class="fc" id="L363">  }</span>
  
  /**
   * Get the classifier used as the classifier
   *
   * @return the classifier used as the classifier
   */
  public Classifier getClassifier() {
<span class="fc" id="L371">    return m_Classifier;</span>
  }
  
  /**
   * Run a battery of tests for a given class attribute type
   *
   * @param classType true if the class attribute should be numeric
   * @param updateable true if the classifier is updateable
   * @param weighted true if the classifier says it handles weights
   * @param multiInstance true if the classifier is a multi-instance classifier
   */
  protected void testsPerClassType(int classType, 
                                   boolean updateable,
                                   boolean weighted,
                                   boolean multiInstance) {
    
<span class="nc" id="L387">    boolean PNom = canPredict(true,  false, false, false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L388">    boolean PNum = canPredict(false, true,  false, false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L389">    boolean PStr = canPredict(false, false, true,  false, false, multiInstance, classType)[0];</span>
<span class="nc" id="L390">    boolean PDat = canPredict(false, false, false, true,  false, multiInstance, classType)[0];</span>
    boolean PRel;
<span class="nc bnc" id="L392" title="All 2 branches missed.">    if (!multiInstance)</span>
<span class="nc" id="L393">      PRel = canPredict(false, false, false, false,  true, multiInstance, classType)[0];</span>
    else
<span class="nc" id="L395">      PRel = false;</span>

<span class="nc bnc" id="L397" title="All 10 branches missed.">    if (PNom || PNum || PStr || PDat || PRel) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">      if (weighted)</span>
<span class="nc" id="L399">        instanceWeights(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
      
<span class="nc" id="L401">      canHandleOnlyClass(PNom, PNum, PStr, PDat, PRel, classType);</span>
      
<span class="nc bnc" id="L403" title="All 2 branches missed.">      if (classType == Attribute.NOMINAL)</span>
<span class="nc" id="L404">        canHandleNClasses(PNom, PNum, PStr, PDat, PRel, multiInstance, 4);</span>

<span class="nc bnc" id="L406" title="All 2 branches missed.">      if (!multiInstance) {</span>
<span class="nc" id="L407">	canHandleClassAsNthAttribute(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, 0);</span>
<span class="nc" id="L408">	canHandleClassAsNthAttribute(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, 1);</span>
      }
      
<span class="nc" id="L411">      canHandleZeroTraining(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
<span class="nc" id="L412">      boolean handleMissingPredictors = canHandleMissing(PNom, PNum, PStr, PDat, PRel, </span>
<span class="nc" id="L413">          multiInstance, classType, </span>
<span class="nc" id="L414">          true, false, 20)[0];</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">      if (handleMissingPredictors)</span>
<span class="nc" id="L416">        canHandleMissing(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, true, false, 100);</span>
      
<span class="nc" id="L418">      boolean handleMissingClass = canHandleMissing(PNom, PNum, PStr, PDat, PRel, </span>
<span class="nc" id="L419">          multiInstance, classType, </span>
<span class="nc" id="L420">          false, true, 20)[0];</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      if (handleMissingClass)</span>
<span class="nc" id="L422">        canHandleMissing(PNom, PNum, PStr, PDat, PRel, multiInstance, classType, false, true, 100);</span>
      
<span class="nc" id="L424">      correctBuildInitialisation(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
<span class="nc" id="L425">      datasetIntegrity(PNom, PNum, PStr, PDat, PRel, multiInstance, classType,</span>
<span class="nc" id="L426">          handleMissingPredictors, handleMissingClass);</span>
<span class="nc" id="L427">      doesntUseTestClassVal(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">      if (updateable)</span>
<span class="nc" id="L429">        updatingEquality(PNom, PNum, PStr, PDat, PRel, multiInstance, classType);</span>
    }
<span class="nc" id="L431">  }</span>

  /**
   * Checks whether the scheme's toString() method works even though the 
   * classifies hasn't been built yet.
   *
   * @return index 0 is true if the toString() method works fine
   */
  protected boolean[] testToString() {
<span class="fc" id="L440">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L442">    print(&quot;toString...&quot;);</span>
    
    try {
<span class="fc" id="L445">      Classifier copy = (Classifier) m_Classifier.getClass().newInstance();</span>
<span class="fc" id="L446">      copy.toString();</span>
<span class="fc" id="L447">      result[0] = true;</span>
<span class="fc" id="L448">      println(&quot;yes&quot;);</span>
    }
<span class="nc" id="L450">    catch (Exception e) {</span>
<span class="nc" id="L451">      result[0] = false;</span>
<span class="nc" id="L452">      println(&quot;no&quot;);</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L454">        println(&quot;\n=== Full report ===&quot;);</span>
<span class="nc" id="L455">        e.printStackTrace();</span>
<span class="nc" id="L456">        println(&quot;\n&quot;);</span>
      }
    }
    
<span class="fc" id="L460">    return result;</span>
  }
  
  /**
   * tests for a serialVersionUID. Fails in case the scheme doesn't declare
   * a UID.
   *
   * @return index 0 is true if the scheme declares a UID
   */
  protected boolean[] declaresSerialVersionUID() {
<span class="fc" id="L470">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L472">    print(&quot;serialVersionUID...&quot;);</span>
    
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">    result[0] = !SerializationHelper.needsUID(m_Classifier.getClass());</span>
    
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">    if (result[0])</span>
<span class="fc" id="L477">      println(&quot;yes&quot;);</span>
    else
<span class="nc" id="L479">      println(&quot;no&quot;);</span>
    
<span class="fc" id="L481">    return result;</span>
  }
  
  /**
   * Checks whether the scheme can take command line options.
   *
   * @return index 0 is true if the classifier can take options
   */
  protected boolean[] canTakeOptions() {
    
<span class="nc" id="L491">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L493">    print(&quot;options...&quot;);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">    if (m_Classifier instanceof OptionHandler) {</span>
<span class="nc" id="L495">      println(&quot;yes&quot;);</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L497">        println(&quot;\n=== Full report ===&quot;);</span>
<span class="nc" id="L498">        Enumeration enu = ((OptionHandler)m_Classifier).listOptions();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        while (enu.hasMoreElements()) {</span>
<span class="nc" id="L500">          Option option = (Option) enu.nextElement();</span>
<span class="nc" id="L501">          print(option.synopsis() + &quot;\n&quot; </span>
<span class="nc" id="L502">              + option.description() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L504">        println(&quot;\n&quot;);</span>
      }
<span class="nc" id="L506">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L509">      println(&quot;no&quot;);</span>
<span class="nc" id="L510">      result[0] = false;</span>
    }
    
<span class="nc" id="L513">    return result;</span>
  }
  
  /**
   * Checks whether the scheme can build models incrementally.
   *
   * @return index 0 is true if the classifier can train incrementally
   */
  protected boolean[] updateableClassifier() {
    
<span class="fc" id="L523">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L525">    print(&quot;updateable classifier...&quot;);</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">    if (m_Classifier instanceof UpdateableClassifier) {</span>
<span class="fc" id="L527">      println(&quot;yes&quot;);</span>
<span class="fc" id="L528">      result[0] = true;</span>
    }
    else {
<span class="fc" id="L531">      println(&quot;no&quot;);</span>
<span class="fc" id="L532">      result[0] = false;</span>
    }
    
<span class="fc" id="L535">    return result;</span>
  }
  
  /**
   * Checks whether the scheme says it can handle instance weights.
   *
   * @return true if the classifier handles instance weights
   */
  protected boolean[] weightedInstancesHandler() {
    
<span class="fc" id="L545">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L547">    print(&quot;weighted instances classifier...&quot;);</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">    if (m_Classifier instanceof WeightedInstancesHandler) {</span>
<span class="fc" id="L549">      println(&quot;yes&quot;);</span>
<span class="fc" id="L550">      result[0] = true;</span>
    }
    else {
<span class="fc" id="L553">      println(&quot;no&quot;);</span>
<span class="fc" id="L554">      result[0] = false;</span>
    }
    
<span class="fc" id="L557">    return result;</span>
  }
  
  /**
   * Checks whether the scheme handles multi-instance data.
   * 
   * @return true if the classifier handles multi-instance data
   */
  protected boolean[] multiInstanceHandler() {
<span class="fc" id="L566">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L568">    print(&quot;multi-instance classifier...&quot;);</span>
<span class="fc bfc" id="L569" title="All 2 branches covered.">    if (m_Classifier instanceof MultiInstanceCapabilitiesHandler) {</span>
<span class="fc" id="L570">      println(&quot;yes&quot;);</span>
<span class="fc" id="L571">      result[0] = true;</span>
    }
    else {
<span class="fc" id="L574">      println(&quot;no&quot;);</span>
<span class="fc" id="L575">      result[0] = false;</span>
    }
    
<span class="fc" id="L578">    return result;</span>
  }
  
  /**
   * Checks basic prediction of the scheme, for simple non-troublesome
   * datasets.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canPredict(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="fc" id="L604">    print(&quot;basic predict&quot;);</span>
<span class="fc" id="L605">    printAttributeSummary(</span>
<span class="fc" id="L606">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L607">    print(&quot;...&quot;);</span>
<span class="fc" id="L608">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L609">    accepts.addElement(&quot;unary&quot;);</span>
<span class="fc" id="L610">    accepts.addElement(&quot;binary&quot;);</span>
<span class="fc" id="L611">    accepts.addElement(&quot;nominal&quot;);</span>
<span class="fc" id="L612">    accepts.addElement(&quot;numeric&quot;);</span>
<span class="fc" id="L613">    accepts.addElement(&quot;string&quot;);</span>
<span class="fc" id="L614">    accepts.addElement(&quot;date&quot;);</span>
<span class="fc" id="L615">    accepts.addElement(&quot;relational&quot;);</span>
<span class="fc" id="L616">    accepts.addElement(&quot;multi-instance&quot;);</span>
<span class="fc" id="L617">    accepts.addElement(&quot;not in classpath&quot;);</span>
<span class="fc" id="L618">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L619">    numClasses = 2, missingLevel = 0;</span>
<span class="fc" id="L620">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L622">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="fc" id="L623">        datePredictor, relationalPredictor, </span>
<span class="fc" id="L624">        multiInstance,</span>
<span class="fc" id="L625">        classType, </span>
<span class="fc" id="L626">        missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L627">        numTrain, numTest, numClasses, </span>
<span class="fc" id="L628">        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle data that contains only the class
   * attribute. If a scheme cannot build a proper model with that data, it
   * should default back to a ZeroR model.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleOnlyClass(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      int classType) {
    
<span class="fc" id="L653">    print(&quot;only class in data&quot;);</span>
<span class="fc" id="L654">    printAttributeSummary(</span>
<span class="fc" id="L655">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, false, classType);</span>
<span class="fc" id="L656">    print(&quot;...&quot;);</span>
<span class="fc" id="L657">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L658">    accepts.addElement(&quot;class&quot;);</span>
<span class="fc" id="L659">    accepts.addElement(&quot;zeror&quot;);</span>
<span class="fc" id="L660">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L661">    missingLevel = 0;</span>
<span class="fc" id="L662">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L664">    return runBasicTest(false, false, false, false, false, </span>
<span class="fc" id="L665">                        false,</span>
<span class="fc" id="L666">                        classType,</span>
<span class="fc" id="L667">                        missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L668">                        numTrain, numTest, 2, </span>
<span class="fc" id="L669">                        accepts);</span>
  }
  
  /**
   * Checks whether nominal schemes can handle more than two classes.
   * If a scheme is only designed for two-class problems it should
   * throw an appropriate exception for multi-class problems.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param numClasses the number of classes to test
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleNClasses(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int numClasses) {
    
<span class="fc" id="L696">    print(&quot;more than two class problems&quot;);</span>
<span class="fc" id="L697">    printAttributeSummary(</span>
<span class="fc" id="L698">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, Attribute.NOMINAL);</span>
<span class="fc" id="L699">    print(&quot;...&quot;);</span>
<span class="fc" id="L700">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L701">    accepts.addElement(&quot;number&quot;);</span>
<span class="fc" id="L702">    accepts.addElement(&quot;class&quot;);</span>
<span class="fc" id="L703">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L704">    missingLevel = 0;</span>
<span class="fc" id="L705">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L707">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="fc" id="L708">                        datePredictor, relationalPredictor, </span>
<span class="fc" id="L709">                        multiInstance,</span>
<span class="fc" id="L710">                        Attribute.NOMINAL,</span>
<span class="fc" id="L711">                        missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L712">                        numTrain, numTest, numClasses, </span>
<span class="fc" id="L713">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle class attributes as Nth attribute.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class attribute (0-based, -1 means last attribute)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   * @see TestInstances#CLASS_IS_LAST
   */
  protected boolean[] canHandleClassAsNthAttribute(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int classIndex) {
    
<span class="pc bpc" id="L741" title="1 of 2 branches missed.">    if (classIndex == TestInstances.CLASS_IS_LAST)</span>
<span class="nc" id="L742">      print(&quot;class attribute as last attribute&quot;);</span>
    else
<span class="fc" id="L744">      print(&quot;class attribute as &quot; + (classIndex + 1) + &quot;. attribute&quot;);</span>
<span class="fc" id="L745">    printAttributeSummary(</span>
<span class="fc" id="L746">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L747">    print(&quot;...&quot;);</span>
<span class="fc" id="L748">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L749">    int numTrain = getNumInstances(), numTest = getNumInstances(), numClasses = 2, </span>
<span class="fc" id="L750">    missingLevel = 0;</span>
<span class="fc" id="L751">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L753">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="fc" id="L754">                        datePredictor, relationalPredictor, </span>
<span class="fc" id="L755">                        multiInstance,</span>
<span class="fc" id="L756">                        classType,</span>
<span class="fc" id="L757">                        classIndex,</span>
<span class="fc" id="L758">                        missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L759">                        numTrain, numTest, numClasses, </span>
<span class="fc" id="L760">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle zero training instances.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleZeroTraining(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="fc" id="L785">    print(&quot;handle zero training instances&quot;);</span>
<span class="fc" id="L786">    printAttributeSummary(</span>
<span class="fc" id="L787">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L788">    print(&quot;...&quot;);</span>
<span class="fc" id="L789">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L790">    accepts.addElement(&quot;train&quot;);</span>
<span class="fc" id="L791">    accepts.addElement(&quot;value&quot;);</span>
<span class="fc" id="L792">    int numTrain = 0, numTest = getNumInstances(), numClasses = 2, </span>
<span class="fc" id="L793">    missingLevel = 0;</span>
<span class="fc" id="L794">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L796">    return runBasicTest(</span>
<span class="fc" id="L797">              nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="fc" id="L798">              datePredictor, relationalPredictor, </span>
<span class="fc" id="L799">              multiInstance,</span>
<span class="fc" id="L800">              classType, </span>
<span class="fc" id="L801">              missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L802">              numTrain, numTest, numClasses, </span>
<span class="fc" id="L803">              accepts);</span>
  }
  
  /**
   * Checks whether the scheme correctly initialises models when 
   * buildClassifier is called. This test calls buildClassifier with
   * one training dataset and records performance on a test set. 
   * buildClassifier is then called on a training set with different
   * structure, and then again with the original training set. The
   * performance on the test set is compared with the original results
   * and any performance difference noted as incorrect build initialisation.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if the
   *         scheme performs worse than ZeroR, but without error (index 0 is
   *         false)
   */
  protected boolean[] correctBuildInitialisation(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {

<span class="fc" id="L835">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L837">    print(&quot;correct initialisation during buildClassifier&quot;);</span>
<span class="fc" id="L838">    printAttributeSummary(</span>
<span class="fc" id="L839">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L840">    print(&quot;...&quot;);</span>
<span class="fc" id="L841">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L842">    numClasses = 2, missingLevel = 0;</span>
<span class="fc" id="L843">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L845">    Instances train1 = null;</span>
<span class="fc" id="L846">    Instances test1 = null;</span>
<span class="fc" id="L847">    Instances train2 = null;</span>
<span class="fc" id="L848">    Instances test2 = null;</span>
<span class="fc" id="L849">    Classifier classifier = null;</span>
<span class="fc" id="L850">    Evaluation evaluation1A = null;</span>
<span class="fc" id="L851">    Evaluation evaluation1B = null;</span>
<span class="fc" id="L852">    Evaluation evaluation2 = null;</span>
<span class="fc" id="L853">    boolean built = false;</span>
<span class="fc" id="L854">    int stage = 0;</span>
    try {
      
      // Make two sets of train/test splits with different 
      // numbers of attributes
<span class="fc" id="L859">      train1 = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">                               nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">                               numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                               stringPredictor     ? getNumString()     : 0, </span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">                               datePredictor       ? getNumDate()       : 0, </span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">                               relationalPredictor ? getNumRelational() : 0, </span>
<span class="fc" id="L865">                               numClasses, </span>
<span class="fc" id="L866">                               classType,</span>
<span class="fc" id="L867">                               multiInstance);</span>
<span class="fc" id="L868">      train2 = makeTestDataset(84, numTrain, </span>
<span class="fc bfc" id="L869" title="All 2 branches covered.">                               nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L870" title="All 2 branches covered.">                               numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">                               stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L872" title="All 2 branches covered.">                               datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">                               relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L874">                               numClasses, </span>
<span class="fc" id="L875">                               classType,</span>
<span class="fc" id="L876">                               multiInstance);</span>
<span class="fc" id="L877">      test1 = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">                              nominalPredictor     ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L879" title="All 2 branches covered.">                              numericPredictor     ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L880" title="All 2 branches covered.">                              stringPredictor      ? getNumString()     : 0, </span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">                              datePredictor        ? getNumDate()       : 0, </span>
<span class="fc bfc" id="L882" title="All 2 branches covered.">                              relationalPredictor  ? getNumRelational() : 0, </span>
<span class="fc" id="L883">                              numClasses, </span>
<span class="fc" id="L884">                              classType,</span>
<span class="fc" id="L885">                              multiInstance);</span>
<span class="fc" id="L886">      test2 = makeTestDataset(48, numTest,</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">                              nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">                              numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L889" title="All 2 branches covered.">                              stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">                              datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L891" title="All 2 branches covered.">                              relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L892">                              numClasses, </span>
<span class="fc" id="L893">                              classType,</span>
<span class="fc" id="L894">                              multiInstance);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L896">        addMissing(train1, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L897">        addMissing(test1, Math.min(missingLevel,50), predictorMissing, </span>
<span class="nc" id="L898">            classMissing);</span>
<span class="nc" id="L899">        addMissing(train2, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L900">        addMissing(test2, Math.min(missingLevel,50), predictorMissing, </span>
<span class="nc" id="L901">            classMissing);</span>
      }
      
<span class="fc" id="L904">      classifier = Classifier.makeCopies(getClassifier(), 1)[0];</span>
<span class="fc" id="L905">      evaluation1A = new Evaluation(train1);</span>
<span class="fc" id="L906">      evaluation1B = new Evaluation(train1);</span>
<span class="fc" id="L907">      evaluation2 = new Evaluation(train2);</span>
<span class="nc" id="L908">    } catch (Exception ex) {</span>
<span class="nc" id="L909">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="fc" id="L912">      stage = 0;</span>
<span class="fc" id="L913">      classifier.buildClassifier(train1);</span>
<span class="fc" id="L914">      built = true;</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">      if (!testWRTZeroR(classifier, evaluation1A, train1, test1)[0]) {</span>
<span class="fc" id="L916">        throw new Exception(&quot;Scheme performs worse than ZeroR&quot;);</span>
      }
      
<span class="fc" id="L919">      stage = 1;</span>
<span class="fc" id="L920">      built = false;</span>
<span class="fc" id="L921">      classifier.buildClassifier(train2);</span>
<span class="fc" id="L922">      built = true;</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">      if (!testWRTZeroR(classifier, evaluation2, train2, test2)[0]) {</span>
<span class="nc" id="L924">        throw new Exception(&quot;Scheme performs worse than ZeroR&quot;);</span>
      }
      
<span class="fc" id="L927">      stage = 2;</span>
<span class="fc" id="L928">      built = false;</span>
<span class="fc" id="L929">      classifier.buildClassifier(train1);</span>
<span class="fc" id="L930">      built = true;</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">      if (!testWRTZeroR(classifier, evaluation1B, train1, test1)[0]) {</span>
<span class="nc" id="L932">        throw new Exception(&quot;Scheme performs worse than ZeroR&quot;);</span>
      }
      
<span class="fc" id="L935">      stage = 3;</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">      if (!evaluation1A.equals(evaluation1B)) {</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L938">          println(&quot;\n=== Full report ===\n&quot;</span>
<span class="nc" id="L939">              + evaluation1A.toSummaryString(&quot;\nFirst buildClassifier()&quot;,</span>
<span class="nc" id="L940">                  true)</span>
<span class="nc" id="L941">                  + &quot;\n\n&quot;);</span>
<span class="nc" id="L942">          println(</span>
<span class="nc" id="L943">              evaluation1B.toSummaryString(&quot;\nSecond buildClassifier()&quot;,</span>
<span class="nc" id="L944">                  true)</span>
<span class="nc" id="L945">                  + &quot;\n\n&quot;);</span>
        }
<span class="nc" id="L947">        throw new Exception(&quot;Results differ between buildClassifier calls&quot;);</span>
      }
<span class="fc" id="L949">      println(&quot;yes&quot;);</span>
<span class="fc" id="L950">      result[0] = true;</span>
      
      if (false &amp;&amp; m_Debug) {
        println(&quot;\n=== Full report ===\n&quot;
            + evaluation1A.toSummaryString(&quot;\nFirst buildClassifier()&quot;,
                true)
                + &quot;\n\n&quot;);
        println(
            evaluation1B.toSummaryString(&quot;\nSecond buildClassifier()&quot;,
                true)
                + &quot;\n\n&quot;);
      }
    } 
<span class="fc" id="L963">    catch (Exception ex) {</span>
<span class="fc" id="L964">      String msg = ex.getMessage().toLowerCase();</span>
<span class="pc bpc" id="L965" title="1 of 2 branches missed.">      if (msg.indexOf(&quot;worse than zeror&quot;) &gt;= 0) {</span>
<span class="fc" id="L966">        println(&quot;warning: performs worse than ZeroR&quot;);</span>
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">        result[0] = (stage &lt; 1);</span>
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">        result[1] = (stage &lt; 1);</span>
      } else {
<span class="nc" id="L970">        println(&quot;no&quot;);</span>
<span class="nc" id="L971">        result[0] = false;</span>
      }
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L974">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L975">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L977">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L979">          print(&quot; training&quot;);</span>
        }
<span class="nc bnc" id="L981" title="All 5 branches missed.">        switch (stage) {</span>
          case 0:
<span class="nc" id="L983">            print(&quot; of dataset 1&quot;);</span>
<span class="nc" id="L984">            break;</span>
          case 1:
<span class="nc" id="L986">            print(&quot; of dataset 2&quot;);</span>
<span class="nc" id="L987">            break;</span>
          case 2:
<span class="nc" id="L989">            print(&quot; of dataset 1 (2nd build)&quot;);</span>
<span class="nc" id="L990">            break;</span>
          case 3:
<span class="nc" id="L992">            print(&quot;, comparing results from builds of dataset 1&quot;);</span>
            break;	  
        }
<span class="nc" id="L995">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L996">        println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L997">        println(&quot;=== Train1 Dataset ===\n&quot;</span>
<span class="nc" id="L998">            + train1.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L999">        println(&quot;=== Test1 Dataset ===\n&quot;</span>
<span class="nc" id="L1000">            + test1.toString() + &quot;\n\n&quot;);</span>
<span class="nc" id="L1001">        println(&quot;=== Train2 Dataset ===\n&quot;</span>
<span class="nc" id="L1002">            + train2.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1003">        println(&quot;=== Test2 Dataset ===\n&quot;</span>
<span class="nc" id="L1004">            + test2.toString() + &quot;\n\n&quot;);</span>
      }
    }
    
<span class="fc" id="L1008">    return result;</span>
  }
  
  /**
   * Checks basic missing value handling of the scheme. If the missing
   * values cause an exception to be thrown by the scheme, this will be
   * recorded.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param missingLevel the percentage of missing values
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleMissing(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      boolean predictorMissing,
      boolean classMissing,
      int missingLevel) {
    
<span class="fc bfc" id="L1042" title="All 2 branches covered.">    if (missingLevel == 100)</span>
<span class="fc" id="L1043">      print(&quot;100% &quot;);</span>
<span class="fc" id="L1044">    print(&quot;missing&quot;);</span>
<span class="fc bfc" id="L1045" title="All 2 branches covered.">    if (predictorMissing) {</span>
<span class="fc" id="L1046">      print(&quot; predictor&quot;);</span>
<span class="pc bpc" id="L1047" title="1 of 2 branches missed.">      if (classMissing)</span>
<span class="nc" id="L1048">        print(&quot; and&quot;);</span>
    }
<span class="fc bfc" id="L1050" title="All 2 branches covered.">    if (classMissing)</span>
<span class="fc" id="L1051">      print(&quot; class&quot;);</span>
<span class="fc" id="L1052">    print(&quot; values&quot;);</span>
<span class="fc" id="L1053">    printAttributeSummary(</span>
<span class="fc" id="L1054">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L1055">    print(&quot;...&quot;);</span>
<span class="fc" id="L1056">    FastVector accepts = new FastVector();</span>
<span class="fc" id="L1057">    accepts.addElement(&quot;missing&quot;);</span>
<span class="fc" id="L1058">    accepts.addElement(&quot;value&quot;);</span>
<span class="fc" id="L1059">    accepts.addElement(&quot;train&quot;);</span>
<span class="fc" id="L1060">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L1061">    numClasses = 2;</span>
    
<span class="fc" id="L1063">    return runBasicTest(nominalPredictor, numericPredictor, stringPredictor, </span>
<span class="fc" id="L1064">        datePredictor, relationalPredictor, </span>
<span class="fc" id="L1065">        multiInstance,</span>
<span class="fc" id="L1066">        classType, </span>
<span class="fc" id="L1067">        missingLevel, predictorMissing, classMissing,</span>
<span class="fc" id="L1068">        numTrain, numTest, numClasses, </span>
<span class="fc" id="L1069">        accepts);</span>
  }
  
  /**
   * Checks whether an updateable scheme produces the same model when
   * trained incrementally as when batch trained. The model itself
   * cannot be compared, so we compare the evaluation on test data
   * for both models. It is possible to get a false positive on this
   * test (likelihood depends on the classifier).
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed
   */
  protected boolean[] updatingEquality(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="fc" id="L1097">    print(&quot;incremental training produces the same results&quot;</span>
        + &quot; as batch training&quot;);
<span class="fc" id="L1099">    printAttributeSummary(</span>
<span class="fc" id="L1100">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L1101">    print(&quot;...&quot;);</span>
<span class="fc" id="L1102">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L1103">    numClasses = 2, missingLevel = 0;</span>
<span class="fc" id="L1104">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L1106">    boolean[] result = new boolean[2];</span>
<span class="fc" id="L1107">    Instances train = null;</span>
<span class="fc" id="L1108">    Instances test = null;</span>
<span class="fc" id="L1109">    Classifier [] classifiers = null;</span>
<span class="fc" id="L1110">    Evaluation evaluationB = null;</span>
<span class="fc" id="L1111">    Evaluation evaluationI = null;</span>
<span class="fc" id="L1112">    boolean built = false;</span>
    try {
<span class="fc" id="L1114">      train = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L1115" title="All 2 branches covered.">                              nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">                              numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">                              stringPredictor     ? getNumString()     : 0, </span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">                              datePredictor       ? getNumDate()       : 0, </span>
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">                              relationalPredictor ? getNumRelational() : 0, </span>
<span class="fc" id="L1120">                              numClasses, </span>
<span class="fc" id="L1121">                              classType,</span>
<span class="fc" id="L1122">                              multiInstance);</span>
<span class="fc" id="L1123">      test = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">                             nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1125" title="All 2 branches covered.">                             numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="pc bpc" id="L1126" title="1 of 2 branches missed.">                             stringPredictor     ? getNumString()     : 0, </span>
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                             datePredictor       ? getNumDate()       : 0, </span>
<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">                             relationalPredictor ? getNumRelational() : 0, </span>
<span class="fc" id="L1129">                             numClasses, </span>
<span class="fc" id="L1130">                             classType,</span>
<span class="fc" id="L1131">                             multiInstance);</span>
<span class="pc bpc" id="L1132" title="1 of 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1133">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1134">        addMissing(test, Math.min(missingLevel, 50), predictorMissing, </span>
<span class="nc" id="L1135">            classMissing);</span>
      }
<span class="fc" id="L1137">      classifiers = Classifier.makeCopies(getClassifier(), 2);</span>
<span class="fc" id="L1138">      evaluationB = new Evaluation(train);</span>
<span class="fc" id="L1139">      evaluationI = new Evaluation(train);</span>
<span class="fc" id="L1140">      classifiers[0].buildClassifier(train);</span>
<span class="fc" id="L1141">      testWRTZeroR(classifiers[0], evaluationB, train, test);</span>
<span class="nc" id="L1142">    } catch (Exception ex) {</span>
<span class="nc" id="L1143">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="fc" id="L1146">      classifiers[1].buildClassifier(new Instances(train, 0));</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">      for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="fc" id="L1148">        ((UpdateableClassifier)classifiers[1]).updateClassifier(</span>
<span class="fc" id="L1149">            train.instance(i));</span>
      }
<span class="fc" id="L1151">      built = true;</span>
<span class="fc" id="L1152">      testWRTZeroR(classifiers[1], evaluationI, train, test);</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">      if (!evaluationB.equals(evaluationI)) {</span>
<span class="fc" id="L1154">        println(&quot;no&quot;);</span>
<span class="fc" id="L1155">        result[0] = false;</span>
        
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1158">          println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1159">          println(&quot;Results differ between batch and &quot;</span>
              + &quot;incrementally built models.\n&quot;
              + &quot;Depending on the classifier, this may be OK&quot;);
<span class="nc" id="L1162">          println(&quot;Here are the results:\n&quot;);</span>
<span class="nc" id="L1163">          println(evaluationB.toSummaryString(</span>
<span class="nc" id="L1164">              &quot;\nbatch built results\n&quot;, true));</span>
<span class="nc" id="L1165">          println(evaluationI.toSummaryString(</span>
<span class="nc" id="L1166">              &quot;\nincrementally built results\n&quot;, true));</span>
<span class="nc" id="L1167">          println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1168">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1169">              + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1170">          println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1171">              + test.toString() + &quot;\n\n&quot;);</span>
        }
      }
      else {
<span class="fc" id="L1175">        println(&quot;yes&quot;);</span>
<span class="fc" id="L1176">        result[0] = true;</span>
      }
<span class="nc" id="L1178">    } catch (Exception ex) {</span>
<span class="nc" id="L1179">      result[0] = false;</span>
      
<span class="nc" id="L1181">      print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">      if (built)</span>
<span class="nc" id="L1183">        print(&quot; testing&quot;);</span>
      else
<span class="nc" id="L1185">        print(&quot; training&quot;);</span>
<span class="nc" id="L1186">      println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
    }
    
<span class="fc" id="L1189">    return result;</span>
  }
  
  /**
   * Checks whether the classifier erroneously uses the class
   * value of test instances (if provided). Runs the classifier with
   * test instance class values set to missing and compares with results
   * when test instance class values are left intact.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed
   */
  protected boolean[] doesntUseTestClassVal(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="fc" id="L1216">    print(&quot;classifier ignores test instance class vals&quot;);</span>
<span class="fc" id="L1217">    printAttributeSummary(</span>
<span class="fc" id="L1218">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L1219">    print(&quot;...&quot;);</span>
<span class="fc" id="L1220">    int numTrain = 2*getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L1221">    numClasses = 2, missingLevel = 0;</span>
<span class="fc" id="L1222">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L1224">    boolean[] result = new boolean[2];</span>
<span class="fc" id="L1225">    Instances train = null;</span>
<span class="fc" id="L1226">    Instances test = null;</span>
<span class="fc" id="L1227">    Classifier [] classifiers = null;</span>
<span class="fc" id="L1228">    boolean evalFail = false;</span>
    try {
<span class="fc" id="L1230">      train = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">                              nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L1232" title="All 2 branches covered.">                              numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L1233" title="All 2 branches covered.">                              stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L1234" title="All 2 branches covered.">                              datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">                              relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L1236">                              numClasses, </span>
<span class="fc" id="L1237">                              classType,</span>
<span class="fc" id="L1238">                              multiInstance);</span>
<span class="fc" id="L1239">      test = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L1240" title="All 2 branches covered.">                             nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L1241" title="All 2 branches covered.">                             numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">                             stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L1243" title="All 2 branches covered.">                             datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                             relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L1245">                             numClasses, </span>
<span class="fc" id="L1246">                             classType,</span>
<span class="fc" id="L1247">                             multiInstance);</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1249">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1250">        addMissing(test, Math.min(missingLevel, 50), predictorMissing, </span>
<span class="nc" id="L1251">            classMissing);</span>
      }
<span class="fc" id="L1253">      classifiers = Classifier.makeCopies(getClassifier(), 2);</span>
<span class="fc" id="L1254">      classifiers[0].buildClassifier(train);</span>
<span class="fc" id="L1255">      classifiers[1].buildClassifier(train);</span>
<span class="nc" id="L1256">    } catch (Exception ex) {</span>
<span class="nc" id="L1257">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
      
      // Now set test values to missing when predicting
<span class="fc bfc" id="L1262" title="All 2 branches covered.">      for (int i = 0; i &lt; test.numInstances(); i++) {</span>
<span class="fc" id="L1263">        Instance testInst = test.instance(i);</span>
<span class="fc" id="L1264">        Instance classMissingInst = (Instance)testInst.copy();</span>
<span class="fc" id="L1265">        classMissingInst.setDataset(test);</span>
<span class="fc" id="L1266">        classMissingInst.setClassMissing();</span>
<span class="fc" id="L1267">        double [] dist0 = classifiers[0].distributionForInstance(testInst);</span>
<span class="fc" id="L1268">        double [] dist1 = classifiers[1].distributionForInstance(classMissingInst);</span>
<span class="fc bfc" id="L1269" title="All 2 branches covered.">        for (int j = 0; j &lt; dist0.length; j++) {</span>
          // ignore, if both are NaNs
<span class="pc bpc" id="L1271" title="1 of 4 branches missed.">          if (Double.isNaN(dist0[j]) &amp;&amp; Double.isNaN(dist1[j])) {</span>
<span class="pc bpc" id="L1272" title="1 of 2 branches missed.">            if (getDebug())</span>
<span class="nc" id="L1273">              System.out.println(&quot;Both predictions are NaN!&quot;);</span>
<span class="nc" id="L1274">            continue;</span>
          }
          // distribution different?
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">          if (dist0[j] != dist1[j]) {</span>
<span class="nc" id="L1278">            throw new Exception(&quot;Prediction different for instance &quot; + (i + 1));</span>
          }
        }
      }
      
<span class="fc" id="L1283">      println(&quot;yes&quot;);</span>
<span class="fc" id="L1284">      result[0] = true;</span>
<span class="nc" id="L1285">    } catch (Exception ex) {</span>
<span class="nc" id="L1286">      println(&quot;no&quot;);</span>
<span class="nc" id="L1287">      result[0] = false;</span>
      
<span class="nc bnc" id="L1289" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1290">        println(&quot;\n=== Full Report ===&quot;);</span>
        
<span class="nc bnc" id="L1292" title="All 2 branches missed.">        if (evalFail) {</span>
<span class="nc" id="L1293">          println(&quot;Results differ between non-missing and &quot;</span>
              + &quot;missing test class values.&quot;);
        } else {
<span class="nc" id="L1296">          print(&quot;Problem during testing&quot;);</span>
<span class="nc" id="L1297">          println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L1299">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1300">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1301">            + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1302">        println(&quot;=== Train Weights ===\n&quot;);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1304">          println(&quot; &quot; + (i + 1) </span>
<span class="nc" id="L1305">              + &quot;    &quot; + train.instance(i).weight());</span>
        }
<span class="nc" id="L1307">        println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1308">            + test.toString() + &quot;\n\n&quot;);	</span>
<span class="nc" id="L1309">        println(&quot;(test weights all 1.0\n&quot;);</span>
      }
    }
    
<span class="fc" id="L1313">    return result;</span>
  }
  
  /**
   * Checks whether the classifier can handle instance weights.
   * This test compares the classifier performance on two datasets
   * that are identical except for the training weights. If the 
   * results change, then the classifier must be using the weights. It
   * may be possible to get a false positive from this test if the 
   * weight changes aren't significant enough to induce a change
   * in classifier performance (but the weights are chosen to minimize
   * the likelihood of this).
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 true if the test was passed
   */
  protected boolean[] instanceWeights(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType) {
    
<span class="fc" id="L1344">    print(&quot;classifier uses instance weights&quot;);</span>
<span class="fc" id="L1345">    printAttributeSummary(</span>
<span class="fc" id="L1346">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L1347">    print(&quot;...&quot;);</span>
<span class="fc" id="L1348">    int numTrain = 2*getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L1349">    numClasses = 2, missingLevel = 0;</span>
<span class="fc" id="L1350">    boolean predictorMissing = false, classMissing = false;</span>
    
<span class="fc" id="L1352">    boolean[] result = new boolean[2];</span>
<span class="fc" id="L1353">    Instances train = null;</span>
<span class="fc" id="L1354">    Instances test = null;</span>
<span class="fc" id="L1355">    Classifier [] classifiers = null;</span>
<span class="fc" id="L1356">    Evaluation evaluationB = null;</span>
<span class="fc" id="L1357">    Evaluation evaluationI = null;</span>
<span class="fc" id="L1358">    boolean built = false;</span>
<span class="fc" id="L1359">    boolean evalFail = false;</span>
    try {
<span class="fc" id="L1361">      train = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">                              nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L1363" title="All 2 branches covered.">                              numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                              stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L1365" title="All 2 branches covered.">                              datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">                              relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L1367">                              numClasses, </span>
<span class="fc" id="L1368">                              classType,</span>
<span class="fc" id="L1369">                              multiInstance);</span>
<span class="fc" id="L1370">      test = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">                             nominalPredictor    ? getNumNominal() + 1 : 0,</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                             numericPredictor    ? getNumNumeric() + 1 : 0, </span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                             stringPredictor     ? getNumString()      : 0, </span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">                             datePredictor       ? getNumDate()        : 0, </span>
<span class="fc bfc" id="L1375" title="All 2 branches covered.">                             relationalPredictor ? getNumRelational()  : 0, </span>
<span class="fc" id="L1376">                             numClasses, </span>
<span class="fc" id="L1377">                             classType,</span>
<span class="fc" id="L1378">                             multiInstance);</span>
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1380">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="nc" id="L1381">        addMissing(test, Math.min(missingLevel, 50), predictorMissing, </span>
<span class="nc" id="L1382">            classMissing);</span>
      }
<span class="fc" id="L1384">      classifiers = Classifier.makeCopies(getClassifier(), 2);</span>
<span class="fc" id="L1385">      evaluationB = new Evaluation(train);</span>
<span class="fc" id="L1386">      evaluationI = new Evaluation(train);</span>
<span class="fc" id="L1387">      classifiers[0].buildClassifier(train);</span>
<span class="fc" id="L1388">      testWRTZeroR(classifiers[0], evaluationB, train, test);</span>
<span class="nc" id="L1389">    } catch (Exception ex) {</span>
<span class="nc" id="L1390">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
      
      // Now modify instance weights and re-built/test
<span class="fc bfc" id="L1395" title="All 2 branches covered.">      for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="fc" id="L1396">        train.instance(i).setWeight(0);</span>
      }
<span class="fc" id="L1398">      Random random = new Random(1);</span>
<span class="fc bfc" id="L1399" title="All 2 branches covered.">      for (int i = 0; i &lt; train.numInstances() / 2; i++) {</span>
<span class="fc" id="L1400">        int inst = Math.abs(random.nextInt()) % train.numInstances();</span>
<span class="fc" id="L1401">        int weight = Math.abs(random.nextInt()) % 10 + 1;</span>
<span class="fc" id="L1402">        train.instance(inst).setWeight(weight);</span>
      }
<span class="fc" id="L1404">      classifiers[1].buildClassifier(train);</span>
<span class="fc" id="L1405">      built = true;</span>
<span class="fc" id="L1406">      testWRTZeroR(classifiers[1], evaluationI, train, test);</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">      if (evaluationB.equals(evaluationI)) {</span>
        //	println(&quot;no&quot;);
<span class="fc" id="L1409">        evalFail = true;</span>
<span class="fc" id="L1410">        throw new Exception(&quot;evalFail&quot;);</span>
      }
      
<span class="fc" id="L1413">      println(&quot;yes&quot;);</span>
<span class="fc" id="L1414">      result[0] = true;</span>
<span class="fc" id="L1415">    } catch (Exception ex) {</span>
<span class="fc" id="L1416">      println(&quot;no&quot;);</span>
<span class="fc" id="L1417">      result[0] = false;</span>
      
<span class="pc bpc" id="L1419" title="1 of 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1420">        println(&quot;\n=== Full Report ===&quot;);</span>
        
<span class="nc bnc" id="L1422" title="All 2 branches missed.">        if (evalFail) {</span>
<span class="nc" id="L1423">          println(&quot;Results don't differ between non-weighted and &quot;</span>
              + &quot;weighted instance models.&quot;);
<span class="nc" id="L1425">          println(&quot;Here are the results:\n&quot;);</span>
<span class="nc" id="L1426">          println(evaluationB.toSummaryString(&quot;\nboth methods\n&quot;,</span>
<span class="nc" id="L1427">              true));</span>
        } else {
<span class="nc" id="L1429">          print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">          if (built) {</span>
<span class="nc" id="L1431">            print(&quot; testing&quot;);</span>
          } else {
<span class="nc" id="L1433">            print(&quot; training&quot;);</span>
          }
<span class="nc" id="L1435">          println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L1437">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1438">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1439">            + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1440">        println(&quot;=== Train Weights ===\n&quot;);</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">        for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1442">          println(&quot; &quot; + (i + 1) </span>
<span class="nc" id="L1443">              + &quot;    &quot; + train.instance(i).weight());</span>
        }
<span class="nc" id="L1445">        println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1446">            + test.toString() + &quot;\n\n&quot;);	</span>
<span class="nc" id="L1447">        println(&quot;(test weights all 1.0\n&quot;);</span>
      }
    }
    
<span class="fc" id="L1451">    return result;</span>
  }
  
  /**
   * Checks whether the scheme alters the training dataset during
   * training. If the scheme needs to modify the training
   * data it should take a copy of the training data. Currently checks
   * for changes to header structure, number of instances, order of
   * instances, instance weights.
   *
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param predictorMissing true if we know the classifier can handle
   * (at least) moderate missing predictor values
   * @param classMissing true if we know the classifier can handle
   * (at least) moderate missing class values
   * @return index 0 is true if the test was passed
   */
  protected boolean[] datasetIntegrity(
      boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor, 
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      boolean predictorMissing,
      boolean classMissing) {
    
<span class="fc" id="L1485">    print(&quot;classifier doesn't alter original datasets&quot;);</span>
<span class="fc" id="L1486">    printAttributeSummary(</span>
<span class="fc" id="L1487">        nominalPredictor, numericPredictor, stringPredictor, datePredictor, relationalPredictor, multiInstance, classType);</span>
<span class="fc" id="L1488">    print(&quot;...&quot;);</span>
<span class="fc" id="L1489">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="fc" id="L1490">    numClasses = 2, missingLevel = 20;</span>
    
<span class="fc" id="L1492">    boolean[] result = new boolean[2];</span>
<span class="fc" id="L1493">    Instances train = null;</span>
<span class="fc" id="L1494">    Instances test = null;</span>
<span class="fc" id="L1495">    Classifier classifier = null;</span>
<span class="fc" id="L1496">    Evaluation evaluation = null;</span>
<span class="fc" id="L1497">    boolean built = false;</span>
    try {
<span class="fc" id="L1499">      train = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">                              nominalPredictor    ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">                              numericPredictor    ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L1502" title="All 2 branches covered.">                              stringPredictor     ? getNumString()     : 0, </span>
<span class="fc bfc" id="L1503" title="All 2 branches covered.">                              datePredictor       ? getNumDate()       : 0, </span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">                              relationalPredictor ? getNumRelational() : 0, </span>
<span class="fc" id="L1505">                              numClasses, </span>
<span class="fc" id="L1506">                              classType,</span>
<span class="fc" id="L1507">                              multiInstance);</span>
<span class="fc" id="L1508">      test = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">                             nominalPredictor     ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">                             numericPredictor     ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">                             stringPredictor      ? getNumString()     : 0, </span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">                             datePredictor        ? getNumDate()       : 0, </span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">                             relationalPredictor  ? getNumRelational() : 0, </span>
<span class="fc" id="L1514">                             numClasses, </span>
<span class="fc" id="L1515">                             classType,</span>
<span class="fc" id="L1516">                             multiInstance);</span>
<span class="pc bpc" id="L1517" title="1 of 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="fc" id="L1518">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="fc" id="L1519">        addMissing(test, Math.min(missingLevel, 50), predictorMissing, </span>
<span class="fc" id="L1520">            classMissing);</span>
      }
<span class="fc" id="L1522">      classifier = Classifier.makeCopies(getClassifier(), 1)[0];</span>
<span class="fc" id="L1523">      evaluation = new Evaluation(train);</span>
<span class="nc" id="L1524">    } catch (Exception ex) {</span>
<span class="nc" id="L1525">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="fc" id="L1528">      Instances trainCopy = new Instances(train);</span>
<span class="fc" id="L1529">      Instances testCopy = new Instances(test);</span>
<span class="fc" id="L1530">      classifier.buildClassifier(trainCopy);</span>
<span class="fc" id="L1531">      compareDatasets(train, trainCopy);</span>
<span class="fc" id="L1532">      built = true;</span>
<span class="fc" id="L1533">      testWRTZeroR(classifier, evaluation, trainCopy, testCopy);</span>
<span class="fc" id="L1534">      compareDatasets(test, testCopy);</span>
      
<span class="fc" id="L1536">      println(&quot;yes&quot;);</span>
<span class="fc" id="L1537">      result[0] = true;</span>
<span class="nc" id="L1538">    } catch (Exception ex) {</span>
<span class="nc" id="L1539">      println(&quot;no&quot;);</span>
<span class="nc" id="L1540">      result[0] = false;</span>
      
<span class="nc bnc" id="L1542" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1543">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1544">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L1546">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L1548">          print(&quot; training&quot;);</span>
        }
<span class="nc" id="L1550">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L1551">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1552">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1553">            + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1554">        println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1555">            + test.toString() + &quot;\n\n&quot;);</span>
      }
    }
    
<span class="fc" id="L1559">    return result;</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param missingLevel the percentage of missing values
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numTest the number of instaces in the test set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor,
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int missingLevel,
      boolean predictorMissing,
      boolean classMissing,
      int numTrain,
      int numTest,
      int numClasses,
      FastVector accepts) {
    
<span class="fc" id="L1598">    return runBasicTest(</span>
<span class="fc" id="L1599">		nominalPredictor, </span>
<span class="fc" id="L1600">		numericPredictor,</span>
<span class="fc" id="L1601">		stringPredictor,</span>
<span class="fc" id="L1602">		datePredictor,</span>
<span class="fc" id="L1603">		relationalPredictor,</span>
<span class="fc" id="L1604">		multiInstance,</span>
<span class="fc" id="L1605">		classType, </span>
<span class="fc" id="L1606">		TestInstances.CLASS_IS_LAST,</span>
<span class="fc" id="L1607">		missingLevel,</span>
<span class="fc" id="L1608">		predictorMissing,</span>
<span class="fc" id="L1609">		classMissing,</span>
<span class="fc" id="L1610">		numTrain,</span>
<span class="fc" id="L1611">		numTest,</span>
<span class="fc" id="L1612">		numClasses,</span>
<span class="fc" id="L1613">		accepts);</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param nominalPredictor if true use nominal predictor attributes
   * @param numericPredictor if true use numeric predictor attributes
   * @param stringPredictor if true use string predictor attributes
   * @param datePredictor if true use date predictor attributes
   * @param relationalPredictor if true use relational predictor attributes
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the attribute index of the class
   * @param missingLevel the percentage of missing values
   * @param predictorMissing true if the missing values may be in 
   * the predictors
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numTest the number of instaces in the test set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(boolean nominalPredictor,
      boolean numericPredictor, 
      boolean stringPredictor,
      boolean datePredictor,
      boolean relationalPredictor,
      boolean multiInstance,
      int classType,
      int classIndex,
      int missingLevel,
      boolean predictorMissing,
      boolean classMissing,
      int numTrain,
      int numTest,
      int numClasses,
      FastVector accepts) {
    
<span class="fc" id="L1654">    boolean[] result = new boolean[2];</span>
<span class="fc" id="L1655">    Instances train = null;</span>
<span class="fc" id="L1656">    Instances test = null;</span>
<span class="fc" id="L1657">    Classifier classifier = null;</span>
<span class="fc" id="L1658">    Evaluation evaluation = null;</span>
<span class="fc" id="L1659">    boolean built = false;</span>
    try {
<span class="fc" id="L1661">      train = makeTestDataset(42, numTrain, </span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">                              nominalPredictor     ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">                              numericPredictor     ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">                              stringPredictor      ? getNumString()     : 0,</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">                              datePredictor        ? getNumDate()       : 0,</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">                              relationalPredictor  ? getNumRelational() : 0,</span>
<span class="fc" id="L1667">                              numClasses, </span>
<span class="fc" id="L1668">                              classType,</span>
<span class="fc" id="L1669">                              classIndex,</span>
<span class="fc" id="L1670">                              multiInstance);</span>
<span class="fc" id="L1671">      test = makeTestDataset(24, numTest,</span>
<span class="fc bfc" id="L1672" title="All 2 branches covered.">                             nominalPredictor     ? getNumNominal()    : 0,</span>
<span class="fc bfc" id="L1673" title="All 2 branches covered.">                             numericPredictor     ? getNumNumeric()    : 0, </span>
<span class="fc bfc" id="L1674" title="All 2 branches covered.">                             stringPredictor      ? getNumString()     : 0,</span>
<span class="fc bfc" id="L1675" title="All 2 branches covered.">                             datePredictor        ? getNumDate()       : 0,</span>
<span class="fc bfc" id="L1676" title="All 2 branches covered.">                             relationalPredictor  ? getNumRelational() : 0,</span>
<span class="fc" id="L1677">                             numClasses, </span>
<span class="fc" id="L1678">                             classType,</span>
<span class="fc" id="L1679">                             classIndex,</span>
<span class="fc" id="L1680">                             multiInstance);</span>
<span class="fc bfc" id="L1681" title="All 2 branches covered.">      if (missingLevel &gt; 0) {</span>
<span class="fc" id="L1682">        addMissing(train, missingLevel, predictorMissing, classMissing);</span>
<span class="fc" id="L1683">        addMissing(test, Math.min(missingLevel, 50), predictorMissing, </span>
<span class="fc" id="L1684">            classMissing);</span>
      }
<span class="fc" id="L1686">      classifier = Classifier.makeCopies(getClassifier(), 1)[0];</span>
<span class="fc" id="L1687">      evaluation = new Evaluation(train);</span>
<span class="nc" id="L1688">    } catch (Exception ex) {</span>
<span class="nc" id="L1689">      ex.printStackTrace();</span>
<span class="nc" id="L1690">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="fc" id="L1693">      classifier.buildClassifier(train);</span>
<span class="fc" id="L1694">      built = true;</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">      if (!testWRTZeroR(classifier, evaluation, train, test)[0]) {</span>
<span class="fc" id="L1696">        result[0] = true;</span>
<span class="fc" id="L1697">        result[1] = true;</span>
<span class="fc" id="L1698">        throw new Exception(&quot;Scheme performs worse than ZeroR&quot;);</span>
      }
      
<span class="fc" id="L1701">      println(&quot;yes&quot;);</span>
<span class="fc" id="L1702">      result[0] = true;</span>
    } 
<span class="fc" id="L1704">    catch (Exception ex) {</span>
<span class="fc" id="L1705">      boolean acceptable = false;</span>
      String msg;
<span class="pc bpc" id="L1707" title="1 of 2 branches missed.">      if (ex.getMessage() == null)</span>
<span class="nc" id="L1708">	msg = &quot;&quot;;</span>
      else
<span class="fc" id="L1710">        msg = ex.getMessage().toLowerCase();</span>
<span class="fc bfc" id="L1711" title="All 2 branches covered.">      if (msg.indexOf(&quot;not in classpath&quot;) &gt; -1)</span>
<span class="fc" id="L1712">	m_ClasspathProblems = true;</span>
<span class="fc bfc" id="L1713" title="All 2 branches covered.">      if (msg.indexOf(&quot;worse than zeror&quot;) &gt;= 0) {</span>
<span class="fc" id="L1714">        println(&quot;warning: performs worse than ZeroR&quot;);</span>
<span class="fc" id="L1715">        result[0] = true;</span>
<span class="fc" id="L1716">        result[1] = true;</span>
      } else {
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">          if (msg.indexOf((String)accepts.elementAt(i)) &gt;= 0) {</span>
<span class="fc" id="L1720">            acceptable = true;</span>
          }
        }
        
<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">        println(&quot;no&quot; + (acceptable ? &quot; (OK error message)&quot; : &quot;&quot;));</span>
<span class="fc" id="L1725">        result[1] = acceptable;</span>
      }
      
<span class="pc bpc" id="L1728" title="1 of 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1729">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1730">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L1732">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L1734">          print(&quot; training&quot;);</span>
        }
<span class="nc" id="L1736">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        if (!acceptable) {</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">          if (accepts.size() &gt; 0) {</span>
<span class="nc" id="L1739">            print(&quot;Error message doesn't mention &quot;);</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">            for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">              if (i != 0) {</span>
<span class="nc" id="L1742">                print(&quot; or &quot;);</span>
              }
<span class="nc" id="L1744">              print('&quot;' + (String)accepts.elementAt(i) + '&quot;');</span>
            }
          }
<span class="nc" id="L1747">          println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L1748">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1749">              + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1750">          println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1751">              + test.toString() + &quot;\n\n&quot;);</span>
        }
      }
    }
    
<span class="fc" id="L1756">    return result;</span>
  }
  
  /**
   * Determine whether the scheme performs worse than ZeroR during testing
   *
   * @param classifier the pre-trained classifier
   * @param evaluation the classifier evaluation object
   * @param train the training data
   * @param test the test data
   * @return index 0 is true if the scheme performs better than ZeroR
   * @throws Exception if there was a problem during the scheme's testing
   */
  protected boolean[] testWRTZeroR(Classifier classifier,
                                   Evaluation evaluation,
                                   Instances train, Instances test) 
  throws Exception {
    
<span class="fc" id="L1774">    boolean[] result = new boolean[2];</span>
    
<span class="fc" id="L1776">    evaluation.evaluateModel(classifier, test);</span>
    try {
      
      // Tested OK, compare with ZeroR
<span class="fc" id="L1780">      Classifier zeroR = new weka.classifiers.rules.ZeroR();</span>
<span class="fc" id="L1781">      zeroR.buildClassifier(train);</span>
<span class="fc" id="L1782">      Evaluation zeroREval = new Evaluation(train);</span>
<span class="fc" id="L1783">      zeroREval.evaluateModel(zeroR, test);</span>
<span class="fc" id="L1784">      result[0] = Utils.grOrEq(zeroREval.errorRate(), evaluation.errorRate());</span>
    } 
<span class="nc" id="L1786">    catch (Exception ex) {</span>
<span class="nc" id="L1787">      throw new Error(&quot;Problem determining ZeroR performance: &quot;</span>
<span class="nc" id="L1788">          + ex.getMessage());</span>
    }
    
<span class="fc" id="L1791">    return result;</span>
  }
  
  /**
   * Make a simple set of instances, which can later be modified
   * for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numNominal the number of nominal attributes
   * @param numNumeric the number of numeric attributes
   * @param numString the number of string attributes
   * @param numDate the number of date attributes
   * @param numRelational the number of relational attributes
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param multiInstance whether the dataset should a multi-instance dataset
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, int numInstances, 
                                      int numNominal, int numNumeric, 
                                      int numString, int numDate,
                                      int numRelational,
                                      int numClasses, int classType,
                                      boolean multiInstance)
    throws Exception {
    
<span class="fc" id="L1820">    return makeTestDataset(</span>
<span class="fc" id="L1821">		seed, </span>
<span class="fc" id="L1822">		numInstances,</span>
<span class="fc" id="L1823">		numNominal,</span>
<span class="fc" id="L1824">		numNumeric,</span>
<span class="fc" id="L1825">		numString,</span>
<span class="fc" id="L1826">		numDate, </span>
<span class="fc" id="L1827">		numRelational,</span>
<span class="fc" id="L1828">		numClasses, </span>
<span class="fc" id="L1829">		classType,</span>
<span class="fc" id="L1830">		TestInstances.CLASS_IS_LAST,</span>
<span class="fc" id="L1831">		multiInstance);</span>
  }
  
  /**
   * Make a simple set of instances with variable position of the class 
   * attribute, which can later be modified for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numNominal the number of nominal attributes
   * @param numNumeric the number of numeric attributes
   * @param numString the number of string attributes
   * @param numDate the number of date attributes
   * @param numRelational the number of relational attributes
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class (0-based, -1 as last)
   * @param multiInstance whether the dataset should a multi-instance dataset
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see TestInstances#CLASS_IS_LAST
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, int numInstances, 
                                      int numNominal, int numNumeric, 
                                      int numString, int numDate,
                                      int numRelational,
                                      int numClasses, int classType,
                                      int classIndex,
                                      boolean multiInstance)
  throws Exception {
    
<span class="fc" id="L1863">    TestInstances dataset = new TestInstances();</span>
    
<span class="fc" id="L1865">    dataset.setSeed(seed);</span>
<span class="fc" id="L1866">    dataset.setNumInstances(numInstances);</span>
<span class="fc" id="L1867">    dataset.setNumNominal(numNominal);</span>
<span class="fc" id="L1868">    dataset.setNumNumeric(numNumeric);</span>
<span class="fc" id="L1869">    dataset.setNumString(numString);</span>
<span class="fc" id="L1870">    dataset.setNumDate(numDate);</span>
<span class="fc" id="L1871">    dataset.setNumRelational(numRelational);</span>
<span class="fc" id="L1872">    dataset.setNumClasses(numClasses);</span>
<span class="fc" id="L1873">    dataset.setClassType(classType);</span>
<span class="fc" id="L1874">    dataset.setClassIndex(classIndex);</span>
<span class="fc" id="L1875">    dataset.setNumClasses(numClasses);</span>
<span class="fc" id="L1876">    dataset.setMultiInstance(multiInstance);</span>
<span class="fc" id="L1877">    dataset.setWords(getWords());</span>
<span class="fc" id="L1878">    dataset.setWordSeparators(getWordSeparators());</span>
    
<span class="fc" id="L1880">    return process(dataset.generate());</span>
  }
  
  /**
   * Print out a short summary string for the dataset characteristics
   *
   * @param nominalPredictor true if nominal predictor attributes are present
   * @param numericPredictor true if numeric predictor attributes are present
   * @param stringPredictor true if string predictor attributes are present
   * @param datePredictor true if date predictor attributes are present
   * @param relationalPredictor true if relational predictor attributes are present
   * @param multiInstance whether multi-instance is needed
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   */
  protected void printAttributeSummary(boolean nominalPredictor, 
                                       boolean numericPredictor, 
                                       boolean stringPredictor, 
                                       boolean datePredictor, 
                                       boolean relationalPredictor, 
                                       boolean multiInstance,
                                       int classType) {
    
<span class="fc" id="L1902">    String str = &quot;&quot;;</span>

<span class="fc bfc" id="L1904" title="All 2 branches covered.">    if (numericPredictor)</span>
<span class="fc" id="L1905">      str += &quot; numeric&quot;;</span>
    
<span class="fc bfc" id="L1907" title="All 2 branches covered.">    if (nominalPredictor) {</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">      if (str.length() &gt; 0)</span>
<span class="fc" id="L1909">        str += &quot; &amp;&quot;;</span>
<span class="fc" id="L1910">      str += &quot; nominal&quot;;</span>
    }
    
<span class="fc bfc" id="L1913" title="All 2 branches covered.">    if (stringPredictor) {</span>
<span class="fc bfc" id="L1914" title="All 2 branches covered.">      if (str.length() &gt; 0)</span>
<span class="fc" id="L1915">        str += &quot; &amp;&quot;;</span>
<span class="fc" id="L1916">      str += &quot; string&quot;;</span>
    }
    
<span class="fc bfc" id="L1919" title="All 2 branches covered.">    if (datePredictor) {</span>
<span class="fc bfc" id="L1920" title="All 2 branches covered.">      if (str.length() &gt; 0)</span>
<span class="fc" id="L1921">        str += &quot; &amp;&quot;;</span>
<span class="fc" id="L1922">      str += &quot; date&quot;;</span>
    }
    
<span class="fc bfc" id="L1925" title="All 2 branches covered.">    if (relationalPredictor) {</span>
<span class="fc bfc" id="L1926" title="All 2 branches covered.">      if (str.length() &gt; 0)</span>
<span class="fc" id="L1927">        str += &quot; &amp;&quot;;</span>
<span class="fc" id="L1928">      str += &quot; relational&quot;;</span>
    }
    
<span class="fc" id="L1931">    str += &quot; predictors)&quot;;</span>
    
<span class="pc bpc" id="L1933" title="1 of 6 branches missed.">    switch (classType) {</span>
      case Attribute.NUMERIC:
<span class="fc" id="L1935">        str = &quot; (numeric class,&quot; + str;</span>
<span class="fc" id="L1936">        break;</span>
      case Attribute.NOMINAL:
<span class="fc" id="L1938">        str = &quot; (nominal class,&quot; + str;</span>
<span class="fc" id="L1939">        break;</span>
      case Attribute.STRING:
<span class="fc" id="L1941">        str = &quot; (string class,&quot; + str;</span>
<span class="fc" id="L1942">        break;</span>
      case Attribute.DATE:
<span class="fc" id="L1944">        str = &quot; (date class,&quot; + str;</span>
<span class="fc" id="L1945">        break;</span>
      case Attribute.RELATIONAL:
<span class="fc" id="L1947">        str = &quot; (relational class,&quot; + str;</span>
        break;
    }
    
<span class="fc" id="L1951">    print(str);</span>
<span class="fc" id="L1952">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1960">    return RevisionUtils.extract(&quot;$Revision: 1.33 $&quot;);</span>
  }
  
  /**
   * Test method for this class
   * 
   * @param args the commandline parameters
   */
  public static void main(String [] args) {
<span class="nc" id="L1969">    runCheck(new CheckClassifier(), args);</span>
<span class="nc" id="L1970">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>