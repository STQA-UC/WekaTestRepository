<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MINND.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.mi</a> &gt; <span class="el_source">MINND.java</span></div><h1>MINND.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * MINND.java
 * Copyright (C) 2005 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.mi;

import weka.classifiers.Classifier;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.MultiInstanceCapabilitiesHandler;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.Enumeration;
import java.util.Vector;

/** 
 &lt;!-- globalinfo-start --&gt;
 * Multiple-Instance Nearest Neighbour with Distribution learner.&lt;br/&gt;
 * &lt;br/&gt;
 * It uses gradient descent to find the weight for each dimension of each exeamplar from the starting point of 1.0. In order to avoid overfitting, it uses mean-square function (i.e. the Euclidean distance) to search for the weights.&lt;br/&gt;
 *  It then uses the weights to cleanse the training data. After that it searches for the weights again from the starting points of the weights searched before.&lt;br/&gt;
 *  Finally it uses the most updated weights to cleanse the test exemplar and then finds the nearest neighbour of the test exemplar using partly-weighted Kullback distance. But the variances in the Kullback distance are the ones before cleansing.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Xin Xu (2001). A nearest distribution approach to multiple-instance learning. Hamilton, NZ.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;misc{Xu2001,
 *    address = {Hamilton, NZ},
 *    author = {Xin Xu},
 *    note = {0657.591B},
 *    school = {University of Waikato},
 *    title = {A nearest distribution approach to multiple-instance learning},
 *    year = {2001}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -K &amp;lt;number of neighbours&amp;gt;
 *  Set number of nearest neighbour for prediction
 *  (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;number of neighbours&amp;gt;
 *  Set number of nearest neighbour for cleansing the training data
 *  (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;number of neighbours&amp;gt;
 *  Set number of nearest neighbour for cleansing the testing data
 *  (default 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Xin Xu (xx5@cs.waikato.ac.nz)
 * @version $Revision: 9144 $ 
 */
<span class="fc" id="L92">public class MINND </span>
  extends Classifier 
  implements OptionHandler, MultiInstanceCapabilitiesHandler,
             TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = -4512599203273864994L;
  
  /** The number of nearest neighbour for prediction */
<span class="fc" id="L101">  protected int m_Neighbour = 1;</span>

  /** The mean for each attribute of each exemplar */
<span class="fc" id="L104">  protected double[][] m_Mean = null;</span>

  /** The variance for each attribute of each exemplar */
<span class="fc" id="L107">  protected double[][] m_Variance = null;</span>

  /** The dimension of each exemplar, i.e. (numAttributes-2) */
<span class="fc" id="L110">  protected int m_Dimension = 0;</span>

  /** header info of the data */
  protected Instances m_Attributes;;

  /** The class label of each exemplar */
<span class="fc" id="L116">  protected double[] m_Class = null;</span>

  /** The number of class labels in the data */
<span class="fc" id="L119">  protected int m_NumClasses = 0;</span>

  /** The weight of each exemplar */
<span class="fc" id="L122">  protected double[] m_Weights = null;</span>

  /** The very small number representing zero */
<span class="fc" id="L125">  static private double m_ZERO = 1.0e-45;</span>

  /** The learning rate in the gradient descent */
<span class="fc" id="L128">  protected double m_Rate = -1;</span>

  /** The minimum values for numeric attributes. */
<span class="fc" id="L131">  private double [] m_MinArray=null;</span>

  /** The maximum values for numeric attributes. */
<span class="fc" id="L134">  private double [] m_MaxArray=null;</span>

  /** The stopping criteria of gradient descent*/
<span class="fc" id="L137">  private double m_STOP = 1.0e-45;</span>

  /** The weights that alter the dimnesion of each exemplar */
<span class="fc" id="L140">  private double[][] m_Change=null;</span>

  /** The noise data of each exemplar */
<span class="fc" id="L143">  private double[][] m_NoiseM = null, m_NoiseV = null, m_ValidM = null, </span>
<span class="fc" id="L144">          m_ValidV = null;</span>

  /** The number of nearest neighbour instances in the selection of noises 
    in the training data*/
<span class="fc" id="L148">  private int m_Select = 1;</span>

  /** The number of nearest neighbour exemplars in the selection of noises 
    in the test data */
<span class="fc" id="L152">  private int m_Choose = 1;</span>

  /** The decay rate of learning rate */
<span class="fc" id="L155">  private double m_Decay = 0.5;</span>

  /**
   * Returns a string describing this filter
   *
   * @return a description of the filter suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L164">    return </span>
<span class="nc" id="L165">        &quot;Multiple-Instance Nearest Neighbour with Distribution learner.\n\n&quot;</span>
      + &quot;It uses gradient descent to find the weight for each dimension of &quot;
      + &quot;each exeamplar from the starting point of 1.0. In order to avoid &quot;
      + &quot;overfitting, it uses mean-square function (i.e. the Euclidean &quot;
      + &quot;distance) to search for the weights.\n &quot;
      + &quot;It then uses the weights to cleanse the training data. After that &quot;
      + &quot;it searches for the weights again from the starting points of the &quot;
      + &quot;weights searched before.\n &quot;
      + &quot;Finally it uses the most updated weights to cleanse the test exemplar &quot;
      + &quot;and then finds the nearest neighbour of the test exemplar using &quot;
      + &quot;partly-weighted Kullback distance. But the variances in the Kullback &quot;
      + &quot;distance are the ones before cleansing.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L178">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L191">    result = new TechnicalInformation(Type.MISC);</span>
<span class="nc" id="L192">    result.setValue(Field.AUTHOR, &quot;Xin Xu&quot;);</span>
<span class="nc" id="L193">    result.setValue(Field.YEAR, &quot;2001&quot;);</span>
<span class="nc" id="L194">    result.setValue(Field.TITLE, &quot;A nearest distribution approach to multiple-instance learning&quot;);</span>
<span class="nc" id="L195">    result.setValue(Field.SCHOOL, &quot;University of Waikato&quot;);</span>
<span class="nc" id="L196">    result.setValue(Field.ADDRESS, &quot;Hamilton, NZ&quot;);</span>
<span class="nc" id="L197">    result.setValue(Field.NOTE, &quot;0657.591B&quot;);</span>
    
<span class="nc" id="L199">    return result;</span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L208">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L209">    result.disableAll();</span>

    // attributes
<span class="fc" id="L212">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L213">    result.enable(Capability.RELATIONAL_ATTRIBUTES);</span>

    // class
<span class="fc" id="L216">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L217">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
    // other
<span class="fc" id="L220">    result.enable(Capability.ONLY_MULTIINSTANCE);</span>
    
<span class="fc" id="L222">    return result;</span>
  }

  /**
   * Returns the capabilities of this multi-instance classifier for the
   * relational data.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getMultiInstanceCapabilities() {
<span class="fc" id="L233">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L234">    result.disableAll();</span>
    
    // attributes
<span class="fc" id="L237">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L238">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L239">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L242">    result.disableAllClasses();</span>
<span class="fc" id="L243">    result.enable(Capability.NO_CLASS);</span>
    
<span class="fc" id="L245">    return result;</span>
  }

  /**
   * As normal Nearest Neighbour algorithm does, it's lazy and simply
   * records the exemplar information (i.e. mean and variance for each
   * dimension of each exemplar and their classes) when building the model.
   * There is actually no need to store the exemplars themselves.
   *
   * @param exs the training exemplars
   * @throws Exception if the model cannot be built properly
   */    
  public void buildClassifier(Instances exs)throws Exception{
    // can classifier handle the data?
<span class="fc" id="L259">    getCapabilities().testWithFail(exs);</span>

    // remove instances with missing class
<span class="fc" id="L262">    Instances newData = new Instances(exs);</span>
<span class="fc" id="L263">    newData.deleteWithMissingClass();</span>
    
<span class="fc" id="L265">    int numegs = newData.numInstances();</span>
<span class="fc" id="L266">    m_Dimension = newData.attribute(1).relation().numAttributes();</span>
<span class="fc" id="L267">    m_Attributes = newData.stringFreeStructure(); </span>
<span class="fc" id="L268">    m_Change = new double[numegs][m_Dimension];</span>
<span class="fc" id="L269">    m_NumClasses = exs.numClasses();</span>
<span class="fc" id="L270">    m_Mean = new double[numegs][m_Dimension];</span>
<span class="fc" id="L271">    m_Variance = new double[numegs][m_Dimension];</span>
<span class="fc" id="L272">    m_Class = new double[numegs];</span>
<span class="fc" id="L273">    m_Weights = new double[numegs];</span>
<span class="fc" id="L274">    m_NoiseM = new double[numegs][m_Dimension];</span>
<span class="fc" id="L275">    m_NoiseV = new double[numegs][m_Dimension];</span>
<span class="fc" id="L276">    m_ValidM = new double[numegs][m_Dimension];</span>
<span class="fc" id="L277">    m_ValidV = new double[numegs][m_Dimension];</span>
<span class="fc" id="L278">    m_MinArray = new double[m_Dimension];</span>
<span class="fc" id="L279">    m_MaxArray = new double[m_Dimension];</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">    for(int v=0; v &lt; m_Dimension; v++)</span>
<span class="fc" id="L281">      m_MinArray[v] = m_MaxArray[v] = Double.NaN;</span>

<span class="fc bfc" id="L283" title="All 2 branches covered.">    for(int w=0; w &lt; numegs; w++){</span>
<span class="fc" id="L284">      updateMinMax(newData.instance(w));</span>
    }

    // Scale exemplars
<span class="fc" id="L288">    Instances data = m_Attributes;</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">    for(int x=0; x &lt; numegs; x++){</span>
<span class="fc" id="L291">      Instance example = newData.instance(x);</span>
<span class="fc" id="L292">      example = scale(example);</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">      for (int i=0; i&lt;m_Dimension; i++) {</span>
<span class="fc" id="L294">        m_Mean[x][i] = example.relationalValue(1).meanOrMode(i);	</span>
<span class="fc" id="L295">        m_Variance[x][i] = example.relationalValue(1).variance(i);</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if(Utils.eq(m_Variance[x][i],0.0))</span>
<span class="nc" id="L297">          m_Variance[x][i] = m_ZERO;</span>
<span class="fc" id="L298">        m_Change[x][i] = 1.0;</span>
      }
      /* for(int y=0; y &lt; m_Variance[x].length; y++){
         if(Utils.eq(m_Variance[x][y],0.0))
         m_Variance[x][y] = m_ZERO;
         m_Change[x][y] = 1.0;
         }  */	

<span class="fc" id="L306">      data.add(example);</span>
<span class="fc" id="L307">      m_Class[x] = example.classValue();</span>
<span class="fc" id="L308">      m_Weights[x] = example.weight();	</span>
    }

<span class="fc bfc" id="L311" title="All 2 branches covered.">    for(int z=0; z &lt; numegs; z++)</span>
<span class="fc" id="L312">      findWeights(z, m_Mean);</span>

    // Pre-process and record &quot;true estimated&quot; parameters for distributions 
<span class="fc bfc" id="L315" title="All 2 branches covered.">    for(int x=0; x &lt; numegs; x++){</span>
<span class="fc" id="L316">      Instance example = preprocess(data, x);</span>
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">      if (getDebug())</span>
<span class="nc" id="L318">        System.out.println(&quot;???Exemplar &quot;+x+&quot; has been pre-processed:&quot;+</span>
<span class="nc" id="L319">            data.instance(x).relationalValue(1).sumOfWeights()+</span>
<span class="nc" id="L320">            &quot;|&quot;+example.relationalValue(1).sumOfWeights()+</span>
<span class="nc" id="L321">            &quot;; class:&quot;+m_Class[x]);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">      if(Utils.gr(example.relationalValue(1).sumOfWeights(), 0)){	</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">        for (int i=0; i&lt;m_Dimension; i++) {</span>
<span class="fc" id="L324">          m_ValidM[x][i] = example.relationalValue(1).meanOrMode(i);</span>
<span class="fc" id="L325">          m_ValidV[x][i] = example.relationalValue(1).variance(i);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">          if(Utils.eq(m_ValidV[x][i],0.0))</span>
<span class="fc" id="L327">            m_ValidV[x][i] = m_ZERO;</span>
        }
        /*	for(int y=0; y &lt; m_ValidV[x].length; y++){
                if(Utils.eq(m_ValidV[x][y],0.0))
                m_ValidV[x][y] = m_ZERO;
                }*/	
      }
      else{
<span class="fc" id="L335">        m_ValidM[x] = null;</span>
<span class="fc" id="L336">        m_ValidV[x] = null;</span>
      }
    }

<span class="fc bfc" id="L340" title="All 2 branches covered.">    for(int z=0; z &lt; numegs; z++)</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      if(m_ValidM[z] != null)</span>
<span class="fc" id="L342">        findWeights(z, m_ValidM);	</span>

<span class="fc" id="L344">  }</span>

  /**
   * Pre-process the given exemplar according to the other exemplars 
   * in the given exemplars.  It also updates noise data statistics.
   *
   * @param data the whole exemplars
   * @param pos the position of given exemplar in data
   * @return the processed exemplar
   * @throws Exception if the returned exemplar is wrong 
   */
  public Instance preprocess(Instances data, int pos)
    throws Exception{
<span class="fc" id="L357">    Instance before = data.instance(pos);</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">    if((int)before.classValue() == 0){</span>
<span class="fc" id="L359">      m_NoiseM[pos] = null;</span>
<span class="fc" id="L360">      m_NoiseV[pos] = null;</span>
<span class="fc" id="L361">      return before;</span>
    }

<span class="fc" id="L364">    Instances after_relationInsts =before.attribute(1).relation().stringFreeStructure();</span>
<span class="fc" id="L365">    Instances noises_relationInsts =before.attribute(1).relation().stringFreeStructure();</span>

<span class="fc" id="L367">    Instances newData = m_Attributes;</span>
<span class="fc" id="L368">    Instance after = new Instance(before.numAttributes());</span>
<span class="fc" id="L369">    Instance noises =  new Instance(before.numAttributes());</span>
<span class="fc" id="L370">    after.setDataset(newData);</span>
<span class="fc" id="L371">    noises.setDataset(newData);</span>

<span class="fc bfc" id="L373" title="All 2 branches covered.">    for(int g=0; g &lt; before.relationalValue(1).numInstances(); g++){</span>
<span class="fc" id="L374">      Instance datum = before.relationalValue(1).instance(g);</span>
<span class="fc" id="L375">      double[] dists = new double[data.numInstances()];</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">      for(int i=0; i &lt; data.numInstances(); i++){</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if(i != pos)</span>
<span class="fc" id="L379">          dists[i] = distance(datum, m_Mean[i], m_Variance[i], i);</span>
        else
<span class="fc" id="L381">          dists[i] = Double.POSITIVE_INFINITY;</span>
      }		   

<span class="fc" id="L384">      int[] pred = new int[m_NumClasses];</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">      for(int n=0; n &lt; pred.length; n++)</span>
<span class="fc" id="L386">        pred[n] = 0;</span>

<span class="fc bfc" id="L388" title="All 2 branches covered.">      for(int o=0; o&lt;m_Select; o++){</span>
<span class="fc" id="L389">        int index = Utils.minIndex(dists);</span>
<span class="fc" id="L390">        pred[(int)m_Class[index]]++;</span>
<span class="fc" id="L391">        dists[index] = Double.POSITIVE_INFINITY;</span>
      }

<span class="fc" id="L394">      int clas = Utils.maxIndex(pred);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">      if((int)before.classValue() != clas)</span>
<span class="fc" id="L396">        noises_relationInsts.add(datum);</span>
      else
<span class="fc" id="L398">        after_relationInsts.add(datum);		</span>
    }

    int relationValue;
<span class="fc" id="L402">    relationValue = noises.attribute(1).addRelation( noises_relationInsts);</span>
<span class="fc" id="L403">    noises.setValue(0,before.value(0));</span>
<span class="fc" id="L404">    noises.setValue(1, relationValue);</span>
<span class="fc" id="L405">    noises.setValue(2, before.classValue());</span>

<span class="fc" id="L407">    relationValue = after.attribute(1).addRelation( after_relationInsts);</span>
<span class="fc" id="L408">    after.setValue(0,before.value(0));</span>
<span class="fc" id="L409">    after.setValue(1, relationValue);</span>
<span class="fc" id="L410">    after.setValue(2, before.classValue());</span>


<span class="fc bfc" id="L413" title="All 2 branches covered.">    if(Utils.gr(noises.relationalValue(1).sumOfWeights(), 0)){	</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">      for (int i=0; i&lt;m_Dimension; i++) {</span>
<span class="fc" id="L415">        m_NoiseM[pos][i] = noises.relationalValue(1).meanOrMode(i);</span>
<span class="fc" id="L416">        m_NoiseV[pos][i] = noises.relationalValue(1).variance(i);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if(Utils.eq(m_NoiseV[pos][i],0.0))</span>
<span class="fc" id="L418">          m_NoiseV[pos][i] = m_ZERO;</span>
      }
      /* for(int y=0; y &lt; m_NoiseV[pos].length; y++){
         if(Utils.eq(m_NoiseV[pos][y],0.0))
         m_NoiseV[pos][y] = m_ZERO;
         } */	
    }
    else{
<span class="fc" id="L426">      m_NoiseM[pos] = null;</span>
<span class="fc" id="L427">      m_NoiseV[pos] = null;</span>
    }

<span class="fc" id="L430">    return after;</span>
  }

  /**
   * Calculates the distance between two instances
   *
   * @param first the first instance
   * @param second the second instance
   * @return the distance between the two given instances
   */          
  private double distance(Instance first, double[] mean, double[] var, int pos) {

<span class="fc" id="L442">    double diff, distance = 0;</span>

<span class="fc bfc" id="L444" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Dimension; i++) { </span>
      // If attribute is numeric
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">      if(first.attribute(i).isNumeric()){</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (!first.isMissing(i)){      </span>
<span class="fc" id="L448">          diff = first.value(i) - mean[i];</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">          if(Utils.gr(var[i], m_ZERO))</span>
<span class="fc" id="L450">            distance += m_Change[pos][i] * var[i] * diff * diff;</span>
          else
<span class="fc" id="L452">            distance += m_Change[pos][i] * diff * diff; </span>
        }
        else{
<span class="nc bnc" id="L455" title="All 2 branches missed.">          if(Utils.gr(var[i], m_ZERO))</span>
<span class="nc" id="L456">            distance += m_Change[pos][i] * var[i];</span>
          else
<span class="nc" id="L458">            distance += m_Change[pos][i] * 1.0;</span>
        }
      }

    }

<span class="fc" id="L464">    return distance;</span>
  }

  /**
   * Updates the minimum and maximum values for all the attributes
   * based on a new exemplar.
   *
   * @param ex the new exemplar
   */
  private void updateMinMax(Instance ex) {	
<span class="fc" id="L474">    Instances insts = ex.relationalValue(1);</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">    for (int j = 0;j &lt; m_Dimension; j++) {</span>
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">      if (insts.attribute(j).isNumeric()){</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">        for(int k=0; k &lt; insts.numInstances(); k++){</span>
<span class="fc" id="L478">          Instance ins = insts.instance(k);</span>
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">          if(!ins.isMissing(j)){</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">            if (Double.isNaN(m_MinArray[j])) {</span>
<span class="fc" id="L481">              m_MinArray[j] = ins.value(j);</span>
<span class="fc" id="L482">              m_MaxArray[j] = ins.value(j);</span>
            } else {
<span class="fc bfc" id="L484" title="All 2 branches covered.">              if (ins.value(j) &lt; m_MinArray[j])</span>
<span class="fc" id="L485">                m_MinArray[j] = ins.value(j);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">              else if (ins.value(j) &gt; m_MaxArray[j])</span>
<span class="fc" id="L487">                m_MaxArray[j] = ins.value(j);</span>
            }
          }
        }
      }
    }
<span class="fc" id="L493">  }</span>

  /**
   * Scale the given exemplar so that the returned exemplar
   * has the value of 0 to 1 for each dimension
   * 
   * @param before the given exemplar
   * @return the resultant exemplar after scaling
   * @throws Exception if given exampler cannot be scaled properly
   */
  private Instance scale(Instance before) throws Exception{

<span class="fc" id="L505">    Instances afterInsts = before.relationalValue(1).stringFreeStructure();</span>
<span class="fc" id="L506">    Instance after = new Instance(before.numAttributes());</span>
<span class="fc" id="L507">    after.setDataset(m_Attributes);</span>

<span class="fc bfc" id="L509" title="All 2 branches covered.">    for(int i=0; i &lt; before.relationalValue(1).numInstances(); i++){</span>
<span class="fc" id="L510">      Instance datum = before.relationalValue(1).instance(i);</span>
<span class="fc" id="L511">      Instance inst = (Instance)datum.copy();</span>

<span class="fc bfc" id="L513" title="All 2 branches covered.">      for(int j=0; j &lt; m_Dimension; j++){</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if(before.relationalValue(1).attribute(j).isNumeric())</span>
<span class="fc" id="L515">          inst.setValue(j, (datum.value(j) - m_MinArray[j])/(m_MaxArray[j] - m_MinArray[j]));	</span>
      }
<span class="fc" id="L517">      afterInsts.add(inst);</span>
    }

<span class="fc" id="L520">    int attValue = after.attribute(1).addRelation(afterInsts);</span>
<span class="fc" id="L521">    after.setValue(0, before.value( 0));</span>
<span class="fc" id="L522">    after.setValue(1, attValue);	</span>
<span class="fc" id="L523">    after.setValue(2, before.value( 2));</span>

<span class="fc" id="L525">    return after;</span>
  }

  /**
   * Use gradient descent to distort the MU parameter for
   * the exemplar.  The exemplar can be in the specified row in the 
   * given matrix, which has numExemplar rows and numDimension columns;
   * or not in the matrix.
   * 
   * @param row the given row index
   * @param mean
   */
  public void findWeights(int row, double[][] mean){

<span class="fc" id="L539">    double[] neww = new double[m_Dimension];</span>
<span class="fc" id="L540">    double[] oldw = new double[m_Dimension];</span>
<span class="fc" id="L541">    System.arraycopy(m_Change[row], 0, neww, 0, m_Dimension);</span>
    //for(int z=0; z&lt;m_Dimension; z++)
    //System.out.println(&quot;mu(&quot;+row+&quot;): &quot;+origin[z]+&quot; | &quot;+newmu[z]);
<span class="fc" id="L544">    double newresult = target(neww, mean, row, m_Class);</span>
<span class="fc" id="L545">    double result = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L546">    double rate= 0.05;</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">    if(m_Rate != -1)</span>
<span class="nc" id="L548">      rate = m_Rate;</span>
    //System.out.println(&quot;???Start searching ...&quot;);
search: 
<span class="pc bfc" id="L551" title="All 2 branches covered.">    while(Utils.gr((result-newresult), m_STOP)){ // Full step</span>
<span class="fc" id="L552">      oldw = neww;</span>
<span class="fc" id="L553">      neww= new double[m_Dimension];</span>

<span class="fc" id="L555">      double[] delta = delta(oldw, mean, row, m_Class);</span>

<span class="fc bfc" id="L557" title="All 2 branches covered.">      for(int i=0; i &lt; m_Dimension; i++)</span>
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">        if(Utils.gr(m_Variance[row][i], 0.0))</span>
<span class="fc" id="L559">          neww[i] = oldw[i] + rate * delta[i];</span>

<span class="fc" id="L561">      result = newresult;</span>
<span class="fc" id="L562">      newresult = target(neww, mean, row, m_Class);</span>

      //System.out.println(&quot;???old: &quot;+result+&quot;|new: &quot;+newresult);
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">      while(Utils.gr(newresult, result)){ // Search back</span>
        //System.out.println(&quot;search back&quot;);
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if(m_Rate == -1){</span>
<span class="nc" id="L568">          rate *= m_Decay; // Decay</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">          for(int i=0; i &lt; m_Dimension; i++)</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if(Utils.gr(m_Variance[row][i], 0.0))</span>
<span class="nc" id="L571">              neww[i] = oldw[i] + rate * delta[i];</span>
<span class="nc" id="L572">          newresult = target(neww, mean, row, m_Class);</span>
        }
        else{
<span class="nc bnc" id="L575" title="All 2 branches missed.">          for(int i=0; i &lt; m_Dimension; i++)</span>
<span class="nc" id="L576">            neww[i] = oldw[i];</span>
<span class="nc" id="L577">          break search;</span>
        }
      }
    }
    //System.out.println(&quot;???Stop&quot;);
<span class="fc" id="L582">    m_Change[row] = neww;</span>
<span class="fc" id="L583">  }</span>

  /**
   * Delta of x in one step of gradient descent:
   * delta(Wij) = 1/2 * sum[k=1..N, k!=i](sqrt(P)*(Yi-Yk)/D - 1) * (MUij -
   * MUkj)^2 where D = sqrt(sum[j=1..P]Kkj(MUij - MUkj)^2)
   * N is number of exemplars and P is number of dimensions
   *
   * @param x the weights of the exemplar in question
   * @param rowpos row index of x in X
   * @param Y the observed class label
   * @return the delta for all dimensions
   */
  private double[] delta(double[] x, double[][] X, int rowpos, double[] Y){
<span class="fc" id="L597">    double y = Y[rowpos];</span>

<span class="fc" id="L599">    double[] delta=new double[m_Dimension];</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">    for(int h=0; h &lt; m_Dimension; h++)</span>
<span class="fc" id="L601">      delta[h] = 0.0;</span>

<span class="fc bfc" id="L603" title="All 2 branches covered.">    for(int i=0; i &lt; X.length; i++){</span>
<span class="fc bfc" id="L604" title="All 4 branches covered.">      if((i != rowpos) &amp;&amp; (X[i] != null)){</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        double var = (y==Y[i]) ? 0.0 : Math.sqrt((double)m_Dimension - 1);</span>
<span class="fc" id="L606">        double distance=0;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">        for(int j=0; j &lt; m_Dimension; j++)</span>
<span class="pc bpc" id="L608" title="1 of 2 branches missed.">          if(Utils.gr(m_Variance[rowpos][j], 0.0))</span>
<span class="fc" id="L609">            distance += x[j]*(X[rowpos][j]-X[i][j]) * (X[rowpos][j]-X[i][j]);</span>
<span class="fc" id="L610">        distance = Math.sqrt(distance);</span>
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">        if(distance != 0)</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">          for(int k=0; k &lt; m_Dimension; k++)</span>
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">            if(m_Variance[rowpos][k] &gt; 0.0)</span>
<span class="fc" id="L614">              delta[k] += (var/distance - 1.0) * 0.5 *</span>
<span class="fc" id="L615">                (X[rowpos][k]-X[i][k]) *</span>
<span class="fc" id="L616">                (X[rowpos][k]-X[i][k]);</span>
      }
    }
    //System.out.println(&quot;???delta: &quot;+delta);
<span class="fc" id="L620">    return delta;</span>
  }

  /**
   * Compute the target function to minimize in gradient descent
   * The formula is:&lt;br/&gt;
   * 1/2*sum[i=1..p](f(X, Xi)-var(Y, Yi))^2 &lt;p/&gt;
   * where p is the number of exemplars and Y is the class label.
   * In the case of X=MU, f() is the Euclidean distance between two
   * exemplars together with the related weights and var() is 
   * sqrt(numDimension)*(Y-Yi) where Y-Yi is either 0 (when Y==Yi)
   * or 1 (Y!=Yi) 
   *
   * @param x the weights of the exemplar in question
   * @param rowpos row index of x in X
   * @param Y the observed class label
   * @return the result of the target function
   */
  public double target(double[] x, double[][] X, int rowpos, double[] Y){
<span class="fc" id="L639">    double y = Y[rowpos], result=0;</span>

<span class="fc bfc" id="L641" title="All 2 branches covered.">    for(int i=0; i &lt; X.length; i++){</span>
<span class="fc bfc" id="L642" title="All 4 branches covered.">      if((i != rowpos) &amp;&amp; (X[i] != null)){</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        double var = (y==Y[i]) ? 0.0 : Math.sqrt((double)m_Dimension - 1);</span>
<span class="fc" id="L644">        double f=0;</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">        for(int j=0; j &lt; m_Dimension; j++)</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">          if(Utils.gr(m_Variance[rowpos][j], 0.0)){</span>
<span class="fc" id="L647">            f += x[j]*(X[rowpos][j]-X[i][j]) * (X[rowpos][j]-X[i][j]);     </span>
            //System.out.println(&quot;i:&quot;+i+&quot; j: &quot;+j+&quot; row: &quot;+rowpos);
          }
<span class="fc" id="L650">        f = Math.sqrt(f);</span>
        //System.out.println(&quot;???distance between &quot;+rowpos+&quot; and &quot;+i+&quot;: &quot;+f+&quot;|y:&quot;+y+&quot; vs &quot;+Y[i]);
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if(Double.isInfinite(f))</span>
<span class="nc" id="L653">          System.exit(1);</span>
<span class="fc" id="L654">        result += 0.5 * (f - var) * (f - var);</span>
      }
    }
    //System.out.println(&quot;???target: &quot;+result);
<span class="fc" id="L658">    return result;</span>
  }    

  /**
   * Use Kullback Leibler distance to find the nearest neighbours of
   * the given exemplar.
   * It also uses K-Nearest Neighbour algorithm to classify the 
   * test exemplar
   *
   * @param ex the given test exemplar
   * @return the classification 
   * @throws Exception if the exemplar could not be classified
   * successfully
   */
  public double classifyInstance(Instance ex)throws Exception{

<span class="fc" id="L674">    ex = scale(ex);</span>

<span class="fc" id="L676">    double[] var = new double [m_Dimension];</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">    for (int i=0; i&lt;m_Dimension; i++) </span>
<span class="fc" id="L678">      var[i]= ex.relationalValue(1).variance(i);	</span>

    // The Kullback distance to all exemplars
<span class="fc" id="L681">    double[] kullback = new double[m_Class.length];</span>

    // The first K nearest neighbours' predictions */
<span class="fc" id="L684">  double[] predict = new double[m_NumClasses];</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">  for(int h=0; h &lt; predict.length; h++)</span>
<span class="fc" id="L686">    predict[h] = 0;</span>
<span class="fc" id="L687">  ex = cleanse(ex);</span>

<span class="pc bpc" id="L689" title="1 of 2 branches missed.">  if(ex.relationalValue(1).numInstances() == 0){</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">    if (getDebug())</span>
<span class="nc" id="L691">      System.out.println(&quot;???Whole exemplar falls into ambiguous area!&quot;);</span>
<span class="nc" id="L692">    return 1.0;                          // Bias towards positive class</span>
  }

<span class="fc" id="L695">  double[] mean = new double[m_Dimension];	</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">  for (int i=0; i&lt;m_Dimension; i++)</span>
<span class="fc" id="L697">    mean [i]=ex.relationalValue(1).meanOrMode(i);</span>

  // Avoid zero sigma
<span class="fc bfc" id="L700" title="All 2 branches covered.">  for(int h=0; h &lt; var.length; h++){</span>
<span class="pc bpc" id="L701" title="1 of 2 branches missed.">    if(Utils.eq(var[h],0.0))</span>
<span class="nc" id="L702">      var[h] = m_ZERO;</span>
  }	

<span class="fc bfc" id="L705" title="All 2 branches covered.">  for(int i=0; i &lt; m_Class.length; i++){</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">    if(m_ValidM[i] != null)</span>
<span class="fc" id="L707">      kullback[i] = kullback(mean, m_ValidM[i], var, m_Variance[i], i);</span>
    else
<span class="fc" id="L709">      kullback[i] = Double.POSITIVE_INFINITY;</span>
  }

<span class="fc bfc" id="L712" title="All 2 branches covered.">  for(int j=0; j &lt; m_Neighbour; j++){</span>
<span class="fc" id="L713">    int pos = Utils.minIndex(kullback);</span>
<span class="fc" id="L714">    predict[(int)m_Class[pos]] += m_Weights[pos];	   </span>
<span class="fc" id="L715">    kullback[pos] = Double.POSITIVE_INFINITY;</span>
  }	

<span class="pc bpc" id="L718" title="1 of 2 branches missed.">  if (getDebug())</span>
<span class="nc" id="L719">    System.out.println(&quot;???There are still some unambiguous instances in this exemplar! Predicted as: &quot;+Utils.maxIndex(predict));</span>
<span class="fc" id="L720">  return (double)Utils.maxIndex(predict);	</span>
  } 

  /**
   * Cleanse the given exemplar according to the valid and noise data
   * statistics
   *
   * @param before the given exemplar
   * @return the processed exemplar
   * @throws Exception if the returned exemplar is wrong 
   */
  public Instance cleanse(Instance before) throws Exception{

<span class="fc" id="L733">    Instances insts = before.relationalValue(1).stringFreeStructure();</span>
<span class="fc" id="L734">    Instance after = new Instance (before.numAttributes());</span>
<span class="fc" id="L735">    after.setDataset(m_Attributes);</span>

<span class="fc bfc" id="L737" title="All 2 branches covered.">    for(int g=0; g &lt; before.relationalValue(1).numInstances(); g++){</span>
<span class="fc" id="L738">      Instance datum = before.relationalValue(1).instance(g);</span>
<span class="fc" id="L739">      double[] minNoiDists = new double[m_Choose];</span>
<span class="fc" id="L740">      double[] minValDists = new double[m_Choose];</span>
<span class="fc" id="L741">      int noiseCount = 0, validCount = 0;</span>
<span class="fc" id="L742">      double[] nDist = new double[m_Mean.length]; </span>
<span class="fc" id="L743">      double[] vDist = new double[m_Mean.length]; </span>

<span class="fc bfc" id="L745" title="All 2 branches covered.">      for(int h=0; h &lt; m_Mean.length; h++){</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">        if(m_ValidM[h] == null)</span>
<span class="fc" id="L747">          vDist[h] = Double.POSITIVE_INFINITY;</span>
        else
<span class="fc" id="L749">          vDist[h] = distance(datum, m_ValidM[h], m_ValidV[h], h);</span>

<span class="fc bfc" id="L751" title="All 2 branches covered.">        if(m_NoiseM[h] == null)</span>
<span class="fc" id="L752">          nDist[h] = Double.POSITIVE_INFINITY;</span>
        else
<span class="fc" id="L754">          nDist[h] = distance(datum, m_NoiseM[h], m_NoiseV[h], h);</span>
      }

<span class="fc bfc" id="L757" title="All 2 branches covered.">      for(int k=0; k &lt; m_Choose; k++){</span>
<span class="fc" id="L758">        int pos = Utils.minIndex(vDist);</span>
<span class="fc" id="L759">        minValDists[k] = vDist[pos];</span>
<span class="fc" id="L760">        vDist[pos] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L761">        pos = Utils.minIndex(nDist);</span>
<span class="fc" id="L762">        minNoiDists[k] = nDist[pos];</span>
<span class="fc" id="L763">        nDist[pos] = Double.POSITIVE_INFINITY;</span>
      }

<span class="fc" id="L766">      int x = 0,y = 0;</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">      while((x+y) &lt; m_Choose){</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">        if(minValDists[x] &lt;= minNoiDists[y]){</span>
<span class="fc" id="L769">          validCount++;</span>
<span class="fc" id="L770">          x++;</span>
        }
        else{
<span class="fc" id="L773">          noiseCount++;</span>
<span class="fc" id="L774">          y++;</span>
        }
      }
<span class="fc bfc" id="L777" title="All 2 branches covered.">      if(x &gt;= y)</span>
<span class="fc" id="L778">        insts.add (datum);</span>

    }

<span class="fc" id="L782">    after.setValue(0, before.value( 0));</span>
<span class="fc" id="L783">    after.setValue(1, after.attribute(1).addRelation(insts));</span>
<span class="fc" id="L784">    after.setValue(2, before.value( 2));</span>

<span class="fc" id="L786">    return after;</span>
  }    

  /**
   * This function calculates the Kullback Leibler distance between
   * two normal distributions.  This distance is always positive. 
   * Kullback Leibler distance = integral{f(X)ln(f(X)/g(X))}
   * Note that X is a vector.  Since we assume dimensions are independent
   * f(X)(g(X) the same) is actually the product of normal density
   * functions of each dimensions.  Also note that it should be log2
   * instead of (ln) in the formula, but we use (ln) simply for computational
   * convenience.
   *
   * The result is as follows, suppose there are P dimensions, and f(X)
   * is the first distribution and g(X) is the second:
   * Kullback = sum[1..P](ln(SIGMA2/SIGMA1)) +
   *            sum[1..P](SIGMA1^2 / (2*(SIGMA2^2))) +
   *            sum[1..P]((MU1-MU2)^2 / (2*(SIGMA2^2))) -
   *            P/2
   *
   * @param mu1 mu of the first normal distribution
   * @param mu2 mu of the second normal distribution 
   * @param var1 variance(SIGMA^2) of the first normal distribution
   * @param var2 variance(SIGMA^2) of the second normal distribution
   * @return the Kullback distance of two distributions
   */
  public double kullback(double[] mu1, double[] mu2,
      double[] var1, double[] var2, int pos){
<span class="fc" id="L814">    int p = mu1.length;</span>
<span class="fc" id="L815">    double result = 0;</span>

<span class="fc bfc" id="L817" title="All 2 branches covered.">    for(int y=0; y &lt; p; y++){</span>
<span class="pc bpc" id="L818" title="2 of 4 branches missed.">      if((Utils.gr(var1[y], 0)) &amp;&amp; (Utils.gr(var2[y], 0))){</span>
<span class="fc" id="L819">        result +=  </span>
<span class="fc" id="L820">          ((Math.log(Math.sqrt(var2[y]/var1[y]))) +</span>
<span class="fc" id="L821">           (var1[y] / (2.0*var2[y])) + </span>
<span class="fc" id="L822">           (m_Change[pos][y] * (mu1[y]-mu2[y])*(mu1[y]-mu2[y]) / (2.0*var2[y])) -</span>
<span class="fc" id="L823">           0.5);</span>
      }
    }

<span class="fc" id="L827">    return result;</span>
  }

  /**
   * Returns an enumeration describing the available options
   *
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L836">    Vector result = new Vector();</span>

<span class="fc" id="L838">    result.addElement(new Option(</span>
<span class="fc" id="L839">          &quot;\tSet number of nearest neighbour for prediction\n&quot;</span>
          + &quot;\t(default 1)&quot;,
<span class="fc" id="L841">          &quot;K&quot;, 1, &quot;-K &lt;number of neighbours&gt;&quot;));</span>
    
<span class="fc" id="L843">    result.addElement(new Option(</span>
<span class="fc" id="L844">          &quot;\tSet number of nearest neighbour for cleansing the training data\n&quot;</span>
          + &quot;\t(default 1)&quot;,
<span class="fc" id="L846">          &quot;S&quot;, 1, &quot;-S &lt;number of neighbours&gt;&quot;));</span>
    
<span class="fc" id="L848">    result.addElement(new Option(</span>
<span class="fc" id="L849">          &quot;\tSet number of nearest neighbour for cleansing the testing data\n&quot;</span>
          + &quot;\t(default 1)&quot;,
<span class="fc" id="L851">          &quot;E&quot;, 1, &quot;-E &lt;number of neighbours&gt;&quot;));</span>

<span class="fc" id="L853">    return result.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -K &amp;lt;number of neighbours&amp;gt;
   *  Set number of nearest neighbour for prediction
   *  (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;number of neighbours&amp;gt;
   *  Set number of nearest neighbour for cleansing the training data
   *  (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E &amp;lt;number of neighbours&amp;gt;
   *  Set number of nearest neighbour for cleansing the testing data
   *  (default 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception{

<span class="fc" id="L881">    setDebug(Utils.getFlag('D', options));</span>

<span class="fc" id="L883">    String numNeighbourString = Utils.getOption('K', options);</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">    if (numNeighbourString.length() != 0) </span>
<span class="fc" id="L885">      setNumNeighbours(Integer.parseInt(numNeighbourString));</span>
    else 
<span class="fc" id="L887">      setNumNeighbours(1);</span>

<span class="fc" id="L889">    numNeighbourString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">    if (numNeighbourString.length() != 0) </span>
<span class="fc" id="L891">      setNumTrainingNoises(Integer.parseInt(numNeighbourString));</span>
    else 
<span class="fc" id="L893">      setNumTrainingNoises(1);</span>

<span class="fc" id="L895">    numNeighbourString = Utils.getOption('E', options);</span>
<span class="fc bfc" id="L896" title="All 2 branches covered.">    if (numNeighbourString.length() != 0) </span>
<span class="fc" id="L897">      setNumTestingNoises(Integer.parseInt(numNeighbourString));</span>
    else 
<span class="fc" id="L899">      setNumTestingNoises(1);</span>
<span class="fc" id="L900">  }</span>

  /**
   * Gets the current settings of the Classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    
<span class="fc" id="L910">    result = new Vector();</span>

<span class="pc bpc" id="L912" title="1 of 2 branches missed.">    if (getDebug())</span>
<span class="nc" id="L913">      result.add(&quot;-D&quot;);</span>
    
<span class="fc" id="L915">    result.add(&quot;-K&quot;);</span>
<span class="fc" id="L916">    result.add(&quot;&quot; + getNumNeighbours());</span>
    
<span class="fc" id="L918">    result.add(&quot;-S&quot;);</span>
<span class="fc" id="L919">    result.add(&quot;&quot; + getNumTrainingNoises());</span>
    
<span class="fc" id="L921">    result.add(&quot;-E&quot;);</span>
<span class="fc" id="L922">    result.add(&quot;&quot; + getNumTestingNoises());</span>

<span class="fc" id="L924">    return (String[]) result.toArray(new String[result.size()]);</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numNeighboursTipText() {
<span class="nc" id="L934">    return &quot;The number of nearest neighbours to the estimate the class prediction of test bags.&quot;;</span>
  }

  /**
   * Sets the number of nearest neighbours to estimate
   * the class prediction of tests bags
   * @param numNeighbour the number of citers
   */
  public void setNumNeighbours(int numNeighbour){
<span class="fc" id="L943">    m_Neighbour = numNeighbour;</span>
<span class="fc" id="L944">  }</span>

  /**
   * Returns the number of nearest neighbours to estimate
   * the class prediction of tests bags
   * @return the number of neighbours
   */
  public int getNumNeighbours(){
<span class="fc" id="L952">    return m_Neighbour;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numTrainingNoisesTipText() {
<span class="nc" id="L962">    return &quot;The number of nearest neighbour instances in the selection of noises in the training data.&quot;;</span>
  }

  /**
   * Sets the number of nearest neighbour instances in the 
   * selection of noises in the training data
   * 
   * @param numTraining the number of noises in training data 
   */
  public void setNumTrainingNoises (int numTraining){
<span class="fc" id="L972">    m_Select = numTraining;</span>
<span class="fc" id="L973">  }</span>

  /**
   * Returns the number of nearest neighbour instances in the 
   * selection of noises in the training data
   * 
   * @return the number of noises in training data
   */
  public int getNumTrainingNoises(){
<span class="fc" id="L982">    return m_Select;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numTestingNoisesTipText() {
<span class="nc" id="L992">    return &quot;The number of nearest neighbour instances in the selection of noises in the test data.&quot;;</span>
  }

  /**
   * Returns The number of nearest neighbour instances in the 
   * selection of noises in the test data 
   * @return the number of noises in test data
   */
  public int getNumTestingNoises(){
<span class="fc" id="L1001">    return m_Choose;</span>
  }

  /**
   * Sets The number of nearest neighbour exemplars in the 
   * selection of noises in the test data 
   * @param numTesting the number of noises in test data
   */
  public void setNumTestingNoises (int numTesting){
<span class="fc" id="L1010">    m_Choose = numTesting;</span>
<span class="fc" id="L1011">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1019">    return RevisionUtils.extract(&quot;$Revision: 9144 $&quot;);</span>
  }

  /**
   * Main method for testing.
   *
   * @param args the options for the classifier
   */
  public static void main(String[] args) {	
<span class="nc" id="L1028">    runClassifier(new MINND(), args);</span>
<span class="nc" id="L1029">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>