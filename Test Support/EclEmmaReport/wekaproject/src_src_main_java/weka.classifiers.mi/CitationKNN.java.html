<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CitationKNN.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.mi</a> &gt; <span class="el_source">CitationKNN.java</span></div><h1>CitationKNN.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * CitationKNN.java
 * Copyright (C) 2005 Miguel Garcia Torres
 */

package weka.classifiers.mi;

import weka.classifiers.Classifier;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.MultiInstanceCapabilitiesHandler;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Vector;
/**
 &lt;!-- globalinfo-start --&gt;
 * Modified version of the Citation kNN multi instance classifier.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Jun Wang, Zucker, Jean-Daniel: Solving Multiple-Instance Problem: A Lazy Learning Approach. In: 17th International Conference on Machine Learning, 1119-1125, 2000.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 * 
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Wang2000,
 *    author = {Jun Wang and Zucker and Jean-Daniel},
 *    booktitle = {17th International Conference on Machine Learning},
 *    editor = {Pat Langley},
 *    pages = {1119-1125},
 *    title = {Solving Multiple-Instance Problem: A Lazy Learning Approach},
 *    year = {2000}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 * 
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -R &amp;lt;number of references&amp;gt;
 *  Number of Nearest References (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;number of citers&amp;gt;
 *  Number of Nearest Citers (default 1)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H &amp;lt;rank&amp;gt;
 *  Rank of the Hausdorff Distance (default 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Miguel Garcia Torres (mgarciat@ull.es)
 * @version $Revision: 9146 $ 
 */
<span class="fc" id="L85">public class CitationKNN </span>
  extends Classifier 
  implements OptionHandler, MultiInstanceCapabilitiesHandler,
             TechnicalInformationHandler {

  /** for serialization */
  static final long serialVersionUID = -8435377743874094852L;
  
  /** The index of the class attribute */
  protected int m_ClassIndex;

  /** The number of the class labels */
  protected int m_NumClasses;

  /** */
  protected int m_IdIndex;    

  /** Debugging output */
  protected boolean m_Debug;

  /** Class labels for each bag */
  protected int[] m_Classes;

  /** attribute name structure of the relational attribute*/
  protected Instances m_Attributes;

  /** Number of references */
<span class="fc" id="L112">  protected int m_NumReferences = 1;</span>

  /** Number of citers*/
<span class="fc" id="L115">  protected int m_NumCiters = 1;</span>

  /** Training bags*/
  protected Instances m_TrainBags;

  /** Different debugging output */
<span class="fc" id="L121">  protected boolean m_CNNDebug = false;</span>

<span class="fc" id="L123">  protected boolean m_CitersDebug = false;</span>

<span class="fc" id="L125">  protected boolean m_ReferencesDebug = false;</span>

<span class="fc" id="L127">  protected boolean m_HDistanceDebug = false;</span>

<span class="fc" id="L129">  protected boolean m_NeighborListDebug = false;</span>

  /** C nearest neighbors considering all the bags*/
  protected NeighborList[] m_CNN;

  /** C nearest citers */
  protected int[] m_Citers;

  /** R nearest references */
  protected int[] m_References;

  /** Rank associated to the Hausdorff distance*/
<span class="fc" id="L141">  protected int m_HDRank = 1;</span>

  /** Normalization of the euclidean distance */
  private double[] m_Diffs;

  private double[] m_Min;

<span class="fc" id="L148">  private double m_MinNorm = 0.95;</span>

  private double[] m_Max;

<span class="fc" id="L152">  private double m_MaxNorm = 1.05;</span>

  /**
   * Returns a string describing this filter
   *
   * @return a description of the filter suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L161">    return </span>
<span class="nc" id="L162">        &quot;Modified version of the Citation kNN multi instance classifier.\n\n&quot;</span>
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L164">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L177">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L178">    result.setValue(Field.AUTHOR, &quot;Jun Wang and Zucker and Jean-Daniel&quot;);</span>
<span class="nc" id="L179">    result.setValue(Field.TITLE, &quot;Solving Multiple-Instance Problem: A Lazy Learning Approach&quot;);</span>
<span class="nc" id="L180">    result.setValue(Field.BOOKTITLE, &quot;17th International Conference on Machine Learning&quot;);</span>
<span class="nc" id="L181">    result.setValue(Field.EDITOR, &quot;Pat Langley&quot;);</span>
<span class="nc" id="L182">    result.setValue(Field.YEAR, &quot;2000&quot;);</span>
<span class="nc" id="L183">    result.setValue(Field.PAGES, &quot;1119-1125&quot;);</span>
    
<span class="nc" id="L185">    return result;</span>
  }

  /** 
   * Calculates the normalization of each attribute.
   */
  public void preprocessData(){
    int i,j, k;
    double min, max;
    Instances instances;
    Instance instance;
    // compute the min/max of each feature

<span class="fc bfc" id="L198" title="All 2 branches covered.">    for (i=0;i&lt;m_Attributes.numAttributes();i++) {</span>
<span class="fc" id="L199">      min=Double.POSITIVE_INFINITY ;</span>
<span class="fc" id="L200">      max=Double.NEGATIVE_INFINITY ;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">      for(j = 0; j &lt; m_TrainBags.numInstances(); j++){</span>
<span class="fc" id="L202">        instances = m_TrainBags.instance(j).relationalValue(1);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        for (k=0;k&lt;instances.numInstances();k++) {</span>
<span class="fc" id="L204">          instance = instances.instance(k);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">          if(instance.value(i) &lt; min)</span>
<span class="fc" id="L206">            min= instance.value(i);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">          if(instance.value(i) &gt; max)</span>
<span class="fc" id="L208">            max= instance.value(i);</span>
        }
      }
<span class="fc" id="L211">      m_Min[i] = min * m_MinNorm;</span>
<span class="fc" id="L212">      m_Max[i] = max * m_MaxNorm;</span>
<span class="fc" id="L213">      m_Diffs[i]= max * m_MaxNorm - min * m_MinNorm;</span>
    }	    

<span class="fc" id="L216">  }</span>

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String HDRankTipText() {
<span class="nc" id="L225">    return &quot;The rank associated to the Hausdorff distance.&quot;;</span>
  }

  /**
   * Sets the rank associated to the Hausdorff distance
   * @param hDRank the rank of the Hausdorff distance
   */
  public void setHDRank(int hDRank){
<span class="fc" id="L233">    m_HDRank = hDRank;</span>
<span class="fc" id="L234">  }</span>

  /**
   * Returns the rank associated to the Hausdorff distance
   * @return the rank number
   */
  public int getHDRank(){
<span class="fc" id="L241">    return m_HDRank;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numReferencesTipText() {
<span class="nc" id="L251">    return </span>
<span class="nc" id="L252">        &quot;The number of references considered to estimate the class &quot;</span>
      + &quot;prediction of tests bags.&quot;;
  }

  /**
   * Sets the number of references considered to estimate
   * the class prediction of tests bags
   * @param numReferences the number of references
   */
  public void setNumReferences(int numReferences){
<span class="fc" id="L262">    m_NumReferences = numReferences;</span>
<span class="fc" id="L263">  }</span>

  /**
   * Returns the number of references considered to estimate
   * the class prediction of tests bags
   * @return the number of references
   */
  public int getNumReferences(){
<span class="fc" id="L271">    return m_NumReferences;</span>
  }

  /**
   * Returns the tip text for this property
   *
   * @return tip text for this property suitable for
   * displaying in the explorer/experimenter gui
   */
  public String numCitersTipText() {
<span class="nc" id="L281">    return </span>
<span class="nc" id="L282">        &quot;The number of citers considered to estimate the class &quot;</span>
      + &quot;prediction of test bags.&quot;;
  }

  /**
   * Sets the number of citers considered to estimate
   * the class prediction of tests bags
   * @param numCiters the number of citers
   */
  public void setNumCiters(int numCiters){
<span class="fc" id="L292">    m_NumCiters = numCiters;</span>
<span class="fc" id="L293">  }</span>

  /**
   * Returns the number of citers considered to estimate
   * the class prediction of tests bags
   * @return the number of citers
   */
  public int getNumCiters(){
<span class="fc" id="L301">    return m_NumCiters;</span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L310">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L311">    result.disableAll();</span>

    // attributes
<span class="fc" id="L314">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L315">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L316">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L317">    result.enable(Capability.RELATIONAL_ATTRIBUTES);</span>
//    result.enable(Capability.MISSING_VALUES);

    // class
<span class="fc" id="L321">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L322">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
    // other
<span class="fc" id="L325">    result.enable(Capability.ONLY_MULTIINSTANCE);</span>
    
<span class="fc" id="L327">    return result;</span>
  }

  /**
   * Returns the capabilities of this multi-instance classifier for the
   * relational data.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getMultiInstanceCapabilities() {
<span class="fc" id="L338">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L339">    result.disableAll();</span>
    
    // attributes
<span class="fc" id="L342">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L343">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L344">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L345">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L348">    result.disableAllClasses();</span>
<span class="fc" id="L349">    result.enable(Capability.NO_CLASS);</span>
    
<span class="fc" id="L351">    return result;</span>
  }

  /**
   * Builds the classifier
   *
   * @param train the training data to be used for generating the
   * boosted classifier.
   * @throws Exception if the classifier could not be built successfully
   */
  public void buildClassifier(Instances train) throws Exception {
    // can classifier handle the data?
<span class="fc" id="L363">    getCapabilities().testWithFail(train);</span>

    // remove instances with missing class
<span class="fc" id="L366">    train = new Instances(train);</span>
<span class="fc" id="L367">    train.deleteWithMissingClass();</span>
    
<span class="fc" id="L369">    m_TrainBags = train;</span>
<span class="fc" id="L370">    m_ClassIndex = train.classIndex();</span>
<span class="fc" id="L371">    m_IdIndex = 0;</span>
<span class="fc" id="L372">    m_NumClasses = train.numClasses();</span>

<span class="fc" id="L374">    m_Classes  = new int [train.numInstances()]; // Class values</span>
<span class="fc" id="L375">    m_Attributes = train.instance(0).relationalValue(1).stringFreeStructure();</span>

<span class="fc" id="L377">    m_Citers = new int[train.numClasses()];</span>
<span class="fc" id="L378">    m_References = new int[train.numClasses()];</span>

<span class="fc" id="L380">    m_Diffs = new double[m_Attributes.numAttributes()];</span>
<span class="fc" id="L381">    m_Min = new double[m_Attributes.numAttributes()];</span>
<span class="fc" id="L382">    m_Max = new double[m_Attributes.numAttributes()];	</span>

<span class="fc" id="L384">    preprocessData();</span>

<span class="fc" id="L386">    buildCNN();</span>

<span class="pc bpc" id="L388" title="1 of 2 branches missed.">    if(m_CNNDebug){</span>
<span class="nc" id="L389">      System.out.println(&quot;########################################### &quot;);</span>
<span class="nc" id="L390">      System.out.println(&quot;###########CITATION######################## &quot;);</span>
<span class="nc" id="L391">      System.out.println(&quot;########################################### &quot;);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">      for(int i = 0; i &lt; m_CNN.length; i++){</span>
<span class="nc" id="L393">        System.out.println(&quot;Bag: &quot; + i);</span>
<span class="nc" id="L394">        m_CNN[i].printReducedList();</span>
      }
    }		
<span class="fc" id="L397">  }</span>

  /**
   * generates all the variables associated to the citation
   * classifier
   * 
   * @throws Exception if generation fails
   */
  public void buildCNN() throws Exception {

<span class="fc" id="L407">    int numCiters = 0;</span>

<span class="pc bpc" id="L409" title="1 of 2 branches missed.">    if((m_NumCiters &gt;= m_TrainBags.numInstances()) ||</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">        (m_NumCiters &lt; 0))</span>
<span class="nc" id="L411">      throw new Exception(&quot;Number of citers is out of the range [0, numInstances)&quot;);</span>
    else
<span class="fc" id="L413">      numCiters = m_NumCiters;</span>

<span class="fc" id="L415">    m_CNN = new NeighborList[m_TrainBags.numInstances()]; </span>
    Instance bag;

<span class="fc bfc" id="L418" title="All 2 branches covered.">    for(int i = 0; i&lt; m_TrainBags.numInstances(); i++){</span>
<span class="fc" id="L419">      bag = m_TrainBags.instance(i);</span>
      //first we find its neighbors
<span class="fc" id="L421">      NeighborList neighborList = findNeighbors(bag, numCiters, m_TrainBags);</span>
<span class="fc" id="L422">      m_CNN[i] = neighborList;</span>
    }
<span class="fc" id="L424">  }</span>

  /**
   * calculates the citers associated to a bag
   * @param bag the bag cited
   */
  public void countBagCiters(Instance bag){

    //Initialization of the vector
<span class="fc bfc" id="L433" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numClasses(); i++)</span>
<span class="fc" id="L434">      m_Citers[i] = 0;</span>
    //
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">    if(m_CitersDebug == true)</span>
<span class="nc" id="L437">      System.out.println(&quot;-------CITERS--------&quot;);</span>

    NeighborList neighborList;
    NeighborNode current;
<span class="fc" id="L441">    boolean stopSearch = false;</span>
    int index;

    // compute the distance between the test bag and each training bag. Update
    // the bagCiter count in case it be a neighbour

<span class="fc" id="L447">    double bagDistance = 0;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numInstances(); i++){</span>
      //measure the distance
<span class="fc" id="L450">      bagDistance =  distanceSet(bag, m_TrainBags.instance(i));</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">      if(m_CitersDebug == true){</span>
<span class="nc" id="L452">        System.out.print(&quot;bag - bag(&quot; + i + &quot;): &quot; + bagDistance);</span>
<span class="nc" id="L453">        System.out.println(&quot;   &lt;&quot; + m_TrainBags.instance(i).classValue() + &quot;&gt;&quot;);</span>
      }
      //compare the distance to see if it would belong to the
      // neighborhood of each training exemplar
<span class="fc" id="L457">      neighborList = m_CNN[i];</span>
<span class="fc" id="L458">      current = neighborList.mFirst;</span>

<span class="fc bfc" id="L460" title="All 4 branches covered.">      while((current != null) &amp;&amp; (!stopSearch)) {</span>
<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if(m_CitersDebug == true)</span>
<span class="nc" id="L462">          System.out.println(&quot;\t\tciter Distance: &quot; + current.mDistance);</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if(current.mDistance &lt; bagDistance){</span>
<span class="fc" id="L464">          current = current.mNext;</span>
        } else{  
<span class="fc" id="L466">          stopSearch = true;		    </span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">          if(m_CitersDebug == true){</span>
<span class="nc" id="L468">            System.out.println(&quot;\t***&quot;);</span>
          }
        }
      } 

<span class="fc bfc" id="L473" title="All 2 branches covered.">      if(stopSearch == true){</span>
<span class="fc" id="L474">        stopSearch = false;</span>
<span class="fc" id="L475">        index = (int)(m_TrainBags.instance(i)).classValue();</span>
<span class="fc" id="L476">        m_Citers[index] += 1;</span>
      }

    }

<span class="pc bpc" id="L481" title="1 of 2 branches missed.">    if(m_CitersDebug == true){</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">      for(int i= 0; i &lt; m_Citers.length; i++){</span>
<span class="nc" id="L483">        System.out.println(&quot;[&quot; + i + &quot;]: &quot; + m_Citers[i]);</span>
      }
    }

<span class="fc" id="L487">  }</span>

  /**
   * Calculates the references of the exemplar bag
   * @param bag the exemplar to which the nearest references
   * will be calculated
   */
  public void countBagReferences(Instance bag){
<span class="fc" id="L495">    int index = 0, referencesIndex = 0;</span>

<span class="pc bpc" id="L497" title="1 of 2 branches missed.">    if(m_TrainBags.numInstances() &lt; m_NumReferences)</span>
<span class="nc" id="L498">      referencesIndex = m_TrainBags.numInstances() - 1;</span>
    else
<span class="fc" id="L500">      referencesIndex = m_NumReferences;</span>

<span class="pc bpc" id="L502" title="1 of 2 branches missed.">    if(m_CitersDebug == true){</span>
<span class="nc" id="L503">      System.out.println(&quot;-------References (&quot; + referencesIndex+ &quot;)--------&quot;);</span>
    }
    //Initialization of the vector
<span class="fc bfc" id="L506" title="All 2 branches covered.">    for(int i = 0; i &lt; m_References.length; i++)</span>
<span class="fc" id="L507">      m_References[i] = 0;</span>

<span class="pc bpc" id="L509" title="1 of 2 branches missed.">    if(referencesIndex &gt; 0){</span>
      //first we find its neighbors
<span class="fc" id="L511">      NeighborList neighborList = findNeighbors(bag, referencesIndex, m_TrainBags);</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">      if(m_ReferencesDebug == true){</span>
<span class="nc" id="L513">        System.out.println(&quot;Bag: &quot; + bag + &quot; Neighbors: &quot;);</span>
<span class="nc" id="L514">        neighborList.printReducedList();</span>
      }
<span class="fc" id="L516">      NeighborNode current = neighborList.mFirst;</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">      while(current != null){</span>
<span class="fc" id="L518">        index = (int) current.mBag.classValue();</span>
<span class="fc" id="L519">        m_References[index] += 1;</span>
<span class="fc" id="L520">        current = current.mNext;</span>
      }
    }
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">    if(m_ReferencesDebug == true){</span>
<span class="nc" id="L524">      System.out.println(&quot;References:&quot;);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">      for(int j = 0; j &lt; m_References.length; j++)</span>
<span class="nc" id="L526">        System.out.println(&quot;[&quot; + j + &quot;]: &quot; + m_References[j]);</span>
    }
<span class="fc" id="L528">  }</span>

  /**
   * Build the list of nearest k neighbors to the given test instance.
   * @param bag the bag to search for neighbors of
   * @param kNN the number of nearest neighbors
   * @param bags the data
   * @return a list of neighbors
   */
  protected NeighborList findNeighbors(Instance bag, int kNN, Instances bags){
    double distance;
<span class="fc" id="L539">    int index = 0;</span>

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">    if(kNN &gt; bags.numInstances())</span>
<span class="nc" id="L542">      kNN = bags.numInstances() - 1;</span>

<span class="fc" id="L544">    NeighborList neighborList = new NeighborList(kNN);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">    for(int i = 0; i &lt; bags.numInstances(); i++){</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">      if(bag != bags.instance(i)){ // for hold-one-out cross-validation</span>
<span class="fc" id="L547">        distance =  distanceSet(bag, bags.instance(i)) ; //mDistanceSet.distance(bag, mInstances, bags.exemplar(i), mInstances);</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">        if(m_NeighborListDebug)</span>
<span class="nc" id="L549">          System.out.println(&quot;distance(bag, &quot; + i + &quot;): &quot; + distance);</span>
<span class="pc bpc" id="L550" title="1 of 6 branches missed.">        if(neighborList.isEmpty() || (index &lt; kNN) || (distance &lt;= neighborList.mLast.mDistance))</span>
<span class="fc" id="L551">          neighborList.insertSorted(distance, bags.instance(i), i);</span>
<span class="fc" id="L552">        index++;</span>
      } 
    }

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">    if(m_NeighborListDebug){</span>
<span class="nc" id="L557">      System.out.println(&quot;bag neighbors:&quot;);</span>
<span class="nc" id="L558">      neighborList.printReducedList();</span>
    }

<span class="fc" id="L561">    return neighborList;</span>
  }

  /**
   * Calculates the distance between two instances
   * @param first instance
   * @param second instance
   * @return the distance value
   */
  public double distanceSet(Instance first, Instance second){
<span class="fc" id="L571">    double[] h_f = new double[first.relationalValue(1).numInstances()];</span>
    double distance;

    //initilization
<span class="fc bfc" id="L575" title="All 2 branches covered.">    for(int i = 0; i &lt; h_f.length; i++)</span>
<span class="fc" id="L576">      h_f[i] = Double.MAX_VALUE;</span>


    int rank;


<span class="pc bpc" id="L582" title="1 of 2 branches missed.">    if(m_HDRank &gt;= first.relationalValue(1).numInstances())</span>
<span class="nc" id="L583">      rank = first.relationalValue(1).numInstances();</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">    else if(m_HDRank &lt; 1)</span>
<span class="nc" id="L585">      rank = 1;</span>
    else 
<span class="fc" id="L587">      rank = m_HDRank;</span>

<span class="pc bpc" id="L589" title="1 of 2 branches missed.">    if(m_HDistanceDebug){</span>
<span class="nc" id="L590">      System.out.println(&quot;-------HAUSDORFF DISTANCE--------&quot;);</span>
<span class="nc" id="L591">      System.out.println(&quot;rank: &quot; + rank + &quot;\nset of instances:&quot;);</span>
<span class="nc" id="L592">      System.out.println(&quot;\tset 1:&quot;);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">      for(int i = 0; i &lt; first.relationalValue(1).numInstances(); i++)</span>
<span class="nc" id="L594">        System.out.println(first.relationalValue(1).instance(i));</span>

<span class="nc" id="L596">      System.out.println(&quot;\n\tset 2:&quot;);</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">      for(int i = 0; i &lt; second.relationalValue(1).numInstances(); i++)</span>
<span class="nc" id="L598">        System.out.println(second.relationalValue(1).instance(i));</span>

<span class="nc" id="L600">      System.out.println(&quot;\n&quot;);</span>
    }

    //for each instance in bag first
<span class="fc bfc" id="L604" title="All 2 branches covered.">    for(int i = 0; i &lt; first.relationalValue(1).numInstances(); i++){</span>
      // calculate the distance to each instance in 
      // bag second
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">      if(m_HDistanceDebug){</span>
<span class="nc" id="L608">        System.out.println(&quot;\nDistances:&quot;);</span>
      }
<span class="fc bfc" id="L610" title="All 2 branches covered.">      for(int j = 0; j &lt; second.relationalValue(1).numInstances(); j++){</span>
<span class="fc" id="L611">        distance = distance(first.relationalValue(1).instance(i), second.relationalValue(1).instance(j));</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">        if(distance &lt; h_f[i])</span>
<span class="fc" id="L613">          h_f[i] = distance;</span>
<span class="pc bpc" id="L614" title="1 of 2 branches missed.">        if(m_HDistanceDebug){</span>
<span class="nc" id="L615">          System.out.println(&quot;\tdist(&quot; + i + &quot;, &quot;+ j + &quot;): &quot; + distance + &quot;  --&gt; h_f[&quot; + i + &quot;]: &quot; + h_f[i]);</span>
        }
      }
    }
<span class="fc" id="L619">    int[] index_f = Utils.stableSort(h_f);</span>

<span class="pc bpc" id="L621" title="1 of 2 branches missed.">    if(m_HDistanceDebug){</span>
<span class="nc" id="L622">      System.out.println(&quot;\nRanks:\n&quot;);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">      for(int i = 0; i &lt; index_f.length; i++)</span>
<span class="nc" id="L624">        System.out.println(&quot;\trank &quot; + (i + 1) + &quot;: &quot; + h_f[index_f[i]]);</span>

<span class="nc" id="L626">      System.out.println(&quot;\n\t\t&gt;&gt;&gt;&gt;&gt; rank &quot; + rank + &quot;: &quot; + h_f[index_f[rank - 1]] + &quot; &lt;&lt;&lt;&lt;&lt;&quot;);</span>
    }

<span class="fc" id="L629">    return h_f[index_f[rank - 1]];</span>
  }

  /**
   * distance between two instances
   * @param first the first instance
   * @param second the other instance
   * @return the distance in double precision
   */
  public double distance(Instance first, Instance second){

<span class="fc" id="L640">    double sum = 0, diff;</span>
<span class="fc bfc" id="L641" title="All 2 branches covered.">    for(int i = 0; i &lt; m_Attributes.numAttributes(); i++){</span>
<span class="fc" id="L642">      diff = (first.value(i) - m_Min[i])/ m_Diffs[i] - </span>
<span class="fc" id="L643">        (second.value(i) - m_Min[i])/ m_Diffs[i];</span>
<span class="fc" id="L644">      sum += diff * diff;</span>
    }
<span class="fc" id="L646">    return sum = Math.sqrt(sum);</span>
  }

  /**
   * Computes the distribution for a given exemplar
   *
   * @param bag the exemplar for which distribution is computed
   * @return the distribution
   * @throws Exception if the distribution can't be computed successfully
   */
  public double[] distributionForInstance(Instance bag) 
    throws Exception {

<span class="pc bpc" id="L659" title="1 of 2 branches missed.">    if(m_TrainBags.numInstances() == 0)</span>
<span class="nc" id="L660">      throw new Exception(&quot;No training bags!&quot;);</span>

<span class="fc" id="L662">    updateNormalization(bag);</span>

    //build references (R nearest neighbors)
<span class="fc" id="L665">    countBagReferences(bag);</span>

    //build citers
<span class="fc" id="L668">    countBagCiters(bag);</span>

<span class="fc" id="L670">    return makeDistribution();</span>
  }

  /** 
   * Updates the normalization of each attribute.
   * 
   * @param bag the exemplar to update the normalization for
   */
  public void updateNormalization(Instance bag){
    int i, k;
    double min, max;
    Instances instances;
    Instance instance;
    // compute the min/max of each feature
<span class="fc bfc" id="L684" title="All 2 branches covered.">    for (i = 0; i &lt; m_TrainBags.attribute(1).relation().numAttributes(); i++) {</span>
<span class="fc" id="L685">      min = m_Min[i] / m_MinNorm;</span>
<span class="fc" id="L686">      max = m_Max[i] / m_MaxNorm;</span>

<span class="fc" id="L688">      instances = bag.relationalValue(1);</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">      for (k=0;k&lt;instances.numInstances();k++) {</span>
<span class="fc" id="L690">        instance = instances.instance(k);</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">        if(instance.value(i) &lt; min)</span>
<span class="fc" id="L692">          min = instance.value(i);</span>
<span class="fc bfc" id="L693" title="All 2 branches covered.">        if(instance.value(i) &gt; max)</span>
<span class="fc" id="L694">          max = instance.value(i);</span>
      }
<span class="fc" id="L696">      m_Min[i] = min * m_MinNorm;</span>
<span class="fc" id="L697">      m_Max[i] = max * m_MaxNorm;</span>
<span class="fc" id="L698">      m_Diffs[i]= max * m_MaxNorm - min * m_MinNorm;</span>
    }
<span class="fc" id="L700">  }</span>

  /**
   * Wether the instances of two exemplars are or  are not equal
   * @param exemplar1 first exemplar
   * @param exemplar2 second exemplar
   * @return if the instances of the exemplars are equal or not
   */
  public boolean equalExemplars(Instance exemplar1, Instance exemplar2){
<span class="nc bnc" id="L709" title="All 2 branches missed.">    if(exemplar1.relationalValue(1).numInstances() == </span>
<span class="nc" id="L710">        exemplar2.relationalValue(1).numInstances()){</span>
<span class="nc" id="L711">      Instances instances1 = exemplar1.relationalValue(1);</span>
<span class="nc" id="L712">      Instances instances2 = exemplar2.relationalValue(1);</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">      for(int i = 0; i &lt; instances1.numInstances(); i++){</span>
<span class="nc" id="L714">        Instance instance1 = instances1.instance(i);</span>
<span class="nc" id="L715">        Instance instance2 = instances2.instance(i);</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">        for(int j = 0; j &lt; instance1.numAttributes(); j++){</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">          if(instance1.value(j) != instance2.value(j)){</span>
<span class="nc" id="L718">            return false;</span>
          }
        }
      }
<span class="nc" id="L722">      return true;</span>
        }
<span class="nc" id="L724">    return false;</span>
  }

  /**
   * Turn the references and citers list into a probability distribution
   *
   * @return the probability distribution
   * @throws Exception if computation of distribution fails
   */
  protected double[] makeDistribution() throws Exception {
    
<span class="fc" id="L735">    double total = 0;</span>
<span class="fc" id="L736">    double[] distribution = new double[m_TrainBags.numClasses()];</span>
<span class="fc" id="L737">    boolean debug = false;</span>

<span class="fc" id="L739">    total = (double)m_TrainBags.numClasses() / Math.max(1, m_TrainBags.numInstances());</span>

<span class="fc bfc" id="L741" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numClasses(); i++){</span>
<span class="fc" id="L742">      distribution[i] = 1.0 / Math.max(1, m_TrainBags.numInstances());</span>
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">      if(debug) System.out.println(&quot;distribution[&quot; + i + &quot;]: &quot; + distribution[i]);</span>
    }

<span class="pc bpc" id="L746" title="1 of 2 branches missed.">    if(debug)System.out.println(&quot;total: &quot; + total);</span>

<span class="fc bfc" id="L748" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numClasses(); i++){</span>
<span class="fc" id="L749">      distribution[i] += m_References[i];</span>
<span class="fc" id="L750">      distribution[i] += m_Citers[i];</span>
    }

<span class="fc" id="L753">    total = 0;</span>
    //total
<span class="fc bfc" id="L755" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numClasses(); i++){</span>
<span class="fc" id="L756">      total += distribution[i];</span>
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">      if(debug)System.out.println(&quot;distribution[&quot; + i + &quot;]: &quot; + distribution[i]);</span>
    }

<span class="fc bfc" id="L760" title="All 2 branches covered.">    for(int i = 0; i &lt; m_TrainBags.numClasses(); i++){</span>
<span class="fc" id="L761">      distribution[i] = distribution[i] / total;</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">      if(debug)System.out.println(&quot;distribution[&quot; + i + &quot;]: &quot; + distribution[i]);</span>

    }

<span class="fc" id="L766">    return distribution;</span>
  }

  /**
   * Returns an enumeration of all the available options..
   *
   * @return an enumeration of all available options.
   */
  public Enumeration listOptions(){
<span class="fc" id="L775">    Vector result = new Vector();</span>

<span class="fc" id="L777">    result.addElement(new Option(</span>
<span class="fc" id="L778">          &quot;\tNumber of Nearest References (default 1)&quot;,</span>
<span class="fc" id="L779">          &quot;R&quot;, 0, &quot;-R &lt;number of references&gt;&quot;));</span>
    
<span class="fc" id="L781">    result.addElement(new Option(</span>
<span class="fc" id="L782">          &quot;\tNumber of Nearest Citers (default 1)&quot;,</span>
<span class="fc" id="L783">          &quot;C&quot;, 0, &quot;-C &lt;number of citers&gt;&quot;));</span>
    
<span class="fc" id="L785">    result.addElement(new Option(</span>
<span class="fc" id="L786">          &quot;\tRank of the Hausdorff Distance (default 1)&quot;,</span>
<span class="fc" id="L787">          &quot;H&quot;, 0, &quot;-H &lt;rank&gt;&quot;));</span>

<span class="fc" id="L789">    return result.elements();</span>
  }

  /**
   * Sets the OptionHandler's options using the given list. All options
   * will be set (or reset) during this call (i.e. incremental setting
   * of options is not possible). &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -R &amp;lt;number of references&amp;gt;
   *  Number of Nearest References (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;number of citers&amp;gt;
   *  Number of Nearest Citers (default 1)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -H &amp;lt;rank&amp;gt;
   *  Rank of the Hausdorff Distance (default 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception{
<span class="fc" id="L815">    setDebug(Utils.getFlag('D', options));</span>

<span class="fc" id="L817">    String option = Utils.getOption('R', options);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">    if(option.length() != 0)</span>
<span class="fc" id="L819">      setNumReferences(Integer.parseInt(option));</span>
    else
<span class="fc" id="L821">      setNumReferences(1);</span>

<span class="fc" id="L823">    option = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">    if(option.length() != 0)</span>
<span class="fc" id="L825">      setNumCiters(Integer.parseInt(option));</span>
    else
<span class="fc" id="L827">      setNumCiters(1);</span>

<span class="fc" id="L829">    option = Utils.getOption('H', options);</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">    if(option.length() != 0)</span>
<span class="fc" id="L831">      setHDRank(Integer.parseInt(option));</span>
    else
<span class="fc" id="L833">      setHDRank(1);</span>
<span class="fc" id="L834">  }</span>
  /**
   * Gets the current option settings for the OptionHandler.
   *
   * @return the list of current option settings as an array of strings
   */
  public String[] getOptions() {
    Vector        result;
    
<span class="fc" id="L843">    result = new Vector();</span>

<span class="pc bpc" id="L845" title="1 of 2 branches missed.">    if (getDebug())</span>
<span class="nc" id="L846">      result.add(&quot;-D&quot;);</span>
    
<span class="fc" id="L848">    result.add(&quot;-R&quot;);</span>
<span class="fc" id="L849">    result.add(&quot;&quot; + getNumReferences());</span>
    
<span class="fc" id="L851">    result.add(&quot;-C&quot;);</span>
<span class="fc" id="L852">    result.add(&quot;&quot; + getNumCiters());</span>
    
<span class="fc" id="L854">    result.add(&quot;-H&quot;);</span>
<span class="fc" id="L855">    result.add(&quot;&quot; + getHDRank());</span>

<span class="fc" id="L857">    return (String[]) result.toArray(new String[result.size()]);</span>
  }

  /**
   * returns a string representation of the classifier
   * 
   * @return		the string representation
   */
  public String toString() {
    StringBuffer	result;
    int			i;
    
<span class="fc" id="L869">    result = new StringBuffer();</span>
    
    // title
<span class="fc" id="L872">    result.append(this.getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;) + &quot;\n&quot;);</span>
<span class="fc" id="L873">    result.append(this.getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;).replaceAll(&quot;.&quot;, &quot;=&quot;) + &quot;\n\n&quot;);</span>

<span class="pc bpc" id="L875" title="1 of 2 branches missed.">    if (m_Citers == null) {</span>
<span class="fc" id="L876">      result.append(&quot;no model built yet!\n&quot;);</span>
    }
    else {
      // internal representation
<span class="nc" id="L880">      result.append(&quot;Citers....: &quot; + Utils.arrayToString(m_Citers) + &quot;\n&quot;);</span>

<span class="nc" id="L882">      result.append(&quot;References: &quot; + Utils.arrayToString(m_References) + &quot;\n&quot;);</span>

<span class="nc" id="L884">      result.append(&quot;Min.......: &quot;);</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">      for (i = 0; i &lt; m_Min.length; i++) {</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">	if (i &gt; 0)</span>
<span class="nc" id="L887">	  result.append(&quot;,&quot;);</span>
<span class="nc" id="L888">	result.append(Utils.doubleToString(m_Min[i], 3));</span>
      }
<span class="nc" id="L890">      result.append(&quot;\n&quot;);</span>

<span class="nc" id="L892">      result.append(&quot;Max.......: &quot;);</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">      for (i = 0; i &lt; m_Max.length; i++) {</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">	if (i &gt; 0)</span>
<span class="nc" id="L895">	  result.append(&quot;,&quot;);</span>
<span class="nc" id="L896">	result.append(Utils.doubleToString(m_Max[i], 3));</span>
      }
<span class="nc" id="L898">      result.append(&quot;\n&quot;);</span>

<span class="nc" id="L900">      result.append(&quot;Diffs.....: &quot;);</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">      for (i = 0; i &lt; m_Diffs.length; i++) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">	if (i &gt; 0)</span>
<span class="nc" id="L903">	  result.append(&quot;,&quot;);</span>
<span class="nc" id="L904">	result.append(Utils.doubleToString(m_Diffs[i], 3));</span>
      }
<span class="nc" id="L906">      result.append(&quot;\n&quot;);</span>
    }
    
<span class="fc" id="L909">    return result.toString();</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L918">    return RevisionUtils.extract(&quot;$Revision: 9146 $&quot;);</span>
  }
  
  /**
   * Main method for testing this class.
   *
   * @param argv should contain the command line arguments to the
   * scheme (see Evaluation)
   */
  public static void main(String[] argv) {
<span class="nc" id="L928">    runClassifier(new CitationKNN(), argv);</span>
<span class="nc" id="L929">  }</span>

  //########################################################################
  //########################################################################
  //########################################################################
  //########################################################################
  //########################################################################

  /**
   * A class for storing data about a neighboring instance
   */
  private class NeighborNode 
    implements Serializable, RevisionHandler {

    /** for serialization */
    static final long serialVersionUID = -3947320761906511289L;
    
    /** The neighbor bag */
    private Instance mBag;

    /** The distance from the current instance to this neighbor */
    private double mDistance;

    /** A link to the next neighbor instance */
    private NeighborNode mNext;

    /** the position in the bag */
    private int mBagPosition;    
    
    /**
     * Create a new neighbor node.
     *
     * @param distance the distance to the neighbor
     * @param bag the bag instance
     * @param position the position in the bag
     * @param next the next neighbor node
     */
<span class="fc" id="L966">    public NeighborNode(double distance, Instance bag, int position, NeighborNode next){</span>
<span class="fc" id="L967">      mDistance = distance;</span>
<span class="fc" id="L968">      mBag = bag;</span>
<span class="fc" id="L969">      mNext = next;</span>
<span class="fc" id="L970">      mBagPosition = position;</span>
<span class="fc" id="L971">    }</span>

    /**
     * Create a new neighbor node that doesn't link to any other nodes.
     *
     * @param distance the distance to the neighbor
     * @param bag the neighbor instance
     * @param position the position in the bag
     */
    public NeighborNode(double distance, Instance bag, int position) {
<span class="fc" id="L981">      this(distance, bag, position, null);</span>
<span class="fc" id="L982">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L990">      return RevisionUtils.extract(&quot;$Revision: 9146 $&quot;);</span>
    }
  }
  
  //##################################################
  /**
   * A class for a linked list to store the nearest k neighbours
   * to an instance. We use a list so that we can take care of
   * cases where multiple neighbours are the same distance away.
   * i.e. the minimum length of the list is k.
   */
  private class NeighborList 
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = 3432555644456217394L;
    
    /** The first node in the list */
    private NeighborNode mFirst;
    /** The last node in the list */
    private NeighborNode mLast;

    /** The number of nodes to attempt to maintain in the list */
<span class="fc" id="L1013">    private int mLength = 1;</span>

    /**
     * Creates the neighborlist with a desired length
     *
     * @param length the length of list to attempt to maintain
     */
<span class="fc" id="L1020">    public NeighborList(int length) {</span>
<span class="fc" id="L1021">      mLength = length;</span>
<span class="fc" id="L1022">    }</span>
    /**
     * Gets whether the list is empty.
     *
     * @return true if so
     */
    public boolean isEmpty() {
<span class="fc bfc" id="L1029" title="All 2 branches covered.">      return (mFirst == null);</span>
    }
    /**
     * Gets the current length of the list.
     *
     * @return the current length of the list
     */
    public int currentLength() {

<span class="nc" id="L1038">      int i = 0;</span>
<span class="nc" id="L1039">      NeighborNode current = mFirst;</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">      while (current != null) {</span>
<span class="nc" id="L1041">        i++;</span>
<span class="nc" id="L1042">        current = current.mNext;</span>
      }
<span class="nc" id="L1044">      return i;</span>
    }

    /**
     * Inserts an instance neighbor into the list, maintaining the list
     * sorted by distance.
     *
     * @param distance the distance to the instance
     * @param bag the neighboring instance
     * @param position the position in the bag
     */
    public void insertSorted(double distance, Instance bag, int position) {

<span class="fc bfc" id="L1057" title="All 2 branches covered.">      if (isEmpty()) {</span>
<span class="fc" id="L1058">        mFirst = mLast = new NeighborNode(distance, bag, position);</span>
      } else {
<span class="fc" id="L1060">        NeighborNode current = mFirst;</span>
<span class="fc bfc" id="L1061" title="All 2 branches covered.">        if (distance &lt; mFirst.mDistance) {// Insert at head</span>
<span class="fc" id="L1062">          mFirst = new NeighborNode(distance, bag, position, mFirst);</span>
        } else { // Insert further down the list
<span class="fc bfc" id="L1064" title="All 2 branches covered.">          for( ;(current.mNext != null) &amp;&amp; </span>
<span class="pc bpc" id="L1065" title="1 of 2 branches missed.">              (current.mNext.mDistance &lt; distance); </span>
<span class="nc" id="L1066">              current = current.mNext);</span>
<span class="fc" id="L1067">          current.mNext = new NeighborNode(distance, bag, position, current.mNext);</span>
<span class="fc bfc" id="L1068" title="All 2 branches covered.">          if (current.equals(mLast)) {</span>
<span class="fc" id="L1069">            mLast = current.mNext;</span>
          }
        }

        // Trip down the list until we've got k list elements (or more if the
        // distance to the last elements is the same).
<span class="fc" id="L1075">        int valcount = 0;</span>
<span class="fc bfc" id="L1076" title="All 2 branches covered.">        for(current = mFirst; current.mNext != null; </span>
<span class="fc" id="L1077">            current = current.mNext) {</span>
<span class="fc" id="L1078">          valcount++;</span>
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">          if ((valcount &gt;= mLength) &amp;&amp; (current.mDistance != </span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">                current.mNext.mDistance)) {</span>
<span class="fc" id="L1081">            mLast = current;</span>
<span class="fc" id="L1082">            current.mNext = null;</span>
<span class="fc" id="L1083">            break;</span>
                }
            }
      }
<span class="fc" id="L1087">    }</span>

    /**
     * Prunes the list to contain the k nearest neighbors. If there are
     * multiple neighbors at the k'th distance, all will be kept.
     *
     * @param k the number of neighbors to keep in the list.
     */
    public void pruneToK(int k) {
<span class="nc bnc" id="L1096" title="All 2 branches missed.">      if (isEmpty())</span>
<span class="nc" id="L1097">        return;</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">      if (k &lt; 1)</span>
<span class="nc" id="L1099">        k = 1;</span>

<span class="nc" id="L1101">      int currentK = 0;</span>
<span class="nc" id="L1102">      double currentDist = mFirst.mDistance;</span>
<span class="nc" id="L1103">      NeighborNode current = mFirst;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">      for(; current.mNext != null; current = current.mNext) {</span>
<span class="nc" id="L1105">        currentK++;</span>
<span class="nc" id="L1106">        currentDist = current.mDistance;</span>
<span class="nc bnc" id="L1107" title="All 4 branches missed.">        if ((currentK &gt;= k) &amp;&amp; (currentDist != current.mNext.mDistance)) {</span>
<span class="nc" id="L1108">          mLast = current;</span>
<span class="nc" id="L1109">          current.mNext = null;</span>
<span class="nc" id="L1110">          break;</span>
        }
      }
<span class="nc" id="L1113">    }</span>

    /**
     * Prints out the contents of the neighborlist
     */
    public void printList() {

<span class="nc bnc" id="L1120" title="All 2 branches missed.">      if (isEmpty()) {</span>
<span class="nc" id="L1121">        System.out.println(&quot;Empty list&quot;);</span>
      } else {
<span class="nc" id="L1123">        NeighborNode current = mFirst;</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">        while (current != null) {</span>
<span class="nc" id="L1125">          System.out.print(&quot;Node: instance &quot; + current.mBagPosition + &quot;\n&quot;);</span>
<span class="nc" id="L1126">          System.out.println(current.mBag);</span>
<span class="nc" id="L1127">          System.out.println(&quot;, distance &quot; + current.mDistance);</span>
<span class="nc" id="L1128">          current = current.mNext;</span>
        }
<span class="nc" id="L1130">        System.out.println();</span>
      }
<span class="nc" id="L1132">    }</span>
    /**
     * Prints out the contents of the neighborlist
     */
    public void printReducedList() {

<span class="nc bnc" id="L1138" title="All 2 branches missed.">      if (isEmpty()) {</span>
<span class="nc" id="L1139">        System.out.println(&quot;Empty list&quot;);</span>
      } else {
<span class="nc" id="L1141">        NeighborNode current = mFirst;</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">        while (current != null) {</span>
<span class="nc" id="L1143">          System.out.print(&quot;Node: bag &quot; + current.mBagPosition + &quot;  (&quot; + current.mBag.relationalValue(1).numInstances() +&quot;): &quot;);</span>
          //for(int i = 0; i &lt; current.mBag.getInstances().numInstances(); i++){
          //System.out.print(&quot; &quot; + (current.mBag).getInstances().instance(i));
          //}
<span class="nc" id="L1147">          System.out.print(&quot;   &lt;&quot; + current.mBag.classValue() + &quot;&gt;&quot;);</span>
<span class="nc" id="L1148">          System.out.println(&quot;  (d: &quot; + current.mDistance + &quot;)&quot;);</span>
<span class="nc" id="L1149">          current = current.mNext;</span>
        }
<span class="nc" id="L1151">        System.out.println();</span>
      }
<span class="nc" id="L1153">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1161">      return RevisionUtils.extract(&quot;$Revision: 9146 $&quot;);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>