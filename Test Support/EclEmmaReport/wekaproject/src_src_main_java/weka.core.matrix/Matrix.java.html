<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.core.matrix</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">/*
 * This software is a cooperative product of The MathWorks and the National
 * Institute of Standards and Technology (NIST) which has been released to the
 * public domain. Neither The MathWorks nor NIST assumes any responsibility
 * whatsoever for its use by other parties, and makes no guarantees, expressed
 * or implied, about its quality, reliability, or any other characteristic.
 */

/*
 * Matrix.java
 * Copyright (C) 1999 The Mathworks and NIST and 2005 University of Waikato,
 *               Hamilton, New Zealand
 *
 */

package weka.core.matrix;

import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;

import java.io.BufferedReader;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Serializable;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.Writer;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.StringTokenizer;

/**
 * Jama = Java Matrix class.
 * &lt;P&gt;
 * The Java Matrix Class provides the fundamental operations of numerical linear
 * algebra.  Various constructors create Matrices from two dimensional arrays of
 * double precision floating point numbers.  Various &quot;gets&quot; and &quot;sets&quot; provide
 * access to submatrices and matrix elements.  Several methods implement basic
 * matrix arithmetic, including matrix addition and multiplication, matrix
 * norms, and element-by-element array operations.  Methods for reading and
 * printing matrices are also included.  All the operations in this version of
 * the Matrix Class involve real matrices.  Complex matrices may be handled in a
 * future version.
 * &lt;P&gt;
 * Five fundamental matrix decompositions, which consist of pairs or triples of
 * matrices, permutation vectors, and the like, produce results in five
 * decomposition classes.  These decompositions are accessed by the Matrix class
 * to compute solutions of simultaneous linear equations, determinants, inverses
 * and other matrix functions.  The five decompositions are:
 * &lt;P&gt;
 * &lt;UL&gt;
 *    &lt;LI&gt;Cholesky Decomposition of symmetric, positive definite matrices.
 *    &lt;LI&gt;LU Decomposition of rectangular matrices.
 *    &lt;LI&gt;QR Decomposition of rectangular matrices.
 *    &lt;LI&gt;Singular Value Decomposition of rectangular matrices.
 *    &lt;LI&gt;Eigenvalue Decomposition of both symmetric and nonsymmetric square matrices.
 * &lt;/UL&gt;
 * &lt;DL&gt;
 * &lt;DT&gt;&lt;B&gt;Example of use:&lt;/B&gt;&lt;/DT&gt;
 * &lt;P&gt;
 * &lt;DD&gt;Solve a linear system A x = b and compute the residual norm, ||b - A x||.
 * &lt;P&gt;&lt;PRE&gt;
 *       double[][] vals = {{1.,2.,3},{4.,5.,6.},{7.,8.,10.}};
 *       Matrix A = new Matrix(vals);
 *       Matrix b = Matrix.random(3,1);
 *       Matrix x = A.solve(b);
 *       Matrix r = A.times(x).minus(b);
 *       double rnorm = r.normInf();
 * &lt;/PRE&gt;&lt;/DD&gt;
 * &lt;/DL&gt;
 * &lt;p/&gt;
 * Adapted from the &lt;a href=&quot;http://math.nist.gov/javanumerics/jama/&quot; target=&quot;_blank&quot;&gt;JAMA&lt;/a&gt; package. Additional methods are tagged with the 
 * &lt;code&gt;@author&lt;/code&gt; tag.
 *
 * @author The Mathworks and NIST 
 * @author Fracpete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.8 $
 */
public class Matrix 
  implements Cloneable, Serializable, RevisionHandler {

  /** for serialization */
  private static final long serialVersionUID = 7856794138418366180L;

  /** 
   * Array for internal storage of elements.
   * @serial internal array storage.
   */
  protected double[][] A;

  /** 
   * Row and column dimensions.
   * @serial row dimension.
   * @serial column dimension.
   */
  protected int m, n;

  /** 
   * Construct an m-by-n matrix of zeros. 
   * @param m    Number of rows.
   * @param n    Number of colums.
   */
<span class="fc" id="L108">  public Matrix(int m, int n) {</span>
<span class="fc" id="L109">    this.m = m;</span>
<span class="fc" id="L110">    this.n = n;</span>
<span class="fc" id="L111">    A = new double[m][n];</span>
<span class="fc" id="L112">  }</span>

  /** 
   * Construct an m-by-n constant matrix.
   * @param m    Number of rows.
   * @param n    Number of colums.
   * @param s    Fill the matrix with this scalar value.
   */
<span class="fc" id="L120">  public Matrix(int m, int n, double s) {</span>
<span class="fc" id="L121">    this.m = m;</span>
<span class="fc" id="L122">    this.n = n;</span>
<span class="fc" id="L123">    A = new double[m][n];</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L126">        A[i][j] = s;</span>
      }
    }
<span class="fc" id="L129">  }</span>

  /** 
   * Construct a matrix from a 2-D array.
   * @param A    Two-dimensional array of doubles.
   * @throws  IllegalArgumentException All rows must have the same length
   * @see        #constructWithCopy
   */
<span class="fc" id="L137">  public Matrix(double[][] A) {</span>
<span class="fc" id="L138">    m = A.length;</span>
<span class="fc" id="L139">    n = A[0].length;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">      if (A[i].length != n) {</span>
<span class="nc" id="L142">        throw new IllegalArgumentException(&quot;All rows must have the same length.&quot;);</span>
      }
    }
<span class="fc" id="L145">    this.A = A;</span>
<span class="fc" id="L146">  }</span>

  /** 
   * Construct a matrix quickly without checking arguments.
   * @param A    Two-dimensional array of doubles.
   * @param m    Number of rows.
   * @param n    Number of colums.
   */
<span class="fc" id="L154">  public Matrix(double[][] A, int m, int n) {</span>
<span class="fc" id="L155">    this.A = A;</span>
<span class="fc" id="L156">    this.m = m;</span>
<span class="fc" id="L157">    this.n = n;</span>
<span class="fc" id="L158">  }</span>

  /** 
   * Construct a matrix from a one-dimensional packed array
   * @param vals One-dimensional array of doubles, packed by columns (ala
   * Fortran).
   * @param m    Number of rows.
   * @throws  IllegalArgumentException Array length must be a multiple of m.
   */
<span class="fc" id="L167">  public Matrix(double vals[], int m) {</span>
<span class="fc" id="L168">    this.m = m;</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">    n = (m != 0 ? vals.length/m : 0);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">    if (m*n != vals.length) {</span>
<span class="nc" id="L171">      throw new IllegalArgumentException(&quot;Array length must be a multiple of m.&quot;);</span>
    }
<span class="fc" id="L173">    A = new double[m][n];</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L176">        A[i][j] = vals[i+j*m];</span>
      }
    }
<span class="fc" id="L179">  }</span>

  /**
   * Reads a matrix from a reader. The first line in the file should
   * contain the number of rows and columns. Subsequent lines
   * contain elements of the matrix.
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @param     r the reader containing the matrix
   * @throws    Exception if an error occurs
   * @see       #write(Writer)
   */
<span class="fc" id="L191">  public Matrix(Reader r) throws Exception {</span>
<span class="fc" id="L192">    LineNumberReader lnr = new LineNumberReader(r);</span>
    String line;
<span class="fc" id="L194">    int currentRow = -1;</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">    while ((line = lnr.readLine()) != null) {</span>

      // Comments
<span class="pc bpc" id="L199" title="1 of 2 branches missed.">      if (line.startsWith(&quot;%&quot;))  </span>
<span class="nc" id="L200">        continue;</span>
      
<span class="fc" id="L202">      StringTokenizer st = new StringTokenizer(line);</span>
      // Ignore blank lines
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      if (!st.hasMoreTokens())  </span>
<span class="nc" id="L205">        continue;</span>

<span class="fc bfc" id="L207" title="All 2 branches covered.">      if (currentRow &lt; 0) {</span>
<span class="fc" id="L208">        int rows = Integer.parseInt(st.nextToken());</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (!st.hasMoreTokens())</span>
<span class="nc" id="L210">          throw new Exception(&quot;Line &quot; + lnr.getLineNumber() </span>
<span class="nc" id="L211">              + &quot;: expected number of columns&quot;);</span>

<span class="fc" id="L213">        int cols = Integer.parseInt(st.nextToken());</span>
<span class="fc" id="L214">        A = new double[rows][cols];</span>
<span class="fc" id="L215">        m = rows;</span>
<span class="fc" id="L216">        n = cols;</span>
<span class="fc" id="L217">        currentRow++;</span>
<span class="fc" id="L218">        continue;</span>

      } 
      else {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        if (currentRow == getRowDimension())</span>
<span class="nc" id="L223">          throw new Exception(&quot;Line &quot; + lnr.getLineNumber() </span>
<span class="nc" id="L224">              + &quot;: too many rows provided&quot;);</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (int i = 0; i &lt; getColumnDimension(); i++) {</span>
<span class="pc bpc" id="L227" title="1 of 2 branches missed.">          if (!st.hasMoreTokens())</span>
<span class="nc" id="L228">            throw new Exception(&quot;Line &quot; + lnr.getLineNumber() </span>
<span class="nc" id="L229">                + &quot;: too few matrix elements provided&quot;);</span>

<span class="fc" id="L231">          set(currentRow, i, Double.valueOf(st.nextToken()).doubleValue());</span>
        }
<span class="fc" id="L233">        currentRow++;</span>
      }
    }

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">    if (currentRow == -1)</span>
<span class="nc" id="L238">      throw new Exception(&quot;Line &quot; + lnr.getLineNumber() </span>
<span class="nc" id="L239">          + &quot;: expected number of rows&quot;);</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">    else if (currentRow != getRowDimension())</span>
<span class="nc" id="L241">      throw new Exception(&quot;Line &quot; + lnr.getLineNumber() </span>
<span class="nc" id="L242">          + &quot;: too few rows provided&quot;);</span>
<span class="fc" id="L243">  }</span>

  /** 
   * Construct a matrix from a copy of a 2-D array.
   * @param A    Two-dimensional array of doubles.
   * @throws  IllegalArgumentException All rows must have the same length
   */
  public static Matrix constructWithCopy(double[][] A) {
<span class="nc" id="L251">    int m = A.length;</span>
<span class="nc" id="L252">    int n = A[0].length;</span>
<span class="nc" id="L253">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L254">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">      if (A[i].length != n) {</span>
<span class="nc" id="L257">        throw new IllegalArgumentException</span>
<span class="nc" id="L258">          (&quot;All rows must have the same length.&quot;);</span>
      }
<span class="nc bnc" id="L260" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L261">        C[i][j] = A[i][j];</span>
      }
    }
<span class="nc" id="L264">    return X;</span>
  }

  /** 
   * Make a deep copy of a matrix
   */
  public Matrix copy() {
<span class="fc" id="L271">    Matrix X = new Matrix(m,n);</span>
<span class="fc" id="L272">    double[][] C = X.getArray();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L275">        C[i][j] = A[i][j];</span>
      }
    }
<span class="fc" id="L278">    return X;</span>
  }

  /** 
   * Clone the Matrix object.
   */
  public Object clone() {
<span class="nc" id="L285">    return this.copy();</span>
  }

  /** 
   * Access the internal two-dimensional array.
   * @return     Pointer to the two-dimensional array of matrix elements.
   */
  public double[][] getArray() {
<span class="fc" id="L293">    return A;</span>
  }

  /** 
   * Copy the internal two-dimensional array.
   * @return     Two-dimensional array copy of matrix elements.
   */
  public double[][] getArrayCopy() {
<span class="fc" id="L301">    double[][] C = new double[m][n];</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L303" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L304">        C[i][j] = A[i][j];</span>
      }
    }
<span class="fc" id="L307">    return C;</span>
  }

  /** 
   * Make a one-dimensional column packed copy of the internal array.
   * @return     Matrix elements packed in a one-dimensional array by columns.
   */
  public double[] getColumnPackedCopy() {
<span class="nc" id="L315">    double[] vals = new double[m*n];</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L318">        vals[i+j*m] = A[i][j];</span>
      }
    }
<span class="nc" id="L321">    return vals;</span>
  }

  /** 
   * Make a one-dimensional row packed copy of the internal array.
   * @return     Matrix elements packed in a one-dimensional array by rows.
   */
  public double[] getRowPackedCopy() {
<span class="nc" id="L329">    double[] vals = new double[m*n];</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L332">        vals[i*n+j] = A[i][j];</span>
      }
    }
<span class="nc" id="L335">    return vals;</span>
  }

  /** 
   * Get row dimension.
   * @return     m, the number of rows.
   */
  public int getRowDimension() {
<span class="fc" id="L343">    return m;</span>
  }

  /** 
   * Get column dimension.
   * @return     n, the number of columns.
   */
  public int getColumnDimension() {
<span class="fc" id="L351">    return n;</span>
  }

  /** 
   * Get a single element.
   * @param i    Row index.
   * @param j    Column index.
   * @return     A(i,j)
   * @throws  ArrayIndexOutOfBoundsException
   */
  public double get(int i, int j) {
<span class="fc" id="L362">    return A[i][j];</span>
  }

  /** 
   * Get a submatrix.
   * @param i0   Initial row index
   * @param i1   Final row index
   * @param j0   Initial column index
   * @param j1   Final column index
   * @return     A(i0:i1,j0:j1)
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public Matrix getMatrix(int i0, int i1, int j0, int j1) {
<span class="nc" id="L375">    Matrix X = new Matrix(i1-i0+1,j1-j0+1);</span>
<span class="nc" id="L376">    double[][] B = X.getArray();</span>
    try {
<span class="nc bnc" id="L378" title="All 2 branches missed.">      for (int i = i0; i &lt;= i1; i++) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int j = j0; j &lt;= j1; j++) {</span>
<span class="nc" id="L380">          B[i-i0][j-j0] = A[i][j];</span>
        }
      }
<span class="nc" id="L383">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L384">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L386">    return X;</span>
  }

  /** 
   * Get a submatrix.
   * @param r    Array of row indices.
   * @param c    Array of column indices.
   * @return     A(r(:),c(:))
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public Matrix getMatrix(int[] r, int[] c) {
<span class="nc" id="L397">    Matrix X = new Matrix(r.length,c.length);</span>
<span class="nc" id="L398">    double[][] B = X.getArray();</span>
    try {
<span class="nc bnc" id="L400" title="All 2 branches missed.">      for (int i = 0; i &lt; r.length; i++) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        for (int j = 0; j &lt; c.length; j++) {</span>
<span class="nc" id="L402">          B[i][j] = A[r[i]][c[j]];</span>
        }
      }
<span class="nc" id="L405">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L406">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L408">    return X;</span>
  }

  /** 
   * Get a submatrix.
   * @param i0   Initial row index
   * @param i1   Final row index
   * @param c    Array of column indices.
   * @return     A(i0:i1,c(:))
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public Matrix getMatrix(int i0, int i1, int[] c) {
<span class="nc" id="L420">    Matrix X = new Matrix(i1-i0+1,c.length);</span>
<span class="nc" id="L421">    double[][] B = X.getArray();</span>
    try {
<span class="nc bnc" id="L423" title="All 2 branches missed.">      for (int i = i0; i &lt;= i1; i++) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        for (int j = 0; j &lt; c.length; j++) {</span>
<span class="nc" id="L425">          B[i-i0][j] = A[i][c[j]];</span>
        }
      }
<span class="nc" id="L428">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L429">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L431">    return X;</span>
  }

  /** 
   * Get a submatrix.
   * @param r    Array of row indices.
   * @param j0   Initial column index
   * @param j1   Final column index
   * @return     A(r(:),j0:j1)
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public Matrix getMatrix(int[] r, int j0, int j1) {
<span class="fc" id="L443">    Matrix X = new Matrix(r.length,j1-j0+1);</span>
<span class="fc" id="L444">    double[][] B = X.getArray();</span>
    try {
<span class="fc bfc" id="L446" title="All 2 branches covered.">      for (int i = 0; i &lt; r.length; i++) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">        for (int j = j0; j &lt;= j1; j++) {</span>
<span class="fc" id="L448">          B[i][j-j0] = A[r[i]][j];</span>
        }
      }
<span class="nc" id="L451">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L452">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="fc" id="L454">    return X;</span>
  }

  /** 
   * Set a single element.
   * @param i    Row index.
   * @param j    Column index.
   * @param s    A(i,j).
   * @throws  ArrayIndexOutOfBoundsException
   */
  public void set(int i, int j, double s) {
<span class="fc" id="L465">    A[i][j] = s;</span>
<span class="fc" id="L466">  }</span>

  /** 
   * Set a submatrix.
   * @param i0   Initial row index
   * @param i1   Final row index
   * @param j0   Initial column index
   * @param j1   Final column index
   * @param X    A(i0:i1,j0:j1)
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public void setMatrix(int i0, int i1, int j0, int j1, Matrix X) {
    try {
<span class="fc bfc" id="L479" title="All 2 branches covered.">      for (int i = i0; i &lt;= i1; i++) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        for (int j = j0; j &lt;= j1; j++) {</span>
<span class="fc" id="L481">          A[i][j] = X.get(i-i0,j-j0);</span>
        }
      }
<span class="nc" id="L484">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L485">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="fc" id="L487">  }</span>

  /** 
   * Set a submatrix.
   * @param r    Array of row indices.
   * @param c    Array of column indices.
   * @param X    A(r(:),c(:))
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public void setMatrix(int[] r, int[] c, Matrix X) {
    try {
<span class="nc bnc" id="L498" title="All 2 branches missed.">      for (int i = 0; i &lt; r.length; i++) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        for (int j = 0; j &lt; c.length; j++) {</span>
<span class="nc" id="L500">          A[r[i]][c[j]] = X.get(i,j);</span>
        }
      }
<span class="nc" id="L503">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L504">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L506">  }</span>

  /** 
   * Set a submatrix.
   * @param r    Array of row indices.
   * @param j0   Initial column index
   * @param j1   Final column index
   * @param X    A(r(:),j0:j1)
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public void setMatrix(int[] r, int j0, int j1, Matrix X) {
    try {
<span class="nc bnc" id="L518" title="All 2 branches missed.">      for (int i = 0; i &lt; r.length; i++) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        for (int j = j0; j &lt;= j1; j++) {</span>
<span class="nc" id="L520">          A[r[i]][j] = X.get(i,j-j0);</span>
        }
      }
<span class="nc" id="L523">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L524">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L526">  }</span>

  /** 
   * Set a submatrix.
   * @param i0   Initial row index
   * @param i1   Final row index
   * @param c    Array of column indices.
   * @param X    A(i0:i1,c(:))
   * @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public void setMatrix(int i0, int i1, int[] c, Matrix X) {
    try {
<span class="nc bnc" id="L538" title="All 2 branches missed.">      for (int i = i0; i &lt;= i1; i++) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">        for (int j = 0; j &lt; c.length; j++) {</span>
<span class="nc" id="L540">          A[i][c[j]] = X.get(i-i0,j);</span>
        }
      }
<span class="nc" id="L543">    } catch(ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L544">      throw new ArrayIndexOutOfBoundsException(&quot;Submatrix indices&quot;);</span>
    }
<span class="nc" id="L546">  }</span>
  
  /**
   * Returns true if the matrix is symmetric.
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @return boolean true if matrix is symmetric.
   */
  public boolean isSymmetric() {
<span class="nc" id="L555">    int nr = A.length, nc = A[0].length;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">    if (nr != nc)</span>
<span class="nc" id="L557">      return false;</span>

<span class="nc bnc" id="L559" title="All 2 branches missed.">    for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (A[i][j] != A[j][i])</span>
<span class="nc" id="L562">          return false;</span>
      }
    }
<span class="nc" id="L565">    return true;</span>
  }

  /**
   * returns whether the matrix is a square matrix or not.
   *
   * @return true if the matrix is a square matrix
   */
  public boolean isSquare() {
<span class="nc bnc" id="L574" title="All 2 branches missed.">    return (getRowDimension() == getColumnDimension());</span>
  }

  /** 
   * Matrix transpose.
   * @return    A'
   */
  public Matrix transpose() {
<span class="fc" id="L582">    Matrix X = new Matrix(n,m);</span>
<span class="fc" id="L583">    double[][] C = X.getArray();</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L585" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L586">        C[j][i] = A[i][j];</span>
      }
    }
<span class="fc" id="L589">    return X;</span>
  }

  /** 
   * One norm
   * @return    maximum column sum.
   */
  public double norm1() {
<span class="nc" id="L597">    double f = 0;</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">    for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L599">      double s = 0;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">      for (int i = 0; i &lt; m; i++) {</span>
<span class="nc" id="L601">        s += Math.abs(A[i][j]);</span>
      }
<span class="nc" id="L603">      f = Math.max(f,s);</span>
    }
<span class="nc" id="L605">    return f;</span>
  }

  /** 
   * Two norm
   * @return    maximum singular value.
   */
  public double norm2() {
<span class="nc" id="L613">    return (new SingularValueDecomposition(this).norm2());</span>
  }

  /** 
   * Infinity norm
   * @return    maximum row sum.
   */
  public double normInf() {
<span class="nc" id="L621">    double f = 0;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc" id="L623">      double s = 0;</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L625">        s += Math.abs(A[i][j]);</span>
      }
<span class="nc" id="L627">      f = Math.max(f,s);</span>
    }
<span class="nc" id="L629">    return f;</span>
  }

  /** 
   * Frobenius norm
   * @return    sqrt of sum of squares of all elements.
   */
  public double normF() {
<span class="nc" id="L637">    double f = 0;</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L640">        f = Maths.hypot(f,A[i][j]);</span>
      }
    }
<span class="nc" id="L643">    return f;</span>
  }

  /**  
   * Unary minus
   * @return    -A
   */
  public Matrix uminus() {
<span class="nc" id="L651">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L652">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L655">        C[i][j] = -A[i][j];</span>
      }
    }
<span class="nc" id="L658">    return X;</span>
  }

  /** 
   * C = A + B
   * @param B    another matrix
   * @return     A + B
   */
  public Matrix plus(Matrix B) {
<span class="nc" id="L667">    checkMatrixDimensions(B);</span>
<span class="nc" id="L668">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L669">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L672">        C[i][j] = A[i][j] + B.A[i][j];</span>
      }
    }
<span class="nc" id="L675">    return X;</span>
  }

  /** 
   * A = A + B
   * @param B    another matrix
   * @return     A + B
   */
  public Matrix plusEquals(Matrix B) {
<span class="nc" id="L684">    checkMatrixDimensions(B);</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L687">        A[i][j] = A[i][j] + B.A[i][j];</span>
      }
    }
<span class="nc" id="L690">    return this;</span>
  }

  /** 
   * C = A - B
   * @param B    another matrix
   * @return     A - B
   */
  public Matrix minus(Matrix B) {
<span class="fc" id="L699">    checkMatrixDimensions(B);</span>
<span class="fc" id="L700">    Matrix X = new Matrix(m,n);</span>
<span class="fc" id="L701">    double[][] C = X.getArray();</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L704">        C[i][j] = A[i][j] - B.A[i][j];</span>
      }
    }
<span class="fc" id="L707">    return X;</span>
  }

  /** 
   * A = A - B
   * @param B    another matrix
   * @return     A - B
   */
  public Matrix minusEquals(Matrix B) {
<span class="nc" id="L716">    checkMatrixDimensions(B);</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L719">        A[i][j] = A[i][j] - B.A[i][j];</span>
      }
    }
<span class="nc" id="L722">    return this;</span>
  }

  /** 
   * Element-by-element multiplication, C = A.*B
   * @param B    another matrix
   * @return     A.*B
   */
  public Matrix arrayTimes(Matrix B) {
<span class="nc" id="L731">    checkMatrixDimensions(B);</span>
<span class="nc" id="L732">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L733">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L736">        C[i][j] = A[i][j] * B.A[i][j];</span>
      }
    }
<span class="nc" id="L739">    return X;</span>
  }

  /** 
   * Element-by-element multiplication in place, A = A.*B
   * @param B    another matrix
   * @return     A.*B
   */
  public Matrix arrayTimesEquals(Matrix B) {
<span class="nc" id="L748">    checkMatrixDimensions(B);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L751">        A[i][j] = A[i][j] * B.A[i][j];</span>
      }
    }
<span class="nc" id="L754">    return this;</span>
  }

  /** 
   * Element-by-element right division, C = A./B
   * @param B    another matrix
   * @return     A./B
   */
  public Matrix arrayRightDivide(Matrix B) {
<span class="nc" id="L763">    checkMatrixDimensions(B);</span>
<span class="nc" id="L764">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L765">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L768">        C[i][j] = A[i][j] / B.A[i][j];</span>
      }
    }
<span class="nc" id="L771">    return X;</span>
  }

  /** 
   * Element-by-element right division in place, A = A./B
   * @param B    another matrix
   * @return     A./B
   */
  public Matrix arrayRightDivideEquals(Matrix B) {
<span class="nc" id="L780">    checkMatrixDimensions(B);</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L783">        A[i][j] = A[i][j] / B.A[i][j];</span>
      }
    }
<span class="nc" id="L786">    return this;</span>
  }

  /** 
   * Element-by-element left division, C = A.\B
   * @param B    another matrix
   * @return     A.\B
   */
  public Matrix arrayLeftDivide(Matrix B) {
<span class="nc" id="L795">    checkMatrixDimensions(B);</span>
<span class="nc" id="L796">    Matrix X = new Matrix(m,n);</span>
<span class="nc" id="L797">    double[][] C = X.getArray();</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L800">        C[i][j] = B.A[i][j] / A[i][j];</span>
      }
    }
<span class="nc" id="L803">    return X;</span>
  }

  /** 
   * Element-by-element left division in place, A = A.\B
   * @param B    another matrix
   * @return     A.\B
   */
  public Matrix arrayLeftDivideEquals(Matrix B) {
<span class="nc" id="L812">    checkMatrixDimensions(B);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L815">        A[i][j] = B.A[i][j] / A[i][j];</span>
      }
    }
<span class="nc" id="L818">    return this;</span>
  }

  /** 
   * Multiply a matrix by a scalar, C = s*A
   * @param s    scalar
   * @return     s*A
   */
  public Matrix times(double s) {
<span class="fc" id="L827">    Matrix X = new Matrix(m,n);</span>
<span class="fc" id="L828">    double[][] C = X.getArray();</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L831">        C[i][j] = s*A[i][j];</span>
      }
    }
<span class="fc" id="L834">    return X;</span>
  }

  /** 
   * Multiply a matrix by a scalar in place, A = s*A
   * @param s    scalar
   * @return     replace A by s*A
   */
  public Matrix timesEquals(double s) {
<span class="fc bfc" id="L843" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L844" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L845">        A[i][j] = s*A[i][j];</span>
      }
    }
<span class="fc" id="L848">    return this;</span>
  }

  /** 
   * Linear algebraic matrix multiplication, A * B
   * @param B    another matrix
   * @return     Matrix product, A * B
   * @throws  IllegalArgumentException Matrix inner dimensions must agree.
   */
  public Matrix times(Matrix B) {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">    if (B.m != n) {</span>
<span class="nc" id="L859">      throw new IllegalArgumentException(&quot;Matrix inner dimensions must agree.&quot;);</span>
    }
<span class="fc" id="L861">    Matrix X = new Matrix(m,B.n);</span>
<span class="fc" id="L862">    double[][] C = X.getArray();</span>
<span class="fc" id="L863">    double[] Bcolj = new double[n];</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">    for (int j = 0; j &lt; B.n; j++) {</span>
<span class="fc bfc" id="L865" title="All 2 branches covered.">      for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L866">        Bcolj[k] = B.A[k][j];</span>
      }
<span class="fc bfc" id="L868" title="All 2 branches covered.">      for (int i = 0; i &lt; m; i++) {</span>
<span class="fc" id="L869">        double[] Arowi = A[i];</span>
<span class="fc" id="L870">        double s = 0;</span>
<span class="fc bfc" id="L871" title="All 2 branches covered.">        for (int k = 0; k &lt; n; k++) {</span>
<span class="fc" id="L872">          s += Arowi[k]*Bcolj[k];</span>
        }
<span class="fc" id="L874">        C[i][j] = s;</span>
      }
    }
<span class="fc" id="L877">    return X;</span>
  }

  /** 
   * LU Decomposition
   * @return     LUDecomposition
   * @see LUDecomposition
   */
  public LUDecomposition lu() {
<span class="nc" id="L886">    return new LUDecomposition(this);</span>
  }

  /** 
   * QR Decomposition
   * @return     QRDecomposition
   * @see QRDecomposition
   */
  public QRDecomposition qr() {
<span class="nc" id="L895">    return new QRDecomposition(this);</span>
  }

  /** 
   * Cholesky Decomposition
   * @return     CholeskyDecomposition
   * @see CholeskyDecomposition
   */
  public CholeskyDecomposition chol() {
<span class="nc" id="L904">    return new CholeskyDecomposition(this);</span>
  }

  /** 
   * Singular Value Decomposition
   * @return     SingularValueDecomposition
   * @see SingularValueDecomposition
   */
  public SingularValueDecomposition svd() {
<span class="nc" id="L913">    return new SingularValueDecomposition(this);</span>
  }

  /** 
   * Eigenvalue Decomposition
   * @return     EigenvalueDecomposition
   * @see EigenvalueDecomposition
   */
  public EigenvalueDecomposition eig() {
<span class="fc" id="L922">    return new EigenvalueDecomposition(this);</span>
  }

  /** 
   * Solve A*X = B
   * @param B    right hand side
   * @return     solution if A is square, least squares solution otherwise
   */
  public Matrix solve(Matrix B) {
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">    return (m == n ? (new LUDecomposition(this)).solve(B) :</span>
<span class="nc" id="L932">        (new QRDecomposition(this)).solve(B));</span>
  }

  /** 
   * Solve X*A = B, which is also A'*X' = B'
   * @param B    right hand side
   * @return     solution if A is square, least squares solution otherwise.
   */
  public Matrix solveTranspose(Matrix B) {
<span class="nc" id="L941">    return transpose().solve(B.transpose());</span>
  }

  /** 
   * Matrix inverse or pseudoinverse
   * @return     inverse(A) if A is square, pseudoinverse otherwise.
   */
  public Matrix inverse() {
<span class="nc" id="L949">    return solve(identity(m,m));</span>
  }

  /**
   * returns the square root of the matrix, i.e., X from the equation
   * X*X = A.&lt;br/&gt;
   * Steps in the Calculation (see &lt;a href=&quot;http://www.mathworks.com/access/helpdesk/help/techdoc/ref/sqrtm.html&quot; target=&quot;blank&quot;&gt;&lt;code&gt;sqrtm&lt;/code&gt;&lt;/a&gt; in Matlab):&lt;br/&gt;
   * &lt;ol&gt;
   *   &lt;li&gt;perform eigenvalue decomposition&lt;br/&gt;[V,D]=eig(A)&lt;/li&gt;
   *   &lt;li&gt;take the square root of all elements in D (only the ones with 
   *       positive sign are considered for further computation)&lt;br/&gt;
   *       S=sqrt(D)&lt;/li&gt;
   *   &lt;li&gt;calculate the root&lt;br/&gt;
   *       X=V*S/V, which can be also written as X=(V'\(V*S)')'&lt;/li&gt;
   * &lt;/ol&gt;
   * &lt;p/&gt;
   * &lt;b&gt;Note:&lt;/b&gt; since this method uses other high-level methods, it generates
   * several instances of matrices. This can be problematic with large
   * matrices.
   * &lt;p/&gt;
   * Examples:
   * &lt;ol&gt;
   *   &lt;li&gt;
   *   &lt;pre&gt;
   *  X =
   *   5   -4    1    0    0
   *  -4    6   -4    1    0
   *   1   -4    6   -4    1
   *   0    1   -4    6   -4
   *   0    0    1   -4    5
   * 
   *  sqrt(X) =
   *   2   -1   -0   -0   -0 
   *  -1    2   -1    0   -0 
   *   0   -1    2   -1    0 
   *  -0    0   -1    2   -1 
   *  -0   -0   -0   -1    2 
   *  
   *  Matrix m = new Matrix(new double[][]{{5,-4,1,0,0},{-4,6,-4,1,0},{1,-4,6,-4,1},{0,1,-4,6,-4},{0,0,1,-4,5}});
   *   &lt;/pre&gt;
   *   &lt;/li&gt;
   *   &lt;li&gt;
   *   &lt;pre&gt;
   *  X =
   *   7   10
   *  15   22
   *  
   *  sqrt(X) =
   *  1.5667    1.7408
   *  2.6112    4.1779
   * 
   *  Matrix m = new Matrix(new double[][]{{7, 10},{15, 22}});
   *   &lt;/pre&gt;
   *   &lt;/li&gt;
   * &lt;/ol&gt;
   *
   * @return    sqrt(A)
   */
  public Matrix sqrt() {
    EigenvalueDecomposition   evd;
    Matrix                    s;
    Matrix                    v;
    Matrix                    d;
    Matrix                    result;
    Matrix                    a;
    Matrix                    b;
    int                       i;
    int                       n;

<span class="nc" id="L1018">    result = null;</span>
    
    // eigenvalue decomp.
    // [V, D] = eig(A) with A = this
<span class="nc" id="L1022">    evd = this.eig();</span>
<span class="nc" id="L1023">    v   = evd.getV();</span>
<span class="nc" id="L1024">    d   = evd.getD();</span>

    // S = sqrt of cells of D
<span class="nc" id="L1027">    s = new Matrix(d.getRowDimension(), d.getColumnDimension());</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">    for (i = 0; i &lt; s.getRowDimension(); i++)</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">      for (n = 0; n &lt; s.getColumnDimension(); n++)</span>
<span class="nc" id="L1030">        s.set(i, n, StrictMath.sqrt(d.get(i, n)));</span>

    // to calculate:
    //      result = V*S/V
    //
    //    with   X = B/A
    //    and  B/A = (A'\B')'
    //    and V=A and V*S=B
    // we get 
    //      result = (V'\(V*S)')'
    //      
    //         A*X = B
    //           X = A\B
    // which is 
    //           X = A.solve(B)
    //           
    // with A=V' and B=(V*S)' 
    // we get
    //           X = V'.solve((V*S)')
    // or
    //      result = X'
    //
    // which is in full length
    //      result = (V'.solve((V*S)'))'
<span class="nc" id="L1054">    a      = v.inverse();</span>
<span class="nc" id="L1055">    b      = v.times(s).inverse();</span>
<span class="nc" id="L1056">    v      = null;</span>
<span class="nc" id="L1057">    d      = null;</span>
<span class="nc" id="L1058">    evd    = null;</span>
<span class="nc" id="L1059">    s      = null;</span>
<span class="nc" id="L1060">    result = a.solve(b).inverse();</span>

<span class="nc" id="L1062">    return result;</span>
  }

  /**
   * Performs a (ridged) linear regression.
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @param     y the dependent variable vector
   * @param     ridge the ridge parameter
   * @return    the coefficients 
   * @throws    IllegalArgumentException if not successful
   */
  public LinearRegression regression(Matrix y, double ridge) {
<span class="fc" id="L1075">    return new LinearRegression(this, y, ridge);</span>
  }

  /**
   * Performs a weighted (ridged) linear regression. 
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @param     y the dependent variable vector
   * @param     w the array of data point weights
   * @param     ridge the ridge parameter
   * @return    the coefficients 
   * @throws    IllegalArgumentException if the wrong number of weights were
   *            provided.
   */
  public final LinearRegression regression(Matrix y, double[] w, double ridge) {
<span class="nc" id="L1090">    return new LinearRegression(this, y, w, ridge);</span>
  }

  /** 
   * Matrix determinant
   * @return     determinant
   */
  public double det() {
<span class="nc" id="L1098">    return new LUDecomposition(this).det();</span>
  }

  /** 
   * Matrix rank
   * @return     effective numerical rank, obtained from SVD.
   */
  public int rank() {
<span class="nc" id="L1106">    return new SingularValueDecomposition(this).rank();</span>
  }

  /** 
   * Matrix condition (2 norm)
   * @return     ratio of largest to smallest singular value.
   */
  public double cond() {
<span class="nc" id="L1114">    return new SingularValueDecomposition(this).cond();</span>
  }

  /** 
   * Matrix trace.
   * @return     sum of the diagonal elements.
   */
  public double trace() {
<span class="nc" id="L1122">    double t = 0;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">    for (int i = 0; i &lt; Math.min(m,n); i++) {</span>
<span class="nc" id="L1124">      t += A[i][i];</span>
    }
<span class="nc" id="L1126">    return t;</span>
  }

  /** 
   * Generate matrix with random elements
   * @param m    Number of rows.
   * @param n    Number of colums.
   * @return     An m-by-n matrix with uniformly distributed random elements.
   */
  public static Matrix random(int m, int n) {
<span class="nc" id="L1136">    Matrix A = new Matrix(m,n);</span>
<span class="nc" id="L1137">    double[][] X = A.getArray();</span>
<span class="nc bnc" id="L1138" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L1140">        X[i][j] = Math.random();</span>
      }
    }
<span class="nc" id="L1143">    return A;</span>
  }

  /** 
   * Generate identity matrix
   * @param m    Number of rows.
   * @param n    Number of colums.
   * @return     An m-by-n matrix with ones on the diagonal and zeros elsewhere.
   */
  public static Matrix identity(int m, int n) {
<span class="fc" id="L1153">    Matrix A = new Matrix(m,n);</span>
<span class="fc" id="L1154">    double[][] X = A.getArray();</span>
<span class="fc bfc" id="L1155" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L1156" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">        X[i][j] = (i == j ? 1.0 : 0.0);</span>
      }
    }
<span class="fc" id="L1160">    return A;</span>
  }

  /** 
   * Print the matrix to stdout.   Line the elements up in columns
   * with a Fortran-like 'Fw.d' style format.
   * @param w    Column width.
   * @param d    Number of digits after the decimal.
   */
  public void print(int w, int d) {
<span class="nc" id="L1170">    print(new PrintWriter(System.out,true),w,d); </span>
<span class="nc" id="L1171">  }</span>

  /** 
   * Print the matrix to the output stream.   Line the elements up in
   * columns with a Fortran-like 'Fw.d' style format.
   * @param output Output stream.
   * @param w      Column width.
   * @param d      Number of digits after the decimal.
   */
  public void print(PrintWriter output, int w, int d) {
<span class="nc" id="L1181">    DecimalFormat format = new DecimalFormat();</span>
<span class="nc" id="L1182">    format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));</span>
<span class="nc" id="L1183">    format.setMinimumIntegerDigits(1);</span>
<span class="nc" id="L1184">    format.setMaximumFractionDigits(d);</span>
<span class="nc" id="L1185">    format.setMinimumFractionDigits(d);</span>
<span class="nc" id="L1186">    format.setGroupingUsed(false);</span>
<span class="nc" id="L1187">    print(output,format,w+2);</span>
<span class="nc" id="L1188">  }</span>

  /** 
   * Print the matrix to stdout.  Line the elements up in columns.
   * Use the format object, and right justify within columns of width
   * characters.
   * Note that is the matrix is to be read back in, you probably will want
   * to use a NumberFormat that is set to US Locale.
   * @param format A  Formatting object for individual elements.
   * @param width     Field width for each column.
   * @see java.text.DecimalFormat#setDecimalFormatSymbols
   */
  public void print(NumberFormat format, int width) {
<span class="nc" id="L1201">    print(new PrintWriter(System.out,true),format,width); </span>
<span class="nc" id="L1202">  }</span>

  // DecimalFormat is a little disappointing coming from Fortran or C's printf.
  // Since it doesn't pad on the left, the elements will come out different
  // widths.  Consequently, we'll pass the desired column width in as an
  // argument and do the extra padding ourselves.

  /** 
   * Print the matrix to the output stream.  Line the elements up in columns.
   * Use the format object, and right justify within columns of width
   * characters.
   * Note that is the matrix is to be read back in, you probably will want
   * to use a NumberFormat that is set to US Locale.
   * @param output the output stream.
   * @param format A formatting object to format the matrix elements 
   * @param width  Column width.
   * @see java.text.DecimalFormat#setDecimalFormatSymbols
   */
  public void print(PrintWriter output, NumberFormat format, int width) {
<span class="nc" id="L1221">    output.println();  // start on new line.</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L1224">        String s = format.format(A[i][j]); // format the number</span>
<span class="nc" id="L1225">        int padding = Math.max(1,width-s.length()); // At _least_ 1 space</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">        for (int k = 0; k &lt; padding; k++)</span>
<span class="nc" id="L1227">          output.print(' ');</span>
<span class="nc" id="L1228">        output.print(s);</span>
      }
<span class="nc" id="L1230">      output.println();</span>
    }
<span class="nc" id="L1232">    output.println();   // end with blank line.</span>
<span class="nc" id="L1233">  }</span>

  /** 
   * Read a matrix from a stream.  The format is the same the print method,
   * so printed matrices can be read back in (provided they were printed using
   * US Locale).  Elements are separated by
   * whitespace, all the elements for each row appear on a single line,
   * the last row is followed by a blank line.
   * &lt;p/&gt;
   * Note: This format differs from the one that can be read via the
   * Matrix(Reader) constructor! For that format, the write(Writer) method
   * is used (from the original weka.core.Matrix class).
   *
   * @param input the input stream.
   * @see #Matrix(Reader)
   * @see #write(Writer)
   */
  public static Matrix read(BufferedReader input) throws java.io.IOException {
<span class="nc" id="L1251">    StreamTokenizer tokenizer= new StreamTokenizer(input);</span>

    // Although StreamTokenizer will parse numbers, it doesn't recognize
    // scientific notation (E or D); however, Double.valueOf does.
    // The strategy here is to disable StreamTokenizer's number parsing.
    // We'll only get whitespace delimited words, EOL's and EOF's.
    // These words should all be numbers, for Double.valueOf to parse.

<span class="nc" id="L1259">    tokenizer.resetSyntax();</span>
<span class="nc" id="L1260">    tokenizer.wordChars(0,255);</span>
<span class="nc" id="L1261">    tokenizer.whitespaceChars(0, ' ');</span>
<span class="nc" id="L1262">    tokenizer.eolIsSignificant(true);</span>
<span class="nc" id="L1263">    java.util.Vector v = new java.util.Vector();</span>

    // Ignore initial empty lines
<span class="nc bnc" id="L1266" title="All 2 branches missed.">    while (tokenizer.nextToken() == StreamTokenizer.TT_EOL);</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">    if (tokenizer.ttype == StreamTokenizer.TT_EOF)</span>
<span class="nc" id="L1268">      throw new java.io.IOException(&quot;Unexpected EOF on matrix read.&quot;);</span>
    do {
<span class="nc" id="L1270">      v.addElement(Double.valueOf(tokenizer.sval)); // Read &amp; store 1st row.</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">    } while (tokenizer.nextToken() == StreamTokenizer.TT_WORD);</span>

<span class="nc" id="L1273">    int n = v.size();  // Now we've got the number of columns!</span>
<span class="nc" id="L1274">    double row[] = new double[n];</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">    for (int j=0; j&lt;n; j++)  // extract the elements of the 1st row.</span>
<span class="nc" id="L1276">      row[j]=((Double)v.elementAt(j)).doubleValue();</span>
<span class="nc" id="L1277">    v.removeAllElements();</span>
<span class="nc" id="L1278">    v.addElement(row);  // Start storing rows instead of columns.</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">    while (tokenizer.nextToken() == StreamTokenizer.TT_WORD) {</span>
      // While non-empty lines
<span class="nc" id="L1281">      v.addElement(row = new double[n]);</span>
<span class="nc" id="L1282">      int j = 0;</span>
      do {
<span class="nc bnc" id="L1284" title="All 2 branches missed.">        if (j &gt;= n) throw new java.io.IOException</span>
<span class="nc" id="L1285">          (&quot;Row &quot; + v.size() + &quot; is too long.&quot;);</span>
<span class="nc" id="L1286">        row[j++] = Double.valueOf(tokenizer.sval).doubleValue();</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">      } while (tokenizer.nextToken() == StreamTokenizer.TT_WORD);</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">      if (j &lt; n) throw new java.io.IOException</span>
<span class="nc" id="L1289">        (&quot;Row &quot; + v.size() + &quot; is too short.&quot;);</span>
    }
<span class="nc" id="L1291">    int m = v.size();  // Now we've got the number of rows.</span>
<span class="nc" id="L1292">    double[][] A = new double[m][];</span>
<span class="nc" id="L1293">    v.copyInto(A);  // copy the rows out of the vector</span>
<span class="nc" id="L1294">    return new Matrix(A);</span>
  }


  /** 
   * Check if size(A) == size(B) 
   */
  private void checkMatrixDimensions(Matrix B) {
<span class="pc bpc" id="L1302" title="2 of 4 branches missed.">    if (B.m != m || B.n != n) {</span>
<span class="nc" id="L1303">      throw new IllegalArgumentException(&quot;Matrix dimensions must agree.&quot;);</span>
    }
<span class="fc" id="L1305">  }</span>

  /**
   * Writes out a matrix. The format can be read via the Matrix(Reader)
   * constructor.
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @param     w the output Writer
   * @throws    Exception if an error occurs
   * @see       #Matrix(Reader)
   */
  public void write(Writer w) throws Exception {
<span class="nc" id="L1317">    w.write(&quot;% Rows\tColumns\n&quot;);</span>
<span class="nc" id="L1318">    w.write(&quot;&quot; + getRowDimension() + &quot;\t&quot; + getColumnDimension() + &quot;\n&quot;);</span>
<span class="nc" id="L1319">    w.write(&quot;% Matrix elements\n&quot;);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">    for(int i = 0; i &lt; getRowDimension(); i++) {</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">      for(int j = 0; j &lt; getColumnDimension(); j++)</span>
<span class="nc" id="L1322">        w.write(&quot;&quot; + get(i, j) + &quot;\t&quot;);</span>
<span class="nc" id="L1323">      w.write(&quot;\n&quot;);</span>
    }
<span class="nc" id="L1325">    w.flush();</span>
<span class="nc" id="L1326">  }</span>

  /** 
   * Converts a matrix to a string.
   * (FracPete: taken from old weka.core.Matrix class)
   *
   * @return    the converted string
   */
  public String toString() {
    // Determine the width required for the maximum element,
    // and check for fractional display requirement.
<span class="nc" id="L1337">    double maxval = 0;</span>
<span class="nc" id="L1338">    boolean fractional = false;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">    for (int i = 0; i &lt; getRowDimension(); i++) {</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">      for (int j = 0; j &lt; getColumnDimension(); j++) {</span>
<span class="nc" id="L1341">        double current = get(i, j);</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (current &lt; 0)</span>
<span class="nc" id="L1343">          current *= -11;</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (current &gt; maxval)</span>
<span class="nc" id="L1345">          maxval = current;</span>
<span class="nc" id="L1346">        double fract = Math.abs(current - Math.rint(current));</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (!fractional</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">            &amp;&amp; ((Math.log(fract) / Math.log(10)) &gt;= -2)) {</span>
<span class="nc" id="L1349">          fractional = true;</span>
        }
      }
    }
<span class="nc" id="L1353">    int width = (int)(Math.log(maxval) / Math.log(10) </span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        + (fractional ? 4 : 1));</span>

<span class="nc" id="L1356">    StringBuffer text = new StringBuffer();   </span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">    for (int i = 0; i &lt; getRowDimension(); i++) {</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">      for (int j = 0; j &lt; getColumnDimension(); j++)</span>
<span class="nc" id="L1359">        text.append(&quot; &quot;).append(Utils.doubleToString(get(i, j),</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">              width, (fractional ? 2 : 0)));</span>
<span class="nc" id="L1361">      text.append(&quot;\n&quot;);</span>
    }

<span class="nc" id="L1364">    return text.toString();</span>
  } 

  /**
   * converts the Matrix into a single line Matlab string: matrix is enclosed 
   * by parentheses, rows are separated by semicolon and single cells by
   * blanks, e.g., [1 2; 3 4].
   * @return      the matrix in Matlab single line format
   */
  public String toMatlab() {
    StringBuffer      result;
    int               i;
    int               n;

<span class="nc" id="L1378">    result = new StringBuffer();</span>

<span class="nc" id="L1380">    result.append(&quot;[&quot;);</span>

<span class="nc bnc" id="L1382" title="All 2 branches missed.">    for (i = 0; i &lt; getRowDimension(); i++) {</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">      if (i &gt; 0)</span>
<span class="nc" id="L1384">        result.append(&quot;; &quot;);</span>
      
<span class="nc bnc" id="L1386" title="All 2 branches missed.">      for (n = 0; n &lt; getColumnDimension(); n++) {</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (n &gt; 0)</span>
<span class="nc" id="L1388">          result.append(&quot; &quot;);</span>
<span class="nc" id="L1389">        result.append(Double.toString(get(i, n)));</span>
      }
    }
    
<span class="nc" id="L1393">    result.append(&quot;]&quot;);</span>

<span class="nc" id="L1395">    return result.toString();</span>
  }

  /**
   * creates a matrix from the given Matlab string.
   * @param matlab  the matrix in matlab format
   * @return        the matrix represented by the given string
   * @see           #toMatlab()
   */
  public static Matrix parseMatlab(String matlab) throws Exception {
    StringTokenizer   tokRow;
    StringTokenizer   tokCol;
    int               rows;
    int               cols;
    Matrix            result;
    String            cells;
    
    // get content
<span class="nc" id="L1413">    cells = matlab.substring(</span>
<span class="nc" id="L1414">              matlab.indexOf(&quot;[&quot;) + 1, matlab.indexOf(&quot;]&quot;)).trim();</span>
    
    // determine dimenions
<span class="nc" id="L1417">    tokRow = new StringTokenizer(cells, &quot;;&quot;);</span>
<span class="nc" id="L1418">    rows   = tokRow.countTokens();</span>
<span class="nc" id="L1419">    tokCol = new StringTokenizer(tokRow.nextToken(), &quot; &quot;);</span>
<span class="nc" id="L1420">    cols   = tokCol.countTokens();</span>
    
    // fill matrix
<span class="nc" id="L1423">    result = new Matrix(rows, cols);</span>
<span class="nc" id="L1424">    tokRow = new StringTokenizer(cells, &quot;;&quot;);</span>
<span class="nc" id="L1425">    rows   = 0;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">    while (tokRow.hasMoreTokens()) {</span>
<span class="nc" id="L1427">      tokCol = new StringTokenizer(tokRow.nextToken(), &quot; &quot;);</span>
<span class="nc" id="L1428">      cols   = 0;</span>
<span class="nc bnc" id="L1429" title="All 2 branches missed.">      while (tokCol.hasMoreTokens()) {</span>
<span class="nc" id="L1430">        result.set(rows, cols, Double.parseDouble(tokCol.nextToken()));</span>
<span class="nc" id="L1431">        cols++;</span>
      }
<span class="nc" id="L1433">      rows++;</span>
    }
    
<span class="nc" id="L1436">    return result;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1445">    return RevisionUtils.extract(&quot;$Revision: 1.8 $&quot;);</span>
  }
  
  /**
   * Main method for testing this class.
   */
  public static void main(String[] args) {
    Matrix        I;
    Matrix        A;
    Matrix        B;

    try {
      // Identity
<span class="nc" id="L1458">      System.out.println(&quot;\nIdentity\n&quot;);</span>
<span class="nc" id="L1459">      I = Matrix.identity(3, 5);</span>
<span class="nc" id="L1460">      System.out.println(&quot;I(3,5)\n&quot; + I);</span>
      
      // basic operations - square
<span class="nc" id="L1463">      System.out.println(&quot;\nbasic operations - square\n&quot;);</span>
<span class="nc" id="L1464">      A = Matrix.random(3, 3);</span>
<span class="nc" id="L1465">      B = Matrix.random(3, 3);</span>
<span class="nc" id="L1466">      System.out.println(&quot;A\n&quot; + A);</span>
<span class="nc" id="L1467">      System.out.println(&quot;B\n&quot; + B);</span>
<span class="nc" id="L1468">      System.out.println(&quot;A'\n&quot; + A.inverse());</span>
<span class="nc" id="L1469">      System.out.println(&quot;A^T\n&quot; + A.transpose());</span>
<span class="nc" id="L1470">      System.out.println(&quot;A+B\n&quot; + A.plus(B));</span>
<span class="nc" id="L1471">      System.out.println(&quot;A*B\n&quot; + A.times(B));</span>
<span class="nc" id="L1472">      System.out.println(&quot;X from A*X=B\n&quot; + A.solve(B));</span>

      // basic operations - non square
<span class="nc" id="L1475">      System.out.println(&quot;\nbasic operations - non square\n&quot;);</span>
<span class="nc" id="L1476">      A = Matrix.random(2, 3);</span>
<span class="nc" id="L1477">      B = Matrix.random(3, 4);</span>
<span class="nc" id="L1478">      System.out.println(&quot;A\n&quot; + A);</span>
<span class="nc" id="L1479">      System.out.println(&quot;B\n&quot; + B);</span>
<span class="nc" id="L1480">      System.out.println(&quot;A*B\n&quot; + A.times(B));</span>

      // sqrt
<span class="nc" id="L1483">      System.out.println(&quot;\nsqrt (1)\n&quot;);</span>
<span class="nc" id="L1484">      A = new Matrix(new double[][]{{5,-4,1,0,0},{-4,6,-4,1,0},{1,-4,6,-4,1},{0,1,-4,6,-4},{0,0,1,-4,5}});</span>
<span class="nc" id="L1485">      System.out.println(&quot;A\n&quot; + A);</span>
<span class="nc" id="L1486">      System.out.println(&quot;sqrt(A)\n&quot; + A.sqrt());</span>

      // sqrt
<span class="nc" id="L1489">      System.out.println(&quot;\nsqrt (2)\n&quot;);</span>
<span class="nc" id="L1490">      A = new Matrix(new double[][]{{7, 10},{15, 22}});</span>
<span class="nc" id="L1491">      System.out.println(&quot;A\n&quot; + A);</span>
<span class="nc" id="L1492">      System.out.println(&quot;sqrt(A)\n&quot; + A.sqrt());</span>
<span class="nc" id="L1493">      System.out.println(&quot;det(A)\n&quot; + A.det() + &quot;\n&quot;);</span>

      // eigenvalue decomp.
<span class="nc" id="L1496">      System.out.println(&quot;\nEigenvalue Decomposition\n&quot;);</span>
<span class="nc" id="L1497">      EigenvalueDecomposition evd = A.eig();</span>
<span class="nc" id="L1498">      System.out.println(&quot;[V,D] = eig(A)&quot;);</span>
<span class="nc" id="L1499">      System.out.println(&quot;- V\n&quot; + evd.getV());</span>
<span class="nc" id="L1500">      System.out.println(&quot;- D\n&quot; + evd.getD());</span>

      // LU decomp.
<span class="nc" id="L1503">      System.out.println(&quot;\nLU Decomposition\n&quot;);</span>
<span class="nc" id="L1504">      LUDecomposition lud = A.lu();</span>
<span class="nc" id="L1505">      System.out.println(&quot;[L,U,P] = lu(A)&quot;);</span>
<span class="nc" id="L1506">      System.out.println(&quot;- L\n&quot; + lud.getL());</span>
<span class="nc" id="L1507">      System.out.println(&quot;- U\n&quot; + lud.getU());</span>
<span class="nc" id="L1508">      System.out.println(&quot;- P\n&quot; + Utils.arrayToString(lud.getPivot()) + &quot;\n&quot;);</span>

      // regression
<span class="nc" id="L1511">      System.out.println(&quot;\nRegression\n&quot;);</span>
<span class="nc" id="L1512">      B = new Matrix(new double[][]{{3},{2}});</span>
<span class="nc" id="L1513">      double ridge = 0.5;</span>
<span class="nc" id="L1514">      double[] weights = new double[]{0.3, 0.7};</span>
<span class="nc" id="L1515">      LinearRegression lr = A.regression(B, ridge);</span>
<span class="nc" id="L1516">      System.out.println(&quot;A\n&quot; + A);</span>
<span class="nc" id="L1517">      System.out.println(&quot;B\n&quot; + B);</span>
<span class="nc" id="L1518">      System.out.println(&quot;ridge = &quot; + ridge + &quot;\n&quot;);</span>
<span class="nc" id="L1519">      System.out.println(&quot;weights = &quot; + Utils.arrayToString(weights) + &quot;\n&quot;);</span>
<span class="nc" id="L1520">      System.out.println(&quot;A.regression(B, ridge)\n&quot; </span>
<span class="nc" id="L1521">          + A.regression(B, ridge) + &quot;\n&quot;);</span>
<span class="nc" id="L1522">      System.out.println(&quot;A.regression(B, weights, ridge)\n&quot; </span>
<span class="nc" id="L1523">          + A.regression(B, weights, ridge) + &quot;\n&quot;);</span>

      // writer/reader
<span class="nc" id="L1526">      System.out.println(&quot;\nWriter/Reader\n&quot;);</span>
<span class="nc" id="L1527">      StringWriter writer = new StringWriter();</span>
<span class="nc" id="L1528">      A.write(writer);</span>
<span class="nc" id="L1529">      System.out.println(&quot;A.write(Writer)\n&quot; + writer);</span>
<span class="nc" id="L1530">      A = new Matrix(new StringReader(writer.toString()));</span>
<span class="nc" id="L1531">      System.out.println(&quot;A = new Matrix.read(Reader)\n&quot; + A);</span>

      // Matlab
<span class="nc" id="L1534">      System.out.println(&quot;\nMatlab-Format\n&quot;);</span>
<span class="nc" id="L1535">      String matlab = &quot;[ 1   2;3 4 ]&quot;;</span>
<span class="nc" id="L1536">      System.out.println(&quot;Matlab: &quot; + matlab);</span>
<span class="nc" id="L1537">      System.out.println(&quot;from Matlab:\n&quot; + Matrix.parseMatlab(matlab));</span>
<span class="nc" id="L1538">      System.out.println(&quot;to Matlab:\n&quot; + Matrix.parseMatlab(matlab).toMatlab());</span>
<span class="nc" id="L1539">      matlab = &quot;[1 2 3 4;3 4 5 6;7 8 9 10]&quot;;</span>
<span class="nc" id="L1540">      System.out.println(&quot;Matlab: &quot; + matlab);</span>
<span class="nc" id="L1541">      System.out.println(&quot;from Matlab:\n&quot; + Matrix.parseMatlab(matlab));</span>
<span class="nc" id="L1542">      System.out.println(&quot;to Matlab:\n&quot; + Matrix.parseMatlab(matlab).toMatlab() + &quot;\n&quot;);</span>
    }
<span class="nc" id="L1544">    catch (Exception e) {</span>
<span class="nc" id="L1545">      e.printStackTrace();</span>
    }
<span class="nc" id="L1547">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>