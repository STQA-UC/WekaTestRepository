<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MarginCalculator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.bayes.net</a> &gt; <span class="el_source">MarginCalculator.java</span></div><h1>MarginCalculator.java</h1><pre class="source lang-java linenums">package weka.classifiers.bayes.net;

import weka.classifiers.bayes.BayesNet;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;

import java.io.Serializable;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Vector;


<span class="nc" id="L14">public class MarginCalculator implements Serializable, RevisionHandler {</span>
	  /** for serialization */
	  private static final long serialVersionUID = 650278019241175534L;

<span class="nc" id="L18">	  boolean m_debug = false;</span>
<span class="nc" id="L19">	  public JunctionTreeNode m_root = null;</span>
	JunctionTreeNode [] jtNodes;

	public int getNode(String sNodeName) {
<span class="nc" id="L23">    	int iNode = 0;</span>
<span class="nc bnc" id="L24" title="All 2 branches missed.">    	while (iNode &lt; m_root.m_bayesNet.m_Instances.numAttributes()) {</span>
<span class="nc bnc" id="L25" title="All 2 branches missed.">    		if (m_root.m_bayesNet.m_Instances.attribute(iNode).name().equals(sNodeName)) {</span>
<span class="nc" id="L26">    			return iNode;</span>
    		}
<span class="nc" id="L28">	    	iNode++; </span>
    	}
    	//throw new Exception(&quot;Could not find node [[&quot; + sNodeName + &quot;]]&quot;);
<span class="nc" id="L31">    	return -1;</span>
	}
<span class="nc" id="L33">	public String toXMLBIF03() {return m_root.m_bayesNet.toXMLBIF03();}</span>
	
	/**
	 * Calc marginal distributions of nodes in Bayesian network
	 *	 Note that a connected network is assumed. 
	 *	 Unconnected networks may give unexpected results.
	 * @param bayesNet
	 * @return root of junction tree
	 */
	public void calcMargins(BayesNet bayesNet) throws Exception {
		//System.out.println(bayesNet.toString());
<span class="nc" id="L44">		boolean[][] bAdjacencyMatrix = moralize(bayesNet);</span>
<span class="nc" id="L45">		process(bAdjacencyMatrix, bayesNet);</span>
<span class="nc" id="L46">	} // calcMargins</span>

	public void calcFullMargins(BayesNet bayesNet) throws Exception {
		//System.out.println(bayesNet.toString());
<span class="nc" id="L50">		int nNodes = bayesNet.getNrOfNodes();</span>
<span class="nc" id="L51">		boolean[][] bAdjacencyMatrix = new boolean[nNodes][nNodes];</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">			for (int iNode2 = 0; iNode2 &lt; nNodes; iNode2++) {</span>
<span class="nc" id="L54">				bAdjacencyMatrix[iNode][iNode2] = true;</span>
			}
		}
<span class="nc" id="L57">		process(bAdjacencyMatrix, bayesNet);</span>
<span class="nc" id="L58">	} // calcMargins</span>
	
	
	public void process(boolean[][] bAdjacencyMatrix, BayesNet bayesNet) throws Exception {
<span class="nc" id="L62">		int[] order = getMaxCardOrder(bAdjacencyMatrix);</span>
<span class="nc" id="L63">		bAdjacencyMatrix = fillIn(order, bAdjacencyMatrix);</span>
<span class="nc" id="L64">		order = getMaxCardOrder(bAdjacencyMatrix);</span>
<span class="nc" id="L65">		Set [] cliques = getCliques(order, bAdjacencyMatrix);</span>
<span class="nc" id="L66">		Set [] separators = getSeparators(order, cliques);</span>
<span class="nc" id="L67">		int [] parentCliques = getCliqueTree(order, cliques, separators);</span>
		// report cliques
<span class="nc" id="L69">		int nNodes = bAdjacencyMatrix.length;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (m_debug) {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L72">			int iNode = order[i];</span>
<span class="nc bnc" id="L73" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc" id="L74">				System.out.print(&quot;Clique &quot; + iNode + &quot; (&quot;);</span>
<span class="nc" id="L75">				Iterator nodes = cliques[iNode].iterator();</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">				while (nodes.hasNext()) {</span>
<span class="nc" id="L77">					int iNode2 = (Integer) nodes.next();</span>
<span class="nc" id="L78">					System.out.print(iNode2 + &quot; &quot; + bayesNet.getNodeName(iNode2));</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">					if (nodes.hasNext()) {</span>
<span class="nc" id="L80">						System.out.print(&quot;,&quot;);</span>
					}
				}
<span class="nc" id="L83">				System.out.print(&quot;) S(&quot;);</span>
<span class="nc" id="L84">				nodes = separators[iNode].iterator();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">				while (nodes.hasNext()) {</span>
<span class="nc" id="L86">					int iNode2 = (Integer) nodes.next();</span>
<span class="nc" id="L87">					System.out.print(iNode2 + &quot; &quot; + bayesNet.getNodeName(iNode2));</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">					if (nodes.hasNext()) {</span>
<span class="nc" id="L89">						System.out.print(&quot;,&quot;);</span>
					}
				}
<span class="nc" id="L92">				System.out.println(&quot;) parent clique &quot; + parentCliques[iNode]);</span>
			}		
		}
		}
				
<span class="nc" id="L97">		jtNodes = getJunctionTree(cliques, separators, parentCliques, order, bayesNet);</span>
<span class="nc" id="L98">		m_root = null;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc bnc" id="L100" title="All 4 branches missed.">			if (parentCliques[iNode] &lt; 0 &amp;&amp; jtNodes[iNode] != null) {</span>
<span class="nc" id="L101">				m_root = jtNodes[iNode];</span>
<span class="nc" id="L102">				break;</span>
			}
		}
<span class="nc" id="L105">		m_Margins = new double[nNodes][];</span>
<span class="nc" id="L106">		initialize(jtNodes, order, cliques, separators, parentCliques);</span>
		
		// sanity check
<span class="nc bnc" id="L109" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L110">			int iNode = order[i];</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">				if (parentCliques[iNode] == -1 &amp;&amp; separators[iNode].size() &gt; 0) {</span>
<span class="nc" id="L113">					throw new Exception(&quot;Something wrong in clique tree&quot;);</span>
				}
			}
		}
		if (m_debug) {
			//System.out.println(m_root.toString());
		}
<span class="nc" id="L120">	} // process</span>
		
	void initialize(JunctionTreeNode [] jtNodes, int [] order, Set [] cliques, Set [] separators, int [] parentCliques) {
<span class="nc" id="L123">		int nNodes = order.length;</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">		for (int i = nNodes - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L125">			int iNode = order[i];</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">			if (jtNodes[iNode]!=null) {</span>
<span class="nc" id="L127">				jtNodes[iNode].initializeUp();</span>
			}
		}	
<span class="nc bnc" id="L130" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L131">			int iNode = order[i];</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			if (jtNodes[iNode]!=null) {</span>
<span class="nc" id="L133">				jtNodes[iNode].initializeDown(false);</span>
			}
		}	
<span class="nc" id="L136">	} // initialize</span>
	
	JunctionTreeNode [] getJunctionTree(Set [] cliques, Set [] separators, int [] parentCliques, int [] order, BayesNet bayesNet) {
<span class="nc" id="L139">		int nNodes = order.length;</span>
<span class="nc" id="L140">		JunctionTreeNode root = null;</span>
<span class="nc" id="L141">		JunctionTreeNode [] jtns = new JunctionTreeNode[nNodes]; </span>
<span class="nc" id="L142">		boolean [] bDone = new boolean[nNodes];</span>
		// create junction tree nodes
<span class="nc bnc" id="L144" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L145">			int iNode = order[i];</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc" id="L147">				jtns[iNode] = new JunctionTreeNode(cliques[iNode], bayesNet, bDone);</span>
			}
		}
		// create junction tree separators
<span class="nc bnc" id="L151" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L152">			int iNode = order[i];</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc" id="L154">				JunctionTreeNode parent = null;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">				if (parentCliques[iNode] &gt; 0) {</span>
<span class="nc" id="L156">					parent = jtns[parentCliques[iNode]];</span>
<span class="nc" id="L157">					JunctionTreeSeparator jts = new JunctionTreeSeparator(separators[iNode], bayesNet, jtns[iNode], parent);</span>
<span class="nc" id="L158">					jtns[iNode].setParentSeparator(jts);</span>
<span class="nc" id="L159">					jtns[parentCliques[iNode]].addChildClique(jtns[iNode]);</span>
				} else {
<span class="nc" id="L161">					root = jtns[iNode];	</span>
				}
			}
		}
<span class="nc" id="L165">		return jtns;</span>
	} // getJunctionTree
	
	public class JunctionTreeSeparator implements Serializable, RevisionHandler {
	  
		  private static final long serialVersionUID = 6502780192411755343L;
		int [] m_nNodes;
		int m_nCardinality;
		double [] m_fiParent;
		double [] m_fiChild;
		JunctionTreeNode m_parentNode;
		JunctionTreeNode m_childNode;
		BayesNet m_bayesNet;
		
<span class="nc" id="L179">		JunctionTreeSeparator(Set separator, BayesNet bayesNet, JunctionTreeNode childNode, JunctionTreeNode parentNode) {</span>
			//////////////////////
			// initialize node set
<span class="nc" id="L182">			m_nNodes = new int[separator.size()];</span>
<span class="nc" id="L183">			int iPos = 0;</span>
<span class="nc" id="L184">			m_nCardinality = 1;</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">			for(Iterator nodes = separator.iterator(); nodes.hasNext();) {</span>
<span class="nc" id="L186">				int iNode = (Integer) nodes.next();</span>
<span class="nc" id="L187">				m_nNodes[iPos++] = iNode;</span>
<span class="nc" id="L188">				m_nCardinality *= bayesNet.getCardinality(iNode);</span>
			}
<span class="nc" id="L190">			m_parentNode = parentNode;</span>
<span class="nc" id="L191">			m_childNode = childNode;</span>
<span class="nc" id="L192">			m_bayesNet = bayesNet;</span>
<span class="nc" id="L193">		} // c'tor</span>
		
		/** marginalize junciontTreeNode node over all nodes outside the separator set
		 * of the parent clique
		 *
		 */
		public void updateFromParent() {
<span class="nc" id="L200">			double [] fis = update(m_parentNode); </span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">			if (fis == null) {</span>
<span class="nc" id="L202">				m_fiParent = null;</span>
			} else {
<span class="nc" id="L204">				m_fiParent = fis;</span>
				// normalize
<span class="nc" id="L206">				double sum = 0;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L208">					sum += m_fiParent[iPos];</span>
				}
<span class="nc bnc" id="L210" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L211">					m_fiParent[iPos] /= sum;</span>
				}
			}
<span class="nc" id="L214">		} // updateFromParent</span>

		/** marginalize junciontTreeNode node over all nodes outside the separator set
		 * of the child clique
		 *
		 */
		public void updateFromChild() {
<span class="nc" id="L221">			double [] fis = update(m_childNode); </span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if (fis == null) {</span>
<span class="nc" id="L223">				m_fiChild = null;</span>
			} else {
<span class="nc" id="L225">				m_fiChild = fis;</span>
				// normalize
<span class="nc" id="L227">				double sum = 0;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L229">					sum += m_fiChild[iPos];</span>
				}
<span class="nc bnc" id="L231" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L232">					m_fiChild[iPos] /= sum;</span>
				}
			}
<span class="nc" id="L235">		} // updateFromChild</span>
		
		/** marginalize junciontTreeNode node over all nodes outside the separator set
		 * 
		 * @param node: one of the neighboring junciont tree nodes of this separator
		 */
		public double [] update(JunctionTreeNode node) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">			if (node.m_P == null) {</span>
<span class="nc" id="L243">				return null;</span>
			}
<span class="nc" id="L245">			double [] fi = new double[m_nCardinality];</span>

<span class="nc" id="L247">			int [] values = new int[node.m_nNodes.length];</span>
<span class="nc" id="L248">			int [] order = new int[m_bayesNet.getNrOfNodes()];</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; node.m_nNodes.length; iNode++) {</span>
<span class="nc" id="L250">				order[node.m_nNodes[iNode]] = iNode;</span>
			}
			// fill in the values
<span class="nc bnc" id="L253" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; node.m_nCardinality; iPos++) {</span>
<span class="nc" id="L254">				int iNodeCPT = getCPT(node.m_nNodes, node.m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L255">				int iSepCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L256">				fi[iSepCPT] += node.m_P[iNodeCPT];</span>
				// update values
<span class="nc" id="L258">				int i = 0;</span>
<span class="nc" id="L259">				values[i]++;</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">				while (i &lt; node.m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(node.m_nNodes[i])) {</span>
<span class="nc" id="L261">					values[i] = 0;</span>
<span class="nc" id="L262">					i++;</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">					if (i &lt; node.m_nNodes.length) {</span>
<span class="nc" id="L264">						values[i]++;</span>
					}
				}
			}
<span class="nc" id="L268">			return fi;</span>
		} // update
		  
		/**
		 * Returns the revision string.
		 * 
		 * @return		the revision
		 */
		public String getRevision() {
<span class="nc" id="L277">		  return RevisionUtils.extract(&quot;$Revision: 1.2 $&quot;);</span>
		}

	} // class JunctionTreeSeparator

	public class JunctionTreeNode implements Serializable, RevisionHandler {
	  
		  private static final long serialVersionUID = 650278019241175536L;
		/** reference Bayes net for information about variables like name, cardinality, etc.
		 * but not for relations between nodes **/
		BayesNet m_bayesNet;
		/** nodes of the Bayes net in this junction node **/
		public int [] m_nNodes;
		/** cardinality of the instances of variables in this junction node **/
		int m_nCardinality;
		/** potentials for first network **/
		double [] m_fi;

		/** distribution over this junction node according to first Bayes network **/
		double [] m_P;


		double [][] m_MarginalP;		

		
		JunctionTreeSeparator m_parentSeparator;
<span class="nc" id="L303">		public void setParentSeparator(JunctionTreeSeparator parentSeparator) {m_parentSeparator = parentSeparator;}</span>
		public Vector m_children;
<span class="nc" id="L305">		public void addChildClique(JunctionTreeNode child) {m_children.add(child);}</span>

		public void initializeUp() {
<span class="nc" id="L308">			m_P = new double[m_nCardinality];</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L310">				m_P[iPos] = m_fi[iPos];</span>
			}
<span class="nc" id="L312">			int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L313">			int [] order = new int[m_bayesNet.getNrOfNodes()];</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L315">				order[m_nNodes[iNode]] = iNode;</span>
			}
<span class="nc bnc" id="L317" title="All 2 branches missed.">			for (Iterator child = m_children.iterator(); child.hasNext(); ) {</span>
<span class="nc" id="L318">				JunctionTreeNode childNode = (JunctionTreeNode) child.next();</span>
<span class="nc" id="L319">				JunctionTreeSeparator separator = childNode.m_parentSeparator;</span>
			// Update the values
<span class="nc bnc" id="L321" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L322">				int iSepCPT = getCPT(separator.m_nNodes, separator.m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L323">				int iNodeCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L324">					m_P[iNodeCPT] *= separator.m_fiChild[iSepCPT];					</span>
				// update values
<span class="nc" id="L326">				int i = 0;</span>
<span class="nc" id="L327">				values[i]++;</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">				while (i &lt; m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L329">					values[i] = 0;</span>
<span class="nc" id="L330">					i++;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">					if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L332">						values[i]++;</span>
					}
				}
			}
			}
			// normalize
<span class="nc" id="L338">			double sum = 0;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L340">				sum += m_P[iPos];</span>
			}
<span class="nc bnc" id="L342" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L343">				m_P[iPos] /= sum;</span>
			}

<span class="nc bnc" id="L346" title="All 2 branches missed.">			if (m_parentSeparator != null) { // not a root node</span>
<span class="nc" id="L347">				m_parentSeparator.updateFromChild();</span>
			}
<span class="nc" id="L349">		} // initializeUp</span>

		public void initializeDown(boolean recursively) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">			if (m_parentSeparator == null) { // a root node</span>
<span class="nc" id="L353">				calcMarginalProbabilities();</span>
			} else {
<span class="nc" id="L355">			m_parentSeparator.updateFromParent();</span>
<span class="nc" id="L356">				int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L357">				int [] order = new int[m_bayesNet.getNrOfNodes()];</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">				for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L359">					order[m_nNodes[iNode]] = iNode;</span>
				}

				
				// Update the values
<span class="nc bnc" id="L364" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L365">					int iSepCPT = getCPT(m_parentSeparator.m_nNodes, m_parentSeparator.m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L366">					int iNodeCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">					if ( m_parentSeparator.m_fiChild[iSepCPT] &gt; 0) {</span>
<span class="nc" id="L368">						m_P[iNodeCPT] *= m_parentSeparator.m_fiParent[iSepCPT] / m_parentSeparator.m_fiChild[iSepCPT];</span>
					} else {
<span class="nc" id="L370">						m_P[iNodeCPT] = 0;</span>
					}
					// update values
<span class="nc" id="L373">					int i = 0;</span>
<span class="nc" id="L374">					values[i]++;</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">					while (i &lt; m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L376">						values[i] = 0;</span>
<span class="nc" id="L377">						i++;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">						if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L379">							values[i]++;</span>
						}
					}
				}
				// normalize
<span class="nc" id="L384">				double sum = 0;</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L386">					sum += m_P[iPos];</span>
				}
<span class="nc bnc" id="L388" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L389">					m_P[iPos] /= sum;</span>
				}
<span class="nc" id="L391">				m_parentSeparator.updateFromChild();</span>
<span class="nc" id="L392">				calcMarginalProbabilities();</span>
			}
<span class="nc bnc" id="L394" title="All 2 branches missed.">			if (recursively) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">				for (Iterator child = m_children.iterator(); child.hasNext(); ) {</span>
<span class="nc" id="L396">					JunctionTreeNode childNode = (JunctionTreeNode) child.next();</span>
<span class="nc" id="L397">					childNode.initializeDown(true);</span>
				}			
			}
<span class="nc" id="L400">		} // initializeDown</span>
		
		
		/** calculate marginal probabilities for the individual nodes in the clique.
		 * Store results in m_MarginalP 
		 */
		void calcMarginalProbabilities() {			
			// calculate marginal probabilities
<span class="nc" id="L408">			int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L409">			int [] order = new int[m_bayesNet.getNrOfNodes()];</span>
<span class="nc" id="L410">			m_MarginalP = new double[m_nNodes.length][];</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L412">				order[m_nNodes[iNode]] = iNode;</span>
<span class="nc" id="L413">				m_MarginalP[iNode]=new double[m_bayesNet.getCardinality(m_nNodes[iNode])];</span>
			}
<span class="nc bnc" id="L415" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L416">				int iNodeCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">				for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L418">					m_MarginalP[iNode][values[iNode]] += m_P[iNodeCPT];</span>
				}
				// update values
<span class="nc" id="L421">				int i = 0;</span>
<span class="nc" id="L422">				values[i]++;</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">				while (i &lt; m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L424">					values[i] = 0;</span>
<span class="nc" id="L425">					i++;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">					if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L427">						values[i]++;</span>
					}
				}
			}
			
<span class="nc bnc" id="L432" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L433">				m_Margins[m_nNodes[iNode]] = m_MarginalP[iNode]; </span>
			}
<span class="nc" id="L435">		} // calcMarginalProbabilities</span>
		
		public String toString() {
<span class="nc" id="L438">			StringBuffer buf = new StringBuffer();</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L440">				buf.append(m_bayesNet.getNodeName(m_nNodes[iNode]) + &quot;: &quot;);</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">				for (int iValue = 0; iValue &lt; m_MarginalP[iNode].length; iValue++) {</span>
<span class="nc" id="L442">					buf.append(m_MarginalP[iNode][iValue] + &quot; &quot;);</span>
				}
<span class="nc" id="L444">				buf.append('\n');</span>
			}
<span class="nc bnc" id="L446" title="All 2 branches missed.">			for (Iterator child = m_children.iterator(); child.hasNext(); ) {</span>
<span class="nc" id="L447">				JunctionTreeNode childNode = (JunctionTreeNode) child.next();</span>
<span class="nc" id="L448">				buf.append(&quot;----------------\n&quot;);</span>
<span class="nc" id="L449">				buf.append(childNode.toString());</span>
			}			
<span class="nc" id="L451">			return buf.toString();</span>
		} // toString
		
		void calculatePotentials(BayesNet bayesNet, Set clique, boolean [] bDone) {
<span class="nc" id="L455">			m_fi = new double[m_nCardinality];</span>
			
<span class="nc" id="L457">			int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L458">			int [] order = new int[bayesNet.getNrOfNodes()];</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L460">				order[m_nNodes[iNode]] = iNode;</span>
			}
			// find conditional probabilities that need to be taken in account
<span class="nc" id="L463">			boolean [] bIsContained = new boolean[m_nNodes.length];</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L465">				int nNode = m_nNodes[iNode];</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">				bIsContained[iNode] = !bDone[nNode];</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">				for (int iParent = 0; iParent &lt; bayesNet.getNrOfParents(nNode); iParent++) {</span>
<span class="nc" id="L468">					int nParent = bayesNet.getParent(nNode, iParent);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">					if (!clique.contains(nParent)) {</span>
<span class="nc" id="L470">						bIsContained[iNode] = false;</span>
					}
				}
<span class="nc bnc" id="L473" title="All 2 branches missed.">				if (bIsContained[iNode]) {</span>
<span class="nc" id="L474">					bDone[nNode] = true;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">					if (m_debug) {</span>
<span class="nc" id="L476">						System.out.println(&quot;adding node &quot; +nNode);</span>
					}
				}
			}			

			// fill in the values
<span class="nc bnc" id="L482" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L483">				int iCPT = getCPT(m_nNodes, m_nNodes.length, values, order, bayesNet);</span>
<span class="nc" id="L484">				m_fi[iCPT] = 1.0;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">				for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">					if (bIsContained[iNode]) {</span>
<span class="nc" id="L487">						int nNode = m_nNodes[iNode];</span>
<span class="nc" id="L488">						int [] nNodes = bayesNet.getParentSet(nNode).getParents();</span>
<span class="nc" id="L489">						int iCPT2 = getCPT(nNodes, bayesNet.getNrOfParents(nNode), values, order, bayesNet);</span>
<span class="nc" id="L490">						double f = bayesNet.getDistributions()[nNode][iCPT2].getProbability(values[iNode]);</span>
<span class="nc" id="L491">						m_fi[iCPT] *= f;</span>
					}
				}
				
				// update values
<span class="nc" id="L496">				int i = 0;</span>
<span class="nc" id="L497">				values[i]++;</span>
<span class="nc bnc" id="L498" title="All 4 branches missed.">				while (i &lt; m_nNodes.length &amp;&amp; values[i] == bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L499">					values[i] = 0;</span>
<span class="nc" id="L500">					i++;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">					if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L502">						values[i]++;</span>
					}
				}
			}
<span class="nc" id="L506">		} // calculatePotentials</span>

<span class="nc" id="L508">		JunctionTreeNode(Set clique, BayesNet bayesNet, boolean [] bDone) {</span>
<span class="nc" id="L509">			m_bayesNet = bayesNet;</span>
<span class="nc" id="L510">			m_children = new Vector();</span>
			//////////////////////
			// initialize node set
<span class="nc" id="L513">			m_nNodes = new int[clique.size()];</span>
<span class="nc" id="L514">			int iPos = 0;</span>
<span class="nc" id="L515">			m_nCardinality = 1;</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">			for(Iterator nodes = clique.iterator(); nodes.hasNext();) {</span>
<span class="nc" id="L517">				int iNode = (Integer) nodes.next();</span>
<span class="nc" id="L518">				m_nNodes[iPos++] = iNode;</span>
<span class="nc" id="L519">				m_nCardinality *= bayesNet.getCardinality(iNode);</span>
			}
			////////////////////////////////
			// initialize potential function
<span class="nc" id="L523">			calculatePotentials(bayesNet, clique, bDone);</span>
<span class="nc" id="L524">       } // JunctionTreeNode c'tor</span>

		/* check whether this junciton tree node contains node nNode
		 * 
		 */
		boolean contains(int nNode) {
<span class="nc bnc" id="L530" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">				if (m_nNodes[iNode]== nNode){</span>
<span class="nc" id="L532">					return true;</span>
				}
			}
<span class="nc" id="L535">			return false;</span>
		} // contains
		
		public void setEvidence(int nNode, int iValue) throws Exception {
<span class="nc" id="L539">			int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L540">			int [] order = new int[m_bayesNet.getNrOfNodes()];</span>

<span class="nc" id="L542">			int nNodeIdx = -1;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">			for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L544">				order[m_nNodes[iNode]] = iNode;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				if (m_nNodes[iNode] == nNode) {</span>
<span class="nc" id="L546">					nNodeIdx = iNode;</span>
				}
			}
<span class="nc bnc" id="L549" title="All 2 branches missed.">			if (nNodeIdx &lt; 0) {</span>
<span class="nc" id="L550">				throw new Exception(&quot;setEvidence: Node &quot; + nNode + &quot; not found in this clique&quot;);</span>
			}
<span class="nc bnc" id="L552" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">				if (values[nNodeIdx] != iValue) {</span>
<span class="nc" id="L554">					int iNodeCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L555">					m_P[iNodeCPT] = 0;</span>
				}
				// update values
<span class="nc" id="L558">				int i = 0;</span>
<span class="nc" id="L559">				values[i]++;</span>
<span class="nc bnc" id="L560" title="All 4 branches missed.">				while (i &lt; m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L561">					values[i] = 0;</span>
<span class="nc" id="L562">					i++;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">					if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L564">						values[i]++;</span>
					}
				}
			}		
			// normalize
<span class="nc" id="L569">			double sum = 0;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L571">				sum += m_P[iPos];</span>
			}
<span class="nc bnc" id="L573" title="All 2 branches missed.">			for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L574">				m_P[iPos] /= sum;</span>
			}
<span class="nc" id="L576">			calcMarginalProbabilities();</span>
<span class="nc" id="L577">			updateEvidence(this);</span>
<span class="nc" id="L578">		} // setEvidence</span>

		void updateEvidence(JunctionTreeNode source) {
<span class="nc bnc" id="L581" title="All 2 branches missed.">			if (source != this) {</span>
<span class="nc" id="L582">				int [] values = new int[m_nNodes.length];</span>
<span class="nc" id="L583">				int [] order = new int[m_bayesNet.getNrOfNodes()];</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">				for (int iNode = 0; iNode &lt; m_nNodes.length; iNode++) {</span>
<span class="nc" id="L585">					order[m_nNodes[iNode]] = iNode;</span>
				}
<span class="nc" id="L587">				int [] nChildNodes = source.m_parentSeparator.m_nNodes;</span>
<span class="nc" id="L588">				int nNumChildNodes = nChildNodes.length; </span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L590">					int iNodeCPT =  getCPT(m_nNodes, m_nNodes.length, values, order, m_bayesNet);</span>
<span class="nc" id="L591">					int iChildCPT =  getCPT(nChildNodes, nNumChildNodes, values, order, m_bayesNet);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">					if (source.m_parentSeparator.m_fiParent[iChildCPT] != 0) {</span>
<span class="nc" id="L593">						m_P[iNodeCPT] *= source.m_parentSeparator.m_fiChild[iChildCPT]/source.m_parentSeparator.m_fiParent[iChildCPT];</span>
					} else {
<span class="nc" id="L595">						m_P[iNodeCPT] = 0;</span>
					}
					// update values
<span class="nc" id="L598">					int i = 0;</span>
<span class="nc" id="L599">					values[i]++;</span>
<span class="nc bnc" id="L600" title="All 4 branches missed.">					while (i &lt; m_nNodes.length &amp;&amp; values[i] == m_bayesNet.getCardinality(m_nNodes[i])) {</span>
<span class="nc" id="L601">						values[i] = 0;</span>
<span class="nc" id="L602">						i++;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">						if (i &lt; m_nNodes.length) {</span>
<span class="nc" id="L604">							values[i]++;</span>
						}
					}
				}		
				// normalize
<span class="nc" id="L609">				double sum = 0;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L611">					sum += m_P[iPos];</span>
				}
<span class="nc bnc" id="L613" title="All 2 branches missed.">				for (int iPos = 0; iPos &lt; m_nCardinality; iPos++) {</span>
<span class="nc" id="L614">					m_P[iPos] /= sum;</span>
				}
<span class="nc" id="L616">				calcMarginalProbabilities();</span>
			}
<span class="nc bnc" id="L618" title="All 2 branches missed.">			for (Iterator child = m_children.iterator(); child.hasNext(); ) {</span>
<span class="nc" id="L619">				JunctionTreeNode childNode = (JunctionTreeNode) child.next();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">				if (childNode != source) {</span>
<span class="nc" id="L621">					childNode.initializeDown(true);</span>
				}
			}			
<span class="nc bnc" id="L624" title="All 2 branches missed.">			if (m_parentSeparator != null) {</span>
<span class="nc" id="L625">				m_parentSeparator.updateFromChild();</span>
<span class="nc" id="L626">				m_parentSeparator.m_parentNode.updateEvidence(this);</span>
<span class="nc" id="L627">				m_parentSeparator.updateFromParent();</span>
			}
<span class="nc" id="L629">		} // updateEvidence</span>

		/**
		 * Returns the revision string.
		 * 
		 * @return		the revision
		 */
		public String getRevision() {
<span class="nc" id="L637">		  return RevisionUtils.extract(&quot;$Revision: 1.2 $&quot;);</span>
		}
		
	} // class JunctionTreeNode

	int getCPT(int [] nodeSet, int nNodes, int[] values, int[] order, BayesNet bayesNet) {
<span class="nc" id="L643">		int iCPTnew = 0;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc" id="L645">			int nNode = nodeSet[iNode];</span>
<span class="nc" id="L646">			iCPTnew = iCPTnew * bayesNet.getCardinality(nNode);</span>
<span class="nc" id="L647">			iCPTnew += values[order[nNode]];</span>
		}
<span class="nc" id="L649">		return iCPTnew;</span>
	} // getCPT

	int [] getCliqueTree(int [] order, Set [] cliques, Set [] separators) {
<span class="nc" id="L653">		int nNodes = order.length;</span>
<span class="nc" id="L654">		int [] parentCliques = new int[nNodes];</span>
		//for (int i = nNodes - 1; i &gt;= 0; i--) {
<span class="nc bnc" id="L656" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L657">			int iNode = order[i];</span>
<span class="nc" id="L658">			parentCliques[iNode] = -1;</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">			if (cliques[iNode] != null &amp;&amp; separators[iNode].size() &gt; 0) {</span>
				//for (int j = nNodes - 1; j &gt; i; j--) {
<span class="nc bnc" id="L661" title="All 2 branches missed.">				for (int j = 0; j &lt; nNodes; j++) {</span>
<span class="nc" id="L662">					int iNode2 = order[j];</span>
<span class="nc bnc" id="L663" title="All 6 branches missed.">					if (iNode!= iNode2 &amp;&amp; cliques[iNode2] != null &amp;&amp; cliques[iNode2].containsAll(separators[iNode])) {</span>
<span class="nc" id="L664">						parentCliques[iNode] = iNode2;</span>
<span class="nc" id="L665">						j = i;</span>
<span class="nc" id="L666">						j = 0;</span>
<span class="nc" id="L667">						j = nNodes;</span>
					}
				}
				
			}
		}
<span class="nc" id="L673">		return parentCliques;</span>
	} // getCliqueTree
	
	/** calculate separator sets in clique tree
	 * 
	 * @param order: maximum cardinality ordering of the graph
	 * @param cliques: set of cliques
	 * @return set of separator sets
	 */
	Set [] getSeparators(int [] order, Set [] cliques) {
<span class="nc" id="L683">		int nNodes = order.length;</span>
<span class="nc" id="L684">		Set [] separators = new HashSet[nNodes];</span>
<span class="nc" id="L685">		Set processedNodes = new HashSet(); </span>
		//for (int i = nNodes - 1; i &gt;= 0; i--) {
<span class="nc bnc" id="L687" title="All 2 branches missed.">		for (int i = 0; i &lt; nNodes; i++) {</span>
<span class="nc" id="L688">			int iNode = order[i];</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc" id="L690">				Set separator = new HashSet();</span>
<span class="nc" id="L691">				separator.addAll(cliques[iNode]);</span>
<span class="nc" id="L692">				separator.retainAll(processedNodes);</span>
<span class="nc" id="L693">				separators[iNode] = separator;</span>
<span class="nc" id="L694">				processedNodes.addAll(cliques[iNode]);</span>
			}
		}
<span class="nc" id="L697">		return separators;</span>
	} // getSeparators
	
	/**
	 * get cliques in a decomposable graph represented by an adjacency matrix
	 * 
	 * @param order: maximum cardinality ordering of the graph
	 * @param bAdjacencyMatrix: decomposable graph
	 * @return set of cliques
	 */
	Set [] getCliques(int[] order, boolean[][] bAdjacencyMatrix) throws Exception {
<span class="nc" id="L708">		int nNodes = bAdjacencyMatrix.length;</span>
<span class="nc" id="L709">		Set [] cliques = new HashSet[nNodes];</span>
		//int[] inverseOrder = new int[nNodes];
		//for (int iNode = 0; iNode &lt; nNodes; iNode++) {
			//inverseOrder[order[iNode]] = iNode;
		//}
		// consult nodes in reverse order
<span class="nc bnc" id="L715" title="All 2 branches missed.">		for (int i = nNodes - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L716">			int iNode = order[i];</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">			if (iNode == 22) {</span>
<span class="nc" id="L718">				int h = 3;</span>
<span class="nc" id="L719">				h ++;</span>
			}
<span class="nc" id="L721">			Set clique = new HashSet();</span>
<span class="nc" id="L722">			clique.add(iNode);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">			for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L724">				int iNode2 = order[j];</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">				if (bAdjacencyMatrix[iNode][iNode2]) {</span>
<span class="nc" id="L726">					clique.add(iNode2);</span>
				}
			}
			
			//for (int iNode2 = 0; iNode2 &lt; nNodes; iNode2++) {
				//if (bAdjacencyMatrix[iNode][iNode2] &amp;&amp; inverseOrder[iNode2] &lt; inverseOrder[iNode]) {
					//clique.add(iNode2);
				//}
			//}
<span class="nc" id="L735">			cliques[iNode] = clique;</span>
		}
<span class="nc bnc" id="L737" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">			for (int iNode2 = 0; iNode2 &lt; nNodes; iNode2++) {</span>
<span class="nc bnc" id="L739" title="All 8 branches missed.">				if (iNode != iNode2 &amp;&amp; cliques[iNode]!= null &amp;&amp; cliques[iNode2]!= null &amp;&amp; cliques[iNode].containsAll(cliques[iNode2])) {</span>
<span class="nc" id="L740">					cliques[iNode2] = null;</span>
				}
			}
		}		
		// sanity check
<span class="nc bnc" id="L745" title="All 2 branches missed.">		if (m_debug) {</span>
<span class="nc" id="L746">		int [] nNodeSet = new int[nNodes];</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">			if (cliques[iNode] != null) {</span>
<span class="nc" id="L749">				Iterator it = cliques[iNode].iterator();</span>
<span class="nc" id="L750">				int k = 0;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">				while (it.hasNext()) {</span>
<span class="nc" id="L752">					nNodeSet[k++] = (Integer) it.next();</span>
				}
<span class="nc bnc" id="L754" title="All 2 branches missed.">				for (int i = 0; i &lt; cliques[iNode].size(); i++) {</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">					for (int j = 0; j &lt; cliques[iNode].size(); j++) {</span>
<span class="nc bnc" id="L756" title="All 4 branches missed.">						if (i!=j &amp;&amp; !bAdjacencyMatrix[nNodeSet[i]][nNodeSet[j]]) {</span>
<span class="nc" id="L757">							throw new Exception(&quot;Non clique&quot; + i + &quot; &quot; + j);</span>
						}
					}
				}
			}
		}
		}
<span class="nc" id="L764">		return cliques;</span>
	} // getCliques

	/**
	 * moralize DAG and calculate
	 * adjacency matrix representation for a Bayes Network, effecively
	 * converting the directed acyclic graph to an undirected graph.
	 * 
	 * @param bayesNet:
	 *            Bayes Network to process
	 * @return adjacencies in boolean matrix format
	 */
	public boolean[][] moralize(BayesNet bayesNet) {
<span class="nc" id="L777">		int nNodes = bayesNet.getNrOfNodes();</span>
<span class="nc" id="L778">		boolean[][] bAdjacencyMatrix = new boolean[nNodes][nNodes];</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc" id="L780">			ParentSet parents = bayesNet.getParentSets()[iNode];</span>
<span class="nc" id="L781">			moralizeNode(parents, iNode, bAdjacencyMatrix);</span>
		}
<span class="nc" id="L783">		return bAdjacencyMatrix;</span>
	} // moralize

	private void moralizeNode(ParentSet parents, int iNode, boolean[][] bAdjacencyMatrix) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">		for (int iParent = 0; iParent &lt; parents.getNrOfParents(); iParent++) {</span>
<span class="nc" id="L788">			int nParent = parents.getParent(iParent);</span>
<span class="nc bnc" id="L789" title="All 4 branches missed.">			if ( m_debug &amp;&amp; !bAdjacencyMatrix[iNode][nParent])</span>
<span class="nc" id="L790">				System.out.println(&quot;Insert &quot; + iNode + &quot;--&quot; + nParent);</span>
<span class="nc" id="L791">			bAdjacencyMatrix[iNode][nParent] = true;</span>
<span class="nc" id="L792">			bAdjacencyMatrix[nParent][iNode] = true;</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">			for (int iParent2 = iParent + 1; iParent2 &lt; parents.getNrOfParents(); iParent2++) {</span>
<span class="nc" id="L794">				int nParent2 = parents.getParent(iParent2);</span>
<span class="nc bnc" id="L795" title="All 4 branches missed.">				if (m_debug &amp;&amp; !bAdjacencyMatrix[nParent2][nParent])</span>
<span class="nc" id="L796">					System.out.println(&quot;Mary &quot; + nParent + &quot;--&quot; + nParent2);</span>
<span class="nc" id="L797">				bAdjacencyMatrix[nParent2][nParent] = true;</span>
<span class="nc" id="L798">				bAdjacencyMatrix[nParent][nParent2] = true;</span>
			}
		}	
<span class="nc" id="L801">	} // moralizeNode</span>
	
	/**
	 * Apply Tarjan and Yannakakis (1984) fill in algorithm for graph
	 * triangulation. In reverse order, insert edges between any non-adjacent
	 * neighbors that are lower numbered in the ordering.
	 * 
	 * Side effect: input matrix is used as output
	 * 
	 * @param order:
	 *            node ordering
	 * @param bAdjacencyMatrix:
	 *            boolean matrix representing the graph
	 * @return boolean matrix representing the graph with fill ins
	 */
	public boolean[][] fillIn(int[] order, boolean[][] bAdjacencyMatrix) {
<span class="nc" id="L817">		int nNodes = bAdjacencyMatrix.length;</span>
<span class="nc" id="L818">		int[] inverseOrder = new int[nNodes];</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">		for (int iNode = 0; iNode &lt; nNodes; iNode++) {</span>
<span class="nc" id="L820">			inverseOrder[order[iNode]] = iNode;</span>
		}
		// consult nodes in reverse order
<span class="nc bnc" id="L823" title="All 2 branches missed.">		for (int i = nNodes - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L824">			int iNode = order[i];</span>
			// find pairs of neighbors with lower order
<span class="nc bnc" id="L826" title="All 2 branches missed.">			for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L827">				int iNode2 = order[j];</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">				if (bAdjacencyMatrix[iNode][iNode2]) {</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">					for (int k = j+1; k &lt; i; k++) {</span>
<span class="nc" id="L830">						int iNode3 = order[k];</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">						if (bAdjacencyMatrix[iNode][iNode3]) {</span>
							// fill in
<span class="nc bnc" id="L833" title="All 6 branches missed.">							if (m_debug &amp;&amp; (!bAdjacencyMatrix[iNode2][iNode3] || !bAdjacencyMatrix[iNode3][iNode2]) )</span>
<span class="nc" id="L834">								System.out.println(&quot;Fill in &quot; + iNode2 + &quot;--&quot; + iNode3);</span>
<span class="nc" id="L835">							bAdjacencyMatrix[iNode2][iNode3] = true;</span>
<span class="nc" id="L836">							bAdjacencyMatrix[iNode3][iNode2] = true;</span>
						}
					}
				}
			}
		}
<span class="nc" id="L842">		return bAdjacencyMatrix;</span>
	} // fillIn

	/**
	 * calculate maximum cardinality ordering; start with first node add node
	 * that has most neighbors already ordered till all nodes are in the
	 * ordering
	 * 
	 * This implementation does not assume the graph is connected
	 * 
	 * @param bAdjacencyMatrix:
	 *            n by n matrix with adjacencies in graph of n nodes
	 * @return maximum cardinality ordering
	 */
	int[] getMaxCardOrder(boolean[][] bAdjacencyMatrix) {
<span class="nc" id="L857">		int nNodes = bAdjacencyMatrix.length;</span>
<span class="nc" id="L858">		int[] order = new int[nNodes];</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">		if (nNodes==0) {return order;}</span>
<span class="nc" id="L860">		boolean[] bDone = new boolean[nNodes];</span>
		// start with node 0
<span class="nc" id="L862">		order[0] = 0;</span>
<span class="nc" id="L863">		bDone[0] = true;</span>
		// order remaining nodes
<span class="nc bnc" id="L865" title="All 2 branches missed.">		for (int iNode = 1; iNode &lt; nNodes; iNode++) {</span>
<span class="nc" id="L866">			int nMaxCard = -1;</span>
<span class="nc" id="L867">			int iBestNode = -1;</span>
			// find node with higest cardinality of previously ordered nodes
<span class="nc bnc" id="L869" title="All 2 branches missed.">			for (int iNode2 = 0; iNode2 &lt; nNodes; iNode2++) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">				if (!bDone[iNode2]) {</span>
<span class="nc" id="L871">					int nCard = 0;</span>
					// calculate cardinality for node iNode2
<span class="nc bnc" id="L873" title="All 2 branches missed.">					for (int iNode3 = 0; iNode3 &lt; nNodes; iNode3++) {</span>
<span class="nc bnc" id="L874" title="All 4 branches missed.">						if (bAdjacencyMatrix[iNode2][iNode3] &amp;&amp; bDone[iNode3]) {</span>
<span class="nc" id="L875">							nCard++;</span>
						}
					}
<span class="nc bnc" id="L878" title="All 2 branches missed.">					if (nCard &gt; nMaxCard) {</span>
<span class="nc" id="L879">						nMaxCard = nCard;</span>
<span class="nc" id="L880">						iBestNode = iNode2;</span>
					}
				}
			}
<span class="nc" id="L884">			order[iNode] = iBestNode;</span>
<span class="nc" id="L885">			bDone[iBestNode] = true;</span>
		}
<span class="nc" id="L887">		return order;</span>
	} // getMaxCardOrder

	public void setEvidence(int nNode, int iValue) throws Exception {
<span class="nc bnc" id="L891" title="All 2 branches missed.">		if (m_root == null) {</span>
<span class="nc" id="L892">			throw new Exception(&quot;Junction tree not initialize yet&quot;);</span>
		}
<span class="nc" id="L894">		int iJtNode = 0;</span>
<span class="nc bnc" id="L895" title="All 6 branches missed.">		while (iJtNode &lt; jtNodes.length &amp;&amp; (jtNodes[iJtNode] == null ||!jtNodes[iJtNode].contains(nNode))) {</span>
<span class="nc" id="L896">			iJtNode++;</span>
		}
<span class="nc bnc" id="L898" title="All 2 branches missed.">		if (jtNodes.length == iJtNode) {</span>
<span class="nc" id="L899">			throw new Exception(&quot;Could not find node &quot; + nNode + &quot; in junction tree&quot;);</span>
		}
<span class="nc" id="L901">		jtNodes[iJtNode].setEvidence(nNode, iValue);</span>
<span class="nc" id="L902">	} // setEvidence</span>
	
	public String toString() {
<span class="nc" id="L905">		return m_root.toString();</span>
	} // toString

	double [][] m_Margins;
	public double [] getMargin(int iNode) {
<span class="nc" id="L910">		return m_Margins[iNode];</span>
	} // getMargin

	/**
	 * Returns the revision string.
	 * 
	 * @return		the revision
	 */
	public String getRevision() {
<span class="nc" id="L919">	  return RevisionUtils.extract(&quot;$Revision: 1.2 $&quot;);</span>
	}
	
	public static void main(String[] args) {
		try {
<span class="nc" id="L924">			BIFReader bayesNet = new BIFReader();</span>
<span class="nc" id="L925">			bayesNet.processFile(args[0]);</span>

<span class="nc" id="L927">			MarginCalculator dc = new MarginCalculator();</span>
<span class="nc" id="L928">			dc.calcMargins(bayesNet);</span>
<span class="nc" id="L929">			int iNode = 2;</span>
<span class="nc" id="L930">			int iValue = 0;</span>
<span class="nc" id="L931">			int iNode2 = 4;</span>
<span class="nc" id="L932">			int iValue2 = 0;</span>
<span class="nc" id="L933">			dc.setEvidence(iNode, iValue);</span>
<span class="nc" id="L934">			dc.setEvidence(iNode2, iValue2);</span>
<span class="nc" id="L935">			System.out.print(dc.toString());</span>


<span class="nc" id="L938">			dc.calcFullMargins(bayesNet);</span>
<span class="nc" id="L939">			dc.setEvidence(iNode, iValue);</span>
<span class="nc" id="L940">			dc.setEvidence(iNode2, iValue2);</span>
<span class="nc" id="L941">			System.out.println(&quot;==============&quot;);</span>
<span class="nc" id="L942">			System.out.print(dc.toString());</span>
			
			
<span class="nc" id="L945">		} catch (Exception e) {</span>
<span class="nc" id="L946">			e.printStackTrace();</span>
		}
<span class="nc" id="L948">	} // main</span>

} // class MarginCalculator
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>