<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>PaceMatrix.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.functions.pace</a> &gt; <span class="el_source">PaceMatrix.java</span></div><h1>PaceMatrix.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or (at
 *    your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful, but
 *    WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/*
 *    PaceMatrix.java
 *    Copyright (C) 2002 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.functions.pace;

import weka.core.RevisionUtils;
import weka.core.matrix.DoubleVector;
import weka.core.matrix.FlexibleDecimalFormat;
import weka.core.matrix.IntVector;
import weka.core.matrix.Matrix;
import weka.core.matrix.Maths;

import java.util.Random;
import java.text.DecimalFormat;

/**
 * Class for matrix manipulation used for pace regression. &lt;p&gt;
 *
 * REFERENCES &lt;p&gt;
 * 
 * Wang, Y. (2000). &quot;A new approach to fitting linear models in high
 * dimensional spaces.&quot; PhD Thesis. Department of Computer Science,
 * University of Waikato, New Zealand. &lt;p&gt;
 * 
 * Wang, Y. and Witten, I. H. (2002). &quot;Modeling for optimal probability
 * prediction.&quot; Proceedings of ICML'2002. Sydney. &lt;p&gt;
 *
 * @author Yong Wang (yongwang@cs.waikato.ac.nz)
 * @version $Revision: 1.6 $
 */
public class PaceMatrix 
  extends Matrix {
  
  /** for serialization */
  static final long serialVersionUID = 2699925616857843973L;
    
  /* ------------------------
     Constructors
     * ------------------------ */
  
  /** Construct an m-by-n PACE matrix of zeros. 
      @param m    Number of rows.
      @param n    Number of colums.
  */
  public PaceMatrix( int m, int n ) {
<span class="fc" id="L64">    super( m, n );</span>
<span class="fc" id="L65">  }</span>

  /** Construct an m-by-n constant PACE matrix.
      @param m    Number of rows.
      @param n    Number of colums.
      @param s    Fill the matrix with this scalar value.
  */
  public PaceMatrix( int m, int n, double s ) {
<span class="fc" id="L73">    super( m, n, s );</span>
<span class="fc" id="L74">  }</span>
    
  /** Construct a PACE matrix from a 2-D array.
      @param A    Two-dimensional array of doubles.
      @throws  IllegalArgumentException All rows must have the same length
  */
  public PaceMatrix( double[][] A ) {
<span class="fc" id="L81">    super( A );</span>
<span class="fc" id="L82">  }</span>

  /** Construct a PACE matrix quickly without checking arguments.
      @param A    Two-dimensional array of doubles.
      @param m    Number of rows.
      @param n    Number of colums.
  */
  public PaceMatrix( double[][] A, int m, int n ) {
<span class="nc" id="L90">    super( A, m, n );</span>
<span class="nc" id="L91">  }</span>
    
  /** Construct a PaceMatrix from a one-dimensional packed array
      @param vals One-dimensional array of doubles, packed by columns (ala Fortran).
      @param m    Number of rows.
      @throws  IllegalArgumentException Array length must be a multiple of m.
  */
  public PaceMatrix( double vals[], int m ) {
<span class="fc" id="L99">    super( vals, m );</span>
<span class="fc" id="L100">  }</span>
    
  /** Construct a PaceMatrix with a single column from a DoubleVector 
      @param v    DoubleVector
  */
  public PaceMatrix( DoubleVector v ) {
<span class="fc" id="L106">    this( v.size(), 1 );</span>
<span class="fc" id="L107">    setMatrix( 0, v.size()-1, 0, v );</span>
<span class="fc" id="L108">  }</span>
    
  /** Construct a PaceMatrix from a Matrix 
      @param X    Matrix 
  */
  public PaceMatrix( Matrix X ) {
<span class="fc" id="L114">    super( X.getRowDimension(), X.getColumnDimension() );</span>
<span class="fc" id="L115">    A = X.getArray();</span>
<span class="fc" id="L116">  }</span>
    
  /* ------------------------
     Public Methods
     * ------------------------ */

  /** Set the row dimenion of the matrix
   *  @param rowDimension the row dimension
   */
  public void setRowDimension( int rowDimension ) 
  {
<span class="nc" id="L127">    m = rowDimension;</span>
<span class="nc" id="L128">  }</span>

  /** Set the column dimenion of the matrix
   *  @param columnDimension the column dimension
   */
  public void setColumnDimension( int columnDimension ) 
  {
<span class="nc" id="L135">    n = columnDimension;</span>
<span class="nc" id="L136">  }</span>

  /** 
   * Clone the PaceMatrix object.
   * 
   * @return the clone
   */
  public Object clone () {
<span class="fc" id="L144">    PaceMatrix X = new PaceMatrix(m,n);</span>
<span class="fc" id="L145">    double[][] C = X.getArray();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L148">	C[i][j] = A[i][j];</span>
      }
    }
<span class="fc" id="L151">    return (Object) X;</span>
  }
    
  /** Add a value to an element and reset the element
   *  @param i    the row number of the element
   *  @param j    the column number of the element
   *  @param s    the double value to be added with
   */
  public void setPlus(int i, int j, double s) {
<span class="fc" id="L160">    A[i][j] += s;</span>
<span class="fc" id="L161">  }</span>

  /** Multiply a value with an element and reset the element
   *  @param i    the row number of the element
   *  @param j    the column number of the element
   *  @param s    the double value to be multiplied with
   */
  public void setTimes(int i, int j, double s) {
<span class="nc" id="L169">    A[i][j] *= s;</span>
<span class="nc" id="L170">  }</span>

  /** Set the submatrix A[i0:i1][j0:j1] with a same value 
   *  @param i0 the index of the first element of the column
   *  @param i1 the index of the last element of the column
   *  @param j0 the index of the first column
   *  @param j1 the index of the last column
   *  @param s the value to be set to
   */
  public void setMatrix( int i0, int i1, int j0, int j1, double s ) {
    try {
<span class="nc bnc" id="L181" title="All 2 branches missed.">      for( int i = i0; i &lt;= i1; i++ ) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">	for( int j = j0; j &lt;= j1; j++ ) {</span>
<span class="nc" id="L183">	  A[i][j] = s;</span>
	}
      }
<span class="nc" id="L186">    } catch( ArrayIndexOutOfBoundsException e ) {</span>
<span class="nc" id="L187">      throw new ArrayIndexOutOfBoundsException( &quot;Index out of bounds&quot; );</span>
    }
<span class="nc" id="L189">  }</span>
  
  /** Set the submatrix A[i0:i1][j] with the values stored in a
   *  DoubleVector
   *  @param i0 the index of the first element of the column
   *  @param i1 the index of the last element of the column
   *  @param j  the index of the column
   *  @param v the vector that stores the values*/
  public void setMatrix( int i0, int i1, int j, DoubleVector v ) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">    for( int i = i0; i &lt;= i1; i++ ) {</span>
<span class="fc" id="L199">      A[i][j] = v.get(i-i0);</span>
    }
<span class="fc" id="L201">  }</span>

  /** Set the whole matrix from a 1-D array 
   *  @param v    1-D array of doubles
   *  @param columnFirst   Whether to fill the column first or the row.
   *  @throws  ArrayIndexOutOfBoundsException Submatrix indices
   */
  public void setMatrix ( double[] v, boolean columnFirst ) {
    try {
<span class="nc bnc" id="L210" title="All 2 branches missed.">      if( v.length != m * n ) </span>
<span class="nc" id="L211">	throw new IllegalArgumentException(&quot;sizes not match.&quot;);</span>
<span class="nc" id="L212">      int i, j, count = 0;</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">      if( columnFirst ) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">	for( i = 0; i &lt; m; i++ ) {</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">	  for( j = 0; j &lt; n; j++ ) {</span>
<span class="nc" id="L216">	    A[i][j] = v[count];</span>
<span class="nc" id="L217">	    count ++;</span>
	  }
	}
      }
      else {
<span class="nc bnc" id="L222" title="All 2 branches missed.">	for( j = 0; j &lt; n; j++ ) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">	  for( i = 0; i &lt; m; i++ ){</span>
<span class="nc" id="L224">	    A[i][j] = v[count];</span>
<span class="nc" id="L225">	    count ++;</span>
	  }
	}
      }

<span class="nc" id="L230">    } catch( ArrayIndexOutOfBoundsException e ) {</span>
<span class="nc" id="L231">      throw new ArrayIndexOutOfBoundsException( &quot;Submatrix indices&quot; );</span>
    }
<span class="nc" id="L233">  }</span>

  /** Returns the maximum absolute value of all elements 
      @return the maximum value
  */
  public double maxAbs () {
<span class="nc" id="L239">    double ma = Math.abs(A[0][0]);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">    for (int j = 0; j &lt; n; j++) {</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      for (int i = 0; i &lt; m; i++) {</span>
<span class="nc" id="L242">	ma = Math.max(ma, Math.abs(A[i][j]));</span>
      }
    }
<span class="nc" id="L245">    return ma;</span>
  }

  /** Returns the maximum absolute value of some elements of a column,
      that is, the elements of A[i0:i1][j].
      @param i0 the index of the first element of the column
      @param i1 the index of the last element of the column
      @param j  the index of the column
      @return the maximum value */
  public double maxAbs ( int i0, int i1, int j ) {
<span class="nc" id="L255">    double m = Math.abs(A[i0][j]);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    for (int i = i0+1; i &lt;= i1; i++) {</span>
<span class="nc" id="L257">      m = Math.max(m, Math.abs(A[i][j]));</span>
    }
<span class="nc" id="L259">    return m;</span>
  }

  /** Returns the minimum absolute value of some elements of a column,
      that is, the elements of A[i0:i1][j].
      @param i0 the index of the first element of the column
      @param i1 the index of the last element of the column
      @param column the index of the column
      @return the minimum value 
  */
  public double minAbs ( int i0, int i1, int column ) {
<span class="nc" id="L270">    double m = Math.abs(A[i0][column]);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">    for (int i = i0+1; i &lt;= i1; i++) {</span>
<span class="nc" id="L272">      m = Math.min(m, Math.abs(A[i][column]));</span>
    }
<span class="nc" id="L274">    return m;</span>
  }
    
  /** Check if the matrix is empty
   *   @return true if the matrix is empty
   */
  public boolean  isEmpty(){
<span class="nc bnc" id="L281" title="All 4 branches missed.">    if(m == 0 || n == 0) return true;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if(A == null) return true;</span>
<span class="nc" id="L283">    return false;</span>
  }
    
  /** Return a DoubleVector that stores a column of the matrix 
   *  @param j the index of the column
   *  @return the column
   */
  public DoubleVector  getColumn( int j ) {
<span class="fc" id="L291">    DoubleVector v = new DoubleVector( m );</span>
<span class="fc" id="L292">    double [] a = v.getArray();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">    for(int i = 0; i &lt; m; i++)</span>
<span class="fc" id="L294">      a[i] = A[i][j];</span>
<span class="fc" id="L295">    return v;</span>
  }

  /** Return a DoubleVector that stores some elements of a column of the
   *  matrix 
   *  @param i0 the index of the first element of the column
   *  @param i1 the index of the last element of the column
   *  @param j  the index of the column
   *  @return the DoubleVector
   */
  public DoubleVector  getColumn( int i0, int i1, int j ) {
<span class="fc" id="L306">    DoubleVector v = new DoubleVector( i1-i0+1 );</span>
<span class="fc" id="L307">    double [] a = v.getArray();</span>
<span class="fc" id="L308">    int count = 0;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">    for( int i = i0; i &lt;= i1; i++ ) {</span>
<span class="fc" id="L310">      a[count] = A[i][j];</span>
<span class="fc" id="L311">      count++;</span>
    }
<span class="fc" id="L313">    return v;</span>
  }
  
  
  /** Multiplication between a row (or part of a row) of the first matrix
   *  and a column (or part or a column) of the second matrix.
   *  @param i the index of the row in the first matrix
   *  @param j0 the index of the first column in the first matrix
   *  @param j1 the index of the last column in the first matrix
   *  @param B the second matrix
   *  @param l the index of the column in the second matrix
   *  @return the result of the multiplication
   */
  public double  times( int i, int j0, int j1, PaceMatrix B, int l ) {
<span class="fc" id="L327">    double s = 0.0;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">    for(int j = j0; j &lt;= j1; j++ ) {</span>
<span class="fc" id="L329">      s += A[i][j] * B.A[j][l];</span>
    }
<span class="fc" id="L331">    return s;</span>
  }
  
  /** Decimal format for converting a matrix into a string
   *  @return the default decimal format
   */
  protected DecimalFormat []  format() {
<span class="nc" id="L338">    return format(0, m-1, 0, n-1, 7, false );</span>
  }
  
  /** Decimal format for converting a matrix into a string
   *  @param digits the number of digits
   *  @return the decimal format
   */
  protected DecimalFormat []  format( int digits ) {
<span class="nc" id="L346">    return format(0, m-1, 0, n-1, digits, false);</span>
  }

  /** Decimal format for converting a matrix into a string
   *  @param digits the number of digits
   *  @param trailing
   *  @return the decimal format
   */
  protected DecimalFormat []  format( int digits, boolean trailing ) {
<span class="nc" id="L355">    return format(0, m-1, 0, n-1, digits, trailing);</span>
  }
  
  /** Decimal format for converting a matrix into a string
   *  @param i0
   *  @param i1
   *  @param j
   *  @param digits the number of digits
   *  @param trailing
   *  @return the decimal format
   */
  protected DecimalFormat  format(int i0, int i1, int j, int digits, 
				  boolean trailing) {
<span class="nc" id="L368">    FlexibleDecimalFormat df = new FlexibleDecimalFormat(digits, trailing);</span>
<span class="nc" id="L369">    df.grouping( true );</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">    for(int i = i0; i &lt;= i1; i ++ )</span>
<span class="nc" id="L371">      df.update( A[i][j] );</span>
<span class="nc" id="L372">    return df;</span>
  }
  
  /** Decimal format for converting a matrix into a string
   *  @param i0
   *  @param i1
   *  @param j0
   *  @param j1
   *  @param trailing
   *  @param digits the number of digits
   *  @return the decimal format
   */
  protected DecimalFormat []  format(int i0, int i1, int j0, int j1, 
				     int digits, boolean trailing) {
<span class="nc" id="L386">    DecimalFormat [] f = new DecimalFormat[j1-j0+1];</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">    for( int j = j0; j &lt;= j1; j++ ) {</span>
<span class="nc" id="L388">      f[j] = format(i0, i1, j, digits, trailing);</span>
    }
<span class="nc" id="L390">    return f;</span>
  }
  
  /** 
   * Converts matrix to string
   * 
   * @return the matrix as string
   */ 
  public String  toString() {
<span class="nc" id="L399">    return toString( 5, false );</span>
  }
  
  /** 
   * Converts matrix to string
   * 
   * @param digits number of digits after decimal point
   * @param trailing true if trailing zeros are padded
   * @return the matrix as string
   */ 
  public String  toString( int digits, boolean trailing ) {
    
<span class="nc bnc" id="L411" title="All 2 branches missed.">    if( isEmpty() ) return &quot;null matrix&quot;;</span>
    
<span class="nc" id="L413">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L414">    DecimalFormat [] nf = format( digits, trailing );</span>
<span class="nc" id="L415">    int numCols = 0;</span>
<span class="nc" id="L416">    int count = 0;</span>
<span class="nc" id="L417">    int width = 80;</span>
    int lenNumber;
    
<span class="nc" id="L420">    int [] nCols = new int[n];</span>
<span class="nc" id="L421">    int nk=0;</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">    for( int j = 0; j &lt; n; j++ ) {</span>
<span class="nc" id="L423">      lenNumber = nf[j].format( A[0][j]).length(); </span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">      if( count + 1 + lenNumber &gt; width -1 ) {</span>
<span class="nc" id="L425">	nCols[nk++]  = numCols;</span>
<span class="nc" id="L426">	count = 0;</span>
<span class="nc" id="L427">	numCols = 0;</span>
      }
<span class="nc" id="L429">      count += 1 + lenNumber;</span>
<span class="nc" id="L430">      ++numCols;</span>
    }
<span class="nc" id="L432">    nCols[nk] = numCols;</span>
    
<span class="nc" id="L434">    nk = 0;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">    for( int k = 0; k &lt; n; ) {</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">      for( int i = 0; i &lt; m; i++ ) {</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">	for( int j = k; j &lt; k + nCols[nk]; j++)</span>
<span class="nc" id="L438">	  text.append( &quot; &quot; + nf[j].format( A[i][j]) );</span>
<span class="nc" id="L439">	text.append(&quot;\n&quot;);</span>
      }
<span class="nc" id="L441">      k += nCols[nk];</span>
<span class="nc" id="L442">      ++nk;</span>
<span class="nc" id="L443">      text.append(&quot;\n&quot;);</span>
    }
    
<span class="nc" id="L446">    return text.toString();</span>
  }
  
  /** Squared sum of a column or row in a matrix
   * @param j the index of the column or row
   * @param i0 the index of the first element
   * @param i1 the index of the last element
   * @param col if true, sum over a column; otherwise, over a row
   * @return the squared sum
   */
  public double sum2( int j, int i0, int i1, boolean col ) {
<span class="fc" id="L457">    double s2 = 0;</span>
<span class="pc bpc" id="L458" title="1 of 2 branches missed.">    if( col ) {   // column </span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">      for( int i = i0; i &lt;= i1; i++ ) </span>
<span class="fc" id="L460">	s2 += A[i][j] * A[i][j];</span>
    }
    else {
<span class="nc bnc" id="L463" title="All 2 branches missed.">      for( int i = i0; i &lt;= i1; i++ ) </span>
<span class="nc" id="L464">	s2 += A[j][i] * A[j][i];</span>
    }
<span class="fc" id="L466">    return s2;</span>
  }
  
  /** Squared sum of columns or rows of a matrix
   * @param col if true, sum over columns; otherwise, over rows
   * @return the squared sum
   */
  public double[] sum2( boolean col ) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">    int l = col ? n : m;</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">    int p = col ? m : n;</span>
<span class="nc" id="L476">    double [] s2 = new double[l];</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">    for( int i = 0; i &lt; l; i++ ) </span>
<span class="nc" id="L478">      s2[i] = sum2( i, 0, p-1, col );</span>
<span class="nc" id="L479">    return s2;</span>
  }

  /** Constructs single Householder transformation for a column
   *
   @param j    the index of the column
   @param k    the index of the row
   @return     d and q 
  */
  public double [] h1( int j, int k ) {
<span class="fc" id="L489">    double dq[] = new double[2];</span>
<span class="fc" id="L490">    double s2 = sum2(j, k, m-1, true);  </span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">    dq[0] = A[k][j] &gt;= 0 ? - Math.sqrt( s2 ) : Math.sqrt( s2 );</span>
<span class="fc" id="L492">    A[k][j] -= dq[0];</span>
<span class="fc" id="L493">    dq[1] = A[k][j] * dq[0];</span>
<span class="fc" id="L494">    return dq;</span>
  }
  
  /** Performs single Householder transformation on one column of a matrix
   *
   @param j    the index of the column 
   @param k    the index of the row
   @param q    q = - u'u/2; must be negative
   @param b    the matrix to be transformed
   @param l    the column of the matrix b
  */
  public void h2( int j, int k, double q, PaceMatrix b, int l ) {
<span class="fc" id="L506">    double s = 0, alpha;</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">    for( int i = k; i &lt; m; i++ )</span>
<span class="fc" id="L508">      s += A[i][j] * b.A[i][l];</span>
<span class="fc" id="L509">    alpha = s / q;</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">    for( int i = k; i &lt; m; i++ )</span>
<span class="fc" id="L511">      b.A[i][l] += alpha * A[i][j];</span>
<span class="fc" id="L512">  }</span>
  
  /** Constructs the Givens rotation
   *  @param a 
   *  @param b
   *  @return a double array that stores the cosine and sine values
   */
  public double []  g1( double a, double b ) {
<span class="fc" id="L520">    double cs[] = new double[2];</span>
<span class="fc" id="L521">    double r = Maths.hypot(a, b);</span>
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">    if( r == 0.0 ) {</span>
<span class="nc" id="L523">      cs[0] = 1;</span>
<span class="nc" id="L524">      cs[1] = 0;</span>
    }
    else {
<span class="fc" id="L527">      cs[0] = a / r;</span>
<span class="fc" id="L528">      cs[1] = b / r;</span>
    }
<span class="fc" id="L530">    return cs;</span>
  }
  
  /** Performs the Givens rotation
   * @param cs a array storing the cosine and sine values
   * @param i0 the index of the row of the first element
   * @param i1 the index of the row of the second element
   * @param j the index of the column
   */
  public void  g2( double cs[], int i0, int i1, int j ){
<span class="fc" id="L540">    double w =   cs[0] * A[i0][j] + cs[1] * A[i1][j];</span>
<span class="fc" id="L541">    A[i1][j] = - cs[1] * A[i0][j] + cs[0] * A[i1][j];</span>
<span class="fc" id="L542">    A[i0][j] = w;</span>
<span class="fc" id="L543">  }</span>
  
  /** Forward ordering of columns in terms of response explanation.  On
   *  input, matrices A and b are already QR-transformed. The indices of
   *  transformed columns are stored in the pivoting vector.
   *  
   *@param b     the PaceMatrix b
   *@param pvt   the pivoting vector
   *@param k0    the first k0 columns (in pvt) of A are not to be changed
   **/
  public void forward( PaceMatrix b, IntVector pvt, int k0 ) {
<span class="nc bnc" id="L554" title="All 2 branches missed.">    for( int j = k0; j &lt; Math.min(pvt.size(), m); j++ ) {</span>
<span class="nc" id="L555">      steplsqr( b, pvt, j, mostExplainingColumn(b, pvt, j), true );</span>
    }
<span class="nc" id="L557">  }</span>

  /** Returns the index of the column that has the largest (squared)
   *  response, when each of columns pvt[ks:] is moved to become the
   *  ks-th column. On input, A and b are both QR-transformed.
   *  
   * @param b    response
   * @param pvt  pivoting index of A
   * @param ks   columns pvt[ks:] of A are to be tested 
   * @return the index of the column
   */
  public int  mostExplainingColumn( PaceMatrix b, IntVector pvt, int ks ) {
    double val;
<span class="nc" id="L570">    int [] p = pvt.getArray();</span>
<span class="nc" id="L571">    double ma = columnResponseExplanation( b, pvt, ks, ks );</span>
<span class="nc" id="L572">    int jma = ks;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">    for( int i = ks+1; i &lt; pvt.size(); i++ ) {</span>
<span class="nc" id="L574">      val = columnResponseExplanation( b, pvt, i, ks );</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">      if( val &gt; ma ) {</span>
<span class="nc" id="L576">	ma = val;</span>
<span class="nc" id="L577">	jma = i;</span>
      }
    }
<span class="nc" id="L580">    return jma;</span>
  }
  
  /** Backward ordering of columns in terms of response explanation.  On
   *  input, matrices A and b are already QR-transformed. The indices of
   *  transformed columns are stored in the pivoting vector.
   * 
   *  A and b must have the same number of rows, being the (pseudo-)rank. 
   *  
   * @param b     PaceMatrix b
   * @param pvt   pivoting vector
   * @param ks    number of QR-transformed columns; psuedo-rank of A 
   * @param k0    first k0 columns in pvt[] are not to be ordered.
   */
  public void backward( PaceMatrix b, IntVector pvt, int ks, int k0 ) {
<span class="fc bfc" id="L595" title="All 2 branches covered.">    for( int j = ks; j &gt; k0; j-- ) {</span>
<span class="fc" id="L596">      steplsqr( b, pvt, j, leastExplainingColumn(b, pvt, j, k0), false );</span>
    }
<span class="fc" id="L598">  }</span>

  /** Returns the index of the column that has the smallest (squared)
   *  response, when the column is moved to become the (ks-1)-th
   *  column. On input, A and b are both QR-transformed.
   *  
   * @param b    response
   * @param pvt  pivoting index of A
   * @param ks   psudo-rank of A
   * @param k0   A[][pvt[0:(k0-1)]] are excluded from the testing.
   * @return the index of the column
   */
  public int  leastExplainingColumn( PaceMatrix b, IntVector pvt, int ks, 
				     int k0 ) {
    double val;
<span class="fc" id="L613">    int [] p = pvt.getArray();</span>
<span class="fc" id="L614">    double mi = columnResponseExplanation( b, pvt, ks-1, ks );</span>
<span class="fc" id="L615">    int jmi = ks-1;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">    for( int i = k0; i &lt; ks - 1; i++ ) {</span>
<span class="fc" id="L617">      val = columnResponseExplanation( b, pvt, i, ks );</span>
<span class="fc bfc" id="L618" title="All 2 branches covered.">      if( val &lt;= mi ) {</span>
<span class="fc" id="L619">	mi = val;</span>
<span class="fc" id="L620">	jmi = i;</span>
      }
    }
<span class="fc" id="L623">    return jmi;</span>
  }
  
  /** Returns the squared ks-th response value if the j-th column becomes
   *  the ks-th after orthogonal transformation.  A[][pvt[ks:j]] (or
   *  A[][pvt[j:ks]], if ks &gt; j) and b[] are already QR-transformed
   *  on input and will remain unchanged on output.
   *
   *  More generally, it returns the inner product of the corresponding
   *  row vector of the response PaceMatrix. (To be implemented.)
   *
   *@param b    PaceMatrix b
   *@param pvt  pivoting vector
   *@param j    the column A[pvt[j]][] is to be moved
   *@param ks   the target column A[pvt[ks]][]
   *@return     the squared response value */
  public double  columnResponseExplanation( PaceMatrix b, IntVector pvt,
					    int j, int ks ) {
    /*  Implementation: 
     *
     *  If j == ks - 1, returns the squared ks-th response directly.
     *
     *  If j &gt; ks -1, returns the ks-th response after
     *  Householder-transforming the j-th column and the response.
     *
     *  If j &lt; ks - 1, returns the ks-th response after a sequence of
     *  Givens rotations starting from the j-th row. */

    int k, l;
<span class="fc" id="L652">    double [] xxx = new double[n];</span>
<span class="fc" id="L653">    int [] p = pvt.getArray();</span>
    double val;
    
<span class="fc bfc" id="L656" title="All 2 branches covered.">    if( j == ks -1 ) val = b.A[j][0];</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">    else if( j &gt; ks - 1 ) {</span>
<span class="nc" id="L658">      int jm = Math.min(n-1, j);</span>
<span class="nc" id="L659">      DoubleVector u = getColumn(ks,jm,p[j]);</span>
<span class="nc" id="L660">      DoubleVector v = b.getColumn(ks,jm,0);</span>
<span class="nc" id="L661">      val = v.innerProduct(u) / u.norm2();</span>
    }
    else {                 // ks &gt; j
<span class="fc bfc" id="L664" title="All 2 branches covered.">      for( k = j+1; k &lt; ks; k++ ) // make a copy of A[j][]</span>
<span class="fc" id="L665">	xxx[k] = A[j][p[k]];</span>
<span class="fc" id="L666">      val = b.A[j][0];</span>
      double [] cs;
<span class="fc bfc" id="L668" title="All 2 branches covered.">      for( k = j+1; k &lt; ks; k++ ) {</span>
<span class="fc" id="L669">	cs = g1( xxx[k], A[k][p[k]] );</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">	for( l = k+1; l &lt; ks; l++ ) </span>
<span class="fc" id="L671">	  xxx[l] = - cs[1] * xxx[l] + cs[0] * A[k][p[l]];</span>
<span class="fc" id="L672">	val = - cs[1] * val + cs[0] * b.A[k][0];</span>
      }
    }
<span class="fc" id="L675">    return val * val;  // or inner product in later implementation???</span>
  }

  /** 
   * QR transformation for a least squares problem&lt;br/&gt;
   *            A x = b&lt;br/&gt;
   * implicitly both A and b are transformed. pvt.size() is the psuedo-rank of 
   * A.
   *  
   * @param b    PaceMatrix b
   * @param pvt  pivoting vector
   * @param k0   the first k0 columns of A (indexed by pvt) are pre-chosen. 
   *            (But subject to rank examination.) 
   * 
   *            For example, the constant term may be reserved, in which
   *            case k0 = 1.
   **/
  public void  lsqr( PaceMatrix b, IntVector pvt, int k0 ) {
<span class="fc" id="L693">    final double TINY = 1e-15;</span>
<span class="fc" id="L694">    int [] p = pvt.getArray();</span>
<span class="fc" id="L695">    int ks = 0;  // psuedo-rank</span>
<span class="fc bfc" id="L696" title="All 2 branches covered.">    for(int j = 0; j &lt; k0; j++ )   // k0 pre-chosen columns</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">      if( sum2(p[j],ks,m-1,true) &gt; TINY ){ // large diagonal element </span>
<span class="fc" id="L698">	steplsqr(b, pvt, ks, j, true);</span>
<span class="fc" id="L699">	ks++;</span>
      }
      else {                     // collinear column
<span class="nc" id="L702">	pvt.shiftToEnd( j );</span>
<span class="nc" id="L703">	pvt.setSize(pvt.size()-1);</span>
<span class="nc" id="L704">	k0--;</span>
<span class="nc" id="L705">	j--;</span>
      }
	
    // initial QR transformation
<span class="fc bfc" id="L709" title="All 2 branches covered.">    for(int j = k0; j &lt; Math.min( pvt.size(), m ); j++ ) {</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">      if( sum2(p[j], ks, m-1, true) &gt; TINY ) { </span>
<span class="fc" id="L711">	steplsqr(b, pvt, ks, j, true);</span>
<span class="fc" id="L712">	ks++;</span>
      }
      else {                     // collinear column
<span class="nc" id="L715">	pvt.shiftToEnd( j );</span>
<span class="nc" id="L716">	pvt.setSize(pvt.size()-1);</span>
<span class="nc" id="L717">	j--;</span>
      }
    }
	
<span class="fc" id="L721">    b.m = m = ks;           // reset number of rows</span>
<span class="fc" id="L722">    pvt.setSize( ks );</span>
<span class="fc" id="L723">  }</span>
    
  /** QR transformation for a least squares problem &lt;br/&gt;
   *            A x = b &lt;br/&gt;
   * implicitly both A and b are transformed. pvt.size() is the psuedo-rank of A.
   *  
   * @param b    PaceMatrix b
   * @param pvt  pivoting vector
   * @param k0   the first k0 columns of A (indexed by pvt) are pre-chosen. 
   *            (But subject to rank examination.) 
   * 
   *            For example, the constant term may be reserved, in which
   *            case k0 = 1.
   **/
  public void  lsqrSelection( PaceMatrix b, IntVector pvt, int k0 ) {
<span class="fc" id="L738">    int numObs = m;         // number of instances</span>
<span class="fc" id="L739">    int numXs = pvt.size();</span>

<span class="fc" id="L741">    lsqr( b, pvt, k0 );</span>

<span class="pc bpc" id="L743" title="2 of 4 branches missed.">    if( numXs &gt; 200 || numXs &gt; numObs ) { // too many columns.  </span>
<span class="nc" id="L744">      forward(b, pvt, k0);</span>
    }
<span class="fc" id="L746">    backward(b, pvt, pvt.size(), k0);</span>
<span class="fc" id="L747">  }</span>
    
  /** 
   * Sets all diagonal elements to be positive (or nonnegative) without
   * changing the least squares solution 
   * @param Y the response
   * @param pvt the pivoted column index
   */
  public void positiveDiagonal( PaceMatrix Y, IntVector pvt ) {
     
<span class="fc" id="L757">    int [] p = pvt.getArray();</span>
<span class="fc bfc" id="L758" title="All 2 branches covered.">    for( int i = 0; i &lt; pvt.size(); i++ ) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">      if( A[i][p[i]] &lt; 0.0 ) {</span>
<span class="fc bfc" id="L760" title="All 2 branches covered.">	for( int j = i; j &lt; pvt.size(); j++ ) </span>
<span class="fc" id="L761">	  A[i][p[j]] = - A[i][p[j]];</span>
<span class="fc" id="L762">	Y.A[i][0] = - Y.A[i][0];</span>
      }
    }
<span class="fc" id="L765">  }</span>

  /** Stepwise least squares QR-decomposition of the problem
   *	          A x = b
   @param b    PaceMatrix b
   @param pvt  pivoting vector
   @param ks   number of transformed columns
   @param j    pvt[j], the column to adjoin or delete
   @param adjoin   to adjoin if true; otherwise, to delete */
  public void  steplsqr( PaceMatrix b, IntVector pvt, int ks, int j, 
			 boolean adjoin ) {
<span class="fc" id="L776">    final int kp = pvt.size(); // number of columns under consideration</span>
<span class="fc" id="L777">    int [] p = pvt.getArray();</span>
	
<span class="fc bfc" id="L779" title="All 2 branches covered.">    if( adjoin ) {     // adjoining </span>
<span class="fc" id="L780">      int pj = p[j];</span>
<span class="fc" id="L781">      pvt.swap( ks, j );</span>
<span class="fc" id="L782">      double dq[] = h1( pj, ks );</span>
      int pk;
<span class="fc bfc" id="L784" title="All 2 branches covered.">      for( int k = ks+1; k &lt; kp; k++ ){</span>
<span class="fc" id="L785">	pk = p[k];</span>
<span class="fc" id="L786">	h2( pj, ks, dq[1], this, pk);</span>
      }
<span class="fc" id="L788">      h2( pj, ks, dq[1], b, 0 ); // for matrix. ???</span>
<span class="fc" id="L789">      A[ks][pj] = dq[0];</span>
<span class="fc bfc" id="L790" title="All 2 branches covered.">      for( int k = ks+1; k &lt; m; k++ )</span>
<span class="fc" id="L791">	A[k][pj] = 0;</span>
    }
    else {          // removing 
<span class="fc" id="L794">      int pj = p[j];</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">      for( int i = j; i &lt; ks-1; i++ ) </span>
<span class="fc" id="L796">	p[i] = p[i+1];</span>
<span class="fc" id="L797">      p[ks-1] = pj;</span>
      double [] cs;
<span class="fc bfc" id="L799" title="All 2 branches covered.">      for( int i = j; i &lt; ks-1; i++ ){</span>
<span class="fc" id="L800">	cs = g1( A[i][p[i]], A[i+1][p[i]] );</span>
<span class="fc bfc" id="L801" title="All 2 branches covered.">	for( int l = i; l &lt; kp; l++ ) </span>
<span class="fc" id="L802">	  g2( cs, i, i+1, p[l] );</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">	for( int l = 0; l &lt; b.n; l++ )</span>
<span class="fc" id="L804">	  b.g2( cs, i, i+1, l );</span>
      }
    }
<span class="fc" id="L807">  }</span>
    
  /** Solves upper-triangular equation &lt;br/&gt;
   *   	R x = b &lt;br/&gt;
   *  On output, the solution is stored in b
   *  @param b the response
   *  @param pvt the pivoting vector
   *  @param kp the number of the first columns involved 
   */
  public void  rsolve( PaceMatrix b, IntVector pvt, int kp) {
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">    if(kp == 0) b.m = 0;</span>
    int i, j, k;
<span class="fc" id="L819">    int [] p = pvt.getArray();</span>
    double s;
<span class="fc" id="L821">    double [][] ba = b.getArray();</span>
<span class="fc bfc" id="L822" title="All 2 branches covered.">    for( k = 0; k &lt; b.n; k++ ) {</span>
<span class="fc" id="L823">      ba[kp-1][k] /= A[kp-1][p[kp-1]];</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">      for( i = kp - 2; i &gt;= 0; i-- ){</span>
<span class="fc" id="L825">	s = 0;</span>
<span class="fc bfc" id="L826" title="All 2 branches covered.">	for( j = i + 1; j &lt; kp; j++ )</span>
<span class="fc" id="L827">	  s += A[i][p[j]] * ba[j][k];</span>
<span class="fc" id="L828">	ba[i][k] -= s;</span>
<span class="fc" id="L829">	ba[i][k] /= A[i][p[i]];</span>
      }
    } 
<span class="fc" id="L832">    b.m = kp;</span>
<span class="fc" id="L833">  }</span>
    
  /** Returns a new matrix which binds two matrices together with rows. 
   *  @param b  the second matrix
   *  @return the combined matrix
   */
  public PaceMatrix  rbind( PaceMatrix b ){
<span class="nc bnc" id="L840" title="All 2 branches missed.">    if( n != b.n ) </span>
<span class="nc" id="L841">      throw new IllegalArgumentException(&quot;unequal numbers of rows.&quot;);</span>
<span class="nc" id="L842">    PaceMatrix c = new PaceMatrix( m + b.m, n );</span>
<span class="nc" id="L843">    c.setMatrix( 0, m - 1, 0, n - 1, this );</span>
<span class="nc" id="L844">    c.setMatrix( m, m + b.m - 1, 0, n - 1, b );</span>
<span class="nc" id="L845">    return c;</span>
  }

  /** Returns a new matrix which binds two matrices with columns.
   *  @param b the second matrix 
   *  @return the combined matrix
   */
  public PaceMatrix  cbind( PaceMatrix b ) {
<span class="nc bnc" id="L853" title="All 2 branches missed.">    if( m != b.m ) </span>
<span class="nc" id="L854">      throw new IllegalArgumentException(&quot;unequal numbers of rows: &quot; + </span>
<span class="nc" id="L855">					 m + &quot; and &quot; + b.m);</span>
<span class="nc" id="L856">    PaceMatrix c = new PaceMatrix(m, n + b.n);</span>
<span class="nc" id="L857">    c.setMatrix( 0, m - 1, 0, n - 1, this );</span>
<span class="nc" id="L858">    c.setMatrix( 0, m - 1, n, n + b.n - 1, b );</span>
<span class="nc" id="L859">    return c;</span>
  }

  /** Solves the nonnegative linear squares problem. That is, &lt;p&gt;
   *   &lt;center&gt;   min || A x - b||, subject to x &gt;= 0.  &lt;/center&gt; &lt;p&gt;
   * 
   *  For algorithm, refer to P161, Chapter 23 of C. L. Lawson and
   *  R. J. Hanson (1974).  &quot;Solving Least Squares
   *  Problems&quot;. Prentice-Hall.
   * 	@param b the response
   *  @param pvt vector storing pivoting column indices
   *	@return solution */
  public DoubleVector nnls( PaceMatrix b, IntVector pvt ) {
<span class="fc" id="L872">    int j, t, counter = 0, jm = -1, n = pvt.size();</span>
    double ma, max, alpha, wj;
<span class="fc" id="L874">    int [] p = pvt.getArray();</span>
<span class="fc" id="L875">    DoubleVector x = new DoubleVector( n );</span>
<span class="fc" id="L876">    double [] xA = x.getArray();</span>
<span class="fc" id="L877">    PaceMatrix z = new PaceMatrix(n, 1);</span>
    PaceMatrix bt;
	
    // step 1 
<span class="fc" id="L881">    int kp = 0; // #variables in the positive set P</span>
<span class="fc" id="L882">    while ( true ) {         // step 2 </span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">      if( ++counter &gt; 3*n )  // should never happen</span>
<span class="nc" id="L884">	throw new RuntimeException(&quot;Does not converge&quot;);</span>
<span class="fc" id="L885">      t = -1;</span>
<span class="fc" id="L886">      max = 0.0;</span>
<span class="fc" id="L887">      bt = new PaceMatrix( b.transpose() );</span>
<span class="fc bfc" id="L888" title="All 2 branches covered.">      for( j = kp; j &lt;= n-1; j++ ) {   // W = A' (b - A x) </span>
<span class="fc" id="L889">	wj = bt.times( 0, kp, m-1, this, p[j] );</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">	if( wj &gt; max ) {        // step 4</span>
<span class="fc" id="L891">	  max = wj;</span>
<span class="fc" id="L892">	  t = j;</span>
	}
      }
	    
      // step 3 
<span class="fc bfc" id="L897" title="All 2 branches covered.">      if ( t == -1) break; // optimum achieved </span>
	    
      // step 5 
<span class="fc" id="L900">      pvt.swap( kp, t );       // move variable from set Z to set P</span>
<span class="fc" id="L901">      kp++;</span>
<span class="fc" id="L902">      xA[kp-1] = 0;</span>
<span class="fc" id="L903">      steplsqr( b, pvt, kp-1, kp-1, true );</span>
      // step 6
<span class="fc" id="L905">      ma = 0;</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">      while ( ma &lt; 1.5 ) {</span>
<span class="fc bfc" id="L907" title="All 2 branches covered.">	for( j = 0; j &lt;= kp-1; j++ ) z.A[j][0] = b.A[j][0];</span>
<span class="fc" id="L908">	rsolve(z, pvt, kp); </span>
<span class="fc" id="L909">	ma = 2; jm = -1;</span>
<span class="fc bfc" id="L910" title="All 2 branches covered.">	for( j = 0; j &lt;= kp-1; j++ ) {  // step 7, 8 and 9</span>
<span class="pc bpc" id="L911" title="1 of 2 branches missed.">	  if( z.A[j][0] &lt;= 0.0 ) { // alpha always between 0 and 1</span>
<span class="nc" id="L912">	    alpha = xA[j] / ( xA[j] - z.A[j][0] ); </span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">	    if( alpha &lt; ma ) {</span>
<span class="nc" id="L914">	      ma = alpha; jm = j;</span>
	    }
	  }
	}
<span class="pc bpc" id="L918" title="1 of 2 branches missed.">	if( ma &gt; 1.5 ) </span>
<span class="fc bfc" id="L919" title="All 2 branches covered.">	  for( j = 0; j &lt;= kp-1; j++ ) xA[j] = z.A[j][0];  // step 7 </span>
	else { 
<span class="nc bnc" id="L921" title="All 2 branches missed.">	  for( j = kp-1; j &gt;= 0; j-- ) { // step 10</span>
	    // Modified to avoid round-off error (which seemingly 
	    // can cause infinite loop).
<span class="nc bnc" id="L924" title="All 2 branches missed.">	    if( j == jm ) { // step 11 </span>
<span class="nc" id="L925">	      xA[j] = 0.0;</span>
<span class="nc" id="L926">	      steplsqr( b, pvt, kp, j, false );</span>
<span class="nc" id="L927">	      kp--;  // move variable from set P to set Z</span>
	    }
<span class="nc" id="L929">	    else xA[j] += ma * ( z.A[j][0] - xA[j] );</span>
	  }
	}
      }
    }
<span class="fc" id="L934">    x.setSize(kp);</span>
<span class="fc" id="L935">    pvt.setSize(kp);</span>
<span class="fc" id="L936">    return x;</span>
  }

  /** Solves the nonnegative least squares problem with equality
   *	constraint. That is, &lt;p&gt;
   *  &lt;center&gt; min ||A x - b||, subject to x &gt;= 0 and c x = d. &lt;/center&gt; &lt;p&gt;
   *
   *  @param b the response
   *  @param c coeficients of equality constraints
   *  @param d constants of equality constraints
   *  @param pvt vector storing pivoting column indices
   *  @return the solution
   */
  public DoubleVector nnlse( PaceMatrix b, PaceMatrix c, PaceMatrix d, 
			     IntVector pvt ) {
<span class="nc" id="L951">    double eps = 1e-10 * Math.max( c.maxAbs(), d.maxAbs() ) /</span>
<span class="nc" id="L952">    Math.max( maxAbs(), b.maxAbs() );</span>
	
<span class="nc" id="L954">    PaceMatrix e = c.rbind( new PaceMatrix( times(eps) ) );</span>
<span class="nc" id="L955">    PaceMatrix f = d.rbind( new PaceMatrix( b.times(eps) ) );</span>

<span class="nc" id="L957">    return e.nnls( f, pvt );</span>
  }

  /** Solves the nonnegative least squares problem with equality
   *	constraint. That is, &lt;p&gt;
   *  &lt;center&gt; min ||A x - b||,  subject to x &gt;= 0 and || x || = 1. &lt;/center&gt;
   *  &lt;p&gt;
   *  @param b the response 
   *  @param pvt vector storing pivoting column indices
   *  @return the solution
   */
  public DoubleVector nnlse1( PaceMatrix b, IntVector pvt ) {
<span class="nc" id="L969">    PaceMatrix c = new PaceMatrix( 1, n, 1 );</span>
<span class="nc" id="L970">    PaceMatrix d = new PaceMatrix( 1, b.n, 1 );</span>
	
<span class="nc" id="L972">    return nnlse(b, c, d, pvt);</span>
  }

  /** Generate matrix with standard-normally distributed random elements
      @param m    Number of rows.
      @param n    Number of colums.
      @return An m-by-n matrix with random elements.  */
  public static Matrix randomNormal( int m, int n ) {
<span class="nc" id="L980">    Random random = new Random();</span>
     
<span class="nc" id="L982">    Matrix A = new Matrix(m,n);</span>
<span class="nc" id="L983">    double[][] X = A.getArray();</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">    for (int i = 0; i &lt; m; i++) {</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">      for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L986">	X[i][j] = random.nextGaussian();</span>
      }
    }
<span class="nc" id="L989">    return A;</span>
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L998">    return RevisionUtils.extract(&quot;$Revision: 1.6 $&quot;);</span>
  }

  /**
   * for testing only
   * 
   * @param args the commandline arguments - ignored
   */
  public static void  main( String args[] ) {
<span class="nc" id="L1007">    System.out.println(&quot;================================================&quot; + </span>
		       &quot;===========&quot;);
<span class="nc" id="L1009">    System.out.println(&quot;To test the pace estimators of linear model\n&quot; + </span>
		       &quot;coefficients.\n&quot;);

<span class="nc" id="L1012">    double sd = 2;     // standard deviation of the random error term</span>
<span class="nc" id="L1013">    int n = 200;       // total number of observations</span>
<span class="nc" id="L1014">    double beta0 = 100;   // intercept</span>
<span class="nc" id="L1015">    int k1 = 20;       // number of coefficients of the first cluster</span>
<span class="nc" id="L1016">    double beta1 = 0;  // coefficient value of the first cluster</span>
<span class="nc" id="L1017">    int k2 = 20;      // number of coefficients of the second cluster</span>
<span class="nc" id="L1018">    double beta2 = 5; // coefficient value of the second cluster </span>
<span class="nc" id="L1019">    int k = 1 + k1 + k2;</span>

<span class="nc" id="L1021">    DoubleVector beta = new DoubleVector( 1 + k1 + k2 );</span>
<span class="nc" id="L1022">    beta.set( 0, beta0 );</span>
<span class="nc" id="L1023">    beta.set( 1, k1, beta1 );</span>
<span class="nc" id="L1024">    beta.set( k1+1, k1+k2, beta2 );</span>

<span class="nc" id="L1026">    System.out.println(&quot;The data set contains &quot; + n + </span>
<span class="nc" id="L1027">		       &quot; observations plus &quot; + (k1 + k2) + </span>
<span class="nc" id="L1028">		       &quot; variables.\n\nThe coefficients of the true model&quot;</span>
<span class="nc" id="L1029">		       + &quot; are:\n\n&quot; + beta );</span>
	
<span class="nc" id="L1031">    System.out.println(&quot;\nThe standard deviation of the error term is &quot; + </span>
<span class="nc" id="L1032">		       sd );</span>
	
<span class="nc" id="L1034">    System.out.println(&quot;===============================================&quot; </span>
		       + &quot;============&quot;);
		
<span class="nc" id="L1037">    PaceMatrix X = new PaceMatrix( n, k1+k2+1 );</span>
<span class="nc" id="L1038">    X.setMatrix( 0, n-1, 0, 0, 1 );</span>
<span class="nc" id="L1039">    X.setMatrix( 0, n-1, 1, k1+k2, random(n, k1+k2) );</span>
	
<span class="nc" id="L1041">    PaceMatrix Y = new </span>
<span class="nc" id="L1042">      PaceMatrix( X.times( new PaceMatrix(beta) ).</span>
<span class="nc" id="L1043">		  plusEquals( randomNormal(n,1).times(sd) ) );</span>

<span class="nc" id="L1045">    IntVector pvt = (IntVector) IntVector.seq(0, k1+k2);</span>

    /*System.out.println( &quot;The OLS estimate (by jama.Matrix.solve()) is:\n\n&quot; + 
      (new PaceMatrix(X.solve(Y))).getColumn(0) );*/
	
<span class="nc" id="L1050">    X.lsqrSelection( Y, pvt, 1 );</span>
<span class="nc" id="L1051">    X.positiveDiagonal( Y, pvt );</span>

<span class="nc" id="L1053">    PaceMatrix sol = (PaceMatrix) Y.clone();</span>
<span class="nc" id="L1054">    X.rsolve( sol, pvt, pvt.size() );</span>
<span class="nc" id="L1055">    DoubleVector betaHat = sol.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1056">    System.out.println( &quot;\nThe OLS estimate (through lsqr()) is: \n\n&quot; + </span>
<span class="nc" id="L1057">			betaHat );</span>

<span class="nc" id="L1059">    System.out.println( &quot;\nQuadratic loss of the OLS estimate (||X b - X bHat||^2) = &quot; + </span>
<span class="nc" id="L1060">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1061">			  PaceMatrix(beta.minus(betaHat)) )))</span>
<span class="nc" id="L1062">			.getColumn(0).sum2() );</span>

<span class="nc" id="L1064">    System.out.println(&quot;=============================================&quot; + </span>
		       &quot;==============&quot;);
<span class="nc" id="L1066">    System.out.println(&quot;             *** Pace estimation *** \n&quot;);</span>
<span class="nc" id="L1067">    DoubleVector r = Y.getColumn( pvt.size(), n-1, 0);</span>
<span class="nc" id="L1068">    double sde = Math.sqrt(r.sum2() / r.size());</span>
	
<span class="nc" id="L1070">    System.out.println( &quot;Estimated standard deviation = &quot; + sde );</span>

<span class="nc" id="L1072">    DoubleVector aHat = Y.getColumn( 0, pvt.size()-1, 0).times( 1./sde );</span>
<span class="nc" id="L1073">    System.out.println(&quot;\naHat = \n&quot; + aHat );</span>
	
<span class="nc" id="L1075">    System.out.println(&quot;\n========= Based on chi-square mixture ============&quot;);</span>

<span class="nc" id="L1077">    ChisqMixture d2 = new ChisqMixture();</span>
<span class="nc" id="L1078">    int method = MixtureDistribution.NNMMethod;</span>
<span class="nc" id="L1079">    DoubleVector AHat = aHat.square();</span>
<span class="nc" id="L1080">    d2.fit( AHat, method ); </span>
<span class="nc" id="L1081">    System.out.println( &quot;\nEstimated mixing distribution is:\n&quot; + d2 );</span>
	
<span class="nc" id="L1083">    DoubleVector ATilde = d2.pace2( AHat );</span>
<span class="nc" id="L1084">    DoubleVector aTilde = ATilde.sqrt().times(aHat.sign());</span>
<span class="nc" id="L1085">    PaceMatrix YTilde = new </span>
<span class="nc" id="L1086">      PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1087">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1088">    DoubleVector betaTilde = </span>
<span class="nc" id="L1089">    YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1090">    System.out.println( &quot;\nThe pace2 estimate of coefficients = \n&quot; + </span>
<span class="nc" id="L1091">			betaTilde );</span>
<span class="nc" id="L1092">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1093">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1094">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1095">			.getColumn(0).sum2() );</span>
	
<span class="nc" id="L1097">    ATilde = d2.pace4( AHat );</span>
<span class="nc" id="L1098">    aTilde = ATilde.sqrt().times(aHat.sign());</span>
<span class="nc" id="L1099">    YTilde = new PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1100">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1101">    betaTilde = YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1102">    System.out.println( &quot;\nThe pace4 estimate of coefficients = \n&quot; + </span>
<span class="nc" id="L1103">			betaTilde );</span>
<span class="nc" id="L1104">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1105">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1106">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1107">			.getColumn(0).sum2() );</span>
	
<span class="nc" id="L1109">    ATilde = d2.pace6( AHat );</span>
<span class="nc" id="L1110">    aTilde = ATilde.sqrt().times(aHat.sign());</span>
<span class="nc" id="L1111">    YTilde = new PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1112">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1113">    betaTilde = YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1114">    System.out.println( &quot;\nThe pace6 estimate of coefficients = \n&quot; + </span>
<span class="nc" id="L1115">			betaTilde );</span>
<span class="nc" id="L1116">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1117">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1118">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1119">			.getColumn(0).sum2() );</span>
	
<span class="nc" id="L1121">    System.out.println(&quot;\n========= Based on normal mixture ============&quot;);</span>
	
<span class="nc" id="L1123">    NormalMixture d = new NormalMixture();</span>
<span class="nc" id="L1124">    d.fit( aHat, method ); </span>
<span class="nc" id="L1125">    System.out.println( &quot;\nEstimated mixing distribution is:\n&quot; + d );</span>
	
<span class="nc" id="L1127">    aTilde = d.nestedEstimate( aHat );</span>
<span class="nc" id="L1128">    YTilde = new PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1129">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1130">    betaTilde = YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1131">    System.out.println( &quot;The nested estimate of coefficients = \n&quot; + </span>
<span class="nc" id="L1132">			betaTilde );</span>
<span class="nc" id="L1133">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1134">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1135">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1136">			.getColumn(0).sum2() );</span>
	
	
<span class="nc" id="L1139">    aTilde = d.subsetEstimate( aHat );</span>
<span class="nc" id="L1140">    YTilde = new PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1141">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1142">    betaTilde = </span>
<span class="nc" id="L1143">    YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1144">    System.out.println( &quot;\nThe subset estimate of coefficients = \n&quot; + </span>
<span class="nc" id="L1145">			betaTilde );</span>
<span class="nc" id="L1146">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1147">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1148">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1149">			.getColumn(0).sum2() );</span>
	
<span class="nc" id="L1151">    aTilde = d.empiricalBayesEstimate( aHat );</span>
<span class="nc" id="L1152">    YTilde = new PaceMatrix((new PaceMatrix(aTilde)).times( sde ));</span>
<span class="nc" id="L1153">    X.rsolve( YTilde, pvt, pvt.size() );</span>
<span class="nc" id="L1154">    betaTilde = YTilde.getColumn(0).unpivoting( pvt, k );</span>
<span class="nc" id="L1155">    System.out.println( &quot;\nThe empirical Bayes estimate of coefficients = \n&quot;+</span>
<span class="nc" id="L1156">			betaTilde );</span>
	
<span class="nc" id="L1158">    System.out.println( &quot;Quadratic loss = &quot; + </span>
<span class="nc" id="L1159">			( new PaceMatrix( X.times( new </span>
<span class="nc" id="L1160">			  PaceMatrix(beta.minus(betaTilde)) )))</span>
<span class="nc" id="L1161">			.getColumn(0).sum2() );</span>
	
<span class="nc" id="L1163">  }</span>
}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>