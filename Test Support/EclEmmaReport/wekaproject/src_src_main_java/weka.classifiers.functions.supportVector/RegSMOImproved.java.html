<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>RegSMOImproved.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.functions.supportVector</a> &gt; <span class="el_source">RegSMOImproved.java</span></div><h1>RegSMOImproved.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    RegSMOImproved.java
 *    Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.functions.supportVector;

import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.Enumeration;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Learn SVM for regression using SMO with Shevade, Keerthi, et al. adaption of the stopping criterion.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * S.K. Shevade, S.S. Keerthi, C. Bhattacharyya, K.R.K. Murthy: Improvements to the SMO Algorithm for SVM Regression. In: IEEE Transactions on Neural Networks, 1999.&lt;br/&gt;
 * &lt;br/&gt;
 * S.K. Shevade, S.S. Keerthi, C. Bhattacharyya, K.R.K. Murthy (1999). Improvements to the SMO Algorithm for SVM Regression. Control Division, Dept. of Mechanical Engineering.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;inproceedings{Shevade1999,
 *    author = {S.K. Shevade and S.S. Keerthi and C. Bhattacharyya and K.R.K. Murthy},
 *    booktitle = {IEEE Transactions on Neural Networks},
 *    title = {Improvements to the SMO Algorithm for SVM Regression},
 *    year = {1999},
 *    PS = {http://guppy.mpe.nus.edu.sg/\~mpessk/svm/ieee_smo_reg.ps.gz}
 * }
 * 
 * &amp;#64;techreport{Shevade1999,
 *    address = {Control Division, Dept. of Mechanical Engineering},
 *    author = {S.K. Shevade and S.S. Keerthi and C. Bhattacharyya and K.R.K. Murthy},
 *    institution = {National University of Singapore},
 *    number = {CD-99-16},
 *    title = {Improvements to the SMO Algorithm for SVM Regression},
 *    year = {1999},
 *    PS = {http://guppy.mpe.nus.edu.sg/\~mpessk/svm/smoreg_mod.ps.gz}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -T &amp;lt;double&amp;gt;
 *  The tolerance parameter for checking the stopping criterion.
 *  (default 0.001)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V
 *  Use variant 1 of the algorithm when true, otherwise use variant 2.
 *  (default true)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;double&amp;gt;
 *  The epsilon for round-off error.
 *  (default 1.0e-12)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L &amp;lt;double&amp;gt;
 *  The epsilon parameter in epsilon-insensitive loss function.
 *  (default 1.0e-3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W &amp;lt;double&amp;gt;
 *  The random number seed.
 *  (default 1)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author  Remco Bouckaert (remco@cs.waikato.ac.nz,rrb@xm.co.nz)
 * @version $Revision: 1.4 $
 */
<span class="fc" id="L101">public class RegSMOImproved</span>
  extends RegSMO
  implements TechnicalInformationHandler {
  
  /** for serialization */
  private static final long serialVersionUID = 471692841446029784L;
  
  public final static int I0 = 3;
  public final static int I0a = 1;
  public final static int I0b = 2;
  public final static int I1 = 4;
  public final static int I2 = 8;
  public final static int I3 = 16;
  
  /** The different sets used by the algorithm. */
  protected SMOset m_I0;
  
  /** Index set {i: 0 &lt; m_alpha[i] &lt; C || 0 &lt; m_alphaStar[i] &lt; C}} */
  protected int [] m_iSet;
  
  /** b.up and b.low boundaries used to determine stopping criterion */
  protected double m_bUp, m_bLow;
  
  /** index of the instance that gave us b.up and b.low */
  protected int m_iUp, m_iLow;
  
  /** tolerance parameter used for checking stopping criterion b.up &lt; b.low + 2 tol */
<span class="fc" id="L128">  double m_fTolerance = 0.001;</span>
  
  /** set true to use variant 1 of the paper, otherwise use variant 2 */
<span class="fc" id="L131">  boolean m_bUseVariant1 = true;</span>
  
  /**
   * Returns a string describing the object
   * 
   * @return 		a description suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L140">    return </span>
<span class="nc" id="L141">        &quot;Learn SVM for regression using SMO with Shevade, Keerthi, et al. &quot; </span>
      + &quot;adaption of the stopping criterion.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L144">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return 		the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    TechnicalInformation	additional;
    
<span class="nc" id="L158">    result = new TechnicalInformation(Type.INPROCEEDINGS);</span>
<span class="nc" id="L159">    result.setValue(Field.AUTHOR, &quot;S.K. Shevade and S.S. Keerthi and C. Bhattacharyya and K.R.K. Murthy&quot;);</span>
<span class="nc" id="L160">    result.setValue(Field.TITLE, &quot;Improvements to the SMO Algorithm for SVM Regression&quot;);</span>
<span class="nc" id="L161">    result.setValue(Field.BOOKTITLE, &quot;IEEE Transactions on Neural Networks&quot;);</span>
<span class="nc" id="L162">    result.setValue(Field.YEAR, &quot;1999&quot;);</span>
<span class="nc" id="L163">    result.setValue(Field.PS, &quot;http://guppy.mpe.nus.edu.sg/~mpessk/svm/ieee_smo_reg.ps.gz&quot;);</span>
    
<span class="nc" id="L165">    additional = result.add(Type.TECHREPORT);</span>
<span class="nc" id="L166">    additional.setValue(Field.AUTHOR, &quot;S.K. Shevade and S.S. Keerthi and C. Bhattacharyya and K.R.K. Murthy&quot;);</span>
<span class="nc" id="L167">    additional.setValue(Field.TITLE, &quot;Improvements to the SMO Algorithm for SVM Regression&quot;);</span>
<span class="nc" id="L168">    additional.setValue(Field.INSTITUTION, &quot;National University of Singapore&quot;);</span>
<span class="nc" id="L169">    additional.setValue(Field.ADDRESS, &quot;Control Division, Dept. of Mechanical Engineering&quot;);</span>
<span class="nc" id="L170">    additional.setValue(Field.NUMBER, &quot;CD-99-16&quot;);</span>
<span class="nc" id="L171">    additional.setValue(Field.YEAR, &quot;1999&quot;);</span>
<span class="nc" id="L172">    additional.setValue(Field.PS, &quot;http://guppy.mpe.nus.edu.sg/~mpessk/svm/smoreg_mod.ps.gz&quot;);</span>
    
<span class="nc" id="L174">    return result;</span>
  }
  
  /**
   * Returns an enumeration describing the available options
   * 
   * @return 		an enumeration of all the available options
   */
  public Enumeration listOptions() {
<span class="fc" id="L183">    Vector result = new Vector();</span>
    
<span class="fc" id="L185">    result.addElement(new Option(</span>
<span class="fc" id="L186">	&quot;\tThe tolerance parameter for checking the stopping criterion.\n&quot; </span>
	+ &quot;\t(default 0.001)&quot;, 
<span class="fc" id="L188">	&quot;T&quot;, 1, &quot;-T &lt;double&gt;&quot;));</span>
    
<span class="fc" id="L190">    result.addElement(new Option(</span>
<span class="fc" id="L191">	&quot;\tUse variant 1 of the algorithm when true, otherwise use variant 2.\n&quot; </span>
	+ &quot;\t(default true)&quot;, 
<span class="fc" id="L193">	&quot;V&quot;, 0, &quot;-V&quot;));</span>
    
<span class="fc" id="L195">    Enumeration enm = super.listOptions();</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">    while (enm.hasMoreElements()) {</span>
<span class="fc" id="L197">      result.addElement(enm.nextElement());</span>
    }
    
<span class="fc" id="L200">    return result.elements();</span>
  }
  
  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -T &amp;lt;double&amp;gt;
   *  The tolerance parameter for checking the stopping criterion.
   *  (default 0.001)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -V
   *  Use variant 1 of the algorithm when true, otherwise use variant 2.
   *  (default true)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;double&amp;gt;
   *  The epsilon for round-off error.
   *  (default 1.0e-12)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L &amp;lt;double&amp;gt;
   *  The epsilon parameter in epsilon-insensitive loss function.
   *  (default 1.0e-3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W &amp;lt;double&amp;gt;
   *  The random number seed.
   *  (default 1)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options 	the list of options as an array of strings
   * @throws Exception 	if an option is not supported 
   */
  public void setOptions(String[] options) throws Exception {
    String	tmpStr;
    
<span class="fc" id="L237">    tmpStr = Utils.getOption('T', options);</span>
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">    if (tmpStr.length() != 0) {</span>
<span class="fc" id="L239">      setTolerance(Double.parseDouble(tmpStr));</span>
    } else {
<span class="nc" id="L241">      setTolerance(0.001);</span>
    }
    
<span class="fc" id="L244">    setUseVariant1(Utils.getFlag('V', options));</span>
    
<span class="fc" id="L246">    super.setOptions(options);</span>
<span class="fc" id="L247">  }</span>
  
  /**
   * Gets the current settings of the object.
   *
   * @return 		an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    int       	i;
    Vector    	result;
    String[]  	options;

<span class="fc" id="L259">    result = new Vector();</span>

<span class="fc" id="L261">    options = super.getOptions();</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="fc" id="L263">      result.add(options[i]);</span>
    
<span class="fc" id="L265">    result.add(&quot;-T&quot;);</span>
<span class="fc" id="L266">    result.add(&quot;&quot; + getTolerance());</span>
    
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">    if (m_bUseVariant1)</span>
<span class="fc" id="L269">      result.add(&quot;-V&quot;);</span>

<span class="fc" id="L271">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }
  
  /**
   * Returns the tip text for this property
   * 
   * @return 		a description suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String toleranceTipText() {
<span class="nc" id="L281">    return &quot;tolerance parameter used for checking stopping criterion b.up &lt; b.low + 2 tol&quot;;</span>
  }
  
  /**
   * returns the current tolerance
   * 
   * @return	the tolerance
   */
  public double getTolerance() {
<span class="fc" id="L290">    return m_fTolerance;</span>
  }
  
  /**
   * sets the tolerance
   * 
   * @param d	the new tolerance
   */
  public void setTolerance(double d) {
<span class="fc" id="L299">    m_fTolerance = d;</span>
<span class="fc" id="L300">  }</span>
  
  /**
   * Returns the tip text for this property
   * 
   * @return 		a description suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String useVariant1TipText() {
<span class="nc" id="L309">    return &quot;set true to use variant 1 of the paper, otherwise use variant 2.&quot;;</span>
  }
  
  /**
   * Whether variant 1 is used
   * 
   * @return		true if variant 1 is used
   */
  public boolean isUseVariant1() {
<span class="nc" id="L318">    return m_bUseVariant1;</span>
  }
  
  /**
   * Sets whether to use variant 1
   * 
   * @param b		if true then variant 1 is used
   */
  public void setUseVariant1(boolean b) {
<span class="fc" id="L327">    m_bUseVariant1 = b;</span>
<span class="fc" id="L328">  }</span>
  
  /** 
   * takeStep method from Shevade et al.s paper.
   * parameters correspond to pseudocode from paper.
   * 
   * @param i1
   * @param i2
   * @param alpha2
   * @param alpha2Star
   * @param phi2
   * @return
   * @throws Exception
   */
  protected int takeStep(int i1, int i2, double alpha2, double alpha2Star, double phi2) throws Exception {
    //procedure takeStep(i1, i2)
    //
    //  if (i1 == i2) 
    //    return 0 
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">    if (i1 == i2) {</span>
<span class="nc" id="L348">      return 0;</span>
    }
<span class="fc" id="L350">    double C1 = m_C * m_data.instance(i1).weight();</span>
<span class="fc" id="L351">    double C2 = m_C * m_data.instance(i2).weight();</span>
    //  alpha1, alpha1' = Lagrange multipliers for i1 
<span class="fc" id="L353">    double alpha1 = m_alpha[i1];</span>
<span class="fc" id="L354">    double alpha1Star = m_alphaStar[i1];</span>
//  double y1 = m_target[i1];
    // TODO: verify we do not need to recompute m_error[i1] here
    // TODO: since m_error is only updated for indices in m_I0
<span class="fc" id="L358">    double phi1 = m_error[i1];</span>
//  if ((m_iSet[i1] &amp; I0)==0) {
//  phi1 = -SVMOutput(i1) - m_b + m_target[i1];
//  m_error[i1] = phi1;
//  }
    //  k11 = kernel(point[i1], point[i1]) 
    //  k12 = kernel(point[i1], point[i2]) 
    //  k22 = kernel(point[i2], point[i2]) 
    //  eta = -2*k12+k11+k22 
    //  gamma = alpha1-alpha1'+alpha2-alpha2'
    //
<span class="fc" id="L369">    double k11 = m_kernel.eval(i1, i1, m_data.instance(i1));</span>
<span class="fc" id="L370">    double k12 = m_kernel.eval(i1, i2, m_data.instance(i1));</span>
<span class="fc" id="L371">    double k22 = m_kernel.eval(i2, i2, m_data.instance(i2));</span>
<span class="fc" id="L372">    double eta = -2 * k12 + k11 + k22;</span>
<span class="fc" id="L373">    double gamma = alpha1 - alpha1Star + alpha2 - alpha2Star;</span>
//  if (eta &lt; 0) {
    // this may happen due to numeric instability
    // due to Mercer's condition, this should not happen, hence we give up
//  return 0;
//  }
    //  % We assume that eta &gt; 0. Otherwise one has to repeat the complete 
    //  % reasoning similarly (i.e. compute objective functions at L and H 
    //  % and decide which one is largest
    //
    //  case1 = case2 = case3 = case4 = finished = 0 
    //  alpha1old = alpha1, 
    //  alpha1old' = alpha1' 
    //  alpha2old = alpha2, 
    //  alpha2old' = alpha2' 
    //  deltaphi = F1 - F2 
    //
    
    //  while !finished
    //    % This loop is passed at most three times 
    //    % Case variables needed to avoid attempting small changes twice 
    //    if (case1 == 0) &amp;&amp;
    //       (alpha1 &gt; 0 || (alpha1' == 0 &amp;&amp; deltaphi &gt; 0)) &amp;&amp; 
    //       (alpha2 &gt; 0 || (alpha2' == 0 &amp;&amp; deltaphi &lt; 0))
    //        compute L, H (w.r.t. alpha1, alpha2) 
    //        if (L &lt; H)
    //          a2 = alpha2 - (deltaphi / eta ) a2 = min(a2, H) a2 = max(L, a2) a1 = alpha1 - (a2 - alpha2) 
    //          update alpha1, alpha2 if change is larger than some eps 
    //        else
    //          finished = 1 
    //        endif 
    //      case1 = 1 
    //    elseif (case2 == 0) &amp;&amp;
    //           (alpha1 &gt; 0 || (alpha1' == 0 &amp;&amp; deltaphi &gt; 2*epsilon)) &amp;&amp; 
    //           (alpha2' &gt; 0 || (alpha2 == 0 &amp;&amp; deltaphi &gt; 2*epsilon))
    //
    //        compute L, H (w.r.t. alpha1, alpha2') 
    //        if (L &lt; H)
    //          a2 = alpha2' + ((deltaphi - 2*epsilon)/eta)) a2 = min(a2, H) a2 = max(L, a2) a1 = alpha1 + (a2-alpha2') 
    //          update alpha1, alpha2' if change is larger than some eps 
    //        else
    //          finished = 1 
    //        endif 
    //        case2 = 1 
    //    elseif (case3 == 0) &amp;&amp;
    //           (alpha1' &gt; 0 || (alpha1 == 0 &amp;&amp; deltaphi &lt; -2*epsilon)) &amp;&amp; 
    //           (alpha2 &gt; 0 || (alpha2' == 0 &amp;&amp; deltaphi &lt; -2*epsilon))
    //         compute L, H (w.r.t. alpha1', alpha2) 
    //         if (L &lt; H)
    //           a2 = alpha2 - ((deltaphi + 2*epsilon)/eta) a2 = min(a2, H) a2 = max(L, a2) a1 = alpha1' + (a2 - alpha2) 
    //           update alpha1', alpha2 if change is larger than some eps 
    //         else
    //           finished = 1 
    //         endif 
    //         case3 = 1 
    //    elseif (case4 == 0) &amp;&amp;
    //           (alpha1' &gt; 0) || (alpha1 == 0 &amp;&amp; deltaphi &lt; 0)) &amp;&amp; 
    //           (alpha2' &gt; 0) || (alpha2 == 0 &amp;&amp; deltaphi &gt; 0))
    //         compute L, H (w.r.t. alpha1', alpha2') 
    //         if (L &lt; H) 
    //           a2 = alpha2' + deltaphi/eta a2 = min(a2, H) a2 = max(L, a2) a1 = alpha1' - (a2 - alpha2') 
    //           update alpha1, alpha2' if change is larger than some eps 
    //         else
    //           finished = 1 
    //         endif 
    //         case4 = 1 
    //    else
    //      finished = 1 
    //    endif 
    //    update deltaphi 
    //  endwhile 
    
<span class="fc" id="L445">    double alpha1old = alpha1;</span>
<span class="fc" id="L446">    double alpha1Starold = alpha1Star;</span>
<span class="fc" id="L447">    double alpha2old = alpha2;</span>
<span class="fc" id="L448">    double alpha2Starold = alpha2Star;</span>
<span class="fc" id="L449">    double deltaPhi = phi1 - phi2;</span>
    
<span class="fc bfc" id="L451" title="All 2 branches covered.">    if (findOptimalPointOnLine(i1, alpha1, alpha1Star, C1, i2, alpha2, alpha2Star, C2, gamma, eta, deltaPhi)) {</span>
      
<span class="fc" id="L453">      alpha1 = m_alpha[i1];</span>
<span class="fc" id="L454">      alpha1Star = m_alphaStar[i1];</span>
<span class="fc" id="L455">      alpha2 = m_alpha[i2];</span>
<span class="fc" id="L456">      alpha2Star = m_alphaStar[i2];</span>
      
      //  if changes in alpha('), alpha2(') are larger than some eps
      //    Update f-cache[i] for i in I.0 using new Lagrange multipliers 
      //    Store the changes in alpha, alpha' array 
      //    Update I.0, I.1, I.2, I.3 
      //    Compute (i.low, b.low) and (i.up, b.up) by applying the conditions mentioned above, using only i1, i2 and indices in I.0 
      //    return 1 
      //  else
      //    return 0
      //endif endprocedure
      
      //		Update error cache using new Lagrange multipliers 
<span class="fc" id="L469">      double dAlpha1 = alpha1 - alpha1old - (alpha1Star - alpha1Starold);</span>
<span class="fc" id="L470">      double dAlpha2 = alpha2 - alpha2old - (alpha2Star - alpha2Starold);</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">      for (int j = m_I0.getNext(-1); j != -1; j = m_I0.getNext(j)) {</span>
<span class="fc bfc" id="L472" title="All 4 branches covered.">	if ((j != i1) &amp;&amp; (j != i2)) {</span>
<span class="fc" id="L473">	  m_error[j] -= dAlpha1 * m_kernel.eval(i1, j, m_data.instance(i1)) </span>
<span class="fc" id="L474">	  + dAlpha2 * m_kernel.eval(i2, j, m_data.instance(i2));</span>
	}
      }
<span class="fc" id="L477">      m_error[i1] -= dAlpha1 * k11 + dAlpha2 * k12;</span>
<span class="fc" id="L478">      m_error[i2] -= dAlpha1 * k12 + dAlpha2 * k22;</span>
      
<span class="fc" id="L480">      updateIndexSetFor(i1, C1);</span>
<span class="fc" id="L481">      updateIndexSetFor(i2, C2);</span>
      
      //    Compute (i.low, b.low) and (i.up, b.up) by applying the conditions mentioned above, using only i1, i2 and indices in I.0 
<span class="fc" id="L484">      m_bUp = Double.MAX_VALUE; </span>
<span class="fc" id="L485">      m_bLow = -Double.MAX_VALUE; </span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">      for (int j = m_I0.getNext(-1); j != -1; j = m_I0.getNext(j)) {</span>
<span class="fc" id="L487">	updateBoundaries(j, m_error[j]);</span>
      }
<span class="fc bfc" id="L489" title="All 2 branches covered.">      if (!m_I0.contains(i1)) {</span>
<span class="fc" id="L490">	updateBoundaries(i1, m_error[i1]);</span>
      }
<span class="fc bfc" id="L492" title="All 2 branches covered.">      if (!m_I0.contains(i2)) {</span>
<span class="fc" id="L493">	updateBoundaries(i2, m_error[i2]);</span>
      }
      
<span class="fc" id="L496">      return 1;</span>
    } 
    else {
<span class="fc" id="L499">      return 0;</span>
    }
  }
  
  /**
   * updates the index sets I0a, IOb, I1, I2 and I3 for vector i
   * 
   * @param i index of vector
   * @param C capacity for vector i
   * @throws Exception
   */
  protected void updateIndexSetFor(int i, double C) throws Exception {
    /*
     m_I0a.delete(i);
     m_I0b.delete(i);
     m_I1.delete(i);
     m_I2.delete(i);
     m_I3.delete(i);
     */
<span class="fc bfc" id="L518" title="All 4 branches covered.">    if (m_alpha[i] == 0 &amp;&amp; m_alphaStar[i] == 0) {</span>
      //m_I1.insert(i);
<span class="fc" id="L520">      m_iSet[i] = I1;</span>
<span class="fc" id="L521">      m_I0.delete(i);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">    } else if (m_alpha[i] &gt; 0) {</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">      if (m_alpha[i] &lt; C) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">	if ((m_iSet[i] &amp; I0) == 0) {</span>
	  //m_error[i] = -SVMOutput(i) - m_b + m_target[i];
<span class="fc" id="L526">	  m_I0.insert(i);</span>
	}
	//m_I0a.insert(i);
<span class="fc" id="L529">	m_iSet[i] = I0a;</span>
      } else { // m_alpha[i] == C
	//m_I3.insert(i);
<span class="fc" id="L532">	m_iSet[i] = I3;</span>
<span class="fc" id="L533">	m_I0.delete(i);</span>
      }
    } else {// m_alphaStar[i] &gt; 0 
<span class="fc bfc" id="L536" title="All 2 branches covered.">      if (m_alphaStar[i] &lt; C) {</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">	if ((m_iSet[i] &amp; I0) == 0) {</span>
	  //m_error[i] = -SVMOutput(i) - m_b + m_target[i];
<span class="fc" id="L539">	  m_I0.insert(i);</span>
	}
	//m_I0b.insert(i);
<span class="fc" id="L542">	m_iSet[i] = I0b;</span>
      } else { // m_alpha[i] == C
	//m_I2.insert(i);
<span class="fc" id="L545">	m_iSet[i] = I2;</span>
<span class="fc" id="L546">	m_I0.delete(i);</span>
      }
    }
<span class="fc" id="L549">  }</span>
  
  /**
   * updates boundaries bLow and bHi and corresponding indexes
   * 
   * @param i2 index of vector
   * @param F2 error of vector i2
   */
  protected void updateBoundaries(int i2, double F2) {		
<span class="fc" id="L558">    int iSet = m_iSet[i2];</span>
    
<span class="fc" id="L560">    double FLow = m_bLow;</span>
<span class="fc bfc" id="L561" title="All 2 branches covered.">    if ((iSet &amp; (I2 | I0b)) &gt; 0) {</span>
<span class="fc" id="L562">      FLow = F2 + m_epsilon;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">    } else if ((iSet &amp; (I1 | I0a)) &gt; 0) {</span>
<span class="fc" id="L564">      FLow = F2 - m_epsilon;</span>
    }
<span class="fc bfc" id="L566" title="All 2 branches covered.">    if (m_bLow &lt; FLow) {</span>
<span class="fc" id="L567">      m_bLow = FLow;</span>
<span class="fc" id="L568">      m_iLow = i2;</span>
    }
<span class="fc" id="L570">    double FUp = m_bUp;</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">    if ((iSet &amp; (I3 | I0a)) &gt; 0) {</span>
<span class="fc" id="L572">      FUp = F2 - m_epsilon;</span>
<span class="fc bfc" id="L573" title="All 2 branches covered.">    } else if ((iSet &amp; (I1 | I0b)) &gt; 0) {</span>
<span class="fc" id="L574">      FUp = F2 + m_epsilon;</span>
    }
<span class="fc bfc" id="L576" title="All 2 branches covered.">    if (m_bUp &gt; FUp) {</span>
<span class="fc" id="L577">      m_bUp = FUp;</span>
<span class="fc" id="L578">      m_iUp = i2;</span>
    }
<span class="fc" id="L580">  }</span>
  
  /** 
   * parameters correspond to pseudocode from paper.
   * 
   * @param i2 index of  candidate
   * @return
   * @throws Exception
   */
  protected int examineExample(int i2) throws Exception {
    //procedure examineExample(i2)
    //
    //  alpha2, alpha2' = Lagrange multipliers for i2 
<span class="fc" id="L593">    double alpha2 = m_alpha[i2];</span>
<span class="fc" id="L594">    double alpha2Star = m_alphaStar[i2];</span>
    
    //  if (i2 is in I.0)
    //    F2 = f-cache[i2] 
    //  else
    //    compute F2 = F.i2 and set f-cache[i2] = F2 
    //    % Update (b.low, i.low) or (b.up, i.up) using (F2, i2)... 
    //    if (i2 is in I.1)
    //      if (F2+epsilon &lt; b.up)
    //        b.up = F2+epsilon, 
    //        i.up = i2 
    //      elseif (F2-epsilon &gt; b.low)
    //        b.low = F2-epsilon, 
    //        i.low = i2 
    //      end if 
    //    elseif ( (i2 is in I.2) &amp;&amp; (F2+epsilon &gt; b.low) )
    //      b.low = F2+epsilon, 
    //      i.low = i2 
    //    elseif ( (i2 is in I.3) &amp;&amp; (F2-epsilon &lt; b.up) )
    //      b.up = F2-epsilon, 
    //      i.up = i2 
    //    endif 
    //  endif 
    
<span class="fc" id="L618">    int iSet = m_iSet[i2];</span>
<span class="fc" id="L619">    double F2 = m_error[i2];</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">    if (!m_I0.contains(i2)) {</span>
<span class="fc" id="L621">      F2 = -SVMOutput(i2) - m_b + m_target[i2];</span>
<span class="fc" id="L622">      m_error[i2] = F2;</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">      if (iSet == I1) {</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">	if (F2 + m_epsilon &lt; m_bUp) {</span>
<span class="fc" id="L625">	  m_bUp = F2 + m_epsilon;</span>
<span class="fc" id="L626">	  m_iUp = i2;</span>
<span class="fc bfc" id="L627" title="All 2 branches covered.">	} else if (F2 - m_epsilon &gt; m_bLow) {</span>
<span class="fc" id="L628">	  m_bLow = F2 - m_epsilon;</span>
<span class="fc" id="L629">	  m_iLow = i2;</span>
	} 
<span class="fc bfc" id="L631" title="All 4 branches covered.">      } else if ((iSet == I2) &amp;&amp; (F2 + m_epsilon &gt; m_bLow)) {</span>
<span class="fc" id="L632">	m_bLow = F2 + m_epsilon;</span>
<span class="fc" id="L633">	m_iLow = i2;</span>
<span class="fc bfc" id="L634" title="All 4 branches covered.">      } else if ((iSet == I3) &amp;&amp; (F2 - m_epsilon &lt; m_bUp)) {</span>
<span class="fc" id="L635">	m_bUp = F2 - m_epsilon;</span>
<span class="fc" id="L636">	m_iUp = i2;</span>
      }
    }
    
    //  % Check optimality using current b.low and b.up and, if 
    //  % violated, find an index i1 to do joint optimization with i2... 
    //  optimality = 1;
    //  case 1: i2 is in I.0a
    //    if (b.low-(F2-epsilon) &gt; 2 * tol)
    //      optimality = 0;  
    //      i1 = i.low; 
    //      % For i2 in I.0a choose the better i1... 
    //      if ((F2-epsilon)-b.up &gt; b.low-(F2-epsilon))
    //        i1 = i.up; 
    //      endif 
    //    elseif ((F2-epsilon)-b.up &gt; 2 * tol)
    //      optimality = 0; 
    //      i1 = i.up; 
    //      % For i2 in I.0a choose the better i1... 
    //      if ((b.low-(F2-epsilon) &gt; (F2-epsilon)-b.up)
    //        i1 = i.low; 
    //      endif 
    //    endif 
    //  case 2: i2 is in I.0b
    //    if (b.low-(F2+epsilon) &gt; 2 * tol)
    //      optimality = 0; 
    //      i1 = i.low; 
    //      % For i2 in I.0b choose the better i1... 
    //      if ((F2+epsilon)-b.up &gt; b.low-(F2+epsilon))
    //        i1 = i.up; 
    //      endif 
    //    elseif ((F2+epsilon)-b.up &gt; 2 * tol)
    //      optimality = 0; 
    //      i1 = i.up; 
    //      % For i2 in I.0b choose the better i1... 
    //      if ((b.low-(F2+epsilon) &gt; (F2+epsilon)-b.up)
    //        i1 = i.low; 
    //      endif 
    //    endif 
    //  case 3: i2 is in I.1
    //    if (b.low-(F2+epsilon) &gt; 2 * tol)
    //      optimality = 0; 
    //      i1 = i.low; 
    //      % For i2 in I1 choose the better i1... 
    //      if ((F2+epsilon)-b.up &gt; b.low-(F2+epsilon)
    //        i1 = i.up; 
    //      endif 
    //    elseif ((F2-epsilon)-b.up &gt; 2 * tol)
    //      optimality = 0; 
    //      i1 = i.up; 
    //      % For i2 in I1 choose the better i1... 
    //      if (b.low-(F2-epsilon) &gt; (F2-epsilon)-b.up)
    //        i1 = i.low; 
    //      endif 
    //    endif 
    //  case 4: i2 is in I.2
    //    if ((F2+epsilon)-b.up &gt; 2*tol)
    //      optimality = 0, 
    //      i1 = i.up 
    //     endif 
    //  case 5: i2 is in I.3
    //    if ((b.low-(F2-epsilon) &gt; 2*tol)
    //      optimality = 0, i1 = i.low 
    //    endif
    
<span class="fc" id="L701">    int i1 = i2;</span>
<span class="fc" id="L702">    boolean bOptimality = true;</span>
    //case 1: i2 is in I.0a
<span class="fc bfc" id="L704" title="All 2 branches covered.">    if (iSet == I0a) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">      if (m_bLow - (F2 - m_epsilon) &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L706">	bOptimality = false;</span>
<span class="fc" id="L707">	i1 = m_iLow;</span>
	//% For i2 in I .0 a choose the better i1...
<span class="fc bfc" id="L709" title="All 2 branches covered.">	if ((F2 - m_epsilon) - m_bUp &gt; m_bLow - (F2 - m_epsilon)) {</span>
<span class="fc" id="L710">	  i1 = m_iUp;</span>
	}
<span class="fc bfc" id="L712" title="All 2 branches covered.">      } else if ((F2 - m_epsilon) - m_bUp &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L713">	bOptimality = false;</span>
<span class="fc" id="L714">	i1 = m_iUp;</span>
	//% For i2 in I.0a choose the better i1... 
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">	if (m_bLow - (F2 - m_epsilon) &gt; (F2 - m_epsilon) - m_bUp) {</span>
<span class="nc" id="L717">	  i1 = m_iLow;</span>
	}
      }
    } // case 2: i2 is in I.0b
<span class="fc bfc" id="L721" title="All 2 branches covered.">    else if (iSet == I0b) {</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">      if (m_bLow - (F2 + m_epsilon) &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L723">	bOptimality = false;</span>
<span class="fc" id="L724">	i1 = m_iLow; // % For i2 in I.0b choose the better i1... </span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">	if ((F2 + m_epsilon) - m_bUp &gt; m_bLow - (F2 + m_epsilon)) {</span>
<span class="fc" id="L726">	  i1 = m_iUp;</span>
	}
<span class="fc bfc" id="L728" title="All 2 branches covered.">      } else if ((F2 + m_epsilon) - m_bUp &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L729">	bOptimality = false;</span>
<span class="fc" id="L730">	i1 = m_iUp; // % For i2 in I.0b choose the better i1... </span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">	if (m_bLow - (F2 + m_epsilon) &gt; (F2 + m_epsilon) - m_bUp) {</span>
<span class="nc" id="L732">	  i1 = m_iLow;</span>
	}
      }
    } // case 3: i2 is in I.1
<span class="fc bfc" id="L736" title="All 2 branches covered.">    else if (iSet == I1) {</span>
<span class="fc bfc" id="L737" title="All 2 branches covered.">      if (m_bLow - (F2 + m_epsilon) &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L738">	bOptimality = false;</span>
<span class="fc" id="L739">	i1 = m_iLow;</span>
	//% For i2 in I1 choose the better i1...
<span class="fc bfc" id="L741" title="All 2 branches covered.">	if ((F2 + m_epsilon) - m_bUp &gt; m_bLow - (F2 + m_epsilon)) {</span>
<span class="fc" id="L742">	  i1 = m_iUp;</span>
	}
<span class="fc bfc" id="L744" title="All 2 branches covered.">      } else if ((F2 - m_epsilon) - m_bUp &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L745">	bOptimality = false;</span>
<span class="fc" id="L746">	i1 = m_iUp; // % For i2 in I1 choose the better i1... </span>
<span class="fc bfc" id="L747" title="All 2 branches covered.">	if (m_bLow - (F2 - m_epsilon) &gt; (F2 - m_epsilon) - m_bUp) {</span>
<span class="fc" id="L748">	  i1 = m_iLow;</span>
	}
      }
    } //case 4: i2 is in I.2
<span class="fc bfc" id="L752" title="All 2 branches covered.">    else if (iSet == I2) {</span>
<span class="fc bfc" id="L753" title="All 2 branches covered.">      if ((F2 + m_epsilon) - m_bUp &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L754">	bOptimality = false;</span>
<span class="fc" id="L755">	i1 = m_iUp;</span>
      }
    } //case 5: i2 is in I.3
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">    else if (iSet == I3) {</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">      if (m_bLow - (F2 - m_epsilon) &gt; 2 * m_fTolerance) {</span>
<span class="fc" id="L760">	bOptimality = false;</span>
<span class="fc" id="L761">	i1 = m_iLow;</span>
      }
    }
    // if (optimality == 1) 
    //    return 0
    //  if (takeStep(i1, i2))
    //    return 1 
    //   else
    //    return 0 
    //  endif 
    //endprocedure
<span class="fc bfc" id="L772" title="All 2 branches covered.">    if (bOptimality) {</span>
<span class="fc" id="L773">      return 0;</span>
    }
<span class="fc" id="L775">    return takeStep(i1, i2, m_alpha[i2], m_alphaStar[i2], F2);</span>
  }
  
  /** 
   * initialize various variables before starting the actual optimizer 
   * 
   * @param data 	data set used for learning
   * @throws Exception	if something goes wrong
   */
  protected void init(Instances data) throws Exception {
<span class="fc" id="L785">    super.init(data);</span>
    // from Keerthi's pseudo code:
    //  set alpha and alpha' to zero for every example set I.1 to contain all the examples 
    //  Choose any example i from the training set. 
    //  set b.up = target[i]+epsilon 
    //  set b.low = target[i]-espilon 
    //  i.up = i.low = i; 
    // Initialize sets
<span class="fc" id="L793">    m_I0 = new SMOset(m_data.numInstances());</span>
<span class="fc" id="L794">    m_iSet = new int [m_data.numInstances()];</span>
<span class="fc bfc" id="L795" title="All 2 branches covered.">    for (int i = 0; i &lt; m_nInstances; i++) {</span>
<span class="fc" id="L796">      m_iSet[i] = I1;</span>
    }
    // m_iUp = m_random.nextInt(m_nInstances);
<span class="fc" id="L799">    m_iUp = 0;</span>
<span class="fc" id="L800">    m_bUp = m_target[m_iUp] + m_epsilon;</span>
<span class="fc" id="L801">    m_iLow = m_iUp;</span>
<span class="fc" id="L802">    m_bLow = m_target[m_iLow] - m_epsilon;</span>
    //init error cache
<span class="fc" id="L804">    m_error = new double[m_nInstances];</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">    for (int i = 0; i &lt; m_nInstances; i++) {</span>
<span class="fc" id="L806">      m_error[i] = m_target[i];</span>
    }
<span class="fc" id="L808">  }</span>
  
  /** 
   * use variant 1 of Shevade's et al.s paper
   * 
   * @throws Exception	if something goes wrong
   */
  protected void optimize1() throws Exception {
    //% main routine for modification 1 procedure main
    //  while (numChanged &gt; 0 || examineAll)
    //    numChanged = 0; 
<span class="fc" id="L819">    int nNumChanged = 0;</span>
<span class="fc" id="L820">    boolean bExamineAll = true;</span>
    //  while (numChanged &gt; 0 || examineAll)
    //    numChanged = 0; 
<span class="fc bfc" id="L823" title="All 4 branches covered.">    while (nNumChanged &gt; 0 || bExamineAll) {</span>
<span class="fc" id="L824">      nNumChanged = 0;</span>
      //    if (examineAll)
      //      loop I over all the training examples
      //        numChanged += examineExample(I) 
      //    else
      //      loop I over I.0
      //        numChanged += examineExample(I) 
      //        % It is easy to check if optimality on I.0 is attained... 
      //        if (b.up &gt; b.low - 2*tol) at any I
      //          exit the loop after setting numChanged = 0 
      //        endif 
<span class="fc bfc" id="L835" title="All 2 branches covered.">      if (bExamineAll) {</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">	for (int i = 0; i &lt; m_nInstances; i++) {</span>
<span class="fc" id="L837">	  nNumChanged += examineExample(i);</span>
	}
      } else {
<span class="fc bfc" id="L840" title="All 2 branches covered.">	for (int i = m_I0.getNext(-1); i != -1; i = m_I0.getNext(i)) {</span>
	  
<span class="fc" id="L842">	  nNumChanged += examineExample(i);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">	  if (m_bLow - m_bUp &lt; 2 * m_fTolerance) {</span>
<span class="fc" id="L844">	    nNumChanged = 0;</span>
<span class="fc" id="L845">	    break;</span>
	  }
	}
      } //    if (examineAll == 1)
      //      examineAll = 0; 
      //    elseif (numChanged == 0)
      //      examineAll = 1;
      //    endif 
      //  endwhile 
      //endprocedure
<span class="fc bfc" id="L855" title="All 2 branches covered.">      if (bExamineAll) {</span>
<span class="fc" id="L856">	bExamineAll = false;</span>
<span class="fc bfc" id="L857" title="All 2 branches covered.">      } else if (nNumChanged == 0) {</span>
<span class="fc" id="L858">	bExamineAll = true;</span>
      }
    }
<span class="fc" id="L861">  }</span>
  
  /** 
   * use variant 2 of Shevade's et al.s paper 
   * 
   * @throws Exception	if something goes wrong
   */
  protected void optimize2() throws Exception {
    //% main routine for modification 2 procedure main
<span class="nc" id="L870">    int nNumChanged = 0;</span>
<span class="nc" id="L871">    boolean bExamineAll = true;</span>
    //  while (numChanged &gt; 0 || examineAll)
    //    numChanged = 0; 
<span class="nc bnc" id="L874" title="All 4 branches missed.">    while (nNumChanged &gt; 0 || bExamineAll) {</span>
<span class="nc" id="L875">      nNumChanged = 0;</span>
      //    if (examineAll)
      //      loop I over all the training examples
      //        numChanged += examineExample(I) 
      //    else
      //      % The following loop is the only difference between the two 
      //      % SMO modifications. Whereas, modification 1, the type II 
      //      % loop selects i2 fro I.0 sequentially, here i2 is always 
      //      % set to the current i.low and i1 is set to the current i.up; 
      //      % clearly, this corresponds to choosing the worst violating 
      //      % pair using members of I.0 and some other indices
      //      inner.loop.success = 1; 
      //      do
      //        i2 = i.low 
      //	      alpha2, alpha2' = Lagrange multipliers for i2 
      //	      F2 = f-cache[i2] 
      //	      i1 = i.up 
      //	      inner.loop.success = takeStep(i.up, i.low) 
      //	      numChanged += inner.loop.success 
      //      until ( (b.up &gt; b.low - 2*tol) || inner.loop.success == 0) 
      //      numChanged = 0; 
      //    endif 
<span class="nc bnc" id="L897" title="All 2 branches missed.">      if (bExamineAll) {</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">	for (int i = 0; i &lt; m_nInstances; i++) {</span>
<span class="nc" id="L899">	  nNumChanged += examineExample(i);</span>
	}
      } else {
<span class="nc" id="L902">	boolean bInnerLoopSuccess = true;</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">	do {</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">	  if (takeStep(m_iUp, m_iLow, m_alpha[m_iLow], m_alphaStar[m_iLow], m_error[m_iLow]) &gt; 0) {</span>
<span class="nc" id="L905">	    bInnerLoopSuccess = true;</span>
<span class="nc" id="L906">	    nNumChanged += 1;</span>
	  } else {
<span class="nc" id="L908">	    bInnerLoopSuccess = false;</span>
	  }
<span class="nc bnc" id="L910" title="All 2 branches missed.">	} while ((m_bUp &lt;= m_bLow - 2 * m_fTolerance) &amp;&amp; bInnerLoopSuccess);</span>
<span class="nc" id="L911">	nNumChanged = 0;</span>
      } //
      //    if (examineAll == 1)
      //      examineAll = 0 
      //    elseif (numChanged == 0)
      //      examineAll = 1 
      //    endif 
      //  endwhile 
      //endprocedure
      //
<span class="nc bnc" id="L921" title="All 2 branches missed.">      if (bExamineAll) {</span>
<span class="nc" id="L922">	bExamineAll = false;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">      } else if (nNumChanged == 0) {</span>
<span class="nc" id="L924">	bExamineAll = true;</span>
      }
    }
<span class="nc" id="L927">  }</span>
  
  /** 
   * wrap up various variables to save memeory and do some housekeeping after optimization
   * has finished.
   *
   * @throws Exception 	if something goes wrong
   */
  protected void wrapUp() throws Exception {
<span class="fc" id="L936">    m_b = -(m_bLow + m_bUp) / 2.0;</span>
<span class="fc" id="L937">    m_target = null;</span>
<span class="fc" id="L938">    m_error = null;</span>
<span class="fc" id="L939">    super.wrapUp();</span>
<span class="fc" id="L940">  }</span>
  
  /** 
   * learn SVM parameters from data using Keerthi's SMO algorithm.
   * Subclasses should implement something more interesting.
   * 
   * @param instances	the data to work with
   * @throws Exception	if something goes wrong
   */
  public void buildClassifier(Instances instances) throws Exception {
    // initialize variables		
<span class="fc" id="L951">    init(instances); </span>

    // solve optimization problem
<span class="pc bpc" id="L954" title="1 of 2 branches missed.">    if (m_bUseVariant1) {</span>
<span class="fc" id="L955">      optimize1();</span>
    } else {
<span class="nc" id="L957">      optimize2();</span>
    } 
    
    // clean up
<span class="fc" id="L961">    wrapUp();</span>
<span class="fc" id="L962">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L970">    return RevisionUtils.extract(&quot;$Revision: 1.4 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>