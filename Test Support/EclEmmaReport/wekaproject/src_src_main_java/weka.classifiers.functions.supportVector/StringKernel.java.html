<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>StringKernel.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.functions.supportVector</a> &gt; <span class="el_source">StringKernel.java</span></div><h1>StringKernel.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * StringKernel.java
 * 
 * Copyright (C) 2006 University of Waikato, Hamilton, New Zealand
 */

package weka.classifiers.functions.supportVector;

import weka.core.Attribute;
import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.RevisionUtils;
import weka.core.SelectedTag;
import weka.core.Tag;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;

import java.util.Enumeration;
import java.util.Vector;

/**
 &lt;!-- globalinfo-start --&gt;
 * Implementation of the subsequence kernel (SSK) as described in [1] and of the subsequence kernel with lambda pruning (SSK-LP) as described in [2].&lt;br/&gt;
 * &lt;br/&gt;
 * For more information, see&lt;br/&gt;
 * &lt;br/&gt;
 * Huma Lodhi, Craig Saunders, John Shawe-Taylor, Nello Cristianini, Christopher J. C. H. Watkins (2002). Text Classification using String Kernels. Journal of Machine Learning Research. 2:419-444.&lt;br/&gt;
 * &lt;br/&gt;
 * F. Kleedorfer, A. Seewald (2005). Implementation of a String Kernel for WEKA. Wien, Austria.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;article{Lodhi2002,
 *    author = {Huma Lodhi and Craig Saunders and John Shawe-Taylor and Nello Cristianini and Christopher J. C. H. Watkins},
 *    journal = {Journal of Machine Learning Research},
 *    pages = {419-444},
 *    title = {Text Classification using String Kernels},
 *    volume = {2},
 *    year = {2002},
 *    HTTP = {http://www.jmlr.org/papers/v2/lodhi02a.html}
 * }
 * 
 * &amp;#64;techreport{Kleedorfer2005,
 *    address = {Wien, Austria},
 *    author = {F. Kleedorfer and A. Seewald},
 *    institution = {Oesterreichisches Forschungsinstitut fuer Artificial Intelligence},
 *    number = {TR-2005-13},
 *    title = {Implementation of a String Kernel for WEKA},
 *    year = {2005}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 * 
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  Enables debugging output (if available) to be printed.
 *  (default: off)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -no-checks
 *  Turns off all checks - use with caution!
 *  (default: checks on)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -P &amp;lt;0|1&amp;gt;
 *  The pruning method to use:
 *  0 = No pruning
 *  1 = Lambda pruning
 *  (default: 0)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C &amp;lt;num&amp;gt;
 *  The size of the cache (a prime number).
 *  (default: 250007)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -IC &amp;lt;num&amp;gt;
 *  The size of the internal cache (a prime number).
 *  (default: 200003)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -L &amp;lt;num&amp;gt;
 *  The lambda constant. Penalizes non-continuous subsequence
 *  matches. Must be in (0,1).
 *  (default: 0.5)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -ssl &amp;lt;num&amp;gt;
 *  The length of the subsequence.
 *  (default: 3)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -ssl-max &amp;lt;num&amp;gt;
 *  The maximum length of the subsequence.
 *  (default: 9)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N
 *  Use normalization.
 *  (default: no)&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 * 
 * &lt;h1&gt;Theory&lt;/h1&gt;
 * &lt;h2&gt;Overview&lt;/h2&gt;
 * The algorithm computes a measure of similarity between two texts based on
 * the number and form of their common subsequences, which need not be
 * contiguous. This method can be parametrized by specifying the subsequence
 * length k, the penalty factor lambda, which penalizes non-contiguous matches,
 * and optional 'lambda pruning', which takes maxLambdaExponent,
 * &lt;code&gt;m&lt;/code&gt;, as parameter. Lambda pruning causes very 'stretched'
 * substring matches not to be counted, thus speeding up the computation. The
 * functionality of SSK and SSK-LP is explained in the following using simple
 * examples.
 * 
 * &lt;h2&gt;Explanation &amp;amp; Examples&lt;/h2&gt;
 * for all of the following examples, we assume these parameter values: 
 *&lt;pre&gt; 
 *k=2
 *lambda=0.5
 *m=8 (for SSK-LP examples)
 *&lt;/pre&gt;
 * 
 * &lt;h3&gt;SSK&lt;/h3&gt;
 * 
 * &lt;h4&gt;Example 1&lt;/h4&gt;
 * 
 * &lt;pre&gt;
 *SSK(2,&quot;ab&quot;,&quot;axb&quot;)=0.5^5 = 0,03125
 *&lt;/pre&gt;
 * There is one subsequence of the length of 2 that both strings have in
 * common, &quot;ab&quot;.  The result of SSK is computed by raising lambda to the power
 * of L, where L is the length of the subsequence match in the one string plus
 * the length of the subsequence match in the other, in our case:
 * &lt;pre&gt;
 *&amp;nbsp;  ab    axb
 *L= 2  +   3 = 5
 * &lt;/pre&gt;
 * hence, the kernel yields 0.5^5 = 0,03125
 *
 * &lt;h4&gt;Example 2&lt;/h4&gt;
 * &lt;pre&gt;
 *SSK(2,&quot;ab&quot;,&quot;abb&quot;)=0.5^5 + 0.5^4 = 0,09375
 *&lt;/pre&gt;
 * Here, we also have one subsequence of the length of 2 that both strings have
 * in common, &quot;ab&quot;.  The result of SSK is actually computed by summing over all
 * values computed for each occurrence of a common subsequence match. In this
 * example, there are two possible cases:
 * &lt;pre&gt;
 *ab    abb
 *--    --  L=4
 *--    - - L=5
 * &lt;/pre&gt;
 * we have two matches, one of the length of 2+2=4, one of the length of 2+3=5, 
 * so we get the result 0.5^5 + 0.5^4 = 0,09375.
 *
 * &lt;h3&gt;SSK-LP&lt;/h3&gt;
 * Without lambda pruning, the string kernel finds *all* common subsequences of
 * the given length, whereas with lambda pruning, common subsequence matches
 * that are too much stretched in both strings are not taken into account. It
 * is argued that the value yielded for such a common subsequence is too low
 * (&lt;code&gt;lambda ^(length[match_in_s] + length[match_in_t]&lt;/code&gt;) . Tests have
 * shown that a tremendous speedup can be achieved using this technique while
 * suffering from very little quality loss. &lt;br&gt;
 * Lambda pruning is parametrized by the maximum lambda exponent. It is a good
 * idea to choose that value to be about 3 or 4 times the subsequence length as
 * a rule of thumb. YMMV.
 *
 * &lt;h4&gt;Example 3&lt;/h4&gt;
 * Without lambda pruning, one common subsequence, 
 * &quot;AB&quot; would be found in the following two strings. (With k=2)  
 * &lt;pre&gt;
 *SSK(2,&quot;ab&quot;,&quot;axb&quot;)=0.5^14 = 0,00006103515625
 *&lt;/pre&gt;
 * lambda pruning allows for the control of the match length. So, if m 
 * (the maximum lambda exponent) is e.g. 8, these two strings would 
 * yield a kernel value of 0:
 * &lt;pre&gt;
 *with lambda pruning:    SSK-LP(2,8,&quot;AxxxxxxxxxB&quot;,&quot;AyB&quot;)= 0
 *without lambda pruning: SSK(2,&quot;AxxxxxxxxxB&quot;,&quot;AyB&quot;)= 0.5^14 = 0,00006103515625  
 *&lt;/pre&gt;
 * This is because the exponent for lambda (=the length of the subsequence
 * match) would be 14, which is &amp;gt; 8. In Contrast, the next result is
 * &amp;gt; 0
 *&lt;pre&gt;
 *m=8
 *SSK-LP(2,8,&quot;AxxB&quot;,&quot;AyyB&quot;)=0.5^8 = 0,00390625
 *&lt;/pre&gt;
 * because the lambda exponent would be 8, which is just accepted by lambda
 * pruning.
 *
 * &lt;h3&gt;Normalization&lt;/h3&gt;
 * When the string kernel is used for its main purpose, as the kernel of a
 * support vector machine, it is not normalized.  The normalized kernel can be
 * switched on by -F (feature space normalization) but is much slower.  Like
 * most unnormalized kernels, K(x,x) is not a fixed value, see the next
 * example.
 *
 * &lt;h4&gt;Example 4&lt;/h4&gt; 
 *&lt;pre&gt;
 *SSK(2,&quot;ab&quot;,&quot;ab&quot;)=0.5^4 = 0.0625
 *SSK(2,&quot;AxxxxxxxxxB&quot;,&quot;AxxxxxxxxxB&quot;) = 12.761724710464478
 *&lt;/pre&gt;
 * SSK is evaluated twice, each time for two identical strings. A good measure
 * of similarity would produce the same value in both cases, which should  
 * indicate the same level of similarity. The value of the normalized SSK would
 * be 1.0 in both cases. So for the purpose of computing string similarity the
 * normalized kernel should be used. For SVM the unnormalized kernel is usually
 * sufficient.
 *
 * &lt;h2&gt;Complexity of SSK and SSK-LP&lt;/h2&gt;
 * The time complexity of this method (without lambda pruning and with an
 * infinitely large cache) is&lt;br&gt; 
 * &lt;pre&gt;O(k*|s|*|t|)&lt;/pre&gt;
 * Lambda Pruning has a complexity (without caching) of&lt;br&gt; 
 * &lt;pre&gt;O(m*binom(m,k)^2*(|s|+n)*|t|)&lt;/pre&gt; &lt;br&gt;  
 * &lt;pre&gt;
 *k...          subsequence length (ssl)
 *s,t...        strings
 *|s|...        length of string s
 *binom(x,y)... binomial coefficient (x!/[(x-y)!y!])
 *m...          maxLambdaExponent (ssl-max)
 *&lt;/pre&gt;
 * 
 * Keep in mind that execution time can increase fast for long strings 
 * and big values for k, especially if you don't use lambda pruning.
 * With lambda pruning, computation is usually so fast that switching
 * on the cache leads to slower computation because of setup costs. Therefore
 * caching is switched off for lambda pruning.
 * &lt;br&gt;
 * &lt;br&gt;
 * For details and qualitative experiments about SSK, see [1] &lt;br&gt;
 * For details about lambda pruning and performance comparison of SSK 
 * and SSK-LP (SSK with lambda pruning), see [2]   
 * Note that the complexity estimation in [2] assumes no caching of
 * intermediate results, which has been implemented in the meantime and
 * greatly improves the speed of the SSK without lambda pruning.
 *&lt;br&gt;
 *
 *&lt;h1&gt;Notes for usage within Weka&lt;/h1&gt;
 * Only instances of the following form can be processed using string kernels:
 * &lt;pre&gt;
 *+----------+-------------+---------------+
 *|attribute#|     0       |       1       |
 *+----------+-------------+---------------+
 *| content  | [text data] | [class label] |
 *+----------------------------------------+
 * ... or ...
 *+----------+---------------+-------------+
 *|attribute#|     0         |     1       |
 *+----------+---------------+-------------+
 *| content  | [class label] | [text data] |
 *+----------------------------------------+
 *&lt;/pre&gt;
 *
 * @author Florian Kleedorfer (kleedorfer@austria.fm)
 * @author Alexander K. Seewald (alex@seewald.at)
 * @version $Revision: 5518 $
 */
<span class="fc" id="L280">public class StringKernel </span>
  extends Kernel
  implements TechnicalInformationHandler {
  
  /** for serialization */
  private static final long serialVersionUID = -4902954211202690123L;

  /** The size of the cache (a prime number) */
<span class="pc" id="L288">  private int m_cacheSize = 250007;</span>

  /** The size of the internal cache for intermediate results (a prime number) */
<span class="pc" id="L291">  private int m_internalCacheSize = 200003;</span>

  /** The attribute number of the string attribute */
  private int m_strAttr;

  /** Kernel cache (i.e., cache for kernel evaluations) */
  private double[] m_storage;
  private long[] m_keys;

  /** Counts the number of kernel evaluations. */
  private int m_kernelEvals;

  /** The number of instance in the dataset */
  private int m_numInsts;

  /** Pruning method: No Pruning */
  public final static int PRUNING_NONE = 0;
  /** Pruning method: Lambda See [2] for details. */
  public final static int PRUNING_LAMBDA = 1;
  /** Pruning methods */
<span class="fc" id="L311">  public static final Tag [] TAGS_PRUNING = {</span>
<span class="fc" id="L312">    new Tag(PRUNING_NONE, &quot;No pruning&quot;),</span>
<span class="fc" id="L313">    new Tag(PRUNING_LAMBDA, &quot;Lambda pruning&quot;),</span>
  };
  
  /** the pruning method */
<span class="pc" id="L317">  protected int m_PruningMethod = PRUNING_NONE;</span>

  /** the decay factor that penalizes non-continuous substring matches. See [1]
   * for details. */
<span class="pc" id="L321">  protected double m_lambda = 0.5;</span>

  /** The substring length */
<span class="pc" id="L324">  private int m_subsequenceLength = 3;</span>

  /** The maximum substring length for lambda pruning */
<span class="pc" id="L327">  private int m_maxSubsequenceLength = 9;</span>

  /** powers of lambda are prepared prior to kernel evaluations.
   * all powers between 0 and this value are precalculated */
  protected static final int MAX_POWER_OF_LAMBDA = 10000;

  /** the precalculated powers of lambda */
<span class="pc" id="L334">  protected double[] m_powersOflambda = null;</span>

  /** flag for switching normalization on or off. This defaults to false and
   * can be turned on by the switch for feature space normalization in SMO
   */
<span class="pc" id="L339">  private boolean m_normalize = false;</span>

  /** private cache for intermediate results */	
  private int maxCache; // is set in unnormalizedKernel(s1,s2)
  private double[] cachekh;
  private int[] cachekhK;
  private double[] cachekh2;
  private int[] cachekh2K;
  /** cached indexes for private cache */
  private int m_multX;
  private int m_multY;
  private int m_multZ;
  private int m_multZZ;

<span class="pc" id="L353">  private boolean m_useRecursionCache = true;</span>

  /**
   * default constructor
   */
  public StringKernel() {
<span class="fc" id="L359">    super();</span>
<span class="fc" id="L360">  }</span>
  
  /**
   * creates a new StringKernel object. Initializes the kernel cache and the
   * 'lambda cache', i.e. the precalculated powers of lambda from lambda^2 to
   * lambda^MAX_POWER_OF_LAMBDA
   *
   * @param data		the dataset to use
   * @param cacheSize		the size of the cache
   * @param subsequenceLength	the subsequence length
   * @param lambda		the lambda value
   * @param debug		whether to output debug information
   * @throws Exception		if something goes wrong
   */
<span class="nc" id="L374">  public StringKernel(Instances data, int cacheSize, int subsequenceLength,</span>
    double lambda, boolean debug) throws Exception {

<span class="nc" id="L377">    setDebug(debug);</span>
<span class="nc" id="L378">    setCacheSize(cacheSize);</span>
<span class="nc" id="L379">    setInternalCacheSize(200003);</span>
<span class="nc" id="L380">    setSubsequenceLength(subsequenceLength);</span>
<span class="nc" id="L381">    setMaxSubsequenceLength(-1);</span>
<span class="nc" id="L382">    setLambda(lambda);</span>
    
<span class="nc" id="L384">    buildKernel(data);</span>
<span class="nc" id="L385">  }</span>
  
  /**
   * Returns a string describing the kernel
   * 
   * @return a description suitable for displaying in the
   *         explorer/experimenter gui
   */
  public String globalInfo() {
<span class="nc" id="L394">    return </span>
<span class="nc" id="L395">        &quot;Implementation of the subsequence kernel (SSK) as described in [1] &quot;</span>
      + &quot;and of the subsequence kernel with lambda pruning (SSK-LP) as &quot;
      + &quot;described in [2].\n\n&quot;
      + &quot;For more information, see\n\n&quot;
<span class="nc" id="L399">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    TechnicalInformation 	additional;
    
<span class="nc" id="L413">    result = new TechnicalInformation(Type.ARTICLE);</span>
<span class="nc" id="L414">    result.setValue(Field.AUTHOR, &quot;Huma Lodhi and Craig Saunders and John Shawe-Taylor and Nello Cristianini and Christopher J. C. H. Watkins&quot;);</span>
<span class="nc" id="L415">    result.setValue(Field.YEAR, &quot;2002&quot;);</span>
<span class="nc" id="L416">    result.setValue(Field.TITLE, &quot;Text Classification using String Kernels&quot;);</span>
<span class="nc" id="L417">    result.setValue(Field.JOURNAL, &quot;Journal of Machine Learning Research&quot;);</span>
<span class="nc" id="L418">    result.setValue(Field.VOLUME, &quot;2&quot;);</span>
<span class="nc" id="L419">    result.setValue(Field.PAGES, &quot;419-444&quot;);</span>
<span class="nc" id="L420">    result.setValue(Field.HTTP, &quot;http://www.jmlr.org/papers/v2/lodhi02a.html&quot;);</span>

<span class="nc" id="L422">    additional = result.add(Type.TECHREPORT);</span>
<span class="nc" id="L423">    additional.setValue(Field.AUTHOR, &quot;F. Kleedorfer and A. Seewald&quot;);</span>
<span class="nc" id="L424">    additional.setValue(Field.YEAR, &quot;2005&quot;);</span>
<span class="nc" id="L425">    additional.setValue(Field.TITLE, &quot;Implementation of a String Kernel for WEKA&quot;);</span>
<span class="nc" id="L426">    additional.setValue(Field.INSTITUTION, &quot;Oesterreichisches Forschungsinstitut fuer Artificial Intelligence&quot;);</span>
<span class="nc" id="L427">    additional.setValue(Field.ADDRESS, &quot;Wien, Austria&quot;);</span>
<span class="nc" id="L428">    additional.setValue(Field.NUMBER, &quot;TR-2005-13&quot;);</span>
    
<span class="nc" id="L430">    return result;</span>
  }
  
  /**
   * Returns an enumeration describing the available options.
   *
   * @return 		an enumeration of all the available options.
   */
  public Enumeration listOptions() {
    Vector		result;
    Enumeration		en;
    String		desc;
    String		param;
    int			i;
    SelectedTag		tag;
    
<span class="fc" id="L446">    result = new Vector();</span>

<span class="fc" id="L448">    en = super.listOptions();</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">    while (en.hasMoreElements())</span>
<span class="fc" id="L450">      result.addElement(en.nextElement());</span>

<span class="fc" id="L452">    desc  = &quot;&quot;;</span>
<span class="fc" id="L453">    param = &quot;&quot;;</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">    for (i = 0; i &lt; TAGS_PRUNING.length; i++) {</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">      if (i &gt; 0)</span>
<span class="fc" id="L456">	param += &quot;|&quot;;</span>
<span class="fc" id="L457">      tag = new SelectedTag(TAGS_PRUNING[i].getID(), TAGS_PRUNING);</span>
<span class="fc" id="L458">      param += &quot;&quot; + tag.getSelectedTag().getID();</span>
<span class="fc" id="L459">      desc  +=   &quot;\t&quot; + tag.getSelectedTag().getID() </span>
<span class="fc" id="L460">      	       + &quot; = &quot; + tag.getSelectedTag().getReadable()</span>
<span class="fc" id="L461">      	       + &quot;\n&quot;;</span>
    }

<span class="fc" id="L464">    result.addElement(new Option(</span>
<span class="fc" id="L465">	&quot;\tThe pruning method to use:\n&quot;</span>
<span class="fc" id="L466">	+ desc</span>
<span class="fc" id="L467">	+ &quot;\t(default: &quot; + PRUNING_NONE + &quot;)&quot;,</span>
<span class="fc" id="L468">	&quot;P&quot;, 1, &quot;-P &lt;&quot; + param + &quot;&gt;&quot;));</span>

<span class="fc" id="L470">    result.addElement(new Option(</span>
<span class="fc" id="L471">	&quot;\tThe size of the cache (a prime number).\n&quot;</span>
	+ &quot;\t(default: 250007)&quot;,
<span class="fc" id="L473">	&quot;C&quot;, 1, &quot;-C &lt;num&gt;&quot;));</span>

<span class="fc" id="L475">    result.addElement(new Option(</span>
<span class="fc" id="L476">	&quot;\tThe size of the internal cache (a prime number).\n&quot;</span>
	+ &quot;\t(default: 200003)&quot;,
<span class="fc" id="L478">	&quot;IC&quot;, 1, &quot;-IC &lt;num&gt;&quot;));</span>

<span class="fc" id="L480">    result.addElement(new Option(</span>
<span class="fc" id="L481">	&quot;\tThe lambda constant. Penalizes non-continuous subsequence\n&quot;</span>
	+ &quot;\tmatches. Must be in (0,1).\n&quot;
	+ &quot;\t(default: 0.5)&quot;,
<span class="fc" id="L484">	&quot;L&quot;, 1, &quot;-L &lt;num&gt;&quot;));</span>

<span class="fc" id="L486">    result.addElement(new Option(</span>
<span class="fc" id="L487">	&quot;\tThe length of the subsequence.\n&quot;</span>
	+ &quot;\t(default: 3)&quot;,
<span class="fc" id="L489">	&quot;ssl&quot;, 1, &quot;-ssl &lt;num&gt;&quot;));</span>

<span class="fc" id="L491">    result.addElement(new Option(</span>
<span class="fc" id="L492">	&quot;\tThe maximum length of the subsequence.\n&quot;</span>
	+ &quot;\t(default: 9)&quot;,
<span class="fc" id="L494">	&quot;ssl-max&quot;, 1, &quot;-ssl-max &lt;num&gt;&quot;));</span>

<span class="fc" id="L496">    result.addElement(new Option(</span>
<span class="fc" id="L497">	&quot;\tUse normalization.\n&quot;</span>
	+ &quot;\t(default: no)&quot;,
<span class="fc" id="L499">	&quot;N&quot;, 0, &quot;-N&quot;));</span>

<span class="fc" id="L501">    return result.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   * 
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -D
   *  Enables debugging output (if available) to be printed.
   *  (default: off)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -no-checks
   *  Turns off all checks - use with caution!
   *  (default: checks on)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -P &amp;lt;0|1&amp;gt;
   *  The pruning method to use:
   *  0 = No pruning
   *  1 = Lambda pruning
   *  (default: 0)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C &amp;lt;num&amp;gt;
   *  The size of the cache (a prime number).
   *  (default: 250007)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -IC &amp;lt;num&amp;gt;
   *  The size of the internal cache (a prime number).
   *  (default: 200003)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -L &amp;lt;num&amp;gt;
   *  The lambda constant. Penalizes non-continuous subsequence
   *  matches. Must be in (0,1).
   *  (default: 0.5)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -ssl &amp;lt;num&amp;gt;
   *  The length of the subsequence.
   *  (default: 3)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -ssl-max &amp;lt;num&amp;gt;
   *  The maximum length of the subsequence.
   *  (default: 9)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N
   *  Use normalization.
   *  (default: no)&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   * 
   * @param options 	the list of options as an array of strings
   * @throws Exception 	if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String	tmpStr;
    
<span class="fc" id="L557">    tmpStr = Utils.getOption('P', options);</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L559">      setPruningMethod(</span>
<span class="fc" id="L560">	  new SelectedTag(Integer.parseInt(tmpStr), TAGS_PRUNING));</span>
    else
<span class="fc" id="L562">      setPruningMethod(</span>
<span class="fc" id="L563">	  new SelectedTag(PRUNING_NONE, TAGS_PRUNING));</span>

<span class="fc" id="L565">    tmpStr = Utils.getOption('C', options);</span>
<span class="fc bfc" id="L566" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L567">      setCacheSize(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L569">      setCacheSize(250007);</span>
    
<span class="fc" id="L571">    tmpStr = Utils.getOption(&quot;IC&quot;, options);</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L573">      setInternalCacheSize(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L575">      setInternalCacheSize(200003);</span>
    
<span class="fc" id="L577">    tmpStr = Utils.getOption('L', options);</span>
<span class="fc bfc" id="L578" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L579">      setLambda(Double.parseDouble(tmpStr));</span>
    else
<span class="fc" id="L581">      setLambda(0.5);</span>
    
<span class="fc" id="L583">    tmpStr = Utils.getOption(&quot;ssl&quot;, options);</span>
<span class="fc bfc" id="L584" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L585">      setSubsequenceLength(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L587">      setSubsequenceLength(3);</span>
    
<span class="fc" id="L589">    tmpStr = Utils.getOption(&quot;ssl-max&quot;, options);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">    if (tmpStr.length() != 0)</span>
<span class="fc" id="L591">      setMaxSubsequenceLength(Integer.parseInt(tmpStr));</span>
    else
<span class="fc" id="L593">      setMaxSubsequenceLength(9);</span>

<span class="fc" id="L595">    setUseNormalization(Utils.getFlag('N', options));</span>

<span class="pc bpc" id="L597" title="1 of 2 branches missed.">    if (getMaxSubsequenceLength()&lt;2*getSubsequenceLength()) {</span>
<span class="nc" id="L598">      throw new IllegalArgumentException(&quot;Lambda Pruning forbids even contiguous substring matches! &quot; +</span>
      &quot;Use a bigger value for ssl-max (at least 2*ssl).&quot;);
    }
    
<span class="fc" id="L602">    super.setOptions(options);</span>
<span class="fc" id="L603">  }</span>

  /**
   * Gets the current settings of the Kernel.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    int       i;
    Vector    result;
    String[]  options;

<span class="fc" id="L615">    result = new Vector();</span>
<span class="fc" id="L616">    options = super.getOptions();</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">    for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L618">      result.add(options[i]);</span>

<span class="fc" id="L620">    result.add(&quot;-P&quot;);</span>
<span class="fc" id="L621">    result.add(&quot;&quot; + m_PruningMethod);</span>

<span class="fc" id="L623">    result.add(&quot;-C&quot;);</span>
<span class="fc" id="L624">    result.add(&quot;&quot; + getCacheSize());</span>

<span class="fc" id="L626">    result.add(&quot;-IC&quot;);</span>
<span class="fc" id="L627">    result.add(&quot;&quot; + getInternalCacheSize());</span>

<span class="fc" id="L629">    result.add(&quot;-L&quot;);</span>
<span class="fc" id="L630">    result.add(&quot;&quot; + getLambda());</span>

<span class="fc" id="L632">    result.add(&quot;-ssl&quot;);</span>
<span class="fc" id="L633">    result.add(&quot;&quot; + getSubsequenceLength());</span>

<span class="fc" id="L635">    result.add(&quot;-ssl-max&quot;);</span>
<span class="fc" id="L636">    result.add(&quot;&quot; + getMaxSubsequenceLength());</span>

<span class="pc bpc" id="L638" title="1 of 2 branches missed.">    if (getUseNormalization())</span>
<span class="nc" id="L639">      result.add(&quot;-L&quot;);</span>

<span class="fc" id="L641">    return (String[]) result.toArray(new String[result.size()]);	  </span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String pruningMethodTipText() {
<span class="nc" id="L651">    return &quot;The pruning method.&quot;;</span>
  }

  /**
   * Sets the method used to for pruning. 
   *
   * @param value 	the pruning method to use.
   */
  public void setPruningMethod(SelectedTag value) {
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">    if (value.getTags() == TAGS_PRUNING)</span>
<span class="fc" id="L661">      m_PruningMethod = value.getSelectedTag().getID();</span>
<span class="fc" id="L662">  }</span>

  /**
   * Gets the method used for pruning. 
   *
   * @return 		the pruning method to use.
   */
  public SelectedTag getPruningMethod() {
<span class="nc" id="L670">    return new SelectedTag(m_PruningMethod, TAGS_PRUNING);</span>
  }


  /**
   * Sets the size of the cache to use (a prime number)
   * 
   * @param value	the size of the cache
   */
  public void setCacheSize(int value) {
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">    if (value &gt;= 0) {</span>
<span class="fc" id="L681">      m_cacheSize = value;</span>
<span class="fc" id="L682">      clean();</span>
    }
    else {
<span class="nc" id="L685">      System.out.println(</span>
<span class="nc" id="L686">	  &quot;Cache size cannot be smaller than 0 (provided: &quot; + value + &quot;)!&quot;);</span>
    }
<span class="fc" id="L688">  }</span>
  
  /**
   * Gets the size of the cache
   * 
   * @return 		the cache size
   */
  public int getCacheSize() {
<span class="fc" id="L696">    return m_cacheSize;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String cacheSizeTipText() {
<span class="nc" id="L706">    return &quot;The size of the cache (a prime number).&quot;;</span>
  }

  /** 
   * sets the size of the internal cache for intermediate results. Memory
   * consumption is about 16x this amount in bytes. Only use when lambda
   * pruning is switched off.
   *
   * @param value	the size of the internal cache
   */
  public void setInternalCacheSize(int value) {
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">    if (value &gt;= 0) {</span>
<span class="fc" id="L718">      m_internalCacheSize = value;</span>
<span class="fc" id="L719">      clean();</span>
    } else {
<span class="nc" id="L721">      System.out.println(</span>
<span class="nc" id="L722">	  &quot;Cache size cannot be smaller than 0 (provided: &quot; + value + &quot;)!&quot;);</span>
    }
<span class="fc" id="L724">  }</span>
  
  /**
   * Gets the size of the internal cache
   * 
   * @return 		the cache size
   */
  public int getInternalCacheSize() {
<span class="fc" id="L732">    return m_internalCacheSize;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String internalCacheSizeTipText() {
<span class="nc" id="L742">    return &quot;The size of the internal cache (a prime number).&quot;;</span>
  }

  /**
   * Sets the length of the subsequence.
   * 
   * @param value	the length
   */
  public void setSubsequenceLength(int value) {
<span class="fc" id="L751">    m_subsequenceLength = value;</span>
<span class="fc" id="L752">  }</span>
  
  /**
   * Returns the length of the subsequence
   * 
   * @return		the length
   */
  public int getSubsequenceLength() {
<span class="fc" id="L760">    return m_subsequenceLength;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String subsequenceLengthTipText() {
<span class="nc" id="L770">    return &quot;The subsequence length.&quot;;</span>
  }

  /**
   * Sets the maximum length of the subsequence.
   * 
   * @param value	the maximum length
   */
  public void setMaxSubsequenceLength(int value) {
<span class="fc" id="L779">    m_maxSubsequenceLength = value;</span>
<span class="fc" id="L780">  }</span>
  
  /**
   * Returns the maximum length of the subsequence
   * 
   * @return		the maximum length
   */
  public int getMaxSubsequenceLength() {
<span class="fc" id="L788">    return m_maxSubsequenceLength;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String maxSubsequenceLengthTipText() {
<span class="nc" id="L798">    return &quot;The maximum subsequence length (theta in the paper)&quot;;</span>
  }
  
  /**
   * Sets the lambda constant used in the string kernel
   * 
   * @param value	the lambda value to use
   */
  public void setLambda(double value) {
<span class="fc" id="L807">    m_lambda = value;</span>
<span class="fc" id="L808">  }</span>
  
  /**
   * Gets the lambda constant used in the string kernel
   * 
   * @return		the current lambda constant
   */  
  public double getLambda() {
<span class="fc" id="L816">    return m_lambda;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String lambdaTipText(){
<span class="nc" id="L826">    return &quot;Penalizes non-continuous subsequence matches, from (0,1)&quot;;</span>
  }

  /**
   * Sets whether to use normalization.
   * Each time this value is changed, the kernel cache is cleared.
   *
   * @param value	whether to use normalization
   */
  public void setUseNormalization(boolean value) {
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">    if  (value != m_normalize) </span>
<span class="nc" id="L837">      clean();</span>
    
<span class="fc" id="L839">    m_normalize = value;</span>
<span class="fc" id="L840">  }</span>
  
  /**
   * Returns whether normalization is used.
   * 
   * @return		true if normalization is used
   */
  public boolean getUseNormalization() {
<span class="fc" id="L848">    return m_normalize;</span>
  }

  /**
   * Returns the tip text for this property
   * 
   * @return 		tip text for this property suitable for
   * 			displaying in the explorer/experimenter gui
   */
  public String useNormalizationTipText(){
<span class="nc" id="L858">    return &quot;Whether to use normalization.&quot;;</span>
  }

  /**
   * Computes the result of the kernel function for two instances.
   * If id1 == -1, eval use inst1 instead of an instance in the dataset.
   *
   * @param id1 the index of the first instance in the dataset
   * @param id2 the index of the second instance in the dataset
   * @param inst1 the instance corresponding to id1 (used if id1 == -1)
   * @return the result of the kernel function
   * @throws Exception if something goes wrong
   */
  public double eval(int id1, int id2, Instance inst1) throws Exception {
<span class="pc bpc" id="L872" title="5 of 6 branches missed.">    if (m_Debug &amp;&amp; id1&gt;-1 &amp;&amp; id2&gt;-1) {</span>
<span class="nc" id="L873">      System.err.println(&quot;\nEvaluation of string kernel for&quot;);</span>
<span class="nc" id="L874">      System.err.println(m_data.instance(id1).stringValue(m_strAttr));</span>
<span class="nc" id="L875">      System.err.println(&quot;and&quot;);</span>
<span class="nc" id="L876">      System.err.println(m_data.instance(id2).stringValue(m_strAttr));</span>
    }

    //the normalized kernel returns 1 for comparison of 
    //two identical strings
<span class="pc bpc" id="L881" title="1 of 4 branches missed.">    if (id1 == id2 &amp;&amp; m_normalize) </span>
<span class="nc" id="L882">      return 1.0;</span>

<span class="fc" id="L884">    double result = 0;</span>
<span class="fc" id="L885">    long key = -1;</span>
<span class="fc" id="L886">    int location = -1;</span>

    // we can only cache if we know the indexes
<span class="pc bpc" id="L889" title="2 of 4 branches missed.">    if ((id1 &gt;= 0) &amp;&amp; (m_keys != null)) {</span>
<span class="pc bpc" id="L890" title="1 of 2 branches missed.">      if (id1 &gt; id2) {</span>
<span class="nc" id="L891">        key = (long)id1 * m_numInsts + id2;</span>
      } else {
<span class="fc" id="L893">        key = (long)id2 * m_numInsts + id1;</span>
      }
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">      if (key &lt; 0) {</span>
<span class="nc" id="L896">        throw new Exception(&quot;Cache overflow detected!&quot;);</span>
      }
<span class="fc" id="L898">      location = (int)(key % m_keys.length);</span>
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">      if (m_keys[location] == (key + 1)) {</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (m_Debug) </span>
<span class="nc" id="L901">          System.err.println(&quot;result (cached): &quot; + m_storage[location]);</span>
<span class="nc" id="L902">        return m_storage[location];</span>
      }
    }

<span class="fc" id="L906">    m_kernelEvals++;</span>
<span class="fc" id="L907">    long start = System.currentTimeMillis();</span>

<span class="fc" id="L909">    Instance inst2 = m_data.instance(id2);</span>
<span class="fc" id="L910">    char[] s1 = inst1.stringValue(m_strAttr).toCharArray();</span>
<span class="fc" id="L911">    char[] s2 = inst2.stringValue(m_strAttr).toCharArray();</span>

    // prevent the kernel from returning NaN
<span class="pc bpc" id="L914" title="2 of 4 branches missed.">    if (s1.length == 0 || s2.length == 0) return 0;</span>

<span class="pc bpc" id="L916" title="1 of 2 branches missed.">    if (m_normalize) {</span>
<span class="nc" id="L917">      result = normalizedKernel(s1,s2);</span>
    } else {
<span class="fc" id="L919">      result = unnormalizedKernel(s1, s2);</span>
    }

<span class="pc bpc" id="L922" title="1 of 2 branches missed.">    if (m_Debug) {</span>
<span class="nc" id="L923">      long duration = System.currentTimeMillis() - start;</span>
<span class="nc" id="L924">      System.err.println(&quot;result: &quot; + result);</span>
<span class="nc" id="L925">      System.err.println(&quot;evaluation time:&quot; + duration +&quot;\n&quot;);</span>
    }

    // store result in cache
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">    if (key != -1){</span>
<span class="fc" id="L930">      m_storage[location] = result;</span>
<span class="fc" id="L931">      m_keys[location] = (key + 1);</span>
    }
<span class="fc" id="L933">    return result;</span>
  }

  /**
   * Frees the memory used by the kernel.
   * (Useful with kernels which use cache.)
   * This function is called when the training is done.
   * i.e. after that, eval will be called with id1 == -1.
   */
  public void clean() {
<span class="fc" id="L943">    m_storage = null;</span>
<span class="fc" id="L944">    m_keys = null;</span>
<span class="fc" id="L945">  }</span>

  /**
   * Returns the number of kernel evaluation performed.
   *
   * @return the number of kernel evaluation performed.
   */
  public int numEvals() {
<span class="fc" id="L953">    return m_kernelEvals;</span>
  }

  /**
   * Returns the number of dot product cache hits.
   *
   * @return the number of dot product cache hits, or -1 if not supported by
   * this kernel.
   */
  public int numCacheHits() {
    // TODO: implement!
<span class="fc" id="L964">    return -1;</span>
  }
  
  /**
   * evaluates the normalized kernel between s and t. See [1] for details about
   * the normalized SSK. 
   *
   * @param s first input string
   * @param t second input string
   * @return a double indicating their distance, or similarity
   */
  public double normalizedKernel(char[] s, char[] t){
<span class="nc" id="L976">    double k1 = unnormalizedKernel(s, s);</span>
<span class="nc" id="L977">    double k2 = unnormalizedKernel(t, t);</span>
<span class="nc" id="L978">    double normTerm = Math.sqrt( k1*k2 );</span>
<span class="nc" id="L979">    return unnormalizedKernel(s, t) / normTerm;</span>
  }

  /**
   * evaluates the unnormalized kernel between s and t. See [1] for details
   * about the unnormalized SSK.
   *
   * @param s first input string
   * @param t second input string
   * @return a double indicating their distance, or similarity
   */
  public double unnormalizedKernel(char[] s, char[] t){
<span class="fc bfc" id="L991" title="All 2 branches covered.">    if (t.length &gt; s.length) {</span>
      //swap because the algorithm is faster if s is
      //the longer string
<span class="fc" id="L994">      char[] buf = s;</span>
<span class="fc" id="L995">      s = t;</span>
<span class="fc" id="L996">      t = buf;</span>
    }
<span class="pc bpc" id="L998" title="1 of 2 branches missed.">    if (m_PruningMethod == PRUNING_NONE) {</span>
<span class="fc" id="L999">      m_multX=(s.length+1)*(t.length+1); </span>
<span class="fc" id="L1000">      m_multY=(t.length+1); </span>
<span class="fc" id="L1001">      m_multZ=1;</span>
<span class="fc" id="L1002">      maxCache = m_internalCacheSize;</span>
<span class="pc bpc" id="L1003" title="1 of 2 branches missed.">      if (maxCache==0) {</span>
<span class="nc" id="L1004">	maxCache=(m_subsequenceLength+1)*m_multX;</span>
      }
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">      else if ((m_subsequenceLength+1)*m_multX&lt;maxCache) { </span>
<span class="fc" id="L1007">	maxCache=(m_subsequenceLength+1)*m_multX; </span>
      }
<span class="fc" id="L1009">      m_useRecursionCache=true;</span>
<span class="fc" id="L1010">      cachekhK = new int[maxCache];</span>
<span class="fc" id="L1011">      cachekh2K = new int[maxCache];</span>
<span class="fc" id="L1012">      cachekh = new double[maxCache];</span>
<span class="fc" id="L1013">      cachekh2 = new double[maxCache];</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">    } else if (m_PruningMethod == PRUNING_LAMBDA) {</span>
<span class="nc" id="L1015">      maxCache=0; </span>
<span class="nc" id="L1016">      m_useRecursionCache=false;</span>
    }

    double res;
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">    if (m_PruningMethod == PRUNING_LAMBDA) {</span>
<span class="nc" id="L1021">      res = kernelLP(</span>
<span class="nc" id="L1022">              m_subsequenceLength,s,s.length-1,t,t.length-1,</span>
<span class="nc" id="L1023">              m_maxSubsequenceLength);</span>
    } else {
<span class="fc" id="L1025">      res = kernel(</span>
<span class="fc" id="L1026">              m_subsequenceLength,s,s.length-1, t, t.length-1);</span>
    }
<span class="fc" id="L1028">    cachekh = null;</span>
<span class="fc" id="L1029">    cachekhK = null;</span>
<span class="fc" id="L1030">    cachekh2 = null;</span>
<span class="fc" id="L1031">    cachekh2K = null;</span>
    
<span class="fc" id="L1033">    return res;</span>
  }

  /**
   * Recursion-ending function that is called at the end of each 
   * recursion branch.
   * 
   * @param n
   * @return
   */
  protected double getReturnValue(int n){
<span class="fc bfc" id="L1044" title="All 2 branches covered.">    if (n == 0) return 1; else return 0;</span>
  }

  /**
   * the kernel function (Kn). This function performs the outer loop
   * character-wise over the first input string s. For each character
   * encountered, a recursion branch is started that identifies all
   * subsequences in t starting with that character. &lt;br&gt; See [1] for details
   * but note that this code is optimized and may be hard to recognize.
   * 
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @return a double indicating the distance or similarity between s and t, 
   * according to and depending on the initial value for n.
   */
  protected double kernel(int n, char[] s,int endIndexS, char[] t, 
    int endIndexT) {

    //normal recursion ending case
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">    if (Math.min(endIndexS+1,endIndexT+1) &lt; n) return getReturnValue(n);</span>

    //accumulate all recursion results in one:
<span class="fc" id="L1069">    double result = 0;</span>

    //the tail-recursive function defined in [1] is turned into a
    //loop here, preventing stack overflows.
    //skim s from back to front
<span class="fc bfc" id="L1074" title="All 2 branches covered.">    for (int iS=endIndexS; iS &gt; n-2; iS--) {</span>
<span class="fc" id="L1075">      double buf = 0;</span>
      //let the current character in s be x 
<span class="fc" id="L1077">      char x = s[iS];</span>
      // iterate over all occurrences of x in t
<span class="fc bfc" id="L1079" title="All 2 branches covered.">      for (int j=0; j &lt;= endIndexT; j++) {</span>
<span class="fc bfc" id="L1080" title="All 2 branches covered.">        if (t[j] == x){</span>
          //this is a match for the current character, hence
          //1. use previous chars in both strings (iS-1, j-1)
          //2. decrement the remainingMatchLength (n-1)
          //and start a recursion branch for these parameters
<span class="fc" id="L1085">          buf += kernelHelper(n-1,s,iS-1, t, j-1);</span>
        }
      }
      //ok, all occurrences of x in t have been found
      //multiply the result with lambda^2
      //  (one lambda for x, and the other for all matches of x in t)
<span class="fc" id="L1091">      result += buf * m_powersOflambda[2];</span>
    }
<span class="fc" id="L1093">    return result;</span>
  }

  /**
   * The kernel helper function, called K' in [1] and [2].
   *
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @return a partial result for K
   */
  protected double kernelHelper (int n, char[] s,int endIndexS, char[] t, 
    int endIndexT) {

    //recursion ends if the current subsequence has maximal length, 
    //which is the case here
<span class="fc bfc" id="L1111" title="All 2 branches covered.">    if (n &lt;= 0 ) {</span>
<span class="fc" id="L1112">      return getReturnValue(n);</span>
    }

    //recursion ends, too, if the current subsequence is shorter than
    //maximal length, but there is no chance that it will reach maximal length.
    //in this case, normally 0 is returned, but the EXPERIMENTAL 
    //minSubsequenceLength feature allows shorter subsequence matches
    //also to contribute
<span class="fc bfc" id="L1120" title="All 2 branches covered.">    if (Math.min(endIndexS+1,endIndexT+1) &lt; n) {</span>
<span class="fc" id="L1121">      return getReturnValue(n);</span>
    }
<span class="fc" id="L1123">    int adr = 0;</span>
<span class="pc bpc" id="L1124" title="1 of 2 branches missed.">    if (m_useRecursionCache) {</span>
<span class="fc" id="L1125">      adr=m_multX*n+m_multY*endIndexS+m_multZ*endIndexT;</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">      if ( cachekhK[adr % maxCache] == adr+1) return cachekh[adr % maxCache];</span>
    }

    //the tail-recursive function defined in [1] is turned into a
    //loop here, preventing stack overflows.
    //loop over s, nearly from the start (skip the first n-1 characters)
    //and only up until endIndexS, and recursively apply K''. Thus, every
    //character between n-1 and endIndexS in s is counted once as 
    //being part of the subsequence match and once just as a gap. 
    //In both cases lambda is multiplied with the result.
<span class="fc" id="L1136">    double result = 0;</span>
    /*
       for (int iS = n-1; iS &lt;= endIndexS;iS++) {
       result *= m_lambda;
       result += kernelHelper2(n,s,iS, t, endIndexT);
       }
       if (m_useRecursionCache) {
       cachekhK[adr % maxCache]=adr+1; cachekh[adr % maxCache]=result;
       }
       return result;
       */
    /* ^^^ again, above code segment does not store some intermediate results... */
<span class="fc" id="L1148">    result = m_lambda*kernelHelper(n,s,endIndexS-1,t,endIndexT)</span>
<span class="fc" id="L1149">             + kernelHelper2(n,s,endIndexS,t,endIndexT);</span>
<span class="pc bpc" id="L1150" title="1 of 2 branches missed.">    if (m_useRecursionCache) {</span>
<span class="fc" id="L1151">      cachekhK[adr % maxCache]=adr+1; cachekh[adr % maxCache]=result;</span>
    }
<span class="fc" id="L1153">    return result;</span>
  }

  /** 
   * helper function for the evaluation of the kernel K'' see section
   * 'Efficient Computation of SSK' in [1]
   *
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @return a partial result for K'
   */
  protected double kernelHelper2(int n, char[] s, int endIndexS, char[] t, 
    int endIndexT) {

    //recursion ends if one of the indices in both strings is &lt;0
<span class="pc bpc" id="L1171" title="1 of 4 branches missed.">    if (endIndexS &lt;0 || endIndexT &lt;0) {</span>
<span class="fc" id="L1172">      return getReturnValue(n);</span>
    }

<span class="fc" id="L1175">    int adr = 0;</span>
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">    if (m_useRecursionCache) {</span>
<span class="fc" id="L1177">      adr=m_multX*n+m_multY*endIndexS+m_multZ*endIndexT;</span>
<span class="fc bfc" id="L1178" title="All 2 branches covered.">      if ( cachekh2K[adr % maxCache] == adr+1) return cachekh2[adr % maxCache];</span>
    }

    //spot the last character in s, we'll need it
<span class="fc" id="L1182">    char x = s[endIndexS];</span>

    //recurse if the last characters of s and t, x (and y) are identical.
    //which is an easy case: just add up two recursions, 
    // 1. one that counts x and y as a part of the subsequence match
    //	 -&gt; n, endIndexS and endIndexT are decremented for next recursion level
    // 	 -&gt; lambda^2 is multiplied with the result to account for the length
    //      of 2 that has been added to the length of the subsequence match
    //      by accepting x and y.
    // 2. one that counts y as a gap in the match 
    //   -&gt; only endIndexT is decremented for next recursion level
    // 	 -&gt; lambda is multiplied with the result to account for the length
    //      of 1 that has been added to the length of the subsequence match
    //		by omitting y.
<span class="fc bfc" id="L1196" title="All 2 branches covered.">    if (x == t[endIndexT]) {</span>
<span class="fc" id="L1197">      double ret =  m_lambda * (kernelHelper2(n,s,endIndexS, t, endIndexT-1)</span>
<span class="fc" id="L1198">          + m_lambda * kernelHelper(n-1,s,endIndexS-1, t, endIndexT-1));</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">      if (m_useRecursionCache) {</span>
<span class="fc" id="L1200">        cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret;</span>
      }
<span class="fc" id="L1202">      return ret;</span>
    } else {
<span class="fc" id="L1204">      double ret = m_lambda*kernelHelper2(n,s,endIndexS,t,endIndexT-1);</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">      if (m_useRecursionCache) {</span>
<span class="fc" id="L1206">        cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret;</span>
      }
<span class="fc" id="L1208">      return ret;</span>
    }

    //look for x in t from back to front. 
    //this is actually an optimization from [1] that spares unneccessary
    //recursions iff
    //x is actually found in t, but not at the last position.
    /*
       int i;
       int threshold = n&gt;0?n-1:0;
       for (i=endIndexT-1; i &gt;= threshold;i--) {
       if (x == t[i]) {
       double ret=getPowerOfLambda(endIndexT-i) * kernelHelper2(n,s,endIndexS, t, i);
       if (m_useRecursionCache) {
       cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret;
       }
       return ret;
       }
       }
       */		
    //end the recursion if x is not found in t.
    /*        double ret = getReturnValue(n);
              if (m_useRecursionCache) {
              cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret;
              }
              return ret;*/
  }

  /**
   * the kernel function K explained in [1] using lambda pruning, explained in
   * [2].  An additional parameter is introduced, which denotes the maximum
   * length of a subsequence match. This allows for the control of how relaxed
   * the subsequence matches are. &lt;br&gt;
   *
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @param remainingMatchLength actually the initial value for
   * maxLambdaExponent
   * @return a double indicating the distance or similarity between s and t, 
   * according to and depending on the initial value for n. 
   */
  protected double kernelLP(int n, char[] s, int endIndexS,char[] t,
      int endIndexT,int remainingMatchLength) {
    //see code docs in kernel()
<span class="nc bnc" id="L1255" title="All 2 branches missed.">    if (Math.min(endIndexS+1,endIndexT +1) &lt; n) {</span>
<span class="nc" id="L1256">      return getReturnValue(n);</span>
    }
    //lambda pruning check 
    //stops recursion if the match is so long that the resulting
    //power of lambda is smaller than minLambda
    //if lambda pruning is not used, the remainingMatchLength is &lt; 0
    //and this check never stops the recursion
<span class="nc bnc" id="L1263" title="All 2 branches missed.">    if (remainingMatchLength == 0) return getReturnValue(n);</span>
<span class="nc" id="L1264">    double result = 0;</span>
    //see code docs in kernel()
<span class="nc bnc" id="L1266" title="All 2 branches missed.">    for (int iS =endIndexS; iS &gt; n-2; iS--) {</span>
<span class="nc" id="L1267">      double buf = 0;</span>
<span class="nc" id="L1268">      char x = s[iS];</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">      for (int j=0; j &lt;= endIndexT; j++) {</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">        if (t[j] == x){</span>
          //both t[j] and x are considered part of the subsequence match, hence
          //subtract 2 from the remainingMatchLength
<span class="nc" id="L1273">          buf += kernelHelperLP(n-1,s,iS-1,t,j-1,remainingMatchLength-2);</span>
        }
      }
<span class="nc" id="L1276">      result += buf * m_powersOflambda[2];</span>
    }
<span class="nc" id="L1278">    return result;</span>
  }

  /**
   * helper function for the evaluation of the kernel (K'n) using lambda pruning
   *
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @param remainingMatchLength the number of characters that may still be
   * used 
   * for matching (i.e. gaps + matches in both strings)
   * @return a partial result for K 
   */
  protected double kernelHelperLP (int n, char[] s, int endIndexS,char[] t,
    int endIndexT,int remainingMatchLength) {

    //see code docs in kernelHelper()
<span class="nc bnc" id="L1298" title="All 2 branches missed.">    if (n == 0) {</span>
<span class="nc" id="L1299">      return getReturnValue(n);      </span>

    }
    //see code docs in kernelHelper()
<span class="nc bnc" id="L1303" title="All 2 branches missed.">    if (Math.min(endIndexS+1,endIndexT +1) &lt; n) {;</span>
<span class="nc" id="L1304">      return getReturnValue(n);</span>
    }

    //lambda pruning check
    //stops recursion if the match is so long that the resulting
    //power of lambda is smaller than minLambda
    //if lambda pruning is not used, the remainingMatchLength is &lt; 0
    //and this check never stops the recursion
<span class="nc bnc" id="L1312" title="All 2 branches missed.">    if (remainingMatchLength &lt; 2*n) { </span>
<span class="nc" id="L1313">      return getReturnValue(n);</span>
    }
<span class="nc" id="L1315">    int adr=0;</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">    if (m_useRecursionCache) {</span>
<span class="nc" id="L1317">      adr = m_multX*n+m_multY*endIndexS+m_multZ*endIndexT </span>
<span class="nc" id="L1318">            + m_multZZ * remainingMatchLength;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">      if (cachekh2K[adr % maxCache]==adr+1) { </span>
<span class="nc" id="L1320">        return cachekh2[adr % maxCache]; </span>
      }
    }

<span class="nc" id="L1324">    int rml = 0; //counts the remaining match length</span>
<span class="nc" id="L1325">    double result = 0;</span>
    //see code docs in kernelHelper()
    //difference to implementation in kernelHelper:
    //*)choose different starting point, which is found counting
    //the maximal remaining match length from endIndexS.
    //*)keep track of the remaining match length, rml, which is
    //  incremented each loop
<span class="nc bnc" id="L1332" title="All 2 branches missed.">    for (int iS = (endIndexS-remainingMatchLength); iS &lt;= endIndexS;iS++) {</span>
<span class="nc" id="L1333">      result *= m_lambda;</span>
<span class="nc" id="L1334">      result += kernelHelper2LP(n,s,iS, t, endIndexT,rml++);</span>
    }

<span class="nc bnc" id="L1337" title="All 8 branches missed.">    if (m_useRecursionCache &amp;&amp; endIndexS &gt;= 0 &amp;&amp; endIndexT &gt;= 0 &amp;&amp; n &gt;= 0) {</span>
<span class="nc" id="L1338">      cachekhK[adr % maxCache]=adr+1; cachekh[adr % maxCache]=result; </span>
    }
<span class="nc" id="L1340">    return result;</span>
  }

  /**
   * helper function for the evaluation of the kernel (K''n) using lambda
   * pruning
   *
   * @param n the current length of the matching subsequence
   * @param s first string, as a char array
   * @param t second string, as a char array
   * @param endIndexS the portion of s currently regarded is s[1:endIndexS]
   * @param endIndexT the portion of t currently regarded is t[1:endIndexT]
   * @param remainingMatchLength the number of characters that may still be
   * used 
   * for matching (i.e. gaps + matches in both strings)
   * @return a partial result for K' 
   */
  protected double kernelHelper2LP(int n, char[] s, int endIndexS,char[] t,
    int endIndexT,int remainingMatchLength) {

    //lambda pruning check
    //stops recursion if the match is so long that the resulting
    //power of lambda is smaller than minLambda
    //if lambda pruning is not used, the remainingMatchLength is &lt; 0
    //and this check never stops the recursion
    //if (remainingMatchLength &lt;= 0) return 0;
<span class="nc bnc" id="L1366" title="All 2 branches missed.">    if (remainingMatchLength &lt; 2*n) return getReturnValue(n);</span>

    //see code docs in kernelHelper2()
<span class="nc bnc" id="L1369" title="All 4 branches missed.">    if (endIndexS &lt;0 || endIndexT &lt;0) return getReturnValue(n);</span>
<span class="nc" id="L1370">    int adr=0;</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">    if (m_useRecursionCache){</span>
<span class="nc" id="L1372">      adr = m_multX*n+m_multY*endIndexS+m_multZ*endIndexT</span>
<span class="nc" id="L1373">            + m_multZZ * remainingMatchLength;</span>
<span class="nc bnc" id="L1374" title="All 2 branches missed.">      if (cachekh2K[adr % maxCache]==adr+1) { </span>
<span class="nc" id="L1375">        return cachekh2[adr % maxCache]; </span>
      }
    }

<span class="nc" id="L1379">    char x = s[endIndexS];</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">    if (x == t[endIndexT]) {</span>
<span class="nc" id="L1381">      double ret = </span>
<span class="nc" id="L1382">        m_lambda </span>
<span class="nc" id="L1383">        * (kernelHelper2LP(n,s,endIndexS,t,endIndexT-1,remainingMatchLength-1)</span>
<span class="nc" id="L1384">        + m_lambda </span>
<span class="nc" id="L1385">        * kernelHelperLP(n-1,s,endIndexS-1,t,endIndexT-1,remainingMatchLength-2));</span>
<span class="nc bnc" id="L1386" title="All 8 branches missed.">      if (m_useRecursionCache &amp;&amp; endIndexS &gt;= 0 &amp;&amp; endIndexT &gt;= 0 &amp;&amp; n &gt;= 0) {</span>
<span class="nc" id="L1387">        cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret; }</span>
<span class="nc" id="L1388">      return ret;</span>
    }

    //see code docs in kernelHelper()
    //differences to implementation in kernelHelper():
    //*) choose a different ending point for the loop
    //   based on the remaining match length
    int i;
<span class="nc" id="L1396">    int minIndex = endIndexT - remainingMatchLength;</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">    if (minIndex &lt; 0) minIndex = 0;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">    for (i=endIndexT; i &gt;= minIndex;i--) {</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">      if (x == t[i]) {</span>
<span class="nc" id="L1400">        int skipLength = endIndexT -i;</span>
<span class="nc" id="L1401">        double ret = getPowerOfLambda(skipLength) *</span>
<span class="nc" id="L1402">          kernelHelper2LP(n,s,endIndexS,t,i,remainingMatchLength-skipLength);</span>
<span class="nc bnc" id="L1403" title="All 8 branches missed.">        if (m_useRecursionCache &amp;&amp; endIndexS &gt;= 0 &amp;&amp; endIndexT &gt;= 0 &amp;&amp; n &gt;= 0) { </span>
<span class="nc" id="L1404">          cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret; </span>
        }
<span class="nc" id="L1406">        return ret;</span>
      }
    }
<span class="nc" id="L1409">    double ret = getReturnValue(n);</span>
<span class="nc bnc" id="L1410" title="All 8 branches missed.">    if (m_useRecursionCache &amp;&amp; endIndexS &gt;= 0 &amp;&amp; endIndexT &gt;= 0 &amp;&amp; n &gt;= 0) { </span>
<span class="nc" id="L1411">      cachekh2K[adr % maxCache]=adr+1; cachekh2[adr % maxCache]=ret; </span>
    }
<span class="nc" id="L1413">    return ret;</span>
  }

  /**
   * precalculates small powers of lambda to speed up the kernel evaluation
   *
   * @return		the powers
   */
  private double[] calculatePowersOfLambda(){
<span class="fc" id="L1422">    double[] powers = new double[MAX_POWER_OF_LAMBDA+1];</span>
<span class="fc" id="L1423">    powers[0] = 1.0;</span>
<span class="fc" id="L1424">    double val = 1.0;</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">    for (int i = 1; i&lt;=MAX_POWER_OF_LAMBDA;i++) {</span>
<span class="fc" id="L1426">      val *= m_lambda;</span>
<span class="fc" id="L1427">      powers[i] = val;</span>
    }
<span class="fc" id="L1429">    return powers;</span>
  }

  /**
   * retrieves a power of lambda from the lambda cache or calculates it
   * directly
   *
   * @param exponent	the exponent to calculate
   * @return 		the exponent-th power of lambda
   */
  private double getPowerOfLambda(int exponent){
<span class="nc bnc" id="L1440" title="All 2 branches missed.">    if (exponent &gt; MAX_POWER_OF_LAMBDA) </span>
<span class="nc" id="L1441">      return Math.pow(m_lambda,exponent);</span>
    
<span class="nc bnc" id="L1443" title="All 2 branches missed.">    if (exponent &lt; 0) </span>
<span class="nc" id="L1444">      throw new IllegalArgumentException(</span>
<span class="nc" id="L1445">          &quot;only positive powers of lambda may be computed&quot;);</span>

<span class="nc" id="L1447">    return m_powersOflambda[exponent];</span>
  }

  /**
   * initializes variables etc.
   * 
   * @param data	the data to use
   */
  protected void initVars(Instances data) {
<span class="fc" id="L1456">    super.initVars(data);</span>

<span class="fc" id="L1458">    m_kernelEvals    = 0;</span>
    // take the first string attribute
<span class="fc" id="L1460">    m_strAttr        = -1;</span>
<span class="pc bpc" id="L1461" title="1 of 2 branches missed.">    for (int i = 0; i &lt; data.numAttributes(); i++) {</span>
<span class="fc bfc" id="L1462" title="All 2 branches covered.">      if (i == data.classIndex())</span>
<span class="fc" id="L1463">	continue;</span>
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">      if (data.attribute(i).type() == Attribute.STRING) {</span>
<span class="fc" id="L1465">	m_strAttr = i;</span>
<span class="fc" id="L1466">	break;</span>
      }
    }
<span class="fc" id="L1469">    m_numInsts       = m_data.numInstances();</span>
<span class="fc" id="L1470">    m_storage        = new double[m_cacheSize];</span>
<span class="fc" id="L1471">    m_keys           = new long[m_cacheSize];</span>
<span class="fc" id="L1472">    m_powersOflambda = calculatePowersOfLambda();</span>
<span class="fc" id="L1473">  }</span>

  /** 
   * Returns the Capabilities of this kernel.
   *
   * @return            the capabilities of this object
   * @see               Capabilities
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1482">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1483">    result.disableAll();</span>
    
<span class="fc" id="L1485">    result.enable(Capability.STRING_ATTRIBUTES);</span>
<span class="fc" id="L1486">    result.enableAllClasses();</span>
<span class="fc" id="L1487">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
<span class="fc" id="L1489">    return result;</span>
  }
  
  /**
   * builds the kernel with the given data.
   * 
   * @param data	the data to base the kernel on
   * @throws Exception	if something goes wrong, e.g., the data does not
   * 			consist of one string attribute and the class
   */
  public void buildKernel(Instances data) throws Exception {
<span class="fc" id="L1500">    super.buildKernel(data);</span>
<span class="fc" id="L1501">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1509">    return RevisionUtils.extract(&quot;$Revision: 5518 $&quot;);</span>
  }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>