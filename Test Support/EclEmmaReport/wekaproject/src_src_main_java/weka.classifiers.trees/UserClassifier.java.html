<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>UserClassifier.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.trees</a> &gt; <span class="el_source">UserClassifier.java</span></div><h1>UserClassifier.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    UserClassifier.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.classifiers.trees;

import weka.classifiers.Classifier;
import weka.classifiers.functions.LinearRegression;
import weka.core.Capabilities;
import weka.core.Drawable;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TechnicalInformation;
import weka.core.TechnicalInformationHandler;
import weka.core.Utils;
import weka.core.Capabilities.Capability;
import weka.core.TechnicalInformation.Field;
import weka.core.TechnicalInformation.Type;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.Remove;
import weka.gui.GenericObjectEditor;
import weka.gui.PropertyDialog;
import weka.gui.treevisualizer.PlaceNode1;
import weka.gui.treevisualizer.PlaceNode2;
import weka.gui.treevisualizer.TreeDisplayEvent;
import weka.gui.treevisualizer.TreeDisplayListener;
import weka.gui.treevisualizer.TreeVisualizer;
import weka.gui.visualize.VisualizePanel;
import weka.gui.visualize.VisualizePanelEvent;
import weka.gui.visualize.VisualizePanelListener;

import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;

import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JTabbedPane;


/**
 &lt;!-- globalinfo-start --&gt;
 * Interactively classify through visual means. You are Presented with a scatter graph of the data against two user selectable attributes, as well as a view of the decision tree. You can create binary splits by creating polygons around data plotted on the scatter graph, as well as by allowing another classifier to take over at points in the decision tree should you see fit.&lt;br/&gt;
 * &lt;br/&gt;
 * For more information see:&lt;br/&gt;
 * &lt;br/&gt;
 * Malcolm Ware, Eibe Frank, Geoffrey Holmes, Mark Hall, Ian H. Witten (2001). Interactive machine learning: letting users build classifiers. Int. J. Hum.-Comput. Stud.. 55(3):281-292.
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- technical-bibtex-start --&gt;
 * BibTeX:
 * &lt;pre&gt;
 * &amp;#64;article{Ware2001,
 *    author = {Malcolm Ware and Eibe Frank and Geoffrey Holmes and Mark Hall and Ian H. Witten},
 *    journal = {Int. J. Hum.-Comput. Stud.},
 *    number = {3},
 *    pages = {281-292},
 *    title = {Interactive machine learning: letting users build classifiers},
 *    volume = {55},
 *    year = {2001},
 *    PS = {http://www.cs.waikato.ac.nz/\~ml/publications/2000/00MW-etal-Interactive-ML.ps}
 * }
 * &lt;/pre&gt;
 * &lt;p/&gt;
 &lt;!-- technical-bibtex-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, classifier is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Malcolm Ware (mfw4@cs.waikato.ac.nz)
 * @version $Revision: 5535 $
 */
<span class="fc" id="L104">public class UserClassifier </span>
  extends Classifier 
  implements Drawable, TreeDisplayListener, VisualizePanelListener,
             TechnicalInformationHandler {
  
  /** for serialization */
  static final long serialVersionUID = 6483901103562809843L;

  /** I am not sure if these are strictly adhered to in visualizepanel
   * so I am making them private to avoid confusion, (note that they will
   * be correct in this class, VLINE and HLINE aren't used).
   */
  private static final int LEAF = 0;
  private static final int RECTANGLE = 1;
  private static final int POLYGON = 2;
  private static final int POLYLINE = 3;
  private static final int VLINE = 5;
  private static final int HLINE =6;
  

  /** The tree display panel. */
<span class="nc" id="L125">  private transient TreeVisualizer m_tView = null;</span>
  /** The instances display. */
<span class="nc" id="L127">  private transient VisualizePanel m_iView = null;</span>
  /** Two references to the structure of the decision tree. */
  private TreeClass m_top, m_focus;
  /** The next number that can be used as a unique id for a node. */
  private int m_nextId;
  /** The tabbed window for the tree and instances view. */
  private transient JTabbedPane m_reps;
  /** The window. */
  private transient JFrame m_mainWin;
  /** The status of whether there is a decision tree ready or not. */
<span class="nc" id="L137">  private boolean m_built=false;</span>
  /** A list of other m_classifiers. */
  private GenericObjectEditor m_classifiers;
  /** A window for selecting other classifiers. */
  private PropertyDialog m_propertyDialog;

  /** Register the property editors we need */
  static {
<span class="fc" id="L145">     GenericObjectEditor.registerEditors();</span>
  }

  /**
   * Main method for testing this class.
   *
   * @param argv should contain command line options (see setOptions)
   */
  public static void main(String [] argv) {
<span class="nc" id="L154">    runClassifier(new UserClassifier(), argv);</span>
<span class="nc" id="L155">  }</span>

  /**
   * @return a string that represents this objects tree.
   */
  public String toString() {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (!m_built) {</span>

<span class="nc" id="L163">      return &quot;Tree Not Built&quot;;</span>
    }
<span class="nc" id="L165">    StringBuffer text = new StringBuffer();</span>
    try {
<span class="nc" id="L167">      m_top.toString(0, text);</span>
      
<span class="nc" id="L169">      m_top.objectStrings(text);</span>

<span class="nc" id="L171">    } catch(Exception e) {</span>
<span class="nc" id="L172">      System.out.println(&quot;error: &quot; + e.getMessage());</span>
    }
    
<span class="nc" id="L175">    return text.toString();</span>
  }

  /**
   * Receives user choices from the tree view, and then deals with these 
   * choices. 
   * @param e The choice. 
   */
  public void userCommand(TreeDisplayEvent e) {
    
<span class="nc bnc" id="L185" title="All 2 branches missed.">    if (m_propertyDialog != null) {</span>
<span class="nc" id="L186">      m_propertyDialog.dispose();</span>
<span class="nc" id="L187">      m_propertyDialog = null;</span>
    }
    try {
<span class="nc bnc" id="L190" title="All 2 branches missed.">      if (m_iView == null || m_tView == null) {</span>
	//throw exception
      }
<span class="nc bnc" id="L193" title="All 2 branches missed.">      if (e.getCommand() == TreeDisplayEvent.NO_COMMAND) {</span>
	//do nothing
      }
<span class="nc bnc" id="L196" title="All 2 branches missed.">      else if (e.getCommand() == TreeDisplayEvent.ADD_CHILDREN) {</span>
	//highlight the particular node and reset the vis panel
<span class="nc bnc" id="L198" title="All 2 branches missed.">	if (m_top == null) {</span>
	  //this shouldn't happen , someone elses code would 
	  //have to have added a trigger to this listener.
<span class="nc" id="L201">	  System.out.println(&quot;Error : Received event from a TreeDisplayer&quot;</span>
			     + &quot; that is unknown to the classifier.&quot;);
	}
	else {
<span class="nc" id="L205">	  m_tView.setHighlight(e.getID());</span>
	  /*if (m_iView == null)
	    {
	    m_iView = new VisualizePanel(this);
	    m_iView.setSize(400, 300);
	    }*/
<span class="nc" id="L211">	  m_focus = m_top.getNode(e.getID());</span>
<span class="nc" id="L212">	  m_iView.setInstances(m_focus.m_training);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">	  if (m_focus.m_attrib1 &gt;= 0) {</span>
<span class="nc" id="L214">	    m_iView.setXIndex(m_focus.m_attrib1);</span>
	  }
<span class="nc bnc" id="L216" title="All 2 branches missed.">	  if (m_focus.m_attrib2 &gt;= 0) {</span>
<span class="nc" id="L217">	    m_iView.setYIndex(m_focus.m_attrib2);</span>
	  }
<span class="nc" id="L219">	  m_iView.setColourIndex(m_focus.m_training.classIndex());</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">	  if (((Double)((FastVector)m_focus.m_ranges.elementAt(0)).</span>
<span class="nc" id="L221">	       elementAt(0)).intValue() != LEAF) {</span>
<span class="nc" id="L222">	    m_iView.setShapes(m_focus.m_ranges);</span>
	  }
	  //m_iView.setSIndex(2);
	}
      }
<span class="nc bnc" id="L227" title="All 2 branches missed.">      else if (e.getCommand() == TreeDisplayEvent.REMOVE_CHILDREN) {</span>
	/*if (m_iView == null)
	  {
	  m_iView = new VisualizePanel(this);
	  m_iView.setSize(400, 300);
	  }*/
<span class="nc" id="L233">	m_focus = m_top.getNode(e.getID());</span>
<span class="nc" id="L234">	m_iView.setInstances(m_focus.m_training);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">	if (m_focus.m_attrib1 &gt;= 0) {</span>
<span class="nc" id="L236">	  m_iView.setXIndex(m_focus.m_attrib1);</span>
	}
<span class="nc bnc" id="L238" title="All 2 branches missed.">	if (m_focus.m_attrib2 &gt;= 0) {</span>
<span class="nc" id="L239">	  m_iView.setYIndex(m_focus.m_attrib2);</span>
	}
<span class="nc" id="L241">	m_iView.setColourIndex(m_focus.m_training.classIndex());</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">	if (((Double)((FastVector)m_focus.m_ranges.elementAt(0)).</span>
<span class="nc" id="L243">	     elementAt(0)).intValue() != LEAF) {</span>
<span class="nc" id="L244">	  m_iView.setShapes(m_focus.m_ranges);</span>
	}
	//m_iView.setSIndex(2);
	//now to remove all the stuff
<span class="nc" id="L248">	m_focus.m_set1 = null;</span>
<span class="nc" id="L249">	m_focus.m_set2 = null;</span>
<span class="nc" id="L250">	m_focus.setInfo(m_focus.m_attrib1, m_focus.m_attrib2, null);</span>
	//tree_frame.getContentPane().removeAll();
<span class="nc" id="L252">	m_tView = new TreeVisualizer(this, graph(), new PlaceNode2());</span>
	//tree_frame.getContentPane().add(m_tView);
<span class="nc" id="L254">	m_reps.setComponentAt(0, m_tView);</span>
	//tree_frame.getContentPane().doLayout();
<span class="nc" id="L256">	m_tView.setHighlight(m_focus.m_identity);</span>
      }
<span class="nc bnc" id="L258" title="All 2 branches missed.">      else if (e.getCommand() == TreeDisplayEvent.CLASSIFY_CHILD) {</span>
	/*if (m_iView == null)
	  {
	  m_iView = new VisualizePanel(this);
	  m_iView.setSize(400, 300);
	  }*/
<span class="nc" id="L264">	m_focus = m_top.getNode(e.getID());</span>
<span class="nc" id="L265">	m_iView.setInstances(m_focus.m_training);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">	if (m_focus.m_attrib1 &gt;= 0) {</span>
<span class="nc" id="L267">	  m_iView.setXIndex(m_focus.m_attrib1);</span>
	}
<span class="nc bnc" id="L269" title="All 2 branches missed.">	if (m_focus.m_attrib2 &gt;= 0) {</span>
<span class="nc" id="L270">	  m_iView.setYIndex(m_focus.m_attrib2);</span>
	}
<span class="nc" id="L272">	m_iView.setColourIndex(m_focus.m_training.classIndex());</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">	if (((Double)((FastVector)m_focus.m_ranges.elementAt(0)).</span>
<span class="nc" id="L274">	     elementAt(0)).intValue() != LEAF) {</span>
<span class="nc" id="L275">	  m_iView.setShapes(m_focus.m_ranges);</span>
	}
	
<span class="nc" id="L278">	Classifier classifierAtNode = m_focus.getClassifier();</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (classifierAtNode != null) {</span>
<span class="nc" id="L280">          m_classifiers.setValue(classifierAtNode);</span>
        }
<span class="nc" id="L282">	m_propertyDialog = new PropertyDialog((Frame) null, m_classifiers, </span>
<span class="nc" id="L283">					      m_mainWin.getLocationOnScreen().x,</span>
<span class="nc" id="L284">					      m_mainWin.getLocationOnScreen().y);</span>
<span class="nc" id="L285">	m_propertyDialog.setVisible(true);</span>
	
	//note property dialog may change all the time
	//but the generic editor which has the listeners does not
	//so at the construction of the editor is when I am going to add
	//the listeners.
	
	
	
	//focus.setClassifier(new IB1());
	//tree_frame.getContentPane().removeAll();
	//////m_tView = new Displayer(this, graph(), new PlaceNode2());
	//tree_frame.getContentPane().add(m_tView);
	//tree_frame.getContentPane().doLayout();
	/////////////reps.setComponentAt(0, m_tView);
<span class="nc" id="L300">	m_tView.setHighlight(m_focus.m_identity);</span>
      }
      /*else if (e.getCommand() == e.SEND_INSTANCES) {
	TreeClass source = m_top.getNode(e.getID());
	m_iView.setExtInstances(source.m_training);
	}*/
<span class="nc bnc" id="L306" title="All 2 branches missed.">      else if (e.getCommand() == TreeDisplayEvent.ACCEPT) {</span>
	
<span class="nc" id="L308">	int well = JOptionPane.showConfirmDialog(m_mainWin, </span>
<span class="nc" id="L309">						 &quot;Are You Sure...\n&quot;</span>
						 + &quot;Click Yes To Accept The&quot;
						 + &quot; Tree&quot; 
						 + &quot;\n Click No To Return&quot;,
<span class="nc" id="L313">						 &quot;Accept Tree&quot;, </span>
<span class="nc" id="L314">						 JOptionPane.YES_NO_OPTION);</span>
	
<span class="nc bnc" id="L316" title="All 2 branches missed.">	if (well == 0) {</span>
<span class="nc" id="L317">	  m_mainWin.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span>
<span class="nc" id="L318">	  m_mainWin.dispose();</span>
<span class="nc" id="L319">	  blocker(false);  //release the thread waiting at blocker to </span>
	  //continue.
	}
	
      }
<span class="nc" id="L324">    } catch(Exception er) {</span>
<span class="nc" id="L325">      System.out.println(&quot;Error : &quot; + er);</span>
<span class="nc" id="L326">      System.out.println(&quot;Part of user input so had to catch here&quot;);</span>
<span class="nc" id="L327">      er.printStackTrace();</span>
    }
<span class="nc" id="L329">  }</span>

  /**
   * This receives shapes from the data view. 
   * It then enters these shapes into the decision tree structure. 
   * @param e Contains the shapes, and other info.
   */
  public void userDataEvent(VisualizePanelEvent e) {
    
<span class="nc bnc" id="L338" title="All 2 branches missed.">    if (m_propertyDialog != null) {</span>
<span class="nc" id="L339">      m_propertyDialog.dispose();</span>
<span class="nc" id="L340">      m_propertyDialog = null;</span>
    }
    
    try {
<span class="nc bnc" id="L344" title="All 2 branches missed.">      if (m_focus != null) {</span>
	

<span class="nc" id="L347">	double wdom = e.getInstances1().numInstances() </span>
<span class="nc" id="L348">	  + e.getInstances2().numInstances();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">	if (wdom == 0) {</span>
<span class="nc" id="L350">	  wdom = 1;</span>
	}
	
<span class="nc" id="L353">	TreeClass tmp = m_focus;</span>
<span class="nc" id="L354">	m_focus.m_set1 = new TreeClass(null, e.getAttribute1(), </span>
<span class="nc" id="L355">				       e.getAttribute2(), m_nextId, </span>
<span class="nc" id="L356">				       e.getInstances1().numInstances() / wdom,</span>
<span class="nc" id="L357"> 				       e.getInstances1(), m_focus);</span>
	
<span class="nc" id="L359">	m_focus.m_set2 = new TreeClass(null, e.getAttribute1(), </span>
<span class="nc" id="L360">				       e.getAttribute2(), m_nextId, </span>
<span class="nc" id="L361">				       e.getInstances2().numInstances() / wdom,</span>
<span class="nc" id="L362">				       e.getInstances2(), m_focus); </span>
	//this needs the other instance
	
	
	//tree_frame.getContentPane().removeAll();  
<span class="nc" id="L367">	m_focus.setInfo(e.getAttribute1(), e.getAttribute2(), e.getValues());</span>
	//System.out.println(graph());
<span class="nc" id="L369">	m_tView = new TreeVisualizer(this, graph(), new PlaceNode2());</span>
	//tree_frame.getContentPane().add(m_tView);
	//tree_frame.getContentPane().doLayout();
<span class="nc" id="L372">	m_reps.setComponentAt(0, m_tView);</span>
	
<span class="nc" id="L374">	m_focus = m_focus.m_set2;</span>
<span class="nc" id="L375">	m_tView.setHighlight(m_focus.m_identity);</span>
<span class="nc" id="L376">	m_iView.setInstances(m_focus.m_training);</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">	if (tmp.m_attrib1 &gt;= 0) {</span>
<span class="nc" id="L378">	  m_iView.setXIndex(tmp.m_attrib1);</span>
	}
<span class="nc bnc" id="L380" title="All 2 branches missed.">	if (tmp.m_attrib2 &gt;= 0) {</span>
<span class="nc" id="L381">	  m_iView.setYIndex(tmp.m_attrib2);</span>
	}
<span class="nc" id="L383">	m_iView.setColourIndex(m_focus.m_training.classIndex());</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">	if (((Double)((FastVector)m_focus.m_ranges.elementAt(0)).</span>
<span class="nc" id="L385">	     elementAt(0)).intValue() != LEAF) {</span>
<span class="nc" id="L386">	  m_iView.setShapes(m_focus.m_ranges);</span>
	}
	//m_iView.setSIndex(2);
      }
      else {
<span class="nc" id="L391">	System.out.println(&quot;Somehow the focus is null&quot;);</span>
      }
<span class="nc" id="L393">    } catch(Exception er) {</span>
<span class="nc" id="L394">      System.out.println(&quot;Error : &quot; + er);</span>
<span class="nc" id="L395">      System.out.println(&quot;Part of user input so had to catch here&quot;);</span>
      //er.printStackTrace();
    }
    
<span class="nc" id="L399">  }</span>
  
  /** 
   * Constructor
   */
<span class="nc" id="L404">  public UserClassifier() {</span>
    //do nothing here except set alot of variables to default values
<span class="nc" id="L406">    m_top = null;</span>
<span class="nc" id="L407">    m_tView = null;</span>
<span class="nc" id="L408">    m_iView = null;</span>
<span class="nc" id="L409">    m_nextId = 0; </span>
    
<span class="nc" id="L411">  }</span>
  
 /**
   *  Returns the type of graph this classifier
   *  represents.
   *  @return Drawable.TREE
   */   
  public int graphType() {
<span class="nc" id="L419">      return Drawable.TREE;</span>
  }

  /**
   * @return A string formatted with a dotty representation of the decision
   * tree.
   * @throws Exception if String can't be built properly.
   */
  public String graph() throws Exception {
    //create a dotty rep of the tree from here
<span class="nc" id="L429">    StringBuffer text = new StringBuffer();</span>
<span class="nc" id="L430">    text.append(&quot;digraph UserClassifierTree {\n&quot; +</span>
		&quot;node [fontsize=10]\n&quot; +
		&quot;edge [fontsize=10 style=bold]\n&quot;);
    
<span class="nc" id="L434">    m_top.toDotty(text);</span>
<span class="nc" id="L435">    return text.toString() +&quot;}\n&quot;;</span>
    
    
  }
  
  /**
   * A function used to stop the code that called buildclassifier
   * from continuing on before the user has finished the decision tree.
   * @param tf True to stop the thread, False to release the thread that is
   * waiting there (if one).
   */
  private synchronized void blocker(boolean tf) {
<span class="nc bnc" id="L447" title="All 2 branches missed.">    if (tf) {</span>
      try {
<span class="nc" id="L449">	wait();</span>
<span class="nc" id="L450">      } catch(InterruptedException e) {</span>
      }
    }
    else {
<span class="nc" id="L454">      notifyAll();</span>
    }
    
    //System.out.println(&quot;out&quot;);
<span class="nc" id="L458">  }</span>

  /**
   * This will return a string describing the classifier.
   * @return The string.
   */
  public String globalInfo() {

<span class="nc" id="L466">    return &quot;Interactively classify through visual means.&quot;</span>
      + &quot; You are Presented with a scatter graph of the data against two user&quot;
      + &quot; selectable attributes, as well as a view of the decision tree.&quot;
      + &quot; You can create binary splits by creating polygons around data&quot;
      + &quot; plotted on the scatter graph, as well as by allowing another&quot;
      + &quot; classifier to take over at points in the decision tree should you&quot;
      + &quot; see fit.\n\n&quot;
      + &quot;For more information see:\n\n&quot;
<span class="nc" id="L474">      + getTechnicalInformation().toString();</span>
  }

  /**
   * Returns an instance of a TechnicalInformation object, containing 
   * detailed information about the technical background of this class,
   * e.g., paper reference or book this class is based on.
   * 
   * @return the technical information about this class
   */
  public TechnicalInformation getTechnicalInformation() {
    TechnicalInformation 	result;
    
<span class="nc" id="L487">    result = new TechnicalInformation(Type.ARTICLE);</span>
<span class="nc" id="L488">    result.setValue(Field.AUTHOR, &quot;Malcolm Ware and Eibe Frank and Geoffrey Holmes and Mark Hall and Ian H. Witten&quot;);</span>
<span class="nc" id="L489">    result.setValue(Field.YEAR, &quot;2001&quot;);</span>
<span class="nc" id="L490">    result.setValue(Field.TITLE, &quot;Interactive machine learning: letting users build classifiers&quot;);</span>
<span class="nc" id="L491">    result.setValue(Field.JOURNAL, &quot;Int. J. Hum.-Comput. Stud.&quot;);</span>
<span class="nc" id="L492">    result.setValue(Field.VOLUME, &quot;55&quot;);</span>
<span class="nc" id="L493">    result.setValue(Field.NUMBER, &quot;3&quot;);</span>
<span class="nc" id="L494">    result.setValue(Field.PAGES, &quot;281-292&quot;);</span>
<span class="nc" id="L495">    result.setValue(Field.PS, &quot;http://www.cs.waikato.ac.nz/~ml/publications/2000/00MW-etal-Interactive-ML.ps&quot;);</span>
    
<span class="nc" id="L497">    return result;</span>
  }

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="nc" id="L506">    Capabilities result = super.getCapabilities();</span>
<span class="nc" id="L507">    result.disableAll();</span>

    // attributes
<span class="nc" id="L510">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="nc" id="L511">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="nc" id="L512">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="nc" id="L513">    result.enable(Capability.STRING_ATTRIBUTES);</span>
<span class="nc" id="L514">    result.enable(Capability.RELATIONAL_ATTRIBUTES);</span>
<span class="nc" id="L515">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="nc" id="L518">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="nc" id="L519">    result.enable(Capability.NUMERIC_CLASS);</span>
<span class="nc" id="L520">    result.enable(Capability.DATE_CLASS);</span>
<span class="nc" id="L521">    result.enable(Capability.MISSING_CLASS_VALUES);</span>

    // instances
<span class="nc" id="L524">    result.setMinimumNumberInstances(0);</span>
    
<span class="nc" id="L526">    return result;</span>
  }

  /**
   * Call this function to build a decision tree for the training
   * data provided.
   * @param i The training data.
   * @throws Exception if can't build classification properly.
   */
  public void buildClassifier(Instances i) throws Exception {
    // can classifier handle the data?
<span class="nc" id="L537">    getCapabilities().testWithFail(i);</span>

    // remove instances with missing class
<span class="nc" id="L540">    i = new Instances(i);</span>
<span class="nc" id="L541">    i.deleteWithMissingClass();</span>
    
    //construct a visualizer
    //construct a tree displayer and feed both then do nothing
    //note that I will display at the bottom of each split how many 
    //fall into each catagory
    
<span class="nc" id="L548">    m_classifiers = new GenericObjectEditor(true);</span>
<span class="nc" id="L549">    m_classifiers.setClassType(Classifier.class);</span>
<span class="nc" id="L550">    m_classifiers.setValue(new weka.classifiers.rules.ZeroR());</span>
    
<span class="nc" id="L552">    ((GenericObjectEditor.GOEPanel)m_classifiers.getCustomEditor())</span>
<span class="nc" id="L553">      .addOkListener(new ActionListener() {</span>
	  public void actionPerformed(ActionEvent e) {
	    //I want to use the focus variable but to trust it I need
	    //to kill the window if anything gets changed by either
	    //editor
	    try {
<span class="nc" id="L559">	      m_focus.m_set1 = null;</span>
<span class="nc" id="L560">	      m_focus.m_set2 = null;</span>
<span class="nc" id="L561">	      m_focus.setInfo(m_focus.m_attrib1, m_focus.m_attrib2, null);</span>
<span class="nc" id="L562">	      m_focus.setClassifier((Classifier)m_classifiers.getValue());</span>
              /*	      m_classifiers = new GenericObjectEditor();
	      m_classifiers.setClassType(Classifier.class);
	      m_classifiers.setValue(new weka.classifiers.rules.ZeroR());
	      ((GenericObjectEditor.GOEPanel)m_classifiers.getCustomEditor())
              .addOkListener(this); */
<span class="nc" id="L568">	      m_tView = new TreeVisualizer(UserClassifier.this, graph(), </span>
<span class="nc" id="L569">				     new PlaceNode2());</span>
<span class="nc" id="L570">	      m_tView.setHighlight(m_focus.m_identity);</span>
<span class="nc" id="L571">	      m_reps.setComponentAt(0, m_tView);</span>
<span class="nc" id="L572">	      m_iView.setShapes(null);</span>
<span class="nc" id="L573">	    } catch(Exception er) {</span>
<span class="nc" id="L574">	      System.out.println(&quot;Error : &quot; + er);</span>
<span class="nc" id="L575">	      System.out.println(&quot;Part of user input so had to catch here&quot;);</span>
<span class="nc" id="L576">              JOptionPane.showMessageDialog(</span>
<span class="nc" id="L577">                         null,</span>
<span class="nc" id="L578">                         &quot;Unable to use &quot; + m_focus.getClassifier().getClass().getName() </span>
<span class="nc" id="L579">                         + &quot; at this node.\n&quot;</span>
<span class="nc" id="L580">                         + &quot;This exception was produced:\n&quot;</span>
<span class="nc" id="L581">                         + er.toString(),</span>
<span class="nc" id="L582">                         &quot;UserClassifier&quot;,</span>
<span class="nc" id="L583">                         JOptionPane.ERROR_MESSAGE);</span>
	    }
<span class="nc" id="L585">	  }</span>
	});
    
<span class="nc" id="L588">    m_built = false;</span>
<span class="nc" id="L589">    m_mainWin = new JFrame();</span>
    
<span class="nc" id="L591">    m_mainWin.addWindowListener(new WindowAdapter() {</span>
	public void windowClosing(WindowEvent e) {
<span class="nc" id="L593">	  int well = JOptionPane.showConfirmDialog(m_mainWin, </span>
<span class="nc" id="L594">						   &quot;Are You Sure...\n&quot;</span>
						   + &quot;Click Yes To Accept&quot;
						   + &quot; The Tree&quot; 
						   + &quot;\n Click No To Return&quot;,
<span class="nc" id="L598">						   &quot;Accept Tree&quot;, </span>
<span class="nc" id="L599">						   JOptionPane.YES_NO_OPTION);</span>
	  
<span class="nc bnc" id="L601" title="All 2 branches missed.">	  if (well == 0) {</span>
<span class="nc" id="L602">	    m_mainWin.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span>
<span class="nc" id="L603">	    blocker(false);</span>
	    
	  }
	  else {
<span class="nc" id="L607">	    m_mainWin.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);</span>
	  }
<span class="nc" id="L609">	}</span>
      });
    
<span class="nc" id="L612">    m_reps = new JTabbedPane();</span>
<span class="nc" id="L613">    m_mainWin.getContentPane().add(m_reps);</span>
    
    //make a backup of the instances so that any changes don't go past here.
<span class="nc" id="L616">    Instances te = new Instances(i, i.numInstances());</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">    for (int noa = 0; noa &lt; i.numInstances(); noa++) {</span>
<span class="nc" id="L618">      te.add(i.instance(noa));</span>
    }
    
<span class="nc" id="L621">    te.deleteWithMissingClass(); //remove all instances with a missing class</span>
    //from training
    
<span class="nc" id="L624">    m_top = new TreeClass(null, 0, 0, m_nextId, 1, te, null);</span>
<span class="nc" id="L625">    m_focus = m_top;</span>
    //System.out.println(graph());
<span class="nc" id="L627">    m_tView = new TreeVisualizer(this, graph(), new PlaceNode1());</span>
    
<span class="nc" id="L629">    m_reps.add(&quot;Tree Visualizer&quot;, m_tView);</span>
    //tree_frame = new JFrame();
    //tree_frame.getContentPane().add(m_tView);
    //tree_frame.setSize(800,600);
    //tree_frame.setVisible(true);
    
<span class="nc" id="L635">    m_tView.setHighlight(m_top.m_identity);</span>
<span class="nc" id="L636">    m_iView = new VisualizePanel(this);</span>
    //m_iView.setSize(400, 300);
<span class="nc" id="L638">    m_iView.setInstances(m_top.m_training);</span>
<span class="nc" id="L639">    m_iView.setColourIndex(te.classIndex());</span>
    //vis_frame = new JFrame();
    //vis_frame.getContentPane().add(m_iView);
    //vis_frame.setSize(400, 300);
    //vis_frame.setVisible(true);
<span class="nc" id="L644">    m_reps.add(&quot;Data Visualizer&quot;, m_iView);</span>
<span class="nc" id="L645">    m_mainWin.setSize(560, 420);</span>
<span class="nc" id="L646">    m_mainWin.setVisible(true);</span>
<span class="nc" id="L647">    blocker(true);          //a call so that the main thread of </span>
    //execution has to wait for the all clear message from the user.
    
    //so that it can be garbage 
<span class="nc bnc" id="L651" title="All 2 branches missed.">    if (m_propertyDialog != null) {</span>
<span class="nc" id="L652">      m_propertyDialog.dispose();</span>
<span class="nc" id="L653">      m_propertyDialog = null;</span>
    }
    
    //collected
<span class="nc" id="L657">    m_classifiers = null;</span>
<span class="nc" id="L658">    m_built = true;</span>
<span class="nc" id="L659">  }</span>

  /**
   * Call this function to get a double array filled with the probability
   * of how likely each class type is the class of the instance.
   * @param i The instance to classify.
   * @return A double array filled with the probalities of each class type.
   * @throws Exception if can't classify instance.
   */
  public double[] distributionForInstance(Instance i) throws Exception {

<span class="nc bnc" id="L670" title="All 2 branches missed.">    if (!m_built) {</span>
<span class="nc" id="L671">      return null;</span>
    }
    
<span class="nc" id="L674">    double[] res = m_top.calcClassType(i);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">    if (m_top.m_training.classAttribute().isNumeric()) {</span>
<span class="nc" id="L676">      return res;</span>
    }

<span class="nc" id="L679">    double most_likely = 0, highest = -1;</span>
<span class="nc" id="L680">    double count = 0;</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">    for (int noa = 0; noa &lt; m_top.m_training.numClasses(); noa++) {</span>
<span class="nc" id="L682">      count += res[noa];</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">      if (res[noa] &gt; highest) {</span>
<span class="nc" id="L684">	most_likely = noa;</span>
<span class="nc" id="L685">	highest = res[noa];</span>
      }
    }
    
<span class="nc bnc" id="L689" title="All 2 branches missed.">    if (count &lt;= 0) {</span>
      //not sure how this happened.
<span class="nc" id="L691">      return null;</span>
    }

<span class="nc bnc" id="L694" title="All 2 branches missed.">    for (int noa = 0; noa &lt; m_top.m_training.numClasses(); noa++) {</span>
<span class="nc" id="L695">      res[noa] = res[noa] / count;</span>
    }
    //System.out.println(&quot;ret&quot;);
    
<span class="nc" id="L699">    return res;</span>
  }
  
  /**
   * Inner class used to represent the actual decision tree structure and data.
   */
  private class TreeClass 
    implements Serializable, RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = 595663560871347434L;
    
    /**
     * This contains the info for the coords of the shape converted 
     * to attrib coords, 
     * for polygon the first attrib is the number of points, 
     * This is not more object oriented because that would 
     * be over kill.
     */
    public FastVector m_ranges;

    /** the first attribute */
    public int m_attrib1;
    
    /** the second attribute */
    public int m_attrib2;
    
    public TreeClass m_set1;
    public TreeClass m_set2;

    /** the parent */
    public TreeClass m_parent;

    /** A string to uniquely identify this node. */
    public String m_identity;
    
    /** the weight of this node */
    public double m_weight;
    
    /** the training instances for this node */
    public Instances m_training;
    
    /** Used instead of the standard leaf if one exists. */
    public Classifier m_classObject;

    /** Used on the instances while classifying if one exists. */
    public Filter m_filter;
    
    /**
     * Constructs a TreeClass node  with all the important information.
     * @param r A FastVector containing the shapes, null if it's a leaf node.
     * @param a1 The first attribute.
     * @param a2 The second attribute.
     * @param id The unique id number for this node.
     * @param w The weight of this node.
     * @param i The instances that make it to this node from the training data.
     * @param p the parent
     * @throws Exception if can't use 'i' properly.
     */
<span class="nc" id="L758">    public TreeClass(FastVector r, int a1, int a2, int id, double w, </span>
		     Instances i, TreeClass p) throws Exception {
<span class="nc" id="L760">      m_set1 = null;</span>
<span class="nc" id="L761">      m_set2 = null;</span>
<span class="nc" id="L762">      m_ranges = r;</span>
<span class="nc" id="L763">      m_classObject = null;</span>
<span class="nc" id="L764">      m_filter = null;</span>
<span class="nc" id="L765">      m_training = i;</span>
<span class="nc" id="L766">      m_attrib1 = a1;</span>
<span class="nc" id="L767">      m_attrib2 = a2;</span>
<span class="nc" id="L768">      m_identity = &quot;N&quot; + String.valueOf(id);</span>
<span class="nc" id="L769">      m_weight = w;</span>
<span class="nc" id="L770">      m_parent = p;</span>
<span class="nc" id="L771">      m_nextId++;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">      if (m_ranges == null) {</span>
	
<span class="nc" id="L774">	setLeaf();</span>
	//this will fill the ranges array with the 
	//number of times each class type occurs for the instances.
	/*m_ranges = new FastVector(1);
	  m_ranges.addElement(new FastVector(i.numClasses() + 1));
	  FastVector tmp = (FastVector)m_ranges.elementAt(0);
	  tmp.addElement(new Double(0));
	  for (int noa = 0; noa &lt; i.numClasses(); noa++) {
	  tmp.addElement(new Double(0));
	  }
	  for (int noa = 0; noa &lt; i.numInstances(); noa++) {
	  tmp.setElementAt(new Double(((Double)tmp.elementAt
	  ((int)i.instance(noa).
	  classValue() + 1)).doubleValue() + 
	  i.instance(noa).weight()),
	  (int)i.instance(noa).classValue() + 1);  
	  //this gets the current class value and alters it and replaces it
	  }*/
      }     
<span class="nc" id="L793">    }</span>
    
    /**
     * Call this to set an alternate classifier For this node.
     * @param c The alternative classifier to use.
     * @throws Exception if alternate classifier can't build classification.
     */
    public void setClassifier(Classifier c) throws Exception {
<span class="nc" id="L801">      m_classObject = c;</span>
<span class="nc" id="L802">      m_classObject.buildClassifier(m_training);</span>
<span class="nc" id="L803">    }</span>

    /**
     * Get the alternate classifier at this node. Returns null if there is
     * no classifier.
     *
     * @return the alternate classifier at this node, or null if there is none.
     */
    public Classifier getClassifier() {
<span class="nc" id="L812">      return m_classObject;</span>
    }
    
    /**
     * Call this to set this node with different information to what
     * it was created with.
     * @param at1 The first attribute.
     * @param at2 The second attribute.
     * @param ar The shapes at this node, null if leaf node, or 
     * alternate classifier.
     * @throws Exception if leaf node and cant't create leaf info.
     */
    public void setInfo(int at1, int at2, FastVector ar) throws Exception {
<span class="nc" id="L825">      m_classObject = null;</span>
<span class="nc" id="L826">      m_filter = null;</span>
<span class="nc" id="L827">      m_attrib1 = at1;</span>
<span class="nc" id="L828">      m_attrib2 = at2;</span>
<span class="nc" id="L829">      m_ranges = ar;</span>
      
      //FastVector tmp;
<span class="nc bnc" id="L832" title="All 2 branches missed.">      if (m_ranges == null) {</span>
<span class="nc" id="L833">	setLeaf();</span>
	/*
	//this will fill the ranges array with the number of times 
	//each class type occurs for the instances.
	  if (m_training != null) {
	    m_ranges = new FastVector(1);
	    m_ranges.addElement(new FastVector(m_training.numClasses() + 1));
	    tmp = (FastVector)m_ranges.elementAt(0);
	    tmp.addElement(new Double(0));
	    for (int noa = 0; noa &lt; m_training.numClasses(); noa++) {
	      tmp.addElement(new Double(0));
	    }
	    for (int noa = 0; noa &lt; m_training.numInstances(); noa++) {
	      tmp.setElementAt(new Double(((Double)tmp.elementAt
					   ((int)m_training.instance(noa).
					    classValue() + 1)).doubleValue() + 
					  m_training.instance(noa).weight()), 
			       (int)m_training.instance(noa).classValue() + 1);
	      //this gets the current class val and alters it and replaces it
	      }
	      }*/
      }
<span class="nc" id="L855">    }</span>
    
    /**
     * This sets up the informtion about this node such as the s.d or the
     * number of each class.
     * @throws Exception if problem with training instances.
     */
    private void setLeaf() throws Exception {
      //this will fill the ranges array with the number of times 
      //each class type occurs for the instances.
      //System.out.println(&quot;ihere&quot;);
<span class="nc bnc" id="L866" title="All 2 branches missed.">      if (m_training != null ) {</span>
	
<span class="nc bnc" id="L868" title="All 2 branches missed.">	if (m_training.classAttribute().isNominal()) {</span>
	  FastVector tmp;
	  
	  //System.out.println(&quot;ehlpe&quot;);
<span class="nc" id="L872">	  m_ranges = new FastVector(1);</span>
<span class="nc" id="L873">	  m_ranges.addElement(new FastVector(m_training.numClasses() + 1));</span>
<span class="nc" id="L874">	  tmp = (FastVector)m_ranges.elementAt(0);</span>
<span class="nc" id="L875">	  tmp.addElement(new Double(0));</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.numClasses(); noa++) {</span>
<span class="nc" id="L877">	    tmp.addElement(new Double(0));</span>
	  }
<span class="nc bnc" id="L879" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.numInstances(); noa++) {</span>
<span class="nc" id="L880">	    tmp.setElementAt(new Double(((Double)tmp.elementAt</span>
<span class="nc" id="L881">					 ((int)m_training.instance(noa).</span>
<span class="nc" id="L882">					  classValue() + 1)).doubleValue() + </span>
<span class="nc" id="L883">					m_training.instance(noa).weight()), </span>
<span class="nc" id="L884">			     (int)m_training.instance(noa).classValue() + 1);</span>
	    //this gets the current class val and alters it and replaces it
	  }
	}
	else {
	  //then calc the standard deviation.
<span class="nc" id="L890">	  m_ranges = new FastVector(1);</span>
<span class="nc" id="L891">	  double t1 = 0;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.numInstances(); noa++) {</span>
<span class="nc" id="L893">	    t1 += m_training.instance(noa).classValue();</span>
	  }
	  
<span class="nc bnc" id="L896" title="All 2 branches missed.">	  if (m_training.numInstances() != 0) {</span>
<span class="nc" id="L897">	    t1 /= m_training.numInstances();</span>
	  }
<span class="nc" id="L899">	  double t2 = 0;</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.numInstances(); noa++) {</span>
<span class="nc" id="L901">	    t2 += Math.pow(m_training.instance(noa).classValue() - t1, 2);</span>
	  }
	  FastVector tmp;
<span class="nc bnc" id="L904" title="All 2 branches missed.">	  if (m_training.numInstances() != 0) {</span>
<span class="nc" id="L905">	    t1 = Math.sqrt(t2 / m_training.numInstances());</span>
<span class="nc" id="L906">	    m_ranges.addElement(new FastVector(2));</span>
<span class="nc" id="L907">	    tmp = (FastVector)m_ranges.elementAt(0);</span>
<span class="nc" id="L908">	    tmp.addElement(new Double(0));</span>
<span class="nc" id="L909">	    tmp.addElement(new Double(t1));</span>
	  }
	  else {
<span class="nc" id="L912">	    m_ranges.addElement(new FastVector(2));</span>
<span class="nc" id="L913">	    tmp = (FastVector)m_ranges.elementAt(0);</span>
<span class="nc" id="L914">	    tmp.addElement(new Double(0));</span>
<span class="nc" id="L915">	    tmp.addElement(new Double(Double.NaN));</span>
	  }
	}
      }
<span class="nc" id="L919">    }</span>

    /**
     * This will recursively go through the tree and return inside the 
     * array the weightings of each of the class types
     * for this instance. Note that this function returns an otherwise 
     * unreferenced double array so there are no worry's about
     * making changes.
     *
     * @param i The instance to test
     * @return A double array containing the results.
     * @throws Exception if can't use instance i properly.
     */
    public double[] calcClassType(Instance i) throws Exception {
      //note that it will be the same calcs for both numeric and nominal
      //attrib types.
      //note the weightings for returning stuff will need to be modified 
      //to work properly but will do for now.
<span class="nc" id="L937">      double x = 0, y = 0;</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">      if (m_attrib1 &gt;= 0) {</span>
<span class="nc" id="L939">	x = i.value(m_attrib1);</span>
      }
<span class="nc bnc" id="L941" title="All 2 branches missed.">      if (m_attrib2 &gt;= 0) {</span>
<span class="nc" id="L942">	y = i.value(m_attrib2);</span>
      }
      double[] rt;
<span class="nc bnc" id="L945" title="All 2 branches missed.">      if (m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L946">	rt = new double[m_training.numClasses()];</span>
      }
      else {
<span class="nc" id="L949">	rt = new double[1];</span>
      }

      FastVector tmp;
<span class="nc bnc" id="L953" title="All 2 branches missed.">      if (m_classObject != null) {</span>
	//then use the classifier.
<span class="nc bnc" id="L955" title="All 2 branches missed.">	if (m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L956">	  rt[(int)m_classObject.classifyInstance(i)] = 1;</span>
	}
	else {
<span class="nc bnc" id="L959" title="All 2 branches missed.">	  if (m_filter != null) {</span>
<span class="nc" id="L960">	    m_filter.input(i);</span>
<span class="nc" id="L961">	    rt[0] = m_classObject.classifyInstance(m_filter.output());</span>
	  }
	  else {
<span class="nc" id="L964">	    rt[0] = m_classObject.classifyInstance(i);</span>
	  }
	}
	//System.out.println(&quot;j48&quot;);
<span class="nc" id="L968">	return rt;</span>
      }
<span class="nc bnc" id="L970" title="All 2 branches missed.">      else if (((Double)((FastVector)m_ranges.elementAt(0)).</span>
<span class="nc" id="L971">		elementAt(0)).intValue() == LEAF) {</span>
	//System.out.println(&quot;leaf&quot;);
	//then this is a leaf
	//rt = new double[m_training.numClasses()];
	
<span class="nc bnc" id="L976" title="All 2 branches missed.">	if (m_training.classAttribute().isNumeric()) {</span>
	 
<span class="nc" id="L978">	  setLinear();</span>
<span class="nc" id="L979">	  m_filter.input(i);</span>
<span class="nc" id="L980">	  rt[0] = m_classObject.classifyInstance(m_filter.output());</span>
<span class="nc" id="L981">	  return rt;</span>
	}
	
<span class="nc" id="L984">	int totaler = 0;</span>
<span class="nc" id="L985">	tmp = (FastVector)m_ranges.elementAt(0);</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">	for (int noa = 0; noa &lt; m_training.numClasses();noa++) {</span>
<span class="nc" id="L987">	  rt[noa] = ((Double)tmp.elementAt(noa + 1)).doubleValue();</span>
<span class="nc" id="L988">	  totaler += rt[noa];</span>
	}
<span class="nc bnc" id="L990" title="All 2 branches missed.">	for (int noa = 0; noa &lt; m_training.numClasses(); noa++) {</span>
<span class="nc" id="L991">	  rt[noa] = rt[noa] / totaler;</span>
	}
<span class="nc" id="L993">	return rt;</span>
      }
      
<span class="nc bnc" id="L996" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_ranges.size(); noa++) {</span>
	
<span class="nc" id="L998">	tmp = (FastVector)m_ranges.elementAt(noa);</span>
	
<span class="nc bnc" id="L1000" title="All 2 branches missed.">	if (((Double)tmp.elementAt(0)).intValue() </span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">	    == VLINE &amp;&amp; !Instance.isMissingValue(x)) {</span>
	  
	}
<span class="nc bnc" id="L1004" title="All 2 branches missed.">	else if (((Double)tmp.elementAt(0)).intValue() </span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">		 == HLINE &amp;&amp; !Instance.isMissingValue(y)) {</span>
	  
	}
<span class="nc bnc" id="L1008" title="All 4 branches missed.">	else if (Instance.isMissingValue(x) || Instance.isMissingValue(y)) {</span>
	  //System.out.println(&quot;miss&quot;);
	  //then go down both branches using their weights
<span class="nc" id="L1011">	  rt = m_set1.calcClassType(i);</span>
<span class="nc" id="L1012">	  double[] tem = m_set2.calcClassType(i);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">	  if (m_training.classAttribute().isNominal()) {</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">	    for (int nob = 0; nob &lt; m_training.numClasses(); nob++) {</span>
<span class="nc" id="L1015">	      rt[nob] *= m_set1.m_weight;</span>
<span class="nc" id="L1016">	      rt[nob] += tem[nob] * m_set2.m_weight;</span>
	    }
	  }
	  else {
<span class="nc" id="L1020">	    rt[0] *= m_set1.m_weight;</span>
<span class="nc" id="L1021">	    rt[0] += tem[0] * m_set2.m_weight;</span>
	  }
<span class="nc" id="L1023">	  return rt;</span>
	}
<span class="nc bnc" id="L1025" title="All 2 branches missed.">	else if (((Double)tmp.elementAt(0)).intValue() == RECTANGLE) {</span>
	  //System.out.println(&quot;RECT&quot;);
<span class="nc bnc" id="L1027" title="All 2 branches missed.">	  if (x &gt;= ((Double)tmp.elementAt(1)).doubleValue() &amp;&amp; </span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">	      x &lt;= ((Double)tmp.elementAt(3)).doubleValue() &amp;&amp; </span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">	      y &lt;= ((Double)tmp.elementAt(2)).doubleValue() &amp;&amp; </span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">	      y &gt;= ((Double)tmp.elementAt(4)).doubleValue()) {</span>
	    //then falls inside the rectangle
	    //System.out.println(&quot;true&quot;);
<span class="nc" id="L1033">	    rt = m_set1.calcClassType(i);</span>
<span class="nc" id="L1034">	    return rt;</span>
	  }
	  
	}
<span class="nc bnc" id="L1038" title="All 2 branches missed.">	else if (((Double)tmp.elementAt(0)).intValue() == POLYGON) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">	  if (inPoly(tmp, x, y)) {</span>
<span class="nc" id="L1040">	    rt = m_set1.calcClassType(i);</span>
<span class="nc" id="L1041">	    return rt;</span>
	  }
	}
<span class="nc bnc" id="L1044" title="All 2 branches missed.">	else if (((Double)tmp.elementAt(0)).intValue() == POLYLINE) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">	  if (inPolyline(tmp, x, y)) {</span>
<span class="nc" id="L1046">	    rt = m_set1.calcClassType(i);</span>
<span class="nc" id="L1047">	    return rt;</span>
	  }
	}
      }
      //is outside the split
<span class="nc bnc" id="L1052" title="All 2 branches missed.">      if (m_set2 != null) {</span>
<span class="nc" id="L1053">	rt = m_set2.calcClassType(i);</span>
      }
<span class="nc" id="L1055">      return rt;</span>
    }
    
    /**
     * This function gets called to set the node to use a linear regression
     * and attribute filter.
     * @throws Exception If can't set a default linear egression model.
     */
    private void setLinear() throws Exception {
      //then set default behaviour for node.
      //set linear regression combined with attribute filter
      
      //find the attributes used for splitting.
<span class="nc" id="L1068">      boolean[] attributeList = new boolean[m_training.numAttributes()];</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_training.numAttributes(); noa++) {</span>
<span class="nc" id="L1070">	attributeList[noa] = false;</span>
      }
      
<span class="nc" id="L1073">      TreeClass temp = this;</span>
<span class="nc" id="L1074">      attributeList[m_training.classIndex()] = true;</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">      while (temp != null) {</span>
<span class="nc" id="L1076">	attributeList[temp.m_attrib1] = true;</span>
<span class="nc" id="L1077">	attributeList[temp.m_attrib2] = true;</span>
<span class="nc" id="L1078">	temp = temp.m_parent;</span>
      }
<span class="nc" id="L1080">      int classind = 0;</span>
      
      
      //find the new class index
<span class="nc bnc" id="L1084" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_training.classIndex(); noa++) {</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">	if (attributeList[noa]) {</span>
<span class="nc" id="L1086">	  classind++;</span>
	}
      }
      //count how many attribs were used
<span class="nc" id="L1090">      int count = 0;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_training.numAttributes(); noa++) {</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">	if (attributeList[noa]) {</span>
<span class="nc" id="L1093">	  count++;</span>
	}
      }
      
      //fill an int array with the numbers of those attribs
<span class="nc" id="L1098">      int[] attributeList2 = new int[count];</span>
<span class="nc" id="L1099">      count = 0;</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_training.numAttributes(); noa++) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">	if (attributeList[noa]) {</span>
<span class="nc" id="L1102">	  attributeList2[count] = noa;</span>
<span class="nc" id="L1103">	  count++;</span>
	}
      }
      
<span class="nc" id="L1107">      m_filter = new Remove();</span>
<span class="nc" id="L1108">      ((Remove)m_filter).setInvertSelection(true);</span>
<span class="nc" id="L1109">      ((Remove)m_filter).setAttributeIndicesArray(attributeList2);</span>
<span class="nc" id="L1110">      m_filter.setInputFormat(m_training);</span>
      
<span class="nc" id="L1112">      Instances temp2 = Filter.useFilter(m_training, m_filter);</span>
<span class="nc" id="L1113">      temp2.setClassIndex(classind);</span>
<span class="nc" id="L1114">      m_classObject = new LinearRegression();</span>
<span class="nc" id="L1115">      m_classObject.buildClassifier(temp2);</span>
<span class="nc" id="L1116">    }</span>
    
    /**
     * Call to find out if an instance is in a polyline.
     * @param ob The polyline to check.
     * @param x The value of attribute1 to check.
     * @param y The value of attribute2 to check.
     * @return True if inside, false if not.
     */
    private boolean inPolyline(FastVector ob, double x, double y) {
      //this works similar to the inPoly below except that
      //the first and last lines are treated as extending infinite 
      //in one direction and 
      //then infinitly in the x dirction their is a line that will 
      //normaly be infinite but
      //can be finite in one or both directions
      
<span class="nc" id="L1133">      int countx = 0;</span>
      double vecx, vecy;
      double change;
      double x1, y1, x2, y2;
      
<span class="nc bnc" id="L1138" title="All 2 branches missed.">      for (int noa = 1; noa &lt; ob.size() - 4; noa+= 2) {</span>
<span class="nc" id="L1139">	y1 = ((Double)ob.elementAt(noa+1)).doubleValue();</span>
<span class="nc" id="L1140">	y2 = ((Double)ob.elementAt(noa+3)).doubleValue();</span>
<span class="nc" id="L1141">	x1 = ((Double)ob.elementAt(noa)).doubleValue();</span>
<span class="nc" id="L1142">	x2 = ((Double)ob.elementAt(noa+2)).doubleValue();</span>
<span class="nc" id="L1143">	vecy = y2 - y1;</span>
<span class="nc" id="L1144">	vecx = x2 - x1;</span>
<span class="nc bnc" id="L1145" title="All 4 branches missed.">	if (noa == 1 &amp;&amp; noa == ob.size() - 6) {</span>
	  //then do special test first and last edge
<span class="nc bnc" id="L1147" title="All 2 branches missed.">	  if (vecy != 0) {</span>
<span class="nc" id="L1148">	    change = (y - y1) / vecy;</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">	    if (vecx * change + x1 &gt;= x) {</span>
	      //then intersection
<span class="nc" id="L1151">	      countx++;</span>
	    }
	  }
	}
<span class="nc bnc" id="L1155" title="All 2 branches missed.">	else if (noa == 1) {</span>
<span class="nc bnc" id="L1156" title="All 8 branches missed.">	  if ((y &lt; y2 &amp;&amp; vecy &gt; 0) || (y &gt; y2 &amp;&amp; vecy &lt; 0)) {</span>
	    //now just determine intersection or not
<span class="nc" id="L1158">	    change = (y - y1) / vecy;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">	    if (vecx * change + x1 &gt;= x) {</span>
	      //then intersection on horiz
<span class="nc" id="L1161">	      countx++;</span>
	    }
	  }
	}
<span class="nc bnc" id="L1165" title="All 2 branches missed.">	else if (noa == ob.size() - 6) {</span>
	  //then do special test on last edge
<span class="nc bnc" id="L1167" title="All 8 branches missed.">	  if ((y &lt;= y1 &amp;&amp; vecy &lt; 0) || (y &gt;= y1 &amp;&amp; vecy &gt; 0)) {</span>
<span class="nc" id="L1168">	    change = (y - y1) / vecy;</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">	    if (vecx * change + x1 &gt;= x) {</span>
<span class="nc" id="L1170">	      countx++;</span>
	    }
	  }
	  
	}
<span class="nc bnc" id="L1175" title="All 8 branches missed.">	else if ((y1 &lt;= y &amp;&amp; y &lt; y2) || (y2 &lt; y &amp;&amp; y &lt;= y1)) {</span>
	  //then continue tests.
<span class="nc bnc" id="L1177" title="All 2 branches missed.">	  if (vecy == 0) {</span>
	    //then lines are parallel stop tests in 
	    //ofcourse it should never make it this far
	  }
	  else {
<span class="nc" id="L1182">	    change = (y - y1) / vecy;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">	    if (vecx * change + x1 &gt;= x) {</span>
	      //then intersects on horiz
<span class="nc" id="L1185">	      countx++;</span>
	    }
	  }
	}
	
      }
      
      //now check for intersection with the infinity line
<span class="nc" id="L1193">      y1 = ((Double)ob.elementAt(ob.size() - 2)).doubleValue();</span>
<span class="nc" id="L1194">      y2 = ((Double)ob.elementAt(ob.size() - 1)).doubleValue();</span>
      
<span class="nc bnc" id="L1196" title="All 2 branches missed.">      if (y1 &gt; y2) {</span>
	//then normal line
<span class="nc bnc" id="L1198" title="All 4 branches missed.">	if (y1 &gt;= y &amp;&amp; y &gt; y2) {</span>
<span class="nc" id="L1199">	  countx++;</span>
	}
      }
      else {
	//then the line segment is inverted
<span class="nc bnc" id="L1204" title="All 4 branches missed.">	if (y1 &gt;= y || y &gt; y2) {</span>
<span class="nc" id="L1205">	  countx++;</span>
	}
      }
      
<span class="nc bnc" id="L1209" title="All 2 branches missed.">      if ((countx % 2) == 1) {</span>
<span class="nc" id="L1210">	return true;</span>
      }
      else {
<span class="nc" id="L1213">	return false;</span>
      }
    }
    
    /** 
     * Call this to determine if an instance is in a polygon.
     * @param ob The polygon.
     * @param x The value of attribute 1.
     * @param y The value of attribute 2.
     * @return True if in polygon, false if not.
     */
    private boolean inPoly(FastVector ob, double x, double y) {
<span class="nc" id="L1225">      int count = 0;</span>
      double vecx, vecy;
      double change;
      double x1, y1, x2, y2;
<span class="nc bnc" id="L1229" title="All 2 branches missed.">      for (int noa = 1; noa &lt; ob.size() - 2; noa += 2) {</span>
<span class="nc" id="L1230">	y1 = ((Double)ob.elementAt(noa+1)).doubleValue();</span>
<span class="nc" id="L1231">	y2 = ((Double)ob.elementAt(noa+3)).doubleValue();</span>
<span class="nc bnc" id="L1232" title="All 8 branches missed.">	if ((y1 &lt;= y &amp;&amp; y &lt; y2) || (y2 &lt; y &amp;&amp; y &lt;= y1)) {</span>
	  //then continue tests.
<span class="nc" id="L1234">	  vecy = y2 - y1;</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">	  if (vecy == 0) {</span>
	    //then lines are parallel stop tests for this line
	  }
	  else {
<span class="nc" id="L1239">	    x1 = ((Double)ob.elementAt(noa)).doubleValue();</span>
<span class="nc" id="L1240">	    x2 = ((Double)ob.elementAt(noa+2)).doubleValue();</span>
<span class="nc" id="L1241">	    vecx = x2 - x1;</span>
<span class="nc" id="L1242">	    change = (y - y1) / vecy;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">	    if (vecx * change + x1 &gt;= x) {</span>
	      //then add to count as an intersected line
<span class="nc" id="L1245">	      count++;</span>
	    }
	  }
	  
	}
      }
<span class="nc bnc" id="L1251" title="All 2 branches missed.">      if ((count % 2) == 1) {</span>
	//then lies inside polygon
	//System.out.println(&quot;in&quot;);
<span class="nc" id="L1254">	return true;</span>
      }
      else {
	//System.out.println(&quot;out&quot;);
<span class="nc" id="L1258">	return false;</span>
      }
      //System.out.println(&quot;WHAT?!?!?!?!!?!??!?!&quot;);
      //return false;
    }

    /**
     * Goes through the tree structure recursively and returns the node that
     * has the id.
     * @param id The node to find.
     * @return The node that matches the id.
     */
    public TreeClass getNode(String id) {
      //returns the treeclass object with the particular ident
<span class="nc bnc" id="L1272" title="All 2 branches missed.">      if (id.equals(m_identity)) {</span>
<span class="nc" id="L1273">	return this;</span>
      }
      
<span class="nc bnc" id="L1276" title="All 2 branches missed.">      if (m_set1 != null) {</span>
<span class="nc" id="L1277">	TreeClass tmp = m_set1.getNode(id);</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">	if (tmp != null) {</span>
<span class="nc" id="L1279">	  return tmp;</span>
	}
      }
<span class="nc bnc" id="L1282" title="All 2 branches missed.">      if (m_set2 != null) {</span>
<span class="nc" id="L1283">	TreeClass tmp = m_set2.getNode(id);</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">	if (tmp != null) {</span>
<span class="nc" id="L1285">	  return tmp;</span>
	}
      }
<span class="nc" id="L1288">      return null;</span>
    }
    
    /**
     * Returns a string containing a bit of information about this node, in 
     * alternate form.
     * @param s The string buffer to fill.
     * @throws Exception if can't create label.
     */
    public void getAlternateLabel(StringBuffer s) throws Exception {
      
      //StringBuffer s = new StringBuffer();
      
<span class="nc" id="L1301">      FastVector tmp = (FastVector)m_ranges.elementAt(0);</span>
      
<span class="nc bnc" id="L1303" title="All 4 branches missed.">      if (m_classObject != null &amp;&amp; m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L1304">	s.append(&quot;Classified by &quot; + m_classObject.getClass().getName());</span>
      }
<span class="nc bnc" id="L1306" title="All 2 branches missed.">      else if (((Double)tmp.elementAt(0)).intValue() == LEAF) {</span>
<span class="nc bnc" id="L1307" title="All 2 branches missed.">	if (m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L1308">	  double high = -1000;</span>
<span class="nc" id="L1309">	  int num = 0;</span>
<span class="nc" id="L1310">	  double count = 0;</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.classAttribute().numValues();</span>
<span class="nc" id="L1312">	       noa++) {</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">	    if (((Double)tmp.elementAt(noa + 1)).doubleValue() &gt; high) {</span>
<span class="nc" id="L1314">	      high = ((Double)tmp.elementAt(noa + 1)).doubleValue();</span>
<span class="nc" id="L1315">	      num  = noa + 1;</span>
	    }
<span class="nc" id="L1317">	    count += ((Double)tmp.elementAt(noa + 1)).doubleValue();</span>
	  }
<span class="nc" id="L1319">	  s.append(m_training.classAttribute().value(num-1) + &quot;(&quot; + count);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">	  if (count &gt; high) {</span>
<span class="nc" id="L1321">	    s.append(&quot;/&quot; + (count - high));</span>
	  }
<span class="nc" id="L1323">	  s.append(&quot;)&quot;);</span>
	}
	else {
<span class="nc bnc" id="L1326" title="All 2 branches missed.">	  if (m_classObject == null </span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">	      &amp;&amp; ((Double)tmp.elementAt(0)).intValue() == LEAF) {</span>
<span class="nc" id="L1328">	    setLinear();</span>
	  }
<span class="nc" id="L1330">	  s.append(&quot;Standard Deviation = &quot; </span>
<span class="nc" id="L1331">		   + Utils.doubleToString(((Double)tmp.elementAt(1))</span>
<span class="nc" id="L1332">					  .doubleValue(), 6));</span>
	  
	}
      }
      else {
<span class="nc" id="L1337">	s.append(&quot;Split on &quot;);</span>
<span class="nc" id="L1338">	s.append(m_training.attribute(m_attrib1).name() + &quot; AND &quot;);</span>
<span class="nc" id="L1339">	s.append(m_training.attribute(m_attrib2).name());</span>
	
	
      }
      
      //return s.toString();
<span class="nc" id="L1345">    }</span>
    
    /**
     * Returns a string containing a bit of information about this node.
     * @param s The stringbuffer to fill.
     * @throws Exception if can't create label.
     */
    public void getLabel(StringBuffer s) throws Exception {
      //for now just return identity
      //StringBuffer s = new StringBuffer();
      
<span class="nc" id="L1356">      FastVector tmp = (FastVector)m_ranges.elementAt(0);</span>
      
      
<span class="nc bnc" id="L1359" title="All 4 branches missed.">      if (m_classObject != null &amp;&amp; m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L1360">	s.append(&quot;Classified by\\n&quot; + m_classObject.getClass().getName());</span>
      }
<span class="nc bnc" id="L1362" title="All 2 branches missed.">      else if (((Double)tmp.elementAt(0)).intValue() == LEAF) {</span>
	
<span class="nc bnc" id="L1364" title="All 2 branches missed.">	if (m_training.classAttribute().isNominal()) {</span>
<span class="nc" id="L1365">	  boolean first = true;</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">	  for (int noa = 0; noa &lt; m_training.classAttribute().numValues(); </span>
<span class="nc" id="L1367">	       noa++) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">	    if (((Double)tmp.elementAt(noa + 1)).doubleValue() &gt; 0) {</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">	      if (first)</span>
		{
<span class="nc" id="L1371">		  s.append(&quot;[&quot; + m_training.classAttribute().value(noa));</span>
<span class="nc" id="L1372">		  first = false;</span>
		}
	      else
		{
<span class="nc" id="L1376">		  s.append(&quot;\\n[&quot; + m_training.classAttribute().value(noa));</span>
		}
<span class="nc" id="L1378">	      s.append(&quot;, &quot; + ((Double)tmp.elementAt(noa + 1)).doubleValue() </span>
<span class="nc" id="L1379">		       + &quot;]&quot;);</span>
	    }      
	  }
	}
	else {
<span class="nc bnc" id="L1384" title="All 2 branches missed.">	  if (m_classObject == null </span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">	      &amp;&amp; ((Double)tmp.elementAt(0)).intValue() == LEAF) {</span>
<span class="nc" id="L1386">	    setLinear();</span>
	  }
<span class="nc" id="L1388">	  s.append(&quot;Standard Deviation = &quot; </span>
<span class="nc" id="L1389">		   + Utils.doubleToString(((Double)tmp.elementAt(1))</span>
<span class="nc" id="L1390">		   .doubleValue(), 6));</span>
	}
      }
      else {
<span class="nc" id="L1394">	s.append(&quot;Split on\\n&quot;);</span>
<span class="nc" id="L1395">	s.append(m_training.attribute(m_attrib1).name() + &quot; AND\\n&quot;);</span>
<span class="nc" id="L1396">	s.append(m_training.attribute(m_attrib2).name());</span>
      }
      //return s.toString();
<span class="nc" id="L1399">    }</span>

    /**
     * Converts The tree structure to a dotty string.
     * @param t The stringbuffer to fill with the dotty structure.
     * @throws Exception if can't convert structure to dotty.
     */
    public void toDotty(StringBuffer t) throws Exception {
      //this will recursively create all the dotty info for the structure
<span class="nc" id="L1408">      t.append(m_identity + &quot; [label=\&quot;&quot;);</span>
<span class="nc" id="L1409">      getLabel(t);</span>
<span class="nc" id="L1410">      t.append(&quot;\&quot; &quot;);</span>
      //System.out.println(((Double)((FastVector)ranges.elementAt(0)).
      //elementAt(0)).intValue() + &quot; A num &quot;);
<span class="nc bnc" id="L1413" title="All 2 branches missed.">      if (((Double)((FastVector)m_ranges.elementAt(0)).elementAt(0)).intValue()</span>
	  == LEAF) {
<span class="nc" id="L1415">	t.append(&quot;shape=box &quot;);</span>
      }
      else {
<span class="nc" id="L1418">	t.append(&quot;shape=ellipse &quot;);</span>
      }
<span class="nc" id="L1420">      t.append(&quot;style=filled color=gray95]\n&quot;);</span>
      
<span class="nc bnc" id="L1422" title="All 2 branches missed.">      if (m_set1 != null) {</span>
<span class="nc" id="L1423">	t.append(m_identity + &quot;-&gt;&quot;);</span>
<span class="nc" id="L1424">	t.append(m_set1.m_identity + &quot; [label=\&quot;True\&quot;]\n&quot;);//the edge for </span>
	//the left
<span class="nc" id="L1426">	m_set1.toDotty(t);</span>
      }
<span class="nc bnc" id="L1428" title="All 2 branches missed.">      if (m_set2 != null) {</span>
<span class="nc" id="L1429">	t.append(m_identity + &quot;-&gt;&quot;);</span>
<span class="nc" id="L1430">	t.append(m_set2.m_identity + &quot; [label=\&quot;False\&quot;]\n&quot;); //the edge for </span>
	//the 
	//right
<span class="nc" id="L1433">	m_set2.toDotty(t);</span>
      }
      
<span class="nc" id="L1436">    }</span>
    
    /**
     * This will append the class Object in the tree to the string buffer.
     * @param t The stringbuffer.
     */
    public void objectStrings(StringBuffer t) {
      
<span class="nc bnc" id="L1444" title="All 2 branches missed.">      if (m_classObject != null) {</span>
<span class="nc" id="L1445">	t.append(&quot;\n\n&quot; + m_identity +&quot; {\n&quot; + m_classObject.toString()+&quot;\n}&quot;);</span>
      }
<span class="nc bnc" id="L1447" title="All 2 branches missed.">      if (m_set1 != null) {</span>
<span class="nc" id="L1448">	m_set1.objectStrings(t);</span>
      }
<span class="nc bnc" id="L1450" title="All 2 branches missed.">      if (m_set2 != null) {</span>
<span class="nc" id="L1451">	m_set2.objectStrings(t);</span>
      }
<span class="nc" id="L1453">    }</span>
    
    /**
     * Converts the tree structure to a string. for people to read.
     * @param l How deep this node is in the tree.
     * @param t The stringbuffer to fill with the string.
     * @throws Exception if can't convert th string.
     */
    public void toString(int l, StringBuffer t) throws Exception {
      
<span class="nc bnc" id="L1463" title="All 2 branches missed.">      if (((Double)((FastVector)m_ranges.elementAt(0)).elementAt(0)).intValue()</span>
	  == LEAF) {
<span class="nc" id="L1465">	t.append(&quot;: &quot; + m_identity + &quot; &quot;);</span>
<span class="nc" id="L1466">	getAlternateLabel(t);</span>
      }
<span class="nc bnc" id="L1468" title="All 2 branches missed.">      if (m_set1 != null) {</span>
<span class="nc" id="L1469">	t.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">	for (int noa = 0; noa &lt; l; noa++) {</span>
<span class="nc" id="L1471">	  t.append(&quot;|   &quot;);</span>
	  
	}
<span class="nc" id="L1474">	getAlternateLabel(t);</span>
<span class="nc" id="L1475">	t.append(&quot; (In Set)&quot;);</span>
<span class="nc" id="L1476">	m_set1.toString(l+1, t);</span>
      }
<span class="nc bnc" id="L1478" title="All 2 branches missed.">      if (m_set2 != null) {</span>
<span class="nc" id="L1479">	t.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">	for (int noa = 0; noa &lt; l; noa++) {</span>
<span class="nc" id="L1481">	  t.append(&quot;|   &quot;);</span>
	}
<span class="nc" id="L1483">	getAlternateLabel(t);</span>
<span class="nc" id="L1484">	t.append(&quot; (Not in Set)&quot;);</span>
<span class="nc" id="L1485">	m_set2.toString(l+1, t);</span>
      }
      //return t.toString();
<span class="nc" id="L1488">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L1496">      return RevisionUtils.extract(&quot;$Revision: 5535 $&quot;);</span>
    }
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L1506">    return RevisionUtils.extract(&quot;$Revision: 5535 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>