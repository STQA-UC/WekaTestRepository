<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>CheckEstimator.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.estimators</a> &gt; <span class="el_source">CheckEstimator.java</span></div><h1>CheckEstimator.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    CheckEstimator.java
 *    Copyright (C) 1999 University of Waikato, Hamilton, New Zealand
 *
 */

package weka.estimators;

import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.TestInstances;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

/**
 * Class for examining the capabilities and finding problems with 
 * estimators. If you implement a estimator using the WEKA.libraries,
 * you should run the checks on it to ensure robustness and correct
 * operation. Passing all the tests of this object does not mean
 * bugs in the estimator don't exist, but this will help find some
 * common ones. &lt;p/&gt;
 * 
 * Typical usage: &lt;p/&gt;
 * &lt;code&gt;java weka.estimators.CheckEstimator -W estimator_name 
 * estimator_options &lt;/code&gt;&lt;p/&gt;
 * 
 * This class uses code from the CheckEstimatorClass
 * ATTENTION! Current estimators can only 
 * 1. split on a nominal class attribute
 * 2. build estimators for nominal and numeric attributes
 * 3. build estimators independendly of the class type
 * The functionality to test on other class and attribute types
 * is left in big parts in the code. 
 * 
 * CheckEstimator reports on the following:
 * &lt;ul&gt;
 *    &lt;li&gt; Estimator abilities 
 *      &lt;ul&gt;
 *         &lt;li&gt; Possible command line options to the estimator &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can predict nominal, numeric, string, 
 *              date or relational class attributes. Warnings will be displayed if 
 *              performance is worse than ZeroR &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can be trained incrementally &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can build estimates for numeric attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle nominal attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle string attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle date attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle relational  attributes &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator build estimates for multi-instance data &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle missing attribute values &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle missing class values &lt;/li&gt;
 *         &lt;li&gt; Whether a nominal estimator only handles 2 class problems &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator can handle instance weights &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Correct functioning 
 *      &lt;ul&gt;
 *         &lt;li&gt; Correct initialisation during addvalues (i.e. no result
 *              changes when addValues called repeatedly) &lt;/li&gt;
 *         &lt;li&gt; Whether incremental training produces the same results
 *              as during non-incremental training (which may or may not 
 *              be OK) &lt;/li&gt;
 *         &lt;li&gt; Whether the estimator alters the data pased to it 
 *              (number of instances, instance order, instance weights, etc) &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 *    &lt;li&gt; Degenerate cases 
 *      &lt;ul&gt;
 *         &lt;li&gt; building estimator with zero training instances &lt;/li&gt;
 *         &lt;li&gt; all but one attribute attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all attribute attribute values missing &lt;/li&gt;
 *         &lt;li&gt; all but one class values missing &lt;/li&gt;
 *         &lt;li&gt; all class values missing &lt;/li&gt;
 *      &lt;/ul&gt;
 *    &lt;/li&gt;
 * &lt;/ul&gt;
 * Running CheckEstimator with the debug option set will output the 
 * training and test datasets for any failed tests.&lt;p/&gt;
 *
 * The &lt;code&gt;weka.estimators.AbstractEstimatorTest&lt;/code&gt; uses this
 * class to test all the estimators. Any changes here, have to be 
 * checked in that abstract test class, too. &lt;p/&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -D
 *  Turn on debugging output.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S
 *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;num&amp;gt;
 *  The number of instances in the datasets (default 100).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -W
 *  Full name of the estimator analysed.
 *  eg: weka.estimators.NormalEstimator&lt;/pre&gt;
 * 
 * &lt;pre&gt; 
 * Options specific to estimator weka.estimators.NormalEstimator:
 * &lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  If set, estimator is run in debug mode and
 *  may output additional info to the console&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * Options after -- are passed to the designated estimator.&lt;p/&gt;
 *
 * @author Len Trigg (trigg@cs.waikato.ac.nz)
 * @author FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.5 $
 * @see TestInstances
 */
<span class="nc" id="L143">public class CheckEstimator implements OptionHandler, RevisionHandler {</span>

  /*
   * Note about test methods:
   * - methods return array of booleans
   * - first index: success or not
   * - second index: acceptable or not (e.g., Exception is OK)
   * - in case the performance is worse than that of ZeroR both indices are true
   *
   * FracPete (fracpete at waikato dot ac dot nz)
   */
  
  /** a class for postprocessing the test-data 
   */
<span class="nc" id="L157">  public class PostProcessor</span>
    implements RevisionHandler {
    /**
     * Provides a hook for derived classes to further modify the data. Currently,
     * the data is just passed through.
     * 
     * @param data	the data to process
     * @return		the processed data
     */
    protected Instances process(Instances data) {
<span class="nc" id="L167">      return data;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L176">      return RevisionUtils.extract(&quot;$Revision: 1.5 $&quot;);</span>
    }
  }
  
  /*** The estimator to be examined */
<span class="nc" id="L181">  protected Estimator m_Estimator = (Estimator) new weka.estimators.NormalEstimator(0.000001);</span>
  
  /** The options to be passed to the base estimator. */
  protected String[] m_EstimatorOptions;
  
  /** The results of the analysis as a string */
  protected String m_AnalysisResults;
  
  /** Debugging mode, gives extra output if true */
<span class="nc" id="L190">  protected boolean m_Debug = false;</span>
  
  /** Silent mode, for no output at all to stdout */
<span class="nc" id="L193">  protected boolean m_Silent = false;</span>
  
  /** The number of instances in the datasets */
<span class="nc" id="L196">  protected int m_NumInstances = 100;</span>
  
  /** for post-processing the data even further */
<span class="nc" id="L199">  protected PostProcessor m_PostProcessor = null;</span>
  
  /** whether classpath problems occurred */
<span class="nc" id="L202">  protected boolean m_ClasspathProblems = false;</span>
  
  /**
   * class that contains info about the attribute types the estimator can estimate
   * estimator work on one attribute only
   */
  public static class AttrTypes
    implements RevisionHandler {
    
<span class="nc" id="L211">    boolean nominal = false;</span>
<span class="nc" id="L212">    boolean numeric = false; </span>
<span class="nc" id="L213">    boolean string = false;</span>
<span class="nc" id="L214">    boolean date = false;</span>
<span class="nc" id="L215">    boolean relational = false;</span>
	
<span class="nc" id="L217">    AttrTypes() {</span>
<span class="nc" id="L218">    }</span>

<span class="nc" id="L220">    AttrTypes (AttrTypes newTypes) {</span>
<span class="nc" id="L221">      nominal = newTypes.nominal;</span>
<span class="nc" id="L222">      numeric = newTypes.numeric;</span>
<span class="nc" id="L223">      string = newTypes.string;</span>
<span class="nc" id="L224">      date = newTypes.date;</span>
<span class="nc" id="L225">      relational = newTypes.relational;</span>
<span class="nc" id="L226">    }</span>
			
<span class="nc" id="L228">    AttrTypes (int type) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">      if (type == Attribute.NOMINAL) nominal = true;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">      if (type == Attribute.NUMERIC) numeric = true;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">      if (type == Attribute.STRING) string = true;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">      if (type == Attribute.DATE) date = true;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">      if (type == Attribute.RELATIONAL) relational = true;</span>
<span class="nc" id="L234">    }</span>

    int getSetType() throws Exception {			
<span class="nc" id="L237">      int sum = 0;</span>
<span class="nc" id="L238">      int type = -1;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      if (nominal) { sum ++; type = Attribute.NOMINAL; }</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">      if (numeric) { sum ++; type = Attribute.NUMERIC; }</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">      if (string) { sum ++; type = Attribute.STRING; }</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">      if (date) { sum ++; type = Attribute.DATE; }</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">      if (relational) { sum ++; type = Attribute.RELATIONAL; }</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">      if (sum &gt; 1)</span>
<span class="nc" id="L245">	throw new Exception(&quot;Expected to have only one type set used wrongly.&quot;);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">      if (type &lt; 0)</span>
<span class="nc" id="L247">	throw new Exception(&quot;No type set.&quot;);</span>
<span class="nc" id="L248">      return type;</span>
    }

    boolean oneIsSet() {
<span class="nc bnc" id="L252" title="All 10 branches missed.">      return (nominal || numeric || string || date || relational);</span>
    }

    public Vector getVectorOfAttrTypes() {
<span class="nc" id="L256">      Vector attrs = new Vector();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">      if (nominal) attrs.add(new Integer(Attribute.NOMINAL));</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">      if (numeric) attrs.add(new Integer(Attribute.NUMERIC));</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">      if (string) attrs.add(new Integer(Attribute.STRING));</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">      if (date) attrs.add(new Integer(Attribute.DATE));</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">      if (relational) attrs.add(new Integer(Attribute.RELATIONAL));</span>
<span class="nc" id="L262">      return attrs;</span>
    }   
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L271">      return RevisionUtils.extract(&quot;$Revision: 1.5 $&quot;);</span>
    }
  }

  /**
   * public class that contains info about the chosen attribute type
   * estimator work on one attribute only
   */
  public static class EstTypes
    implements RevisionHandler {
    
<span class="nc" id="L282">    boolean incremental = false;</span>
<span class="nc" id="L283">    boolean weighted = false;</span>
<span class="nc" id="L284">    boolean supervised = false;</span>

    /**
     * Constructor
     */
<span class="nc" id="L289">    public EstTypes () {</span>
<span class="nc" id="L290">    }</span>

    /**
     * Constructor
     */
<span class="nc" id="L295">    public EstTypes (boolean i, boolean w, boolean s) {</span>
<span class="nc" id="L296">      incremental = i;</span>
<span class="nc" id="L297">      weighted    = w;</span>
<span class="nc" id="L298">      supervised  = s;</span>
<span class="nc" id="L299">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L307">      return RevisionUtils.extract(&quot;$Revision: 1.5 $&quot;);</span>
    }
  }

  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {
    
<span class="nc" id="L318">    Vector newVector = new Vector(2);</span>
    
<span class="nc" id="L320">    newVector.addElement(new Option(</span>
<span class="nc" id="L321">        &quot;\tTurn on debugging output.&quot;,</span>
<span class="nc" id="L322">        &quot;D&quot;, 0, &quot;-D&quot;));</span>
    
<span class="nc" id="L324">    newVector.addElement(new Option(</span>
<span class="nc" id="L325">        &quot;\tSilent mode - prints nothing to stdout.&quot;,</span>
<span class="nc" id="L326">        &quot;S&quot;, 0, &quot;-S&quot;));</span>
    
<span class="nc" id="L328">    newVector.addElement(new Option(</span>
<span class="nc" id="L329">        &quot;\tThe number of instances in the datasets (default 100).&quot;,</span>
<span class="nc" id="L330">        &quot;N&quot;, 1, &quot;-N &lt;num&gt;&quot;));</span>
    
<span class="nc" id="L332">    newVector.addElement(new Option(</span>
<span class="nc" id="L333">        &quot;\tFull name of the estimator analysed.\n&quot;</span>
        +&quot;\teg: weka.estimators.NormalEstimator&quot;,
<span class="nc" id="L335">        &quot;W&quot;, 1, &quot;-W&quot;));</span>
    
<span class="nc bnc" id="L337" title="All 2 branches missed.">    if ((m_Estimator != null) </span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        &amp;&amp; (m_Estimator instanceof OptionHandler)) {</span>
<span class="nc" id="L339">      newVector.addElement(new Option(&quot;&quot;, &quot;&quot;, 0, </span>
<span class="nc" id="L340">          &quot;\nOptions specific to estimator &quot;</span>
<span class="nc" id="L341">          + m_Estimator.getClass().getName()</span>
<span class="nc" id="L342">          + &quot;:&quot;));</span>
<span class="nc" id="L343">      Enumeration enu = ((OptionHandler)m_Estimator).listOptions();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">      while (enu.hasMoreElements())</span>
<span class="nc" id="L345">        newVector.addElement(enu.nextElement());</span>
    }
    
<span class="nc" id="L348">    return newVector.elements();</span>
  }
  
  /**
   * Parses a given list of options. 
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -D
   *  Turn on debugging output.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S
   *  Silent mode - prints nothing to stdout.&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;num&amp;gt;
   *  The number of instances in the datasets (default 100).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -W
   *  Full name of the estimator analysed.
   *  eg: weka.estimators.NormalEstimator&lt;/pre&gt;
   * 
   * &lt;pre&gt; 
   * Options specific to estimator weka.estimators.NormalEstimator:
   * &lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  If set, estimator is run in debug mode and
   *  may output additional info to the console&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    String      tmpStr;
    
<span class="nc" id="L386">    setDebug(Utils.getFlag('D', options));</span>
    
<span class="nc" id="L388">    setSilent(Utils.getFlag('S', options));</span>
    
<span class="nc" id="L390">    tmpStr = Utils.getOption('N', options);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">    if (tmpStr.length() != 0)</span>
<span class="nc" id="L392">      setNumInstances(Integer.parseInt(tmpStr));</span>
    else
<span class="nc" id="L394">      setNumInstances(100);</span>
    
<span class="nc" id="L396">    tmpStr = Utils.getOption('W', options);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">    if (tmpStr.length() == 0)</span>
<span class="nc" id="L398">      throw new Exception(&quot;A estimator must be specified with the -W option.&quot;);</span>
<span class="nc" id="L399">    setEstimator(Estimator.forName(tmpStr, Utils.partitionOptions(options)));</span>
<span class="nc" id="L400">  }</span>
  
  /**
   * Gets the current settings of the CheckEstimator.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String[] getOptions() {
    Vector        result;
    String[]      options;
    int           i;
    
<span class="nc" id="L412">    result = new Vector();</span>
    
<span class="nc bnc" id="L414" title="All 2 branches missed.">    if (getDebug())</span>
<span class="nc" id="L415">      result.add(&quot;-D&quot;);</span>
    
<span class="nc bnc" id="L417" title="All 2 branches missed.">    if (getSilent())</span>
<span class="nc" id="L418">      result.add(&quot;-S&quot;);</span>
    
<span class="nc" id="L420">    result.add(&quot;-N&quot;);</span>
<span class="nc" id="L421">    result.add(&quot;&quot; + getNumInstances());</span>
    
<span class="nc bnc" id="L423" title="All 2 branches missed.">    if (getEstimator() != null) {</span>
<span class="nc" id="L424">      result.add(&quot;-W&quot;);</span>
<span class="nc" id="L425">      result.add(getEstimator().getClass().getName());</span>
    }
    
<span class="nc bnc" id="L428" title="All 4 branches missed.">    if ((m_Estimator != null) &amp;&amp; (m_Estimator instanceof OptionHandler))</span>
<span class="nc" id="L429">      options = ((OptionHandler) m_Estimator).getOptions();</span>
    else
<span class="nc" id="L431">      options = new String[0];</span>
    
<span class="nc bnc" id="L433" title="All 2 branches missed.">    if (options.length &gt; 0) {</span>
<span class="nc" id="L434">      result.add(&quot;--&quot;);</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">      for (i = 0; i &lt; options.length; i++)</span>
<span class="nc" id="L436">        result.add(options[i]);</span>
    }
    
<span class="nc" id="L439">    return (String[]) result.toArray(new String[result.size()]);</span>
  }
  
  /**
   * sets the PostProcessor to use
   * 
   * @param value	the new PostProcessor
   * @see #m_PostProcessor
   */
  public void setPostProcessor(PostProcessor value) {
<span class="nc" id="L449">    m_PostProcessor = value;</span>
<span class="nc" id="L450">  }</span>
  
  /**
   * returns the current PostProcessor, can be null
   * 
   * @return		the current PostProcessor
   */
  public PostProcessor getPostProcessor() {
<span class="nc" id="L458">    return m_PostProcessor;</span>
  }
  
  /**
   * returns TRUE if the estimator returned a &quot;not in classpath&quot; Exception
   * 
   * @return	true if CLASSPATH problems occurred
   */
  public boolean hasClasspathProblems() {
<span class="nc" id="L467">    return m_ClasspathProblems;</span>
  }
  
  /**
   * Begin the tests, reporting results to System.out
   */
  public void doTests() {
    
<span class="nc bnc" id="L475" title="All 2 branches missed.">    if (getEstimator() == null) {</span>
<span class="nc" id="L476">      println(&quot;\n=== No estimator set ===&quot;);</span>
<span class="nc" id="L477">      return;</span>
    }
<span class="nc" id="L479">    println(&quot;\n=== Check on Estimator: &quot;</span>
<span class="nc" id="L480">        + getEstimator().getClass().getName()</span>
<span class="nc" id="L481">        + &quot; ===\n&quot;);</span>
    
<span class="nc" id="L483">    m_ClasspathProblems = false;</span>

    // Start tests with test for options
<span class="nc" id="L486">    canTakeOptions();</span>

    // test what type of estimator it is 
<span class="nc" id="L489">    EstTypes estTypes = new EstTypes();</span>
<span class="nc" id="L490">    estTypes.incremental = incrementalEstimator()[0];</span>
<span class="nc" id="L491">    estTypes.weighted = weightedInstancesHandler()[0];</span>
<span class="nc" id="L492">    estTypes.supervised = supervisedEstimator()[0];</span>
   
    // in none of the estimators yet the functionality is depending on the class type
    // since this could change the basic structure taken from checkclassifiers is kept here
<span class="nc" id="L496">    int classType = Attribute.NOMINAL;</span>
<span class="nc" id="L497">    AttrTypes attrTypes = testsPerClassType(classType, estTypes);</span>
    
 
    // only nominal class can be split up so far
<span class="nc" id="L501">    canSplitUpClass(attrTypes, classType);</span>
<span class="nc" id="L502"> }</span>
  
  
  /**
   * Set debugging mode
   *
   * @param debug true if debug output should be printed
   */
  public void setDebug(boolean debug) {
<span class="nc" id="L511">    m_Debug = debug;</span>

    // disable silent mode, if necessary
<span class="nc bnc" id="L514" title="All 2 branches missed.">    if (getDebug())</span>
<span class="nc" id="L515">      setSilent(false);</span>
<span class="nc" id="L516">  }</span>
  
  /**
   * Get whether debugging is turned on
   *
   * @return true if debugging output is on
   */
  public boolean getDebug() {
<span class="nc" id="L524">    return m_Debug;</span>
  }
  
  /**
   * Set slient mode, i.e., no output at all to stdout
   *
   * @param value whether silent mode is active or not
   */
  public void setSilent(boolean value) {
<span class="nc" id="L533">    m_Silent = value;</span>
<span class="nc" id="L534">  }</span>
  
  /**
   * Get whether silent mode is turned on
   *
   * @return true if silent mode is on
   */
  public boolean getSilent() {
<span class="nc" id="L542">    return m_Silent;</span>
  }
  
  /**
   * Sets the number of instances to use in the datasets (some estimators
   * might require more instances).
   *
   * @param value the number of instances to use
   */
  public void setNumInstances(int value) {
<span class="nc" id="L552">    m_NumInstances = value;</span>
<span class="nc" id="L553">  }</span>
  
  /**
   * Gets the current number of instances to use for the datasets.
   *
   * @return the number of instances
   */
  public int getNumInstances() {
<span class="nc" id="L561">    return m_NumInstances;</span>
  }
  
  /**
   * Set the estimator for boosting. 
   *
   * @param newEstimator the Estimator to use.
   */
  public void setEstimator(Estimator newEstimator) {
<span class="nc" id="L570">    m_Estimator = newEstimator;</span>
<span class="nc" id="L571">  }</span>
  
  /**
   * Get the estimator used as the estimator
   *
   * @return the estimator used as the estimator
   */
  public Estimator getEstimator() {
<span class="nc" id="L579">    return m_Estimator;</span>
  }
  
  /**
   * prints the given message to stdout, if not silent mode
   * 
   * @param msg         the text to print to stdout
   */
  protected void print(Object msg) {
<span class="nc bnc" id="L588" title="All 2 branches missed.">    if (!getSilent())</span>
<span class="nc" id="L589">      System.out.print(msg);</span>
<span class="nc" id="L590">  }</span>
  
  /**
   * prints the given message (+ LF) to stdout, if not silent mode
   * 
   * @param msg         the message to println to stdout
   */
  protected void println(Object msg) {
<span class="nc" id="L598">    print(msg + &quot;\n&quot;);</span>
<span class="nc" id="L599">  }</span>
  
  /**
   * prints a LF to stdout, if not silent mode
   */
  protected void println() {
<span class="nc" id="L605">    print(&quot;\n&quot;);</span>
<span class="nc" id="L606">  }</span>
  
  /**
   * Run a battery of tests for a given class attribute type
   *
   * @param classType true if the class attribute should be numeric
   * @param estTypes types the estimator is, like incremental, weighted, supervised etc
   * @return attribute types estimator can work with
   */
  protected AttrTypes testsPerClassType(int classType, EstTypes estTypes) {
    
    // in none of the estimators yet is the estimation depending on the class type
    // since this could change the basic structure taken from checkclassifiers is kept here
    
    // test A: simple test - if can estimate
<span class="nc" id="L621">    AttrTypes attrTypes = new AttrTypes();</span>
<span class="nc" id="L622">    AttrTypes at = new AttrTypes(Attribute.NOMINAL);</span>
<span class="nc" id="L623">    attrTypes.nominal = canEstimate(at, estTypes.supervised, classType)[0];</span>
<span class="nc" id="L624">    at = new AttrTypes(Attribute.NUMERIC);</span>
<span class="nc" id="L625">    attrTypes.numeric = canEstimate(at, estTypes.supervised, classType)[0];</span>
<span class="nc" id="L626">    attrTypes.string = false;</span>
<span class="nc" id="L627">    attrTypes.date = false;</span>
<span class="nc" id="L628">    attrTypes.relational = false;</span>
    
//  if (!multiInstance)
//  PRel = canEstimate(false, false, false, false,  true, classType)[0];
//  else
//  PRel = false;
    
//  one of the attribute types succeeded
    
<span class="nc bnc" id="L637" title="All 2 branches missed.">    if (attrTypes.oneIsSet()) {</span>
<span class="nc" id="L638">      Vector attributesSet = attrTypes.getVectorOfAttrTypes();</span>
      
      // make tests for each attribute
<span class="nc bnc" id="L641" title="All 2 branches missed.">      for (int i = 0; i &lt; attributesSet.size(); i++) {</span>
<span class="nc" id="L642">        AttrTypes workAttrTypes = new AttrTypes(((Integer) attributesSet.elementAt(i)).intValue());</span>
        
        // test B: weights change estimate or not
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (estTypes.weighted)</span>
<span class="nc" id="L646">          instanceWeights(workAttrTypes, classType);</span>
        
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (classType == Attribute.NOMINAL) {</span>
<span class="nc" id="L649">          int numClasses = 4;</span>
<span class="nc" id="L650">          canHandleNClasses(workAttrTypes, numClasses);</span>
        }
        
        // tests with class not the last attribute and the attribute not the first
        
        //   if (!multiInstance) {
<span class="nc" id="L656">        int numAtt = 4; </span>
        
<span class="nc" id="L658">        canHandleClassAsNthAttribute(workAttrTypes, numAtt, 0, classType, 1);</span>
        
        //TODOTODOcanHandleAttrAsNthAttribute(workAttrTypes, numAtt, 2, classType);
        //}
        
<span class="nc" id="L663">        canHandleZeroTraining(workAttrTypes, classType);</span>
<span class="nc" id="L664">        boolean handleMissingAttributes = canHandleMissing(workAttrTypes, </span>
<span class="nc" id="L665">            classType, true, false, 20)[0];</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">        if (handleMissingAttributes)</span>
<span class="nc" id="L667">          canHandleMissing(workAttrTypes, classType, true, false, 100);</span>
        
<span class="nc" id="L669">        boolean handleMissingClass = canHandleMissing(workAttrTypes, </span>
<span class="nc" id="L670">            classType, </span>
<span class="nc" id="L671">            false, true, 20)[0];</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (handleMissingClass)</span>
<span class="nc" id="L673">          canHandleMissing(workAttrTypes, classType, false, true, 100);</span>
        
<span class="nc" id="L675">        correctBuildInitialisation(workAttrTypes, classType);</span>
<span class="nc" id="L676">        datasetIntegrity(workAttrTypes, classType,</span>
<span class="nc" id="L677">            handleMissingAttributes, handleMissingClass);</span>
        
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (estTypes.incremental)</span>
<span class="nc" id="L680">          incrementingEquality(workAttrTypes, classType);</span>
      }
    }
<span class="nc" id="L683">    return attrTypes;</span>
  }
  
  /**
   * Checks whether the scheme can take command line options.
   *
   * @return index 0 is true if the estimator can take options
   */
  protected boolean[] canTakeOptions() {
    
<span class="nc" id="L693">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L695">    print(&quot;options...&quot;);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">    if (m_Estimator instanceof OptionHandler) {</span>
<span class="nc" id="L697">      println(&quot;yes&quot;);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L699">        println(&quot;\n=== Full report ===&quot;);</span>
<span class="nc" id="L700">        Enumeration enu = ((OptionHandler)m_Estimator).listOptions();</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">        while (enu.hasMoreElements()) {</span>
<span class="nc" id="L702">          Option option = (Option) enu.nextElement();</span>
<span class="nc" id="L703">          print(option.synopsis() + &quot;\n&quot; </span>
<span class="nc" id="L704">              + option.description() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L706">        println(&quot;\n&quot;);</span>
      }
<span class="nc" id="L708">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L711">      println(&quot;no&quot;);</span>
<span class="nc" id="L712">      result[0] = false;</span>
    }
    
<span class="nc" id="L715">    return result;</span>
  }
  
  /**
   * Checks whether the scheme can build models incrementally.
   *
   * @return index 0 is true if the estimator can train incrementally
   */
  protected boolean[] incrementalEstimator() {
    
<span class="nc" id="L725">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L727">    print(&quot;incremental estimator...&quot;);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">    if (m_Estimator instanceof IncrementalEstimator) {</span>
<span class="nc" id="L729">      println(&quot;yes&quot;);</span>
<span class="nc" id="L730">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L733">      println(&quot;no&quot;);</span>
<span class="nc" id="L734">      result[0] = false;</span>
    }
    
<span class="nc" id="L737">    return result;</span>
  }
  
  /**
   * Checks whether the scheme says it can handle instance weights.
   *
   * @return true if the estimator handles instance weights
   */
  protected boolean[] weightedInstancesHandler() {
    
<span class="nc" id="L747">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L749">    print(&quot;weighted instances estimator...&quot;);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">    if (m_Estimator instanceof WeightedInstancesHandler) {</span>
<span class="nc" id="L751">      println(&quot;yes&quot;);</span>
<span class="nc" id="L752">      result[0] = true;</span>
    }
    else {
<span class="nc" id="L755">      println(&quot;no&quot;);</span>
<span class="nc" id="L756">      result[0] = false;</span>
    }
    
<span class="nc" id="L759">    return result;</span>
  }

  /**
   * Checks whether the estimator is supervised.
   *
   * @return true if the estimator handles instance weights
   */
  protected boolean[] supervisedEstimator() {
<span class="nc" id="L768">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L769">    result[0] = false;</span>
<span class="nc" id="L770">    return result;</span>
  }

  /**
   * Checks basic estimation of one attribute of the scheme, for simple non-troublesome
   * datasets.
   *
   * @param attrTypes the types the estimator can work with
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canEstimate(AttrTypes attrTypes, boolean supervised, int classType) {
    
  // supervised is ignored, no supervised estimators used yet
    
<span class="nc" id="L786">    print(&quot;basic estimation&quot;);</span>
<span class="nc" id="L787">    printAttributeSummary(attrTypes, classType);</span>
<span class="nc" id="L788">    print(&quot;...&quot;);</span>
<span class="nc" id="L789">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L790">    accepts.addElement(&quot;nominal&quot;);</span>
<span class="nc" id="L791">    accepts.addElement(&quot;numeric&quot;);</span>
<span class="nc" id="L792">    accepts.addElement(&quot;string&quot;);</span>
<span class="nc" id="L793">    accepts.addElement(&quot;date&quot;);</span>
<span class="nc" id="L794">    accepts.addElement(&quot;relational&quot;);</span>
<span class="nc" id="L795">    accepts.addElement(&quot;not in classpath&quot;);</span>
<span class="nc" id="L796">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L797">    numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L798">    boolean attributeMissing = false, classMissing = false;</span>
<span class="nc" id="L799">    int numAtts = 1, attrIndex = 0;</span>

<span class="nc" id="L801">    return runBasicTest(attrTypes, numAtts, attrIndex,</span>
<span class="nc" id="L802">			classType, </span>
<span class="nc" id="L803">			missingLevel, attributeMissing, classMissing,</span>
<span class="nc" id="L804">			numTrain, numTest, numClasses, </span>
<span class="nc" id="L805">			accepts);</span>
  }
  
  /**
   * Checks basic estimation of one attribute of the scheme, for simple non-troublesome
   * datasets.
   *
   * @param attrTypes the types the estimator can work with
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
    */
  protected void canSplitUpClass(AttrTypes attrTypes, int classType) {
    
<span class="nc bnc" id="L817" title="All 2 branches missed.">    if (attrTypes.nominal)</span>
<span class="nc" id="L818">      canSplitUpClass(Attribute.NOMINAL, classType);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">    if (attrTypes.numeric)</span>
<span class="nc" id="L820">      canSplitUpClass(Attribute.NUMERIC, classType);</span>
<span class="nc" id="L821">  }</span>
  
  /**
   * Checks basic estimation of one attribute of the scheme, for simple non-troublesome
   * datasets.
   *
   * @param attrType the type of the estimator
   * @param classType the class type (NOMINAL, NUMERIC, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canSplitUpClass(int attrType, int classType) {
    
<span class="nc" id="L834">    boolean[] result = new boolean[2];</span>

<span class="nc" id="L836">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L837">    accepts.addElement(&quot;not in classpath&quot;);</span>

    // supervised is ignored, no supervised estimators used yet
<span class="nc" id="L840">    print(&quot;split per class type &quot;);</span>
<span class="nc" id="L841">    printAttributeSummary(attrType, Attribute.NOMINAL);</span>
<span class="nc" id="L842">    print(&quot;...&quot;);</span>
      
<span class="nc" id="L844">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L845">    numClasses = 2;</span>
<span class="nc" id="L846">    boolean attributeMissing = false, classMissing = false;</span>
<span class="nc" id="L847">    int numAtts = 3, attrIndex = 0, classIndex = 1;</span>
<span class="nc" id="L848">    Instances train = null;</span>
    Vector test;
<span class="nc" id="L850">    Estimator estimator = null;</span>
<span class="nc" id="L851">    boolean built = false;</span>
    
    try {
<span class="nc" id="L854">      AttrTypes at = new AttrTypes(attrType);</span>
<span class="nc" id="L855">      train = makeTestDataset(42, numTrain, numAtts, at,</span>
<span class="nc" id="L856">          numClasses, classType, classIndex);</span>
      
       // prepare training data set and test value list
<span class="nc" id="L859">      test = makeTestValueList(24, numTest, train, attrIndex,</span>
<span class="nc" id="L860">          attrType);</span>
      
<span class="nc" id="L862">       estimator = Estimator.makeCopies(getEstimator(), 1)[0];</span>
<span class="nc" id="L863">    } catch (Exception ex) {</span>
<span class="nc" id="L864">      ex.printStackTrace();</span>
<span class="nc" id="L865">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L868">      estimator.addValues(train, attrIndex, classType, classIndex);</span>
<span class="nc" id="L869">      built = true;</span>
      
<span class="nc" id="L871">      testWithTestValues(estimator, test);</span>
      
<span class="nc" id="L873">      println(&quot;yes&quot;);</span>
<span class="nc" id="L874">      result[0] = true;</span>
    } 
<span class="nc" id="L876">    catch (Exception ex) {</span>
<span class="nc" id="L877">      boolean acceptable = false;</span>
      String msg;
<span class="nc bnc" id="L879" title="All 2 branches missed.">      if (ex.getMessage() == null)</span>
<span class="nc" id="L880">        msg = &quot;&quot;;</span>
      else
<span class="nc" id="L882">        msg = ex.getMessage().toLowerCase();</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">      if (msg.indexOf(&quot;not in classpath&quot;) &gt; -1)</span>
<span class="nc" id="L884">        m_ClasspathProblems = true;</span>
      
<span class="nc bnc" id="L886" title="All 2 branches missed.">      for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (msg.indexOf((String)accepts.elementAt(i)) &gt;= 0) {</span>
<span class="nc" id="L888">          acceptable = true;</span>
        }
      }
      
<span class="nc bnc" id="L892" title="All 2 branches missed.">      println(&quot;no&quot; + (acceptable ? &quot; (OK error message)&quot; : &quot;&quot;));</span>
<span class="nc" id="L893">      result[1] = acceptable;</span>
      
      
<span class="nc bnc" id="L896" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L897">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L898">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L900">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L902">          print(&quot; training&quot;);</span>
        }
<span class="nc" id="L904">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (!acceptable) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">          if (accepts.size() &gt; 0) {</span>
<span class="nc" id="L907">            print(&quot;Error message doesn't mention &quot;);</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">              if (i != 0) {</span>
<span class="nc" id="L910">                print(&quot; or &quot;);</span>
              }
<span class="nc" id="L912">              print('&quot;' + (String)accepts.elementAt(i) + '&quot;');</span>
            }
          }
<span class="nc" id="L915">          println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L916">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L917">              + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L918">          println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L919">              + test.toString() + &quot;\n\n&quot;);</span>
        }
        
      }
    }
<span class="nc" id="L924">    return result;</span>
   }
  
  /**
   * Checks whether nominal schemes can handle more than two classes.
   * If a scheme is only designed for two-class problems it should
   * throw an appropriate exception for multi-class problems.
   *
   * @param attrTypes attribute types the estimator excepts 
   * @param numClasses the number of classes to test
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleNClasses(AttrTypes attrTypes, int numClasses) {
    
<span class="nc" id="L939">    print(&quot;more than two class problems&quot;);</span>
<span class="nc" id="L940">    printAttributeSummary(attrTypes, Attribute.NOMINAL);</span>
<span class="nc" id="L941">    print(&quot;...&quot;);</span>

<span class="nc" id="L943">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L944">    accepts.addElement(&quot;number&quot;);</span>
<span class="nc" id="L945">    accepts.addElement(&quot;class&quot;);</span>

<span class="nc" id="L947">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L948">      missingLevel = 0;</span>
<span class="nc" id="L949">    boolean attributeMissing = false, classMissing = false;</span>
<span class="nc" id="L950">    int numAttr = 1, attrIndex = 0;</span>

<span class="nc" id="L952">    return runBasicTest(attrTypes,</span>
<span class="nc" id="L953">                        numAttr, attrIndex,</span>
<span class="nc" id="L954">                        Attribute.NOMINAL,</span>
<span class="nc" id="L955">                        missingLevel, attributeMissing, classMissing,</span>
<span class="nc" id="L956">                        numTrain, numTest, numClasses, </span>
<span class="nc" id="L957">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle class attributes as Nth attribute.
   *
   * @param attrTypes the attribute types the estimator accepts
   * @param numAtts of attributes
   * @param attrIndex the index of the attribute
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class attribute (0-based, -1 means last attribute)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   * @see TestInstances#CLASS_IS_LAST
   */
  protected boolean[] canHandleClassAsNthAttribute(AttrTypes attrTypes,
						   int numAtts,
						   int attrIndex,
						   int classType,
						   int classIndex) {
    
<span class="nc bnc" id="L978" title="All 2 branches missed.">    if (classIndex == TestInstances.CLASS_IS_LAST)</span>
<span class="nc" id="L979">      print(&quot;class attribute as last attribute&quot;);</span>
    else
<span class="nc" id="L981">      print(&quot;class attribute as &quot; + (classIndex + 1) + &quot;. attribute&quot;);</span>
<span class="nc" id="L982">    printAttributeSummary(attrTypes, classType);</span>
<span class="nc" id="L983">    print(&quot;...&quot;);</span>
<span class="nc" id="L984">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L985">    int numTrain = getNumInstances(), numTest = getNumInstances(), numClasses = 2, </span>
<span class="nc" id="L986">    missingLevel = 0;</span>
<span class="nc" id="L987">    boolean attributeMissing = false, classMissing = false;</span>
    
<span class="nc" id="L989">    return runBasicTest(attrTypes,</span>
<span class="nc" id="L990">			numAtts, attrIndex,</span>
<span class="nc" id="L991">                        classType, classIndex,</span>
<span class="nc" id="L992">                        missingLevel, attributeMissing, classMissing,</span>
<span class="nc" id="L993">                        numTrain, numTest, numClasses, </span>
<span class="nc" id="L994">                        accepts);</span>
  }
  
  /**
   * Checks whether the scheme can handle zero training instances.
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleZeroTraining(AttrTypes attrTypes, int classType) {
    
<span class="nc" id="L1007">    print(&quot;handle zero training instances&quot;);</span>
<span class="nc" id="L1008">    printAttributeSummary(attrTypes, classType);</span>

<span class="nc" id="L1010">    print(&quot;...&quot;);</span>
<span class="nc" id="L1011">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L1012">    accepts.addElement(&quot;train&quot;);</span>
<span class="nc" id="L1013">    accepts.addElement(&quot;value&quot;);</span>
<span class="nc" id="L1014">    int numTrain = 0, numTest = getNumInstances(), numClasses = 2, </span>
<span class="nc" id="L1015">    missingLevel = 0;</span>
<span class="nc" id="L1016">    boolean attributeMissing = false, classMissing = false;</span>
<span class="nc" id="L1017">    int numAtts = 1;</span>
<span class="nc" id="L1018">    int attrIndex = 0;</span>
<span class="nc" id="L1019">    return runBasicTest(</span>
<span class="nc" id="L1020">              attrTypes, numAtts, attrIndex,</span>
<span class="nc" id="L1021">              classType, </span>
<span class="nc" id="L1022">              missingLevel, attributeMissing, classMissing,</span>
<span class="nc" id="L1023">              numTrain, numTest, numClasses, </span>
<span class="nc" id="L1024">              accepts);</span>
  }
  
  /**
   * Checks whether the scheme correctly initialises models when 
   * buildEstimator is called. This test calls buildEstimator with
   * one training dataset and records performance on a test set. 
   * buildEstimator is then called on a training set with different
   * structure, and then again with the original training set. The
   * performance on the test set is compared with the original results
   * and any performance difference noted as incorrect build initialisation.
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed, index 1 is true if the
   *         scheme performs worse than ZeroR, but without error (index 0 is
   *         false)
   */
  protected boolean[] correctBuildInitialisation(AttrTypes attrTypes,
						 int classType) {

<span class="nc" id="L1045">    boolean[] result = new boolean[2];</span>
    
<span class="nc" id="L1047">    print(&quot;correct initialisation during buildEstimator&quot;);</span>
<span class="nc" id="L1048">    printAttributeSummary(attrTypes, classType);</span>

<span class="nc" id="L1050">    print(&quot;...&quot;);</span>
<span class="nc" id="L1051">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L1052">    numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L1053">    boolean attributeMissing = false, classMissing = false;</span>
    
<span class="nc" id="L1055">    Instances train1 = null;</span>
<span class="nc" id="L1056">    Instances test1 = null;</span>
<span class="nc" id="L1057">    Instances train2 = null;</span>
<span class="nc" id="L1058">    Instances test2 = null;</span>
<span class="nc" id="L1059">    Estimator estimator = null;</span>
<span class="nc" id="L1060">    Estimator estimator1 = null;</span>
    
<span class="nc" id="L1062">    boolean built = false;</span>
<span class="nc" id="L1063">    int stage = 0;</span>
<span class="nc" id="L1064">    int attrIndex1 = 1;</span>
<span class="nc" id="L1065">    int attrIndex2 = 2;</span>

    try {
      
      // Make two sets of train/test splits with different 
      // numbers of attributes
<span class="nc" id="L1071">      train1 = makeTestDataset(42, numTrain, 2, attrTypes,</span>
<span class="nc" id="L1072">                               numClasses, </span>
<span class="nc" id="L1073">                               classType);</span>
<span class="nc" id="L1074">      train2 = makeTestDataset(84, numTrain, 3, attrTypes,</span>
<span class="nc" id="L1075">                               numClasses, </span>
<span class="nc" id="L1076">                               classType);</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1078">        addMissing(train1, missingLevel, attributeMissing, classMissing, attrIndex1);</span>
<span class="nc" id="L1079">        addMissing(train2, missingLevel, attributeMissing, classMissing, attrIndex2);</span>
      }
      
<span class="nc" id="L1082">      estimator = Estimator.makeCopies(getEstimator(), 1)[0];</span>
<span class="nc" id="L1083">    } catch (Exception ex) {</span>
<span class="nc" id="L1084">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
      //TESTING??
<span class="nc" id="L1088">      stage = 0;</span>
<span class="nc" id="L1089">      estimator.addValues(train1, attrIndex1);</span>
<span class="nc" id="L1090">      built = true;</span>

<span class="nc" id="L1092">      estimator1 = estimator.makeCopies(getEstimator(), 1)[0];</span>
      
<span class="nc" id="L1094">      stage = 1;</span>
<span class="nc" id="L1095">      built = false;</span>
<span class="nc" id="L1096">      estimator.addValues(train2, attrIndex2);</span>
<span class="nc" id="L1097">      built = true;</span>
       
<span class="nc" id="L1099">      stage = 2;</span>
<span class="nc" id="L1100">      built = false;</span>
<span class="nc" id="L1101">      estimator.addValues(train1, attrIndex1);</span>
<span class="nc" id="L1102">      built = true;</span>
      
<span class="nc" id="L1104">      stage = 3;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">      if (!estimator.equals(estimator1)) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1107">          println(&quot;\n=== Full report ===\n&quot;</span>
		  + &quot;\nFirst build estimator\n&quot;+
<span class="nc" id="L1109">                  estimator.toString() + &quot;\n\n&quot;);</span>
<span class="nc" id="L1110">          println(&quot;\nSecond build estimator\n&quot;+</span>
<span class="nc" id="L1111">		  estimator.toString() + &quot;\n\n&quot;);</span>
	}
<span class="nc" id="L1113">        throw new Exception(&quot;Results differ between buildEstimator calls&quot;);</span>
      }
<span class="nc" id="L1115">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1116">      result[0] = true;</span>
      
      if (false &amp;&amp; m_Debug) {
        println(&quot;\n=== Full report ===\n&quot;
		+ &quot;\nFirst buildEstimator()&quot;
                + &quot;\n\n&quot;);
        println(&quot;\nSecond buildEstimator()&quot; 
		+ &quot;\n\n&quot;);
      }
    }
<span class="nc" id="L1126">    catch (Exception ex) {</span>
<span class="nc" id="L1127">      String msg = ex.getMessage().toLowerCase();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">      if (msg.indexOf(&quot;worse than zeror&quot;) &gt;= 0) {</span>
<span class="nc" id="L1129">        println(&quot;warning: performs worse than ZeroR&quot;);</span>
<span class="nc" id="L1130">        result[0] = true;</span>
<span class="nc" id="L1131">        result[1] = true;</span>
      } else {
<span class="nc" id="L1133">        println(&quot;no&quot;);</span>
<span class="nc" id="L1134">        result[0] = false;</span>
      }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1137">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1138">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L1140">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L1142">          print(&quot; training&quot;);</span>
        }
<span class="nc bnc" id="L1144" title="All 5 branches missed.">        switch (stage) {</span>
          case 0:
<span class="nc" id="L1146">            print(&quot; of dataset 1&quot;);</span>
<span class="nc" id="L1147">            break;</span>
          case 1:
<span class="nc" id="L1149">            print(&quot; of dataset 2&quot;);</span>
<span class="nc" id="L1150">            break;</span>
          case 2:
<span class="nc" id="L1152">            print(&quot; of dataset 1 (2nd build)&quot;);</span>
<span class="nc" id="L1153">            break;</span>
          case 3:
<span class="nc" id="L1155">            print(&quot;, comparing results from builds of dataset 1&quot;);</span>
            break;	  
        }
<span class="nc" id="L1158">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L1159">        println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L1160">        println(&quot;=== Train1 Dataset ===\n&quot;</span>
<span class="nc" id="L1161">            + train1.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1162">        println(&quot;=== Test1 Dataset ===\n&quot;</span>
<span class="nc" id="L1163">            + test1.toString() + &quot;\n\n&quot;);</span>
<span class="nc" id="L1164">        println(&quot;=== Train2 Dataset ===\n&quot;</span>
<span class="nc" id="L1165">            + train2.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1166">        println(&quot;=== Test2 Dataset ===\n&quot;</span>
<span class="nc" id="L1167">            + test2.toString() + &quot;\n\n&quot;);</span>
      }
    }
    
<span class="nc" id="L1171">    return result;</span>
  }
  
  /**
   * Checks basic missing value handling of the scheme. If the missing
   * values cause an exception to be thrown by the scheme, this will be
   * recorded.
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param attributeMissing true if the missing values may be in 
   * the attributes
   * @param classMissing true if the missing values may be in the class
   * @param missingLevel the percentage of missing values
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] canHandleMissing(AttrTypes attrTypes,
				       int classType,
				       boolean attributeMissing,
				       boolean classMissing,
				       int missingLevel) {
    
<span class="nc bnc" id="L1194" title="All 2 branches missed.">    if (missingLevel == 100)</span>
<span class="nc" id="L1195">      print(&quot;100% &quot;);</span>
<span class="nc" id="L1196">    print(&quot;missing&quot;);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">    if (attributeMissing) {</span>
<span class="nc" id="L1198">      print(&quot; attribute&quot;);</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">      if (classMissing)</span>
<span class="nc" id="L1200">        print(&quot; and&quot;);</span>
    }
<span class="nc bnc" id="L1202" title="All 2 branches missed.">    if (classMissing)</span>
<span class="nc" id="L1203">      print(&quot; class&quot;);</span>
<span class="nc" id="L1204">    print(&quot; values&quot;);</span>
<span class="nc" id="L1205">    printAttributeSummary(attrTypes, classType);</span>

<span class="nc" id="L1207">    print(&quot;...&quot;);</span>
<span class="nc" id="L1208">    FastVector accepts = new FastVector();</span>
<span class="nc" id="L1209">    accepts.addElement(&quot;missing&quot;);</span>
<span class="nc" id="L1210">    accepts.addElement(&quot;value&quot;);</span>
<span class="nc" id="L1211">    accepts.addElement(&quot;train&quot;);</span>
<span class="nc" id="L1212">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L1213">    numClasses = 2;</span>
    
<span class="nc" id="L1215">    int numAtts = 1, attrIndex = 0;</span>
<span class="nc" id="L1216">    return runBasicTest(attrTypes,</span>
<span class="nc" id="L1217">			numAtts, attrIndex,</span>
<span class="nc" id="L1218">			classType, </span>
<span class="nc" id="L1219">			missingLevel, attributeMissing, classMissing,</span>
<span class="nc" id="L1220">			numTrain, numTest, numClasses, </span>
<span class="nc" id="L1221">			accepts);</span>
  }
  
  /**
   * Checks whether an incremental scheme produces the same model when
   * trained incrementally as when batch trained. The model itself
   * cannot be compared, so we compare the evaluation on test data
   * for both models. It is possible to get a false positive on this
   * test (likelihood depends on the estimator).
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 is true if the test was passed
   */
  protected boolean[] incrementingEquality(AttrTypes attrTypes,
					   int classType) {
    
<span class="nc" id="L1238">    print(&quot;incremental training produces the same results&quot;</span>
        + &quot; as batch training&quot;);
<span class="nc" id="L1240">    printAttributeSummary(attrTypes, classType);</span>

<span class="nc" id="L1242">    print(&quot;...&quot;);</span>
<span class="nc" id="L1243">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L1244">    numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L1245">    boolean attributeMissing = false, classMissing = false;</span>
    
<span class="nc" id="L1247">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1248">    Instances train = null;</span>
<span class="nc" id="L1249">    Estimator [] estimators = null;</span>
<span class="nc" id="L1250">    boolean built = false;</span>
<span class="nc" id="L1251">    int attrIndex = 0;</span>
    Vector test;
    try {
<span class="nc" id="L1254">      train = makeTestDataset(42, numTrain, 1, attrTypes,</span>
<span class="nc" id="L1255">                              numClasses, </span>
<span class="nc" id="L1256">                              classType</span>
                              );

        // prepare training data set and test value list
<span class="nc" id="L1260">      test = makeTestValueList(24, numTest, train, attrIndex,</span>
<span class="nc" id="L1261">			       attrTypes.getSetType());</span>

<span class="nc bnc" id="L1263" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1264">        addMissing(train, missingLevel, attributeMissing, classMissing, attrIndex);</span>
      }
<span class="nc" id="L1266">      estimators = Estimator.makeCopies(getEstimator(), 2);</span>
<span class="nc" id="L1267">      estimators[0].addValues(train, attrIndex);</span>
<span class="nc" id="L1268">    } catch (Exception ex) {</span>
<span class="nc" id="L1269">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc bnc" id="L1272" title="All 2 branches missed.">      for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1273">        ((IncrementalEstimator)estimators[1]).addValue(train.instance(i).value(attrIndex), 1.0);</span>
      }
<span class="nc" id="L1275">      built = true;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">      if (!estimators[0].equals(estimators[1])) {</span>
<span class="nc" id="L1277">        println(&quot;no&quot;);</span>
<span class="nc" id="L1278">        result[0] = false;</span>
       
<span class="nc bnc" id="L1280" title="All 2 branches missed.">        if (m_Debug) {</span>
<span class="nc" id="L1281">          println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1282">          println(&quot;Results differ between batch and &quot;</span>
              + &quot;incrementally built models.\n&quot;
              + &quot;Depending on the estimator, this may be OK&quot;);
<span class="nc" id="L1285">          println(&quot;Here are the results:\n&quot;);</span>
<span class="nc" id="L1286">          println(&quot;batch built results\n&quot; + estimators[0].toString());</span>
<span class="nc" id="L1287">          println(&quot;incrementally built results\n&quot; + estimators[1].toString());</span>
<span class="nc" id="L1288">          println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1289">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1290">              + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1291">          println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1292">              + test.toString() + &quot;\n\n&quot;);</span>
        }
      }
      else {
<span class="nc" id="L1296">        println(&quot;yes&quot;);</span>
<span class="nc" id="L1297">        result[0] = true;</span>
      }
<span class="nc" id="L1299">    } catch (Exception ex) {</span>
<span class="nc" id="L1300">      result[0] = false;</span>
      
<span class="nc" id="L1302">      print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">      if (built)</span>
<span class="nc" id="L1304">        print(&quot; testing&quot;);</span>
      else
<span class="nc" id="L1306">        print(&quot; training&quot;);</span>
<span class="nc" id="L1307">      println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
    }
    
<span class="nc" id="L1310">    return result;</span>
  }
  
  
  /**
   * Checks whether the estimator can handle instance weights.
   * This test compares the estimator performance on two datasets
   * that are identical except for the training weights. If the 
   * results change, then the estimator must be using the weights. It
   * may be possible to get a false positive from this test if the 
   * weight changes aren't significant enough to induce a change
   * in estimator performance (but the weights are chosen to minimize
   * the likelihood of this).
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return index 0 true if the test was passed
   */
  protected boolean[] instanceWeights(AttrTypes attrTypes,
				      int classType) {
    
<span class="nc" id="L1331">    print(&quot;estimator uses instance weights&quot;);</span>
<span class="nc" id="L1332">    printAttributeSummary(attrTypes, classType);</span>

<span class="nc" id="L1334">    print(&quot;...&quot;);</span>

<span class="nc" id="L1336">    int numTrain = 2 * getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L1337">      numClasses = 2, missingLevel = 0;</span>
<span class="nc" id="L1338">    boolean attributeMissing = false, classMissing = false;</span>
    
<span class="nc" id="L1340">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1341">    Instances train = null;</span>
<span class="nc" id="L1342">    Vector test = null;</span>
<span class="nc" id="L1343">    Estimator [] estimators = null;</span>
    
<span class="nc" id="L1345">    Vector resultProbsO = null;</span>
<span class="nc" id="L1346">    Vector resultProbsW = null;</span>
<span class="nc" id="L1347">    boolean built = false;</span>
<span class="nc" id="L1348">    boolean evalFail = false;</span>
<span class="nc" id="L1349">    int attrIndex = 0;</span>
    try {
<span class="nc" id="L1351">      train = makeTestDataset(42, numTrain, 1, </span>
<span class="nc" id="L1352">                              attrTypes, numClasses, </span>
<span class="nc" id="L1353">                              classType);</span>
  
      // prepare training data set and test value list
<span class="nc" id="L1356">      test = makeTestValueList(24, numTest, train, attrIndex,</span>
<span class="nc" id="L1357">			       attrTypes.getSetType());</span>

<span class="nc bnc" id="L1359" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1360">        addMissing(train, missingLevel, attributeMissing, classMissing, attrIndex);</span>
      }

<span class="nc" id="L1363">      estimators = Estimator.makeCopies(getEstimator(), 2);</span>

<span class="nc" id="L1365">      estimators[0].addValues(train, attrIndex);</span>
<span class="nc" id="L1366">      resultProbsO = testWithTestValues(estimators[0], test);</span>

<span class="nc" id="L1368">    } catch (Exception ex) {</span>
<span class="nc" id="L1369">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
            
      // Now modify instance weights and re-built
<span class="nc bnc" id="L1374" title="All 2 branches missed.">      for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1375">        train.instance(i).setWeight(0);</span>
      }
<span class="nc" id="L1377">      Random random = new Random(1);</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">      for (int i = 0; i &lt; train.numInstances() / 2; i++) {</span>
<span class="nc" id="L1379">        int inst = Math.abs(random.nextInt()) % train.numInstances();</span>
<span class="nc" id="L1380">        int weight = Math.abs(random.nextInt()) % 10 + 1;</span>
<span class="nc" id="L1381">        train.instance(inst).setWeight(weight);</span>
      }
<span class="nc" id="L1383">      estimators[1].addValues(train, attrIndex);</span>
<span class="nc" id="L1384">      resultProbsW = testWithTestValues(estimators[1], test);</span>

<span class="nc" id="L1386">      built = true;</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">      if (resultProbsO.equals(resultProbsW)) {</span>
        //	println(&quot;no&quot;);
<span class="nc" id="L1389">        evalFail = true;</span>
<span class="nc" id="L1390">        throw new Exception(&quot;evalFail&quot;);</span>
      }
      
<span class="nc" id="L1393">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1394">      result[0] = true;</span>
<span class="nc" id="L1395">    } catch (Exception ex) {</span>
<span class="nc" id="L1396">      println(&quot;no&quot;);</span>
<span class="nc" id="L1397">      result[0] = false;</span>
      
<span class="nc bnc" id="L1399" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1400">        println(&quot;\n=== Full Report ===&quot;);</span>
        
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if (evalFail) {</span>
<span class="nc" id="L1403">          println(&quot;Results don't differ between non-weighted and &quot;</span>
              + &quot;weighted instance models.&quot;);
<span class="nc" id="L1405">          println(&quot;Here are the results:\n&quot;);</span>
<span class="nc" id="L1406">          println(probsToString(resultProbsO));</span>
        } else {
<span class="nc" id="L1408">          print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">          if (built) {</span>
<span class="nc" id="L1410">            print(&quot; testing&quot;);</span>
          } else {
<span class="nc" id="L1412">            print(&quot; training&quot;);</span>
          }
<span class="nc" id="L1414">          println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L1416">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1417">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1418">            + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1419">        println(&quot;=== Train Weights ===\n&quot;);</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">        for (int i = 0; i &lt; train.numInstances(); i++) {</span>
<span class="nc" id="L1421">          println(&quot; &quot; + (i + 1) </span>
<span class="nc" id="L1422">              + &quot;    &quot; + train.instance(i).weight());</span>
        }
<span class="nc" id="L1424">        println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1425">            + test.toString() + &quot;\n\n&quot;);	</span>
<span class="nc" id="L1426">        println(&quot;(test weights all 1.0\n&quot;);</span>
      }
    }
    
<span class="nc" id="L1430">    return result;</span>
  }
  
  /**
   * Checks whether the scheme alters the training dataset during
   * training. If the scheme needs to modify the training
   * data it should take a copy of the training data. Currently checks
   * for changes to header structure, number of instances, order of
   * instances, instance weights.
   *
   * @param attrTypes attribute types that can be estimated
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param attributeMissing true if we know the estimator can handle
   * (at least) moderate missing attribute values
   * @param classMissing true if we know the estimator can handle
   * (at least) moderate missing class values
   * @return index 0 is true if the test was passed
   */
  protected boolean[] datasetIntegrity(AttrTypes attrTypes,
				       int classType,
				       boolean attributeMissing,
				       boolean classMissing) {
    
<span class="nc" id="L1453">    Estimator estimator = null;</span>
<span class="nc" id="L1454">    print(&quot;estimator doesn't alter original datasets&quot;);</span>
<span class="nc" id="L1455">    printAttributeSummary(attrTypes, classType);</span>
<span class="nc" id="L1456">    print(&quot;...&quot;);</span>
<span class="nc" id="L1457">    int numTrain = getNumInstances(), numTest = getNumInstances(), </span>
<span class="nc" id="L1458">    numClasses = 2, missingLevel = 100;</span>
    
<span class="nc" id="L1460">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1461">    Instances train = null;</span>
<span class="nc" id="L1462">     boolean built = false;</span>
    try {
<span class="nc" id="L1464">      train = makeTestDataset(42, numTrain, 1, attrTypes,</span>
<span class="nc" id="L1465">                              numClasses, </span>
<span class="nc" id="L1466">                              classType);</span>
<span class="nc" id="L1467">      int attrIndex = 0;</span>
 
<span class="nc bnc" id="L1469" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1470">        addMissing(train, missingLevel, attributeMissing, classMissing, attrIndex);</span>
      }
<span class="nc" id="L1472">      estimator = Estimator.makeCopies(getEstimator(), 1)[0];</span>
<span class="nc" id="L1473">    } catch (Exception ex) {</span>
<span class="nc" id="L1474">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L1477">      Instances trainCopy = new Instances(train);</span>
<span class="nc" id="L1478">      int attrIndex = 0;</span>
<span class="nc" id="L1479">      estimator.addValues(trainCopy, attrIndex);</span>
<span class="nc" id="L1480">      compareDatasets(train, trainCopy);</span>
<span class="nc" id="L1481">      built = true;</span>
      
<span class="nc" id="L1483">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1484">      result[0] = true;</span>
<span class="nc" id="L1485">    } catch (Exception ex) {</span>
<span class="nc" id="L1486">      println(&quot;no&quot;);</span>
<span class="nc" id="L1487">      result[0] = false;</span>
      
<span class="nc bnc" id="L1489" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1490">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1491">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L1493">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L1495">          print(&quot; training&quot;);</span>
        }
<span class="nc" id="L1497">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc" id="L1498">        println(&quot;Here are the datasets:\n&quot;);</span>
<span class="nc" id="L1499">        println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1500">            + train.toString() + &quot;\n&quot;);</span>
      }
    }
    
<span class="nc" id="L1504">    return result;</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param attrTypes attribute types that can be estimated
   * @param numAtts number of attributes
   * @param attrIndex attribute index 
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param missingLevel the percentage of missing values
   * @param attributeMissing true if the missing values may be in 
   * the attributes
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numTest the number of instaces in the test set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(AttrTypes attrTypes,
				   int numAtts,
				   int attrIndex,
				   int classType,
				   int missingLevel,
				   boolean attributeMissing,
				   boolean classMissing,
				   int numTrain,
				   int numTest,
				   int numClasses,
				   FastVector accepts) {
    
<span class="nc" id="L1537">    return runBasicTest(attrTypes,</span>
<span class="nc" id="L1538">			numAtts,</span>
<span class="nc" id="L1539">			attrIndex,</span>
<span class="nc" id="L1540">			classType, </span>
<span class="nc" id="L1541">			TestInstances.CLASS_IS_LAST,</span>
<span class="nc" id="L1542">			missingLevel,</span>
<span class="nc" id="L1543">			attributeMissing,</span>
<span class="nc" id="L1544">			classMissing,</span>
<span class="nc" id="L1545">			numTrain,</span>
<span class="nc" id="L1546">			numTest,</span>
<span class="nc" id="L1547">			numClasses,</span>
<span class="nc" id="L1548">		accepts);</span>
  }
  
  /**
   * Runs a text on the datasets with the given characteristics.
   * 
   * @param attrTypes attribute types that can be estimated
   * @param numAtts number of attributes
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the attribute index of the class
   * @param missingLevel the percentage of missing values
   * @param attributeMissing true if the missing values may be in 
   * the attributes
   * @param classMissing true if the missing values may be in the class
   * @param numTrain the number of instances in the training set
   * @param numTest the number of instaces in the test set
   * @param numClasses the number of classes
   * @param accepts the acceptable string in an exception
   * @return index 0 is true if the test was passed, index 1 is true if test 
   *         was acceptable
   */
  protected boolean[] runBasicTest(AttrTypes attrTypes,
				   int numAtts,
				   int attrIndex,
				   int classType,
				   int classIndex,
				   int missingLevel,
				   boolean attributeMissing,
				   boolean classMissing,
				   int numTrain,
				   int numTest,
				   int numClasses,
				   FastVector accepts) {
    
<span class="nc" id="L1582">    boolean[] result = new boolean[2];</span>
<span class="nc" id="L1583">    Instances train = null;</span>
<span class="nc" id="L1584">    Vector test = null;</span>
<span class="nc" id="L1585">    Estimator estimator = null;</span>
<span class="nc" id="L1586">    boolean built = false;</span>
   
    try {
<span class="nc" id="L1589">      train = makeTestDataset(42, numTrain, numAtts, attrTypes,</span>
<span class="nc" id="L1590">          numClasses, </span>
<span class="nc" id="L1591">          classType,</span>
<span class="nc" id="L1592">          classIndex);</span>
            
      // prepare training data set and test value list
<span class="nc bnc" id="L1595" title="All 2 branches missed.">      if (numTrain &gt; 0) {</span>
<span class="nc" id="L1596">        test = makeTestValueList(24, numTest, train, attrIndex,</span>
<span class="nc" id="L1597">            attrTypes.getSetType());</span>
     
      } else {
<span class="nc" id="L1600">        double min = -10.0;</span>
<span class="nc" id="L1601">        double max = 8.0;</span>
<span class="nc" id="L1602">        test = makeTestValueList(24, numTest, min, max,</span>
<span class="nc" id="L1603">            attrTypes.getSetType());</span>
     }
      
<span class="nc bnc" id="L1606" title="All 2 branches missed.">      if (missingLevel &gt; 0) {</span>
<span class="nc" id="L1607">        addMissing(train, missingLevel, attributeMissing, classMissing, attrIndex);</span>
      }
<span class="nc" id="L1609">      estimator = Estimator.makeCopies(getEstimator(), 1)[0];</span>
<span class="nc" id="L1610">    } catch (Exception ex) {</span>
<span class="nc" id="L1611">      ex.printStackTrace();</span>
<span class="nc" id="L1612">      throw new Error(&quot;Error setting up for tests: &quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L1615">      estimator.addValues(train, attrIndex);</span>
<span class="nc" id="L1616">      built = true;</span>
      
<span class="nc" id="L1618">      testWithTestValues(estimator, test);</span>
      
<span class="nc" id="L1620">      println(&quot;yes&quot;);</span>
<span class="nc" id="L1621">      result[0] = true;</span>
    } 
<span class="nc" id="L1623">    catch (Exception ex) {</span>
<span class="nc" id="L1624">      boolean acceptable = false;</span>
      String msg;
<span class="nc bnc" id="L1626" title="All 2 branches missed.">      if (ex.getMessage() == null)</span>
<span class="nc" id="L1627">        msg = &quot;&quot;;</span>
      else
<span class="nc" id="L1629">        msg = ex.getMessage().toLowerCase();</span>
<span class="nc bnc" id="L1630" title="All 2 branches missed.">      if (msg.indexOf(&quot;not in classpath&quot;) &gt; -1)</span>
<span class="nc" id="L1631">        m_ClasspathProblems = true;</span>
      
<span class="nc bnc" id="L1633" title="All 2 branches missed.">      for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        if (msg.indexOf((String)accepts.elementAt(i)) &gt;= 0) {</span>
<span class="nc" id="L1635">          acceptable = true;</span>
        }
      }
      
<span class="nc bnc" id="L1639" title="All 2 branches missed.">      println(&quot;no&quot; + (acceptable ? &quot; (OK error message)&quot; : &quot;&quot;));</span>
<span class="nc" id="L1640">      result[1] = acceptable;</span>
      
      
<span class="nc bnc" id="L1643" title="All 2 branches missed.">      if (m_Debug) {</span>
<span class="nc" id="L1644">        println(&quot;\n=== Full Report ===&quot;);</span>
<span class="nc" id="L1645">        print(&quot;Problem during&quot;);</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        if (built) {</span>
<span class="nc" id="L1647">          print(&quot; testing&quot;);</span>
        } else {
<span class="nc" id="L1649">          print(&quot; training&quot;);</span>
        }
<span class="nc" id="L1651">        println(&quot;: &quot; + ex.getMessage() + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">        if (!acceptable) {</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">          if (accepts.size() &gt; 0) {</span>
<span class="nc" id="L1654">            print(&quot;Error message doesn't mention &quot;);</span>
<span class="nc bnc" id="L1655" title="All 2 branches missed.">            for (int i = 0; i &lt; accepts.size(); i++) {</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">              if (i != 0) {</span>
<span class="nc" id="L1657">                print(&quot; or &quot;);</span>
              }
<span class="nc" id="L1659">              print('&quot;' + (String)accepts.elementAt(i) + '&quot;');</span>
            }
          }
<span class="nc" id="L1662">          println(&quot;here are the datasets:\n&quot;);</span>
<span class="nc" id="L1663">          println(&quot;=== Train Dataset ===\n&quot;</span>
<span class="nc" id="L1664">              + train.toString() + &quot;\n&quot;);</span>
<span class="nc" id="L1665">          println(&quot;=== Test Dataset ===\n&quot;</span>
<span class="nc" id="L1666">              + test.toString() + &quot;\n\n&quot;);</span>
        }
        
      }
    }
<span class="nc" id="L1671">    return result;</span>
  }
  
  /**
   * Compare two datasets to see if they differ.
   *
   * @param data1 one set of instances
   * @param data2 the other set of instances
   * @throws Exception if the datasets differ
   */
  protected void compareDatasets(Instances data1, Instances data2)
  throws Exception {
<span class="nc bnc" id="L1683" title="All 2 branches missed.">    if (!data2.equalHeaders(data1)) {</span>
<span class="nc" id="L1684">      throw new Exception(&quot;header has been modified&quot;);</span>
    }
<span class="nc bnc" id="L1686" title="All 2 branches missed.">    if (!(data2.numInstances() == data1.numInstances())) {</span>
<span class="nc" id="L1687">      throw new Exception(&quot;number of instances has changed&quot;);</span>
    }
<span class="nc bnc" id="L1689" title="All 2 branches missed.">    for (int i = 0; i &lt; data2.numInstances(); i++) {</span>
<span class="nc" id="L1690">      Instance orig = data1.instance(i);</span>
<span class="nc" id="L1691">      Instance copy = data2.instance(i);</span>
<span class="nc bnc" id="L1692" title="All 2 branches missed.">      for (int j = 0; j &lt; orig.numAttributes(); j++) {</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">        if (orig.isMissing(j)) {</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">          if (!copy.isMissing(j)) {</span>
<span class="nc" id="L1695">            throw new Exception(&quot;instances have changed&quot;);</span>
          }
<span class="nc bnc" id="L1697" title="All 2 branches missed.">        } else if (orig.value(j) != copy.value(j)) {</span>
<span class="nc" id="L1698">          throw new Exception(&quot;instances have changed&quot;);</span>
        }
<span class="nc bnc" id="L1700" title="All 2 branches missed.">        if (orig.weight() != copy.weight()) {</span>
<span class="nc" id="L1701">          throw new Exception(&quot;instance weights have changed&quot;);</span>
        }	  
      }
    }
<span class="nc" id="L1705">  }</span>
  
  /**
   * Add missing values to a dataset.
   *
   * @param data the instances to add missing values to
   * @param level the level of missing values to add (if positive, this
   * is the probability that a value will be set to missing, if negative
   * all but one value will be set to missing (not yet implemented))
   * @param attributeMissing if true, attributes will be modified
   * @param classMissing if true, the class attribute will be modified
   * @param attrIndex index of the attribute
   */
  protected void addMissing(Instances data, int level,
			    boolean attributeMissing, boolean classMissing,
			    int attrIndex) {
    
<span class="nc" id="L1722">    int classIndex = data.classIndex();</span>
<span class="nc" id="L1723">    Random random = new Random(1);</span>
<span class="nc bnc" id="L1724" title="All 2 branches missed.">    for (int i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L1725">      Instance current = data.instance(i);</span>

<span class="nc bnc" id="L1727" title="All 2 branches missed.">      for (int j = 0; j &lt; data.numAttributes(); j++) {</span>
<span class="nc bnc" id="L1728" title="All 4 branches missed.">        if (((j == classIndex) &amp;&amp; classMissing) ||</span>
<span class="nc bnc" id="L1729" title="All 4 branches missed.">            ((j == attrIndex) &amp;&amp; attributeMissing)) {</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">          if (Math.abs(random.nextInt()) % 100 &lt; level)</span>
<span class="nc" id="L1731">            current.setMissing(j);</span>
        }
      }
    }
<span class="nc" id="L1735">  }</span>
  
  /**
   * Make a simple set of instances, which can later be modified
   * for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numAttr the number of attributes
   * @param attrTypes the attribute types
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, 
				      int numInstances, 
				      int numAttr,
				      AttrTypes attrTypes,
				      int numClasses, 
				      int classType)
    throws Exception {
    
<span class="nc" id="L1759">    return makeTestDataset(</span>
<span class="nc" id="L1760">			   seed,</span>
<span class="nc" id="L1761">			   numInstances,</span>
<span class="nc" id="L1762">			   numAttr,</span>
<span class="nc" id="L1763">			   attrTypes,</span>
<span class="nc" id="L1764">			   numClasses, </span>
<span class="nc" id="L1765">			   classType,</span>
<span class="nc" id="L1766">			   TestInstances.CLASS_IS_LAST);</span>
  }


  /**
   * Make a simple set of instances with variable position of the class 
   * attribute, which can later be modified for use in specific tests.
   *
   * @param seed the random number seed
   * @param numInstances the number of instances to generate
   * @param numAttr the number of attributes to generate
   * @param attrTypes the type of attrbute that is excepted
   * @param numClasses the number of classes (if nominal class)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   * @param classIndex the index of the class (0-based, -1 as last)
   * @return the test dataset
   * @throws Exception if the dataset couldn't be generated
   * @see TestInstances#CLASS_IS_LAST
   * @see #process(Instances)
   */
  protected Instances makeTestDataset(int seed, int numInstances, 
				      int numAttr, AttrTypes attrTypes,
				      int numClasses, int classType,
				      int classIndex)
    throws Exception {
    
<span class="nc" id="L1792">    TestInstances dataset = new TestInstances();</span>
    
<span class="nc" id="L1794">    dataset.setSeed(seed);</span>
<span class="nc" id="L1795">    dataset.setNumInstances(numInstances);</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">    dataset.setNumNominal   (attrTypes.nominal     ? numAttr : 0);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">    dataset.setNumNumeric   (attrTypes.numeric     ? numAttr : 0);</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">    dataset.setNumString    (attrTypes.string      ? numAttr : 0);</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">    dataset.setNumDate      (attrTypes.date        ? numAttr : 0);</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">    dataset.setNumRelational(attrTypes.relational  ? numAttr : 0);</span>
<span class="nc" id="L1801">    dataset.setNumClasses(numClasses);</span>
<span class="nc" id="L1802">    dataset.setClassType(classType);</span>
<span class="nc" id="L1803">    dataset.setClassIndex(classIndex);</span>
    
<span class="nc" id="L1805">    return process(dataset.generate());</span>
  }

  /**
   * Make a simple set of values. Only one of the num'type' parameters should be larger 0.
   * (just to make parameter similar to the makeTestDataset parameters)
   *
   * @param seed the random number seed
   * @param numValues the number of values to generate
   * @param data the dataset to make test examples for
   * @param attrIndex index of the attribute
   * @param attrType the class type (NUMERIC, NOMINAL, etc.)
   * @throws Exception if the dataset couldn't be generated
   * @see #process(Instances)
   */
  protected Vector makeTestValueList(int seed, int numValues, 
      Instances data, int attrIndex, int attrType)
  throws Exception {
    
    // get min max
<span class="nc" id="L1825">    double []minMax = getMinimumMaximum(data, attrIndex);</span>
<span class="nc" id="L1826">    double minValue = minMax[0];</span>
<span class="nc" id="L1827">    double maxValue = minMax[1];</span>
    
    // make value list and put into a VECTOR
<span class="nc" id="L1830">    double range = maxValue - minValue; </span>
<span class="nc" id="L1831">    Vector values = new Vector(numValues); </span>
<span class="nc" id="L1832">    Random random = new Random(seed);</span>
    
<span class="nc bnc" id="L1834" title="All 2 branches missed.">    if (attrType == Attribute.NOMINAL) {</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">      for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L1836">        Double v = new Double((Math.abs(random.nextInt()) % (int)range)+ (int)minValue);</span>
<span class="nc" id="L1837">        values.add(v);</span>
      }
    }
<span class="nc bnc" id="L1840" title="All 2 branches missed.">    if (attrType == Attribute.NUMERIC) {</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">      for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L1842">        Double v = new Double(random.nextDouble() * range + minValue);</span>
<span class="nc" id="L1843">        values.add(v);</span>
      }
    }
<span class="nc" id="L1846">    return values;</span>
  }

  /**
   * Make a simple set of values. Only one of the num'type' parameters should be larger 0.
   * (just to make parameter similar to the makeTestDataset parameters)
   *
   * @param seed the random number seed
   * @param numValues the number of values to generate
   * @param minValue the minimal data value
   * @param maxValue the maximal data value
   * @param attrType the class type (NUMERIC, NOMINAL, etc.)
   * @throws Exception if the dataset couldn't be generated
   * @see #process(Instances)
   */
  protected Vector makeTestValueList(int seed, int numValues, 
      double minValue, double maxValue, int attrType)
  throws Exception {
    
      
    // make value list and put into a VECTOR
<span class="nc" id="L1867">    double range = maxValue - minValue; </span>
<span class="nc" id="L1868">    Vector values = new Vector(numValues); </span>
<span class="nc" id="L1869">    Random random = new Random(seed);</span>
    
<span class="nc bnc" id="L1871" title="All 2 branches missed.">    if (attrType == Attribute.NOMINAL) {</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">      for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L1873">        Double v = new Double((Math.abs(random.nextInt()) % (int)range)+ (int)minValue);</span>
<span class="nc" id="L1874">        values.add(v);</span>
      }
    }
<span class="nc bnc" id="L1877" title="All 2 branches missed.">    if (attrType == Attribute.NUMERIC) {</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">      for (int i = 0; i &lt; numValues; i++) {</span>
<span class="nc" id="L1879">        Double v = new Double(random.nextDouble() * range + minValue);</span>
<span class="nc" id="L1880">        values.add(v);</span>
      }
    }
<span class="nc" id="L1883">    return values;</span>
  }

  /**
   * Test with test values.
   *
   * @param est estimator to be tested
   * @param test vector with test values
   *
   **/
  protected Vector testWithTestValues(Estimator est, Vector test) {
    
<span class="nc" id="L1895">    Vector results = new Vector();</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">    for (int i = 0; i &lt; test.size(); i++) {</span>
<span class="nc" id="L1897">      double testValue = ((Double)(test.elementAt(i))).doubleValue();</span>
<span class="nc" id="L1898">      double prob = est.getProbability(testValue);</span>
<span class="nc" id="L1899">      Double p = new Double(prob);</span>
<span class="nc" id="L1900">      results.add(p);</span>
    }
<span class="nc" id="L1902">    return results;</span>
  }

  /**
   * Gets the minimum and maximum of the values a the first attribute
   * of the given data set
   *
   * @param inst the instance
   * @param attrIndex the index of the attribut to find min and max
   * @return the array with the minimum value on index 0 and the max on index 1
   */
  
  protected double[] getMinimumMaximum(Instances inst, int attrIndex) {
<span class="nc" id="L1915">    double []minMax = new double[2];</span>
    
    try {
<span class="nc" id="L1918">      int num = getMinMax(inst, attrIndex, minMax);</span>
<span class="nc" id="L1919">    } catch (Exception ex) {</span>
<span class="nc" id="L1920">      ex.printStackTrace();</span>
<span class="nc" id="L1921">      System.out.println(ex.getMessage());</span>
    }
<span class="nc" id="L1923">    return minMax;</span>
    //      double minValue = minMax[0];
    //      double maxValue = minMax[1];
  }
  
  /** 
   * Find the minimum and the maximum of the attribute and return it in 
   * the last parameter..
   * @param inst instances used to build the estimator
   * @param attrIndex index of the attribute
   * @param minMax the array to return minimum and maximum in
   * @return number of not missing values
   * @exception Exception if parameter minMax wasn't initialized properly
   */
  public static int getMinMax(Instances inst, int attrIndex, double [] minMax) 
    throws Exception {
<span class="nc" id="L1939">    double min = Double.NaN;</span>
<span class="nc" id="L1940">    double max = Double.NaN;</span>
<span class="nc" id="L1941">    Instance instance = null;</span>
<span class="nc" id="L1942">    int numNotMissing = 0;</span>
<span class="nc bnc" id="L1943" title="All 4 branches missed.">    if ((minMax == null) || (minMax.length &lt; 2)) {</span>
<span class="nc" id="L1944">      throw new Exception(&quot;Error in Program, privat method getMinMax&quot;);</span>
    }
    
<span class="nc" id="L1947">    Enumeration enumInst = inst.enumerateInstances();</span>
<span class="nc bnc" id="L1948" title="All 2 branches missed.">    if (enumInst.hasMoreElements()) {</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">      do {</span>
<span class="nc" id="L1950">	instance = (Instance) enumInst.nextElement();</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">      } while (instance.isMissing(attrIndex) &amp;&amp; (enumInst.hasMoreElements()));</span>
      
      // add values if not  missing
<span class="nc bnc" id="L1954" title="All 2 branches missed.">      if (!instance.isMissing(attrIndex)) {</span>
<span class="nc" id="L1955">	numNotMissing++;</span>
<span class="nc" id="L1956">	min = instance.value(attrIndex);</span>
<span class="nc" id="L1957">	max = instance.value(attrIndex);</span>
      }
<span class="nc bnc" id="L1959" title="All 2 branches missed.">      while (enumInst.hasMoreElements()) {</span>
<span class="nc" id="L1960">	instance = (Instance) enumInst.nextElement();</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">	if (!instance.isMissing(attrIndex)) {</span>
<span class="nc" id="L1962">	  numNotMissing++;</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">	  if (instance.value(attrIndex) &lt; min) {</span>
<span class="nc" id="L1964">	    min = (instance.value(attrIndex));</span>
	  } else {
<span class="nc bnc" id="L1966" title="All 2 branches missed.">	    if (instance.value(attrIndex) &gt; max) {	      </span>
<span class="nc" id="L1967">	      max = (instance.value(attrIndex));</span>
	    }
	  }
	}
      }
    }
<span class="nc" id="L1973">    minMax[0] = min;</span>
<span class="nc" id="L1974">    minMax[1] = max;</span>
<span class="nc" id="L1975">    return numNotMissing;</span>
  }

  /**
   * Print the probabilities after testing
   * @param probs vector with probability values
   * @return string with probability values printed
   */ 
  private String probsToString(Vector probs) {
<span class="nc" id="L1984">    StringBuffer txt = new StringBuffer (&quot; &quot;);</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">    for (int i = 0; i &lt; probs.size(); i++) {</span>
<span class="nc" id="L1986">      txt.append(&quot;&quot; + ((Double)(probs.elementAt(i))).doubleValue() + &quot; &quot;);</span>
    }
<span class="nc" id="L1988">    return txt.toString();</span>
  }
  
  /**
   * Provides a hook for derived classes to further modify the data. 
   * 
   * @param data	the data to process
   * @return		the processed data
   * @see #m_PostProcessor
   */
  protected Instances process(Instances data) {
<span class="nc bnc" id="L1999" title="All 2 branches missed.">    if (getPostProcessor() == null)</span>
<span class="nc" id="L2000">      return data;</span>
    else
<span class="nc" id="L2002">      return getPostProcessor().process(data);</span>
  }
  
  /**
   * Print out a short summary string for the dataset characteristics
   *
   * @param attrTypes the attribute types used (NUMERIC, NOMINAL, etc.)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   */
  protected void printAttributeSummary(AttrTypes attrTypes, int classType) {
    
<span class="nc" id="L2013">    String str = &quot;&quot;;</span>
    
<span class="nc bnc" id="L2015" title="All 2 branches missed.">    if (attrTypes.numeric)</span>
<span class="nc" id="L2016">      str += &quot; numeric&quot;;</span>
    
<span class="nc bnc" id="L2018" title="All 2 branches missed.">    if (attrTypes.nominal) {</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L2020">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L2021">      str += &quot; nominal&quot;;</span>
    }
    
<span class="nc bnc" id="L2024" title="All 2 branches missed.">    if (attrTypes.string) {</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L2026">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L2027">      str += &quot; string&quot;;</span>
    }
    
<span class="nc bnc" id="L2030" title="All 2 branches missed.">    if (attrTypes.date) {</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L2032">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L2033">      str += &quot; date&quot;;</span>
    }
    
<span class="nc bnc" id="L2036" title="All 2 branches missed.">    if (attrTypes.relational) {</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">      if (str.length() &gt; 0)</span>
<span class="nc" id="L2038">        str += &quot; &amp;&quot;;</span>
<span class="nc" id="L2039">      str += &quot; relational&quot;;</span>
    }
    
<span class="nc" id="L2042">    str += &quot; attributes)&quot;;</span>
    
<span class="nc bnc" id="L2044" title="All 6 branches missed.">    switch (classType) {</span>
      case Attribute.NUMERIC:
<span class="nc" id="L2046">        str = &quot; (numeric class,&quot; + str;</span>
<span class="nc" id="L2047">        break;</span>
      case Attribute.NOMINAL:
<span class="nc" id="L2049">        str = &quot; (nominal class,&quot; + str;</span>
<span class="nc" id="L2050">        break;</span>
      case Attribute.STRING:
<span class="nc" id="L2052">        str = &quot; (string class,&quot; + str;</span>
<span class="nc" id="L2053">        break;</span>
      case Attribute.DATE:
<span class="nc" id="L2055">        str = &quot; (date class,&quot; + str;</span>
<span class="nc" id="L2056">        break;</span>
      case Attribute.RELATIONAL:
<span class="nc" id="L2058">        str = &quot; (relational class,&quot; + str;</span>
        break;
    }
    
<span class="nc" id="L2062">    print(str);</span>
<span class="nc" id="L2063">  }</span>
  
  /**
   * Print out a short summary string for the dataset characteristics
   *
   * @param attrType the attribute type (NUMERIC, NOMINAL, etc.)
   * @param classType the class type (NUMERIC, NOMINAL, etc.)
   */
  protected void printAttributeSummary(int attrType, int classType) {
    
<span class="nc" id="L2073">    String str = &quot;&quot;;</span>
    
<span class="nc bnc" id="L2075" title="All 6 branches missed.">    switch (attrType) {</span>
    case Attribute.NUMERIC:
<span class="nc" id="L2077">      str = &quot; numeric&quot; + str;</span>
<span class="nc" id="L2078">      break;</span>
    case Attribute.NOMINAL:
<span class="nc" id="L2080">      str = &quot; nominal&quot; + str;</span>
<span class="nc" id="L2081">      break;</span>
    case Attribute.STRING:
<span class="nc" id="L2083">      str = &quot; string&quot; + str;</span>
<span class="nc" id="L2084">      break;</span>
    case Attribute.DATE:
<span class="nc" id="L2086">      str = &quot; date&quot; + str;</span>
<span class="nc" id="L2087">      break;</span>
    case Attribute.RELATIONAL:
<span class="nc" id="L2089">      str = &quot; relational&quot; + str;</span>
      break;
<span class="nc" id="L2091">    }</span>
<span class="nc" id="L2092">    str += &quot; attribute(s))&quot;;</span>
    
<span class="nc bnc" id="L2094" title="All 6 branches missed.">    switch (classType) {</span>
    case Attribute.NUMERIC:
<span class="nc" id="L2096">      str = &quot; (numeric class,&quot; + str;</span>
<span class="nc" id="L2097">      break;</span>
    case Attribute.NOMINAL:
<span class="nc" id="L2099">      str = &quot; (nominal class,&quot; + str;</span>
<span class="nc" id="L2100">      break;</span>
    case Attribute.STRING:
<span class="nc" id="L2102">      str = &quot; (string class,&quot; + str;</span>
<span class="nc" id="L2103">      break;</span>
    case Attribute.DATE:
<span class="nc" id="L2105">      str = &quot; (date class,&quot; + str;</span>
<span class="nc" id="L2106">      break;</span>
    case Attribute.RELATIONAL:
<span class="nc" id="L2108">      str = &quot; (relational class,&quot; + str;</span>
      break;
    }
    
<span class="nc" id="L2112">    print(str);</span>
<span class="nc" id="L2113">  }</span>
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L2121">    return RevisionUtils.extract(&quot;$Revision: 1.5 $&quot;);</span>
  }

  /**
   * Test method for this class
   * 
   * @param args the commandline parameters
   */
  public static void main(String [] args) {
    try {
<span class="nc" id="L2131">      CheckEstimator check = new CheckEstimator();</span>
      
      try {
<span class="nc" id="L2134">        check.setOptions(args);</span>
<span class="nc" id="L2135">        Utils.checkForRemainingOptions(args);</span>
<span class="nc" id="L2136">      } catch (Exception ex) {</span>
<span class="nc" id="L2137">        String result = ex.getMessage() + &quot;\n\n&quot; + check.getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;) + &quot; Options:\n\n&quot;;</span>
<span class="nc" id="L2138">        Enumeration enu = check.listOptions();</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">        while (enu.hasMoreElements()) {</span>
<span class="nc" id="L2140">          Option option = (Option) enu.nextElement();</span>
<span class="nc" id="L2141">          result += option.synopsis() + &quot;\n&quot; + option.description() + &quot;\n&quot;;</span>
        }
<span class="nc" id="L2143">        throw new Exception(result);</span>
      }
      
<span class="nc" id="L2146">      check.doTests();</span>
<span class="nc" id="L2147">    } catch (Exception ex) {</span>
<span class="nc" id="L2148">      System.err.println(ex.getMessage());</span>
    }
<span class="nc" id="L2150">  }</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>