<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>MultilayerPerceptron.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/main/java</a> &gt; <a href="index.source.html" class="el_package">weka.classifiers.functions</a> &gt; <span class="el_source">MultilayerPerceptron.java</span></div><h1>MultilayerPerceptron.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">/*</span>
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    MultilayerPerceptron.java
 *    Copyright (C) 2000 University of Waikato, Hamilton, New Zealand
 */

package weka.classifiers.functions;

import weka.classifiers.Classifier;
import weka.classifiers.functions.neural.LinearUnit;
import weka.classifiers.functions.neural.NeuralConnection;
import weka.classifiers.functions.neural.NeuralNode;
import weka.classifiers.functions.neural.SigmoidUnit;
import weka.core.Capabilities;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.Option;
import weka.core.OptionHandler;
import weka.core.Randomizable;
import weka.core.RevisionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.filters.Filter;
import weka.filters.unsupervised.attribute.NominalToBinary;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Enumeration;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;

/** 
 &lt;!-- globalinfo-start --&gt;
 * A Classifier that uses backpropagation to classify instances.&lt;br/&gt;
 * This network can be built by hand, created by an algorithm or both. The network can also be monitored and modified during training time. The nodes in this network are all sigmoid (except for when the class is numeric in which case the the output nodes become unthresholded linear units).
 * &lt;p/&gt;
 &lt;!-- globalinfo-end --&gt;
 *
 &lt;!-- options-start --&gt;
 * Valid options are: &lt;p/&gt;
 * 
 * &lt;pre&gt; -L &amp;lt;learning rate&amp;gt;
 *  Learning Rate for the backpropagation algorithm.
 *  (Value should be between 0 - 1, Default = 0.3).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -M &amp;lt;momentum&amp;gt;
 *  Momentum Rate for the backpropagation algorithm.
 *  (Value should be between 0 - 1, Default = 0.2).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -N &amp;lt;number of epochs&amp;gt;
 *  Number of epochs to train through.
 *  (Default = 500).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -V &amp;lt;percentage size of validation set&amp;gt;
 *  Percentage size of validation set to use to terminate
 *  training (if this is non zero it can pre-empt num of epochs.
 *  (Value should be between 0 - 100, Default = 0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
 *  The value used to seed the random number generator
 *  (Value should be &amp;gt;= 0 and and a long, Default = 0).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -E &amp;lt;threshold for number of consequetive errors&amp;gt;
 *  The consequetive number of errors allowed for validation
 *  testing before the netwrok terminates.
 *  (Value should be &amp;gt; 0, Default = 20).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -G
 *  GUI will be opened.
 *  (Use this to bring up a GUI).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -A
 *  Autocreation of the network connections will NOT be done.
 *  (This will be ignored if -G is NOT set)&lt;/pre&gt;
 * 
 * &lt;pre&gt; -B
 *  A NominalToBinary filter will NOT automatically be used.
 *  (Set this to not use a NominalToBinary filter).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -H &amp;lt;comma seperated numbers for nodes on each layer&amp;gt;
 *  The hidden layers to be created for the network.
 *  (Value should be a list of comma separated Natural 
 *  numbers or the letters 'a' = (attribs + classes) / 2, 
 *  'i' = attribs, 'o' = classes, 't' = attribs .+ classes)
 *  for wildcard values, Default = a).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -C
 *  Normalizing a numeric class will NOT be done.
 *  (Set this to not normalize the class if it's numeric).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -I
 *  Normalizing the attributes will NOT be done.
 *  (Set this to not normalize the attributes).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -R
 *  Reseting the network will NOT be allowed.
 *  (Set this to not allow the network to reset).&lt;/pre&gt;
 * 
 * &lt;pre&gt; -D
 *  Learning rate decay will occur.
 *  (Set this to cause the learning rate to decay).&lt;/pre&gt;
 * 
 &lt;!-- options-end --&gt;
 *
 * @author Malcolm Ware (mfw4@cs.waikato.ac.nz)
 * @version $Revision: 9445 $
 */
public class MultilayerPerceptron 
  extends Classifier 
  implements OptionHandler, WeightedInstancesHandler, Randomizable {
  
  /** for serialization */
  private static final long serialVersionUID = -5990607817048210779L;

  /**
   * Main method for testing this class.
   *
   * @param argv should contain command line options (see setOptions)
   */
  public static void main(String [] argv) {
<span class="nc" id="L161">    runClassifier(new MultilayerPerceptron(), argv);</span>
<span class="nc" id="L162">  }</span>
  

  /** 
   * This inner class is used to connect the nodes in the network up to
   * the data that they are classifying, Note that objects of this class are
   * only suitable to go on the attribute side or class side of the network
   * and not both.
   */
  protected class NeuralEnd 
    extends NeuralConnection {
    
    /** for serialization */
    static final long serialVersionUID = 7305185603191183338L;
  
    /** 
     * the value that represents the instance value this node represents. 
     * For an input it is the attribute number, for an output, if nominal
     * it is the class value. 
     */
    private int m_link;
    
    /** True if node is an input, False if it's an output. */
    private boolean m_input;

    /**
     * Constructor
     */
    public NeuralEnd(String id) {
<span class="fc" id="L191">      super(id);</span>

<span class="fc" id="L193">      m_link = 0;</span>
<span class="fc" id="L194">      m_input = true;</span>
      
<span class="fc" id="L196">    }</span>
  
    /**
     * Call this function to determine if the point at x,y is on the unit.
     * @param g The graphics context for font size info.
     * @param x The x coord.
     * @param y The y coord.
     * @param w The width of the display.
     * @param h The height of the display.
     * @return True if the point is on the unit, false otherwise.
     */
    public boolean onUnit(Graphics g, int x, int y, int w, int h) {
      
<span class="nc" id="L209">      FontMetrics fm = g.getFontMetrics();</span>
<span class="nc" id="L210">      int l = (int)(m_x * w) - fm.stringWidth(m_id) / 2;</span>
<span class="nc" id="L211">      int t = (int)(m_y * h) - fm.getHeight() / 2;</span>
<span class="nc bnc" id="L212" title="All 4 branches missed.">      if (x &lt; l || x &gt; l + fm.stringWidth(m_id) + 4 </span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">	  || y &lt; t || y &gt; t + fm.getHeight() + fm.getDescent() + 4) {</span>
<span class="nc" id="L214">	return false;</span>
      }
<span class="nc" id="L216">      return true;</span>
      
    }
   

    /**
     * This will draw the node id to the graphics context.
     * @param g The graphics context.
     * @param w The width of the drawing area.
     * @param h The height of the drawing area.
     */
    public void drawNode(Graphics g, int w, int h) {
      
<span class="nc bnc" id="L229" title="All 2 branches missed.">      if ((m_type &amp; PURE_INPUT) == PURE_INPUT) {</span>
<span class="nc" id="L230">	g.setColor(Color.green);</span>
      }
      else {
<span class="nc" id="L233">	g.setColor(Color.orange);</span>
      }
      
<span class="nc" id="L236">      FontMetrics fm = g.getFontMetrics();</span>
<span class="nc" id="L237">      int l = (int)(m_x * w) - fm.stringWidth(m_id) / 2;</span>
<span class="nc" id="L238">      int t = (int)(m_y * h) - fm.getHeight() / 2;</span>
<span class="nc" id="L239">      g.fill3DRect(l, t, fm.stringWidth(m_id) + 4</span>
<span class="nc" id="L240">		   , fm.getHeight() + fm.getDescent() + 4</span>
<span class="nc" id="L241">		   , true);</span>
<span class="nc" id="L242">      g.setColor(Color.black);</span>
      
<span class="nc" id="L244">      g.drawString(m_id, l + 2, t + fm.getHeight() + 2);</span>

<span class="nc" id="L246">    }</span>


    /**
     * Call this function to draw the node highlighted.
     * @param g The graphics context.
     * @param w The width of the drawing area.
     * @param h The height of the drawing area.
     */
    public void drawHighlight(Graphics g, int w, int h) {
      
<span class="nc" id="L257">      g.setColor(Color.black);</span>
<span class="nc" id="L258">      FontMetrics fm = g.getFontMetrics();</span>
<span class="nc" id="L259">      int l = (int)(m_x * w) - fm.stringWidth(m_id) / 2;</span>
<span class="nc" id="L260">      int t = (int)(m_y * h) - fm.getHeight() / 2;</span>
<span class="nc" id="L261">      g.fillRect(l - 2, t - 2, fm.stringWidth(m_id) + 8</span>
<span class="nc" id="L262">		 , fm.getHeight() + fm.getDescent() + 8); </span>
<span class="nc" id="L263">      drawNode(g, w, h);</span>
<span class="nc" id="L264">    }</span>
    
    /**
     * Call this to get the output value of this unit. 
     * @param calculate True if the value should be calculated if it hasn't 
     * been already.
     * @return The output value, or NaN, if the value has not been calculated.
     */
    public double outputValue(boolean calculate) {
     
<span class="pc bpc" id="L274" title="1 of 4 branches missed.">      if (Double.isNaN(m_unitValue) &amp;&amp; calculate) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">	if (m_input) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">	  if (m_currentInstance.isMissing(m_link)) {</span>
<span class="fc" id="L277">	    m_unitValue = 0;</span>
	  }
	  else {
	    
<span class="fc" id="L281">	    m_unitValue = m_currentInstance.value(m_link);</span>
	  }
	}
	else {
	  //node is an output.
<span class="fc" id="L286">	  m_unitValue = 0;</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">	  for (int noa = 0; noa &lt; m_numInputs; noa++) {</span>
<span class="fc" id="L288">	    m_unitValue += m_inputList[noa].outputValue(true);</span>
	   
	  }
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">	  if (m_numeric &amp;&amp; m_normalizeClass) {</span>
	    //then scale the value;
	    //this scales linearly from between -1 and 1
<span class="fc" id="L294">	    m_unitValue = m_unitValue * </span>
<span class="fc" id="L295">	      m_attributeRanges[m_instances.classIndex()] + </span>
<span class="fc" id="L296">	      m_attributeBases[m_instances.classIndex()];</span>
	  }
	}
      }
<span class="fc" id="L300">      return m_unitValue;</span>
      
      
    }
    
    /**
     * Call this to get the error value of this unit, which in this case is
     * the difference between the predicted class, and the actual class.
     * @param calculate True if the value should be calculated if it hasn't 
     * been already.
     * @return The error value, or NaN, if the value has not been calculated.
     */
    public double errorValue(boolean calculate) {
      
<span class="pc bpc" id="L314" title="1 of 4 branches missed.">      if (!Double.isNaN(m_unitValue) &amp;&amp; Double.isNaN(m_unitError) </span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">	  &amp;&amp; calculate) {</span>
	
<span class="fc bfc" id="L317" title="All 2 branches covered.">	if (m_input) {</span>
<span class="fc" id="L318">	  m_unitError = 0;</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">	  for (int noa = 0; noa &lt; m_numOutputs; noa++) {</span>
<span class="fc" id="L320">	    m_unitError += m_outputList[noa].errorValue(true);</span>
	  }
	}
	else {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">	  if (m_currentInstance.classIsMissing()) {</span>
<span class="nc" id="L325">	    m_unitError = .1;  </span>
	  }
<span class="fc bfc" id="L327" title="All 2 branches covered.">	  else if (m_instances.classAttribute().isNominal()) {</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">	    if (m_currentInstance.classValue() == m_link) {</span>
<span class="fc" id="L329">	      m_unitError = 1 - m_unitValue;</span>
	    }
	    else {
<span class="fc" id="L332">	      m_unitError = 0 - m_unitValue;</span>
	    }
	  }
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">	  else if (m_numeric) {</span>
	    
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">	    if (m_normalizeClass) {</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">	      if (m_attributeRanges[m_instances.classIndex()] == 0) {</span>
<span class="nc" id="L339">		m_unitError = 0;</span>
	      }
	      else {
<span class="fc" id="L342">		m_unitError = (m_currentInstance.classValue() - m_unitValue ) /</span>
<span class="fc" id="L343">		  m_attributeRanges[m_instances.classIndex()];</span>
		//m_numericRange;
		
	      }
	    }
	    else {
<span class="nc" id="L349">	      m_unitError = m_currentInstance.classValue() - m_unitValue;</span>
	    }
	  }
	}
      }
<span class="fc" id="L354">      return m_unitError;</span>
    }
    
    
    /**
     * Call this to reset the value and error for this unit, ready for the next
     * run. This will also call the reset function of all units that are 
     * connected as inputs to this one.
     * This is also the time that the update for the listeners will be 
     * performed.
     */
    public void reset() {
      
<span class="pc bpc" id="L367" title="1 of 4 branches missed.">      if (!Double.isNaN(m_unitValue) || !Double.isNaN(m_unitError)) {</span>
<span class="fc" id="L368">	m_unitValue = Double.NaN;</span>
<span class="fc" id="L369">	m_unitError = Double.NaN;</span>
<span class="fc" id="L370">	m_weightsUpdated = false;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">	for (int noa = 0; noa &lt; m_numInputs; noa++) {</span>
<span class="fc" id="L372">	  m_inputList[noa].reset();</span>
	}
      }
<span class="fc" id="L375">    }</span>
    
    /**
     * Call this to have the connection save the current
     * weights.
     */
    public void saveWeights() {
<span class="nc bnc" id="L382" title="All 2 branches missed.">      for (int i = 0; i &lt; m_numInputs; i++) {</span>
<span class="nc" id="L383">        m_inputList[i].saveWeights();</span>
      }
<span class="nc" id="L385">    }</span>
    
    /**
     * Call this to have the connection restore from the saved
     * weights.
     */
    public void restoreWeights() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">      for (int i = 0; i &lt; m_numInputs; i++) {</span>
<span class="nc" id="L393">        m_inputList[i].restoreWeights();</span>
      }
<span class="nc" id="L395">    }</span>
    
    
    /** 
     * Call this function to set What this end unit represents.
     * @param input True if this unit is used for entering an attribute,
     * False if it's used for determining a class value.
     * @param val The attribute number or class type that this unit represents.
     * (for nominal attributes).
     */
    public void setLink(boolean input, int val) throws Exception {
<span class="fc" id="L406">      m_input = input;</span>
      
<span class="fc bfc" id="L408" title="All 2 branches covered.">      if (input) {</span>
<span class="fc" id="L409">	m_type = PURE_INPUT;</span>
      }
      else {
<span class="fc" id="L412">	m_type = PURE_OUTPUT;</span>
      }
<span class="pc bpc" id="L414" title="2 of 6 branches missed.">      if (val &lt; 0 || (input &amp;&amp; val &gt; m_instances.numAttributes()) </span>
<span class="fc bfc" id="L415" title="All 4 branches covered.">	  || (!input &amp;&amp; m_instances.classAttribute().isNominal() </span>
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">	      &amp;&amp; val &gt; m_instances.classAttribute().numValues())) {</span>
<span class="nc" id="L417">	m_link = 0;</span>
      }
      else {
<span class="fc" id="L420">	m_link = val;</span>
      }
<span class="fc" id="L422">    }</span>
    
    /**
     * @return link for this node.
     */
    public int getLink() {
<span class="nc" id="L428">      return m_link;</span>
    }
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L437">      return RevisionUtils.extract(&quot;$Revision: 9445 $&quot;);</span>
    }
  }
  

 
  /** Inner class used to draw the nodes onto.(uses the node lists!!) 
   * This will also handle the user input. */
  private class NodePanel 
    extends JPanel
    implements RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = -3067621833388149984L;

    /**
     * The constructor.
     */
<span class="nc" id="L455">    public NodePanel() {</span>
      

<span class="nc" id="L458">      addMouseListener(new MouseAdapter() {</span>
	  
	  public void mousePressed(MouseEvent e) {
	    
<span class="nc bnc" id="L462" title="All 2 branches missed.">	    if (!m_stopped) {</span>
<span class="nc" id="L463">	      return;</span>
	    }
<span class="nc bnc" id="L465" title="All 2 branches missed.">	    if ((e.getModifiers() &amp; MouseEvent.BUTTON1_MASK) == MouseEvent.BUTTON1_MASK &amp;&amp; </span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">		!e.isAltDown()) {</span>
<span class="nc" id="L467">	      Graphics g = NodePanel.this.getGraphics();</span>
<span class="nc" id="L468">	      int x = e.getX();</span>
<span class="nc" id="L469">	      int y = e.getY();</span>
<span class="nc" id="L470">	      int w = NodePanel.this.getWidth();</span>
<span class="nc" id="L471">	      int h = NodePanel.this.getHeight();</span>
<span class="nc" id="L472">	      FastVector tmp = new FastVector(4);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if (m_inputs[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L475">		  tmp.addElement(m_inputs[noa]);</span>
<span class="nc" id="L476">		  selection(tmp, </span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L478">			    , true);</span>
<span class="nc" id="L479">		  return;</span>
		}
	      }
<span class="nc bnc" id="L482" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (m_outputs[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L484">		  tmp.addElement(m_outputs[noa]);</span>
<span class="nc" id="L485">		  selection(tmp,</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L487">			    , true);</span>
<span class="nc" id="L488">		  return;</span>
		}
	      }
<span class="nc bnc" id="L491" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">		if (m_neuralNodes[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L493">		  tmp.addElement(m_neuralNodes[noa]);</span>
<span class="nc" id="L494">		  selection(tmp,</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L496">			    , true);</span>
<span class="nc" id="L497">		  return;</span>
		}

	      }
<span class="nc" id="L501">	      NeuralNode temp = new NeuralNode(String.valueOf(m_nextId), </span>
<span class="nc" id="L502">					       m_random, m_sigmoidUnit);</span>
<span class="nc" id="L503">	      m_nextId++;</span>
<span class="nc" id="L504">	      temp.setX((double)e.getX() / w);</span>
<span class="nc" id="L505">	      temp.setY((double)e.getY() / h);</span>
<span class="nc" id="L506">	      tmp.addElement(temp);</span>
<span class="nc" id="L507">	      addNode(temp);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">	      selection(tmp, (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L509">			, true);</span>
	    }
	    else {
	      //then right click
<span class="nc" id="L513">	      Graphics g = NodePanel.this.getGraphics();</span>
<span class="nc" id="L514">	      int x = e.getX();</span>
<span class="nc" id="L515">	      int y = e.getY();</span>
<span class="nc" id="L516">	      int w = NodePanel.this.getWidth();</span>
<span class="nc" id="L517">	      int h = NodePanel.this.getHeight();</span>
<span class="nc" id="L518">	      FastVector tmp = new FastVector(4);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		if (m_inputs[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L521">		  tmp.addElement(m_inputs[noa]);</span>
<span class="nc" id="L522">		  selection(tmp, </span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L524">			    , false);</span>
<span class="nc" id="L525">		  return;</span>
		}
		
		
	      }
<span class="nc bnc" id="L530" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">		if (m_outputs[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L532">		  tmp.addElement(m_outputs[noa]);</span>
<span class="nc" id="L533">		  selection(tmp,</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L535">			    , false);</span>
<span class="nc" id="L536">		  return;</span>
		}
	      }
<span class="nc bnc" id="L539" title="All 2 branches missed.">	      for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if (m_neuralNodes[noa].onUnit(g, x, y, w, h)) {</span>
<span class="nc" id="L541">		  tmp.addElement(m_neuralNodes[noa]);</span>
<span class="nc" id="L542">		  selection(tmp,</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">			    (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L544">			    , false);</span>
<span class="nc" id="L545">		  return;</span>
		}
	      }
<span class="nc bnc" id="L548" title="All 2 branches missed.">	      selection(null, (e.getModifiers() &amp; MouseEvent.CTRL_MASK) == MouseEvent.CTRL_MASK</span>
<span class="nc" id="L549">			, false);</span>
	    }
<span class="nc" id="L551">	  }</span>
	});
<span class="nc" id="L553">    }</span>
    
    
    /**
     * This function gets called when the user has clicked something
     * It will amend the current selection or connect the current selection
     * to the new selection.
     * Or if nothing was selected and the right button was used it will 
     * delete the node.
     * @param v The units that were selected.
     * @param ctrl True if ctrl was held down.
     * @param left True if it was the left mouse button.
     */
    private void selection(FastVector v, boolean ctrl, boolean left) {
      
<span class="nc bnc" id="L568" title="All 2 branches missed.">      if (v == null) {</span>
	//then unselect all.
<span class="nc" id="L570">	m_selected.removeAllElements();</span>
<span class="nc" id="L571">	repaint();</span>
<span class="nc" id="L572">	return;</span>
      }
      

      //then exclusive or the new selection with the current one.
<span class="nc bnc" id="L577" title="All 6 branches missed.">      if ((ctrl || m_selected.size() == 0) &amp;&amp; left) {</span>
<span class="nc" id="L578">	boolean removed = false;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">	for (int noa = 0; noa &lt; v.size(); noa++) {</span>
<span class="nc" id="L580">	  removed = false;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">	  for (int nob = 0; nob &lt; m_selected.size(); nob++) {</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">	    if (v.elementAt(noa) == m_selected.elementAt(nob)) {</span>
	      //then remove that element
<span class="nc" id="L584">	      m_selected.removeElementAt(nob);</span>
<span class="nc" id="L585">	      removed = true;</span>
<span class="nc" id="L586">	      break;</span>
	    }
	  }
<span class="nc bnc" id="L589" title="All 2 branches missed.">	  if (!removed) {</span>
<span class="nc" id="L590">	    m_selected.addElement(v.elementAt(noa));</span>
	  }
	}
<span class="nc" id="L593">	repaint();</span>
<span class="nc" id="L594">	return;</span>
      }

      
<span class="nc bnc" id="L598" title="All 2 branches missed.">      if (left) {</span>
	//then connect the current selection to the new one.
<span class="nc bnc" id="L600" title="All 2 branches missed.">	for (int noa = 0; noa &lt; m_selected.size(); noa++) {</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">	  for (int nob = 0; nob &lt; v.size(); nob++) {</span>
	    NeuralConnection
<span class="nc" id="L603">	      .connect((NeuralConnection)m_selected.elementAt(noa)</span>
<span class="nc" id="L604">		       , (NeuralConnection)v.elementAt(nob));</span>
	  }
	}
      }
<span class="nc bnc" id="L608" title="All 2 branches missed.">      else if (m_selected.size() &gt; 0) {</span>
	//then disconnect the current selection from the new one.
	
<span class="nc bnc" id="L611" title="All 2 branches missed.">	for (int noa = 0; noa &lt; m_selected.size(); noa++) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">	  for (int nob = 0; nob &lt; v.size(); nob++) {</span>
	    NeuralConnection
<span class="nc" id="L614">	      .disconnect((NeuralConnection)m_selected.elementAt(noa)</span>
<span class="nc" id="L615">			  , (NeuralConnection)v.elementAt(nob));</span>
	    
	    NeuralConnection
<span class="nc" id="L618">	      .disconnect((NeuralConnection)v.elementAt(nob)</span>
<span class="nc" id="L619">			  , (NeuralConnection)m_selected.elementAt(noa));</span>
	    
	  }
	}
      }
      else {
	//then remove the selected node. (it was right clicked while 
	//no other units were selected
<span class="nc bnc" id="L627" title="All 2 branches missed.">	for (int noa = 0; noa &lt; v.size(); noa++) {</span>
<span class="nc" id="L628">	  ((NeuralConnection)v.elementAt(noa)).removeAllInputs();</span>
<span class="nc" id="L629">	  ((NeuralConnection)v.elementAt(noa)).removeAllOutputs();</span>
<span class="nc" id="L630">	  removeNode((NeuralConnection)v.elementAt(noa));</span>
	}
      }
<span class="nc" id="L633">      repaint();</span>
<span class="nc" id="L634">    }</span>

    /**
     * This will paint the nodes ontot the panel.
     * @param g The graphics context.
     */
    public void paintComponent(Graphics g) {

<span class="nc" id="L642">      super.paintComponent(g);</span>
<span class="nc" id="L643">      int x = getWidth();</span>
<span class="nc" id="L644">      int y = getHeight();</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">      if (25 * m_numAttributes &gt; 25 * m_numClasses &amp;&amp; </span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">	  25 * m_numAttributes &gt; y) {</span>
<span class="nc" id="L647">	setSize(x, 25 * m_numAttributes);</span>
      }
<span class="nc bnc" id="L649" title="All 2 branches missed.">      else if (25 * m_numClasses &gt; y) {</span>
<span class="nc" id="L650">	setSize(x, 25 * m_numClasses);</span>
      }
      else {
<span class="nc" id="L653">	setSize(x, y);</span>
      }

<span class="nc" id="L656">      y = getHeight();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="nc" id="L658">	m_inputs[noa].drawInputLines(g, x, y);</span>
      }
<span class="nc bnc" id="L660" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="nc" id="L661">	m_outputs[noa].drawInputLines(g, x, y);</span>
<span class="nc" id="L662">	m_outputs[noa].drawOutputLines(g, x, y);</span>
      }
<span class="nc bnc" id="L664" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc" id="L665">	m_neuralNodes[noa].drawInputLines(g, x, y);</span>
      }
<span class="nc bnc" id="L667" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="nc" id="L668">	m_inputs[noa].drawNode(g, x, y);</span>
      }
<span class="nc bnc" id="L670" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="nc" id="L671">	m_outputs[noa].drawNode(g, x, y);</span>
      }
<span class="nc bnc" id="L673" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc" id="L674">	m_neuralNodes[noa].drawNode(g, x, y);</span>
      }

<span class="nc bnc" id="L677" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_selected.size(); noa++) {</span>
<span class="nc" id="L678">	((NeuralConnection)m_selected.elementAt(noa)).drawHighlight(g, x, y);</span>
      }
<span class="nc" id="L680">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L688">      return RevisionUtils.extract(&quot;$Revision: 9445 $&quot;);</span>
    }
  }

  /** 
   * This provides the basic controls for working with the neuralnetwork
   * @author Malcolm Ware (mfw4@cs.waikato.ac.nz)
   * @version $Revision: 9445 $
   */
  class ControlPanel 
    extends JPanel
    implements RevisionHandler {
    
    /** for serialization */
    static final long serialVersionUID = 7393543302294142271L;
    
    /** The start stop button. */
    public JButton m_startStop;
    
    /** The button to accept the network (even if it hasn't done all epochs. */
    public JButton m_acceptButton;
    
    /** A label to state the number of epochs processed so far. */
    public JPanel m_epochsLabel;
    
    /** A label to state the total number of epochs to be processed. */
    public JLabel m_totalEpochsLabel;
    
    /** A text field to allow the changing of the total number of epochs. */
    public JTextField m_changeEpochs;
    
    /** A label to state the learning rate. */
    public JLabel m_learningLabel;
    
    /** A label to state the momentum. */
    public JLabel m_momentumLabel;
    
    /** A text field to allow the changing of the learning rate. */
    public JTextField m_changeLearning;
    
    /** A text field to allow the changing of the momentum. */
    public JTextField m_changeMomentum;
    
    /** A label to state roughly the accuracy of the network.(because the
	accuracy is calculated per epoch, but the network is changing 
	throughout each epoch train).
    */
    public JPanel m_errorLabel;
    
    /** The constructor. */
<span class="nc" id="L738">    public ControlPanel() { </span>
<span class="nc" id="L739">      setBorder(BorderFactory.createTitledBorder(&quot;Controls&quot;));</span>
      
<span class="nc" id="L741">      m_totalEpochsLabel = new JLabel(&quot;Num Of Epochs  &quot;);</span>
<span class="nc" id="L742">      m_epochsLabel = new JPanel(){ </span>
	  /** for serialization */
	  private static final long serialVersionUID = 2562773937093221399L;

	  public void paintComponent(Graphics g) {
<span class="nc" id="L747">	    super.paintComponent(g);</span>
<span class="nc" id="L748">	    g.setColor(m_controlPanel.m_totalEpochsLabel.getForeground());</span>
<span class="nc" id="L749">	    g.drawString(&quot;Epoch  &quot; + m_epoch, 0, 10);</span>
<span class="nc" id="L750">	  }</span>
	};
<span class="nc" id="L752">      m_epochsLabel.setFont(m_totalEpochsLabel.getFont());</span>
      
<span class="nc" id="L754">      m_changeEpochs = new JTextField();</span>
<span class="nc" id="L755">      m_changeEpochs.setText(&quot;&quot; + m_numEpochs);</span>
<span class="nc" id="L756">      m_errorLabel = new JPanel(){</span>
	  /** for serialization */
	  private static final long serialVersionUID = 4390239056336679189L;

	  public void paintComponent(Graphics g) {
<span class="nc" id="L761">	    super.paintComponent(g);</span>
<span class="nc" id="L762">	    g.setColor(m_controlPanel.m_totalEpochsLabel.getForeground());</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">	    if (m_valSize == 0) {</span>
<span class="nc" id="L764">	      g.drawString(&quot;Error per Epoch = &quot; + </span>
<span class="nc" id="L765">			   Utils.doubleToString(m_error, 7), 0, 10);</span>
	    }
	    else {
<span class="nc" id="L768">	      g.drawString(&quot;Validation Error per Epoch = &quot;</span>
<span class="nc" id="L769">			   + Utils.doubleToString(m_error, 7), 0, 10);</span>
	    }
<span class="nc" id="L771">	  }</span>
	};
<span class="nc" id="L773">      m_errorLabel.setFont(m_epochsLabel.getFont());</span>
      
<span class="nc" id="L775">      m_learningLabel = new JLabel(&quot;Learning Rate = &quot;);</span>
<span class="nc" id="L776">      m_momentumLabel = new JLabel(&quot;Momentum = &quot;);</span>
<span class="nc" id="L777">      m_changeLearning = new JTextField();</span>
<span class="nc" id="L778">      m_changeMomentum = new JTextField();</span>
<span class="nc" id="L779">      m_changeLearning.setText(&quot;&quot; + m_learningRate);</span>
<span class="nc" id="L780">      m_changeMomentum.setText(&quot;&quot; + m_momentum);</span>
<span class="nc" id="L781">      setLayout(new BorderLayout(15, 10));</span>

<span class="nc" id="L783">      m_stopIt = true;</span>
<span class="nc" id="L784">      m_accepted = false;</span>
<span class="nc" id="L785">      m_startStop = new JButton(&quot;Start&quot;);</span>
<span class="nc" id="L786">      m_startStop.setActionCommand(&quot;Start&quot;);</span>
      
<span class="nc" id="L788">      m_acceptButton = new JButton(&quot;Accept&quot;);</span>
<span class="nc" id="L789">      m_acceptButton.setActionCommand(&quot;Accept&quot;);</span>
      
<span class="nc" id="L791">      JPanel buttons = new JPanel();</span>
<span class="nc" id="L792">      buttons.setLayout(new BoxLayout(buttons, BoxLayout.Y_AXIS));</span>
<span class="nc" id="L793">      buttons.add(m_startStop);</span>
<span class="nc" id="L794">      buttons.add(m_acceptButton);</span>
<span class="nc" id="L795">      add(buttons, BorderLayout.WEST);</span>
<span class="nc" id="L796">      JPanel data = new JPanel();</span>
<span class="nc" id="L797">      data.setLayout(new BoxLayout(data, BoxLayout.Y_AXIS));</span>
      
<span class="nc" id="L799">      Box ab = new Box(BoxLayout.X_AXIS);</span>
<span class="nc" id="L800">      ab.add(m_epochsLabel);</span>
<span class="nc" id="L801">      data.add(ab);</span>
      
<span class="nc" id="L803">      ab = new Box(BoxLayout.X_AXIS);</span>
<span class="nc" id="L804">      Component b = Box.createGlue();</span>
<span class="nc" id="L805">      ab.add(m_totalEpochsLabel);</span>
<span class="nc" id="L806">      ab.add(m_changeEpochs);</span>
<span class="nc" id="L807">      m_changeEpochs.setMaximumSize(new Dimension(200, 20));</span>
<span class="nc" id="L808">      ab.add(b);</span>
<span class="nc" id="L809">      data.add(ab);</span>
      
<span class="nc" id="L811">      ab = new Box(BoxLayout.X_AXIS);</span>
<span class="nc" id="L812">      ab.add(m_errorLabel);</span>
<span class="nc" id="L813">      data.add(ab);</span>
      
<span class="nc" id="L815">      add(data, BorderLayout.CENTER);</span>
      
<span class="nc" id="L817">      data = new JPanel();</span>
<span class="nc" id="L818">      data.setLayout(new BoxLayout(data, BoxLayout.Y_AXIS));</span>
<span class="nc" id="L819">      ab = new Box(BoxLayout.X_AXIS);</span>
<span class="nc" id="L820">      b = Box.createGlue();</span>
<span class="nc" id="L821">      ab.add(m_learningLabel);</span>
<span class="nc" id="L822">      ab.add(m_changeLearning);</span>
<span class="nc" id="L823">      m_changeLearning.setMaximumSize(new Dimension(200, 20));</span>
<span class="nc" id="L824">      ab.add(b);</span>
<span class="nc" id="L825">      data.add(ab);</span>
      
<span class="nc" id="L827">      ab = new Box(BoxLayout.X_AXIS);</span>
<span class="nc" id="L828">      b = Box.createGlue();</span>
<span class="nc" id="L829">      ab.add(m_momentumLabel);</span>
<span class="nc" id="L830">      ab.add(m_changeMomentum);</span>
<span class="nc" id="L831">      m_changeMomentum.setMaximumSize(new Dimension(200, 20));</span>
<span class="nc" id="L832">      ab.add(b);</span>
<span class="nc" id="L833">      data.add(ab);</span>
      
<span class="nc" id="L835">      add(data, BorderLayout.EAST);</span>
      
<span class="nc" id="L837">      m_startStop.addActionListener(new ActionListener() {</span>
	  public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L839" title="All 2 branches missed.">	    if (e.getActionCommand().equals(&quot;Start&quot;)) {</span>
<span class="nc" id="L840">	      m_stopIt = false;</span>
<span class="nc" id="L841">	      m_startStop.setText(&quot;Stop&quot;);</span>
<span class="nc" id="L842">	      m_startStop.setActionCommand(&quot;Stop&quot;);</span>
<span class="nc" id="L843">	      int n = Integer.valueOf(m_changeEpochs.getText()).intValue();</span>
	      
<span class="nc" id="L845">	      m_numEpochs = n;</span>
<span class="nc" id="L846">	      m_changeEpochs.setText(&quot;&quot; + m_numEpochs);</span>
	      
<span class="nc" id="L848">	      double m=Double.valueOf(m_changeLearning.getText()).</span>
<span class="nc" id="L849">		doubleValue();</span>
<span class="nc" id="L850">	      setLearningRate(m);</span>
<span class="nc" id="L851">	      m_changeLearning.setText(&quot;&quot; + m_learningRate);</span>
	      
<span class="nc" id="L853">	      m = Double.valueOf(m_changeMomentum.getText()).doubleValue();</span>
<span class="nc" id="L854">	      setMomentum(m);</span>
<span class="nc" id="L855">	      m_changeMomentum.setText(&quot;&quot; + m_momentum);</span>
	      
<span class="nc" id="L857">	      blocker(false);</span>
	    }
<span class="nc bnc" id="L859" title="All 2 branches missed.">	    else if (e.getActionCommand().equals(&quot;Stop&quot;)) {</span>
<span class="nc" id="L860">	      m_stopIt = true;</span>
<span class="nc" id="L861">	      m_startStop.setText(&quot;Start&quot;);</span>
<span class="nc" id="L862">	      m_startStop.setActionCommand(&quot;Start&quot;);</span>
	    }
<span class="nc" id="L864">	  }</span>
	});
      
<span class="nc" id="L867">      m_acceptButton.addActionListener(new ActionListener() {</span>
	  public void actionPerformed(ActionEvent e) {
<span class="nc" id="L869">	    m_accepted = true;</span>
<span class="nc" id="L870">	    blocker(false);</span>
<span class="nc" id="L871">	  }</span>
	});
      
<span class="nc" id="L874">      m_changeEpochs.addActionListener(new ActionListener() {</span>
	  public void actionPerformed(ActionEvent e) {
<span class="nc" id="L876">	    int n = Integer.valueOf(m_changeEpochs.getText()).intValue();</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">	    if (n &gt; 0) {</span>
<span class="nc" id="L878">	      m_numEpochs = n;</span>
<span class="nc" id="L879">	      blocker(false);</span>
	    }
<span class="nc" id="L881">	  }</span>
	});
<span class="nc" id="L883">    }</span>
    
    /**
     * Returns the revision string.
     * 
     * @return		the revision
     */
    public String getRevision() {
<span class="nc" id="L891">      return RevisionUtils.extract(&quot;$Revision: 9445 $&quot;);</span>
    }
  }
  
  /** a ZeroR model in case no model can be built from the data 
   * or the network predicts all zeros for the classes */
  private Classifier m_ZeroR;

  /** Whether to use the default ZeroR model */
<span class="fc" id="L900">  private boolean m_useDefaultModel = false;</span>
    
  /** The training instances. */
  private Instances m_instances;
  
  /** The current instance running through the network. */
  private Instance m_currentInstance;
  
  /** A flag to say that it's a numeric class. */
  private boolean m_numeric;

  /** The ranges for all the attributes. */
  private double[] m_attributeRanges;

  /** The base values for all the attributes. */
  private double[] m_attributeBases;

  /** The output units.(only feeds the errors, does no calcs) */
  private NeuralEnd[] m_outputs;

  /** The input units.(only feeds the inputs does no calcs) */
  private NeuralEnd[] m_inputs;

  /** All the nodes that actually comprise the logical neural net. */
  private NeuralConnection[] m_neuralNodes;

  /** The number of classes. */
<span class="fc" id="L927">  private int m_numClasses = 0;</span>
  
  /** The number of attributes. */
<span class="fc" id="L930">  private int m_numAttributes = 0; //note the number doesn't include the class.</span>
  
  /** The panel the nodes are displayed on. */
  private NodePanel m_nodePanel;
  
  /** The control panel. */
  private ControlPanel m_controlPanel;

  /** The next id number available for default naming. */
  private int m_nextId;
   
  /** A Vector list of the units currently selected. */
  private FastVector m_selected;

  /** A Vector list of the graphers. */
  private FastVector m_graphers;

  /** The number of epochs to train through. */
  private int m_numEpochs;

  /** a flag to state if the network should be running, or stopped. */
  private boolean m_stopIt;

  /** a flag to state that the network has in fact stopped. */
  private boolean m_stopped;

  /** a flag to state that the network should be accepted the way it is. */
  private boolean m_accepted;
  /** The window for the network. */
  private JFrame m_win;

  /** A flag to tell the build classifier to automatically build a neural net.
   */
  private boolean m_autoBuild;

  /** A flag to state that the gui for the network should be brought up.
      To allow interaction while training. */
  private boolean m_gui;

  /** An int to say how big the validation set should be. */
  private int m_valSize;

  /** The number to to use to quit on validation testing. */
  private int m_driftThreshold;

  /** The number used to seed the random number generator. */
  private int m_randomSeed;

  /** The actual random number generator. */
  private Random m_random;

  /** A flag to state that a nominal to binary filter should be used. */
  private boolean m_useNomToBin;
  
  /** The actual filter. */
  private NominalToBinary m_nominalToBinaryFilter;

  /** The string that defines the hidden layers */
  private String m_hiddenLayers;

  /** This flag states that the user wants the input values normalized. */
  private boolean m_normalizeAttributes;

  /** This flag states that the user wants the learning rate to decay. */
  private boolean m_decay;

  /** This is the learning rate for the network. */
  private double m_learningRate;

  /** This is the momentum for the network. */
  private double m_momentum;

  /** Shows the number of the epoch that the network just finished. */
  private int m_epoch;

  /** Shows the error of the epoch that the network just finished. */
  private double m_error;

  /** This flag states that the user wants the network to restart if it
   * is found to be generating infinity or NaN for the error value. This
   * would restart the network with the current options except that the
   * learning rate would be smaller than before, (perhaps half of its current
   * value). This option will not be available if the gui is chosen (if the
   * gui is open the user can fix the network themselves, it is an 
   * architectural minefield for the network to be reset with the gui open). */
  private boolean m_reset;

  /** This flag states that the user wants the class to be normalized while
   * processing in the network is done. (the final answer will be in the
   * original range regardless). This option will only be used when the class
   * is numeric. */
  private boolean m_normalizeClass;

  /**
   * this is a sigmoid unit. 
   */
  private SigmoidUnit m_sigmoidUnit;
  
  /**
   * This is a linear unit.
   */
  private LinearUnit m_linearUnit;
  
  /**
   * The constructor.
   */
<span class="fc" id="L1036">  public MultilayerPerceptron() {</span>
<span class="fc" id="L1037">    m_instances = null;</span>
<span class="fc" id="L1038">    m_currentInstance = null;</span>
<span class="fc" id="L1039">    m_controlPanel = null;</span>
<span class="fc" id="L1040">    m_nodePanel = null;</span>
<span class="fc" id="L1041">    m_epoch = 0;</span>
<span class="fc" id="L1042">    m_error = 0;</span>
    
    
<span class="fc" id="L1045">    m_outputs = new NeuralEnd[0];</span>
<span class="fc" id="L1046">    m_inputs = new NeuralEnd[0];</span>
<span class="fc" id="L1047">    m_numAttributes = 0;</span>
<span class="fc" id="L1048">    m_numClasses = 0;</span>
<span class="fc" id="L1049">    m_neuralNodes = new NeuralConnection[0];</span>
<span class="fc" id="L1050">    m_selected = new FastVector(4);</span>
<span class="fc" id="L1051">    m_graphers = new FastVector(2);</span>
<span class="fc" id="L1052">    m_nextId = 0;</span>
<span class="fc" id="L1053">    m_stopIt = true;</span>
<span class="fc" id="L1054">    m_stopped = true;</span>
<span class="fc" id="L1055">    m_accepted = false;</span>
<span class="fc" id="L1056">    m_numeric = false;</span>
<span class="fc" id="L1057">    m_random = null;</span>
<span class="fc" id="L1058">    m_nominalToBinaryFilter = new NominalToBinary();</span>
<span class="fc" id="L1059">    m_sigmoidUnit = new SigmoidUnit();</span>
<span class="fc" id="L1060">    m_linearUnit = new LinearUnit();</span>
    //setting all the options to their defaults. To completely change these
    //defaults they will also need to be changed down the bottom in the 
    //setoptions function (the text info in the accompanying functions should 
    //also be changed to reflect the new defaults
<span class="fc" id="L1065">    m_normalizeClass = true;</span>
<span class="fc" id="L1066">    m_normalizeAttributes = true;</span>
<span class="fc" id="L1067">    m_autoBuild = true;</span>
<span class="fc" id="L1068">    m_gui = false;</span>
<span class="fc" id="L1069">    m_useNomToBin = true;</span>
<span class="fc" id="L1070">    m_driftThreshold = 20;</span>
<span class="fc" id="L1071">    m_numEpochs = 500;</span>
<span class="fc" id="L1072">    m_valSize = 0;</span>
<span class="fc" id="L1073">    m_randomSeed = 0;</span>
<span class="fc" id="L1074">    m_hiddenLayers = &quot;a&quot;;</span>
<span class="fc" id="L1075">    m_learningRate = .3;</span>
<span class="fc" id="L1076">    m_momentum = .2;</span>
<span class="fc" id="L1077">    m_reset = true;</span>
<span class="fc" id="L1078">    m_decay = false;</span>
<span class="fc" id="L1079">  }</span>

  /**
   * @param d True if the learning rate should decay.
   */
  public void setDecay(boolean d) {
<span class="fc" id="L1085">    m_decay = d;</span>
<span class="fc" id="L1086">  }</span>
  
  /**
   * @return the flag for having the learning rate decay.
   */
  public boolean getDecay() {
<span class="fc" id="L1092">    return m_decay;</span>
  }

  /**
   * This sets the network up to be able to reset itself with the current 
   * settings and the learning rate at half of what it is currently. This
   * will only happen if the network creates NaN or infinite errors. Also this
   * will continue to happen until the network is trained properly. The 
   * learning rate will also get set back to it's original value at the end of
   * this. This can only be set to true if the GUI is not brought up.
   * @param r True if the network should restart with it's current options
   * and set the learning rate to half what it currently is.
   */
  public void setReset(boolean r) {
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">    if (m_gui) {</span>
<span class="nc" id="L1107">      r = false;</span>
    }
<span class="fc" id="L1109">    m_reset = r;</span>
      
<span class="fc" id="L1111">  }</span>

  /**
   * @return The flag for reseting the network.
   */
  public boolean getReset() {
<span class="fc" id="L1117">    return m_reset;</span>
  }
  
  /**
   * @param c True if the class should be normalized (the class will only ever
   * be normalized if it is numeric). (Normalization puts the range between
   * -1 - 1).
   */
  public void setNormalizeNumericClass(boolean c) {
<span class="fc" id="L1126">    m_normalizeClass = c;</span>
<span class="fc" id="L1127">  }</span>
  
  /**
   * @return The flag for normalizing a numeric class.
   */
  public boolean getNormalizeNumericClass() {
<span class="fc" id="L1133">    return m_normalizeClass;</span>
  }

  /**
   * @param a True if the attributes should be normalized (even nominal
   * attributes will get normalized here) (range goes between -1 - 1).
   */
  public void setNormalizeAttributes(boolean a) {
<span class="fc" id="L1141">    m_normalizeAttributes = a;</span>
<span class="fc" id="L1142">  }</span>

  /**
   * @return The flag for normalizing attributes.
   */
  public boolean getNormalizeAttributes() {
<span class="fc" id="L1148">    return m_normalizeAttributes;</span>
  }

  /**
   * @param f True if a nominalToBinary filter should be used on the
   * data.
   */
  public void setNominalToBinaryFilter(boolean f) {
<span class="fc" id="L1156">    m_useNomToBin = f;</span>
<span class="fc" id="L1157">  }</span>

  /**
   * @return The flag for nominal to binary filter use.
   */
  public boolean getNominalToBinaryFilter() {
<span class="fc" id="L1163">    return m_useNomToBin;</span>
  }

  /**
   * This seeds the random number generator, that is used when a random
   * number is needed for the network.
   * @param l The seed.
   */
  public void setSeed(int l) {
<span class="pc bpc" id="L1172" title="1 of 2 branches missed.">    if (l &gt;= 0) {</span>
<span class="fc" id="L1173">      m_randomSeed = l;</span>
    }
<span class="fc" id="L1175">  }</span>
  
  /**
   * @return The seed for the random number generator.
   */
  public int getSeed() {
<span class="fc" id="L1181">    return m_randomSeed;</span>
  }

  /**
   * This sets the threshold to use for when validation testing is being done.
   * It works by ending testing once the error on the validation set has 
   * consecutively increased a certain number of times.
   * @param t The threshold to use for this.
   */
  public void setValidationThreshold(int t) {
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">    if (t &gt; 0) {</span>
<span class="fc" id="L1192">      m_driftThreshold = t;</span>
    }
<span class="fc" id="L1194">  }</span>

  /**
   * @return The threshold used for validation testing.
   */
  public int getValidationThreshold() {
<span class="fc" id="L1200">    return m_driftThreshold;</span>
  }
  
  /**
   * The learning rate can be set using this command.
   * NOTE That this is a static variable so it affect all networks that are
   * running.
   * Must be greater than 0 and no more than 1.
   * @param l The New learning rate. 
   */
  public void setLearningRate(double l) {
<span class="pc bpc" id="L1211" title="2 of 4 branches missed.">    if (l &gt; 0 &amp;&amp; l &lt;= 1) {</span>
<span class="fc" id="L1212">      m_learningRate = l;</span>
    
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">      if (m_controlPanel != null) {</span>
<span class="nc" id="L1215">	m_controlPanel.m_changeLearning.setText(&quot;&quot; + l);</span>
      }
    }
<span class="fc" id="L1218">  }</span>

  /**
   * @return The learning rate for the nodes.
   */
  public double getLearningRate() {
<span class="fc" id="L1224">    return m_learningRate;</span>
  }

  /**
   * The momentum can be set using this command.
   * THE same conditions apply to this as to the learning rate.
   * @param m The new Momentum.
   */
  public void setMomentum(double m) {
<span class="pc bpc" id="L1233" title="2 of 4 branches missed.">    if (m &gt;= 0 &amp;&amp; m &lt;= 1) {</span>
<span class="fc" id="L1234">      m_momentum = m;</span>
  
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">      if (m_controlPanel != null) {</span>
<span class="nc" id="L1237">	m_controlPanel.m_changeMomentum.setText(&quot;&quot; + m);</span>
      }
    }
<span class="fc" id="L1240">  }</span>
  
  /**
   * @return The momentum for the nodes.
   */
  public double getMomentum() {
<span class="fc" id="L1246">    return m_momentum;</span>
  }

  /**
   * This will set whether the network is automatically built
   * or if it is left up to the user. (there is nothing to stop a user
   * from altering an autobuilt network however). 
   * @param a True if the network should be auto built.
   */
  public void setAutoBuild(boolean a) {
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">    if (!m_gui) {</span>
<span class="fc" id="L1257">      a = true;</span>
    }
<span class="fc" id="L1259">    m_autoBuild = a;</span>
<span class="fc" id="L1260">  }</span>

  /**
   * @return The auto build state.
   */
  public boolean getAutoBuild() {
<span class="fc" id="L1266">    return m_autoBuild;</span>
  }


  /**
   * This will set what the hidden layers are made up of when auto build is
   * enabled. Note to have no hidden units, just put a single 0, Any more
   * 0's will indicate that the string is badly formed and make it unaccepted.
   * Negative numbers, and floats will do the same. There are also some
   * wildcards. These are 'a' = (number of attributes + number of classes) / 2,
   * 'i' = number of attributes, 'o' = number of classes, and 't' = number of
   * attributes + number of classes.
   * @param h A string with a comma seperated list of numbers. Each number is 
   * the number of nodes to be on a hidden layer.
   */
  public void setHiddenLayers(String h) {
<span class="fc" id="L1282">    String tmp = &quot;&quot;;</span>
<span class="fc" id="L1283">    StringTokenizer tok = new StringTokenizer(h, &quot;,&quot;);</span>
<span class="pc bpc" id="L1284" title="1 of 2 branches missed.">    if (tok.countTokens() == 0) {</span>
<span class="nc" id="L1285">      return;</span>
    }
    double dval;
    int val;
    String c;
<span class="fc" id="L1290">    boolean first = true;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">    while (tok.hasMoreTokens()) {</span>
<span class="fc" id="L1292">      c = tok.nextToken().trim();</span>

<span class="pc bpc" id="L1294" title="5 of 6 branches missed.">      if (c.equals(&quot;a&quot;) || c.equals(&quot;i&quot;) || c.equals(&quot;o&quot;) || </span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">	       c.equals(&quot;t&quot;)) {</span>
<span class="fc" id="L1296">	tmp += c;</span>
      }
      else {
<span class="nc" id="L1299">	dval = Double.valueOf(c).doubleValue();</span>
<span class="nc" id="L1300">	val = (int)dval;</span>
	
<span class="nc bnc" id="L1302" title="All 8 branches missed.">	if ((val == dval &amp;&amp; (val != 0 || (tok.countTokens() == 0 &amp;&amp; first)) &amp;&amp; </span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">	     val &gt;= 0)) {</span>
<span class="nc" id="L1304">	  tmp += val;</span>
	}
	else {
<span class="nc" id="L1307">	  return;</span>
	}
      }
      
<span class="fc" id="L1311">      first = false;</span>
<span class="pc bpc" id="L1312" title="1 of 2 branches missed.">      if (tok.hasMoreTokens()) {</span>
<span class="nc" id="L1313">	tmp += &quot;, &quot;;</span>
      }
    }
<span class="fc" id="L1316">    m_hiddenLayers = tmp;</span>
<span class="fc" id="L1317">  }</span>

  /**
   * @return A string representing the hidden layers, each number is the number
   * of nodes on a hidden layer.
   */
  public String getHiddenLayers() {
<span class="fc" id="L1324">    return m_hiddenLayers;</span>
  }

  /**
   * This will set whether A GUI is brought up to allow interaction by the user
   * with the neural network during training.
   * @param a True if gui should be created.
   */
  public void setGUI(boolean a) {
<span class="fc" id="L1333">    m_gui = a;</span>
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">    if (!a) {</span>
<span class="fc" id="L1335">      setAutoBuild(true);</span>
      
    }
    else {
<span class="nc" id="L1339">      setReset(false);</span>
    }
<span class="fc" id="L1341">  }</span>

  /**
   * @return The true if should show gui.
   */
  public boolean getGUI() {
<span class="fc" id="L1347">    return m_gui;</span>
  }

  /**
   * This will set the size of the validation set.
   * @param a The size of the validation set, as a percentage of the whole.
   */
  public void setValidationSetSize(int a) {
<span class="pc bpc" id="L1355" title="2 of 4 branches missed.">    if (a &lt; 0 || a &gt; 99) {</span>
<span class="nc" id="L1356">      return;</span>
    }
<span class="fc" id="L1358">    m_valSize = a;</span>
<span class="fc" id="L1359">  }</span>

  /**
   * @return The percentage size of the validation set.
   */
  public int getValidationSetSize() {
<span class="fc" id="L1365">    return m_valSize;</span>
  }

  
  
  
  /**
   * Set the number of training epochs to perform.
   * Must be greater than 0.
   * @param n The number of epochs to train through.
   */
  public void setTrainingTime(int n) {
<span class="pc bpc" id="L1377" title="1 of 2 branches missed.">    if (n &gt; 0) {</span>
<span class="fc" id="L1378">      m_numEpochs = n;</span>
    }
<span class="fc" id="L1380">  }</span>

  /**
   * @return The number of epochs to train through.
   */
  public int getTrainingTime() {
<span class="fc" id="L1386">    return m_numEpochs;</span>
  }
  
  /**
   * Call this function to place a node into the network list.
   * @param n The node to place in the list.
   */
  private void addNode(NeuralConnection n) {
    
<span class="fc" id="L1395">    NeuralConnection[] temp1 = new NeuralConnection[m_neuralNodes.length + 1];</span>
<span class="fc bfc" id="L1396" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="fc" id="L1397">      temp1[noa] = m_neuralNodes[noa];</span>
    }

<span class="fc" id="L1400">    temp1[temp1.length-1] = n;</span>
<span class="fc" id="L1401">    m_neuralNodes = temp1;</span>
<span class="fc" id="L1402">  }</span>

  /** 
   * Call this function to remove the passed node from the list.
   * This will only remove the node if it is in the neuralnodes list.
   * @param n The neuralConnection to remove.
   * @return True if removed false if not (because it wasn't there).
   */
  private boolean removeNode(NeuralConnection n) {
<span class="nc" id="L1411">    NeuralConnection[] temp1 = new NeuralConnection[m_neuralNodes.length - 1];</span>
<span class="nc" id="L1412">    int skip = 0;</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">    for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">      if (n == m_neuralNodes[noa]) {</span>
<span class="nc" id="L1415">	skip++;</span>
      }
<span class="nc bnc" id="L1417" title="All 2 branches missed.">      else if (!((noa - skip) &gt;= temp1.length)) {</span>
<span class="nc" id="L1418">	temp1[noa - skip] = m_neuralNodes[noa];</span>
      }
      else {
<span class="nc" id="L1421">	return false;</span>
      }
    }
<span class="nc" id="L1424">    m_neuralNodes = temp1;</span>
<span class="nc" id="L1425">    return true;</span>
  }

  /**
   * This function sets what the m_numeric flag to represent the passed class
   * it also performs the normalization of the attributes if applicable
   * and sets up the info to normalize the class. (note that regardless of
   * the options it will fill an array with the range and base, set to 
   * normalize all attributes and the class to be between -1 and 1)
   * @param inst the instances.
   * @return The modified instances. This needs to be done. If the attributes
   * are normalized then deep copies will be made of all the instances which
   * will need to be passed back out.
   */
  private Instances setClassType(Instances inst) throws Exception {
<span class="pc bpc" id="L1440" title="1 of 2 branches missed.">    if (inst != null) {</span>
      // x bounds
<span class="fc" id="L1442">      double min=Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1443">      double max=Double.NEGATIVE_INFINITY;</span>
      double value;
<span class="fc" id="L1445">      m_attributeRanges = new double[inst.numAttributes()];</span>
<span class="fc" id="L1446">      m_attributeBases = new double[inst.numAttributes()];</span>
<span class="fc bfc" id="L1447" title="All 2 branches covered.">      for (int noa = 0; noa &lt; inst.numAttributes(); noa++) {</span>
<span class="fc" id="L1448">	min = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1449">	max = Double.NEGATIVE_INFINITY;</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">	for (int i=0; i &lt; inst.numInstances();i++) {</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">	  if (!inst.instance(i).isMissing(noa)) {</span>
<span class="fc" id="L1452">	    value = inst.instance(i).value(noa);</span>
<span class="fc bfc" id="L1453" title="All 2 branches covered.">	    if (value &lt; min) {</span>
<span class="fc" id="L1454">	      min = value;</span>
	    }
<span class="fc bfc" id="L1456" title="All 2 branches covered.">	    if (value &gt; max) {</span>
<span class="fc" id="L1457">	      max = value;</span>
	    }
	  }
	}
	
<span class="fc" id="L1462">	m_attributeRanges[noa] = (max - min) / 2;</span>
<span class="fc" id="L1463">	m_attributeBases[noa] = (max + min) / 2;</span>
<span class="pc bpc" id="L1464" title="1 of 4 branches missed.">	if (noa != inst.classIndex() &amp;&amp; m_normalizeAttributes) {</span>
<span class="fc bfc" id="L1465" title="All 2 branches covered.">	  for (int i = 0; i &lt; inst.numInstances(); i++) {</span>
<span class="pc bpc" id="L1466" title="1 of 2 branches missed.">	    if (m_attributeRanges[noa] != 0) {</span>
<span class="fc" id="L1467">	      inst.instance(i).setValue(noa, (inst.instance(i).value(noa)  </span>
<span class="fc" id="L1468">					      - m_attributeBases[noa]) /</span>
<span class="fc" id="L1469">					m_attributeRanges[noa]);</span>
	    }
	    else {
<span class="nc" id="L1472">	      inst.instance(i).setValue(noa, inst.instance(i).value(noa) - </span>
<span class="nc" id="L1473">					m_attributeBases[noa]);</span>
	    }
	  }
	}
      }
<span class="fc bfc" id="L1478" title="All 2 branches covered.">      if (inst.classAttribute().isNumeric()) {</span>
<span class="fc" id="L1479">	m_numeric = true;</span>
      }
      else {
<span class="fc" id="L1482">	m_numeric = false;</span>
      }
    }
<span class="fc" id="L1485">    return inst;</span>
  }

  /**
   * A function used to stop the code that called buildclassifier
   * from continuing on before the user has finished the decision tree.
   * @param tf True to stop the thread, False to release the thread that is
   * waiting there (if one).
   */
  public synchronized void blocker(boolean tf) {
<span class="nc bnc" id="L1495" title="All 2 branches missed.">    if (tf) {</span>
      try {
<span class="nc" id="L1497">	wait();</span>
<span class="nc" id="L1498">      } catch(InterruptedException e) {</span>
      }
    }
    else {
<span class="nc" id="L1502">      notifyAll();</span>
    }
<span class="nc" id="L1504">  }</span>

  /**
   * Call this function to update the control panel for the gui.
   */
  private void updateDisplay() {
    
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">    if (m_gui) {</span>
<span class="nc" id="L1512">      m_controlPanel.m_errorLabel.repaint();</span>
<span class="nc" id="L1513">      m_controlPanel.m_epochsLabel.repaint();</span>
    }
<span class="fc" id="L1515">  }</span>
  

  /**
   * this will reset all the nodes in the network.
   */
  private void resetNetwork() {
<span class="fc bfc" id="L1522" title="All 2 branches covered.">    for (int noc = 0; noc &lt; m_numClasses; noc++) {</span>
<span class="fc" id="L1523">      m_outputs[noc].reset();</span>
    }
<span class="fc" id="L1525">  }</span>
  
  /**
   * This will cause the output values of all the nodes to be calculated.
   * Note that the m_currentInstance is used to calculate these values.
   */
  private void calculateOutputs() {
<span class="fc bfc" id="L1532" title="All 2 branches covered.">    for (int noc = 0; noc &lt; m_numClasses; noc++) {	</span>
      //get the values. 
<span class="fc" id="L1534">      m_outputs[noc].outputValue(true);</span>
    }
<span class="fc" id="L1536">  }</span>

  /**
   * This will cause the error values to be calculated for all nodes.
   * Note that the m_currentInstance is used to calculate these values.
   * Also the output values should have been calculated first.
   * @return The squared error.
   */
  private double calculateErrors() throws Exception {
<span class="fc" id="L1545">    double ret = 0, temp = 0; </span>
<span class="fc bfc" id="L1546" title="All 2 branches covered.">    for (int noc = 0; noc &lt; m_numAttributes; noc++) {</span>
      //get the errors.
<span class="fc" id="L1548">      m_inputs[noc].errorValue(true);</span>
      
    }
<span class="fc bfc" id="L1551" title="All 2 branches covered.">    for (int noc = 0; noc &lt; m_numClasses; noc++) {</span>
<span class="fc" id="L1552">      temp = m_outputs[noc].errorValue(false);</span>
<span class="fc" id="L1553">      ret += temp * temp;</span>
    }    
<span class="fc" id="L1555">    return ret;</span>
    
  }

  /**
   * This will cause the weight values to be updated based on the learning
   * rate, momentum and the errors that have been calculated for each node.
   * @param l The learning rate to update with.
   * @param m The momentum to update with.
   */
  private void updateNetworkWeights(double l, double m) {
<span class="fc bfc" id="L1566" title="All 2 branches covered.">    for (int noc = 0; noc &lt; m_numClasses; noc++) {</span>
      //update weights
<span class="fc" id="L1568">      m_outputs[noc].updateWeights(l, m);</span>
    }

<span class="fc" id="L1571">  }</span>
  
  /**
   * This creates the required input units.
   */
  private void setupInputs() throws Exception {
<span class="fc" id="L1577">    m_inputs = new NeuralEnd[m_numAttributes];</span>
<span class="fc" id="L1578">    int now = 0;</span>
<span class="fc bfc" id="L1579" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_numAttributes+1; noa++) {</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">      if (m_instances.classIndex() != noa) {</span>
<span class="fc" id="L1581">	m_inputs[noa - now] = new NeuralEnd(m_instances.attribute(noa).name());</span>
	
<span class="fc" id="L1583">	m_inputs[noa - now].setX(.1);</span>
<span class="fc" id="L1584">	m_inputs[noa - now].setY((noa - now + 1.0) / (m_numAttributes + 1));</span>
<span class="fc" id="L1585">	m_inputs[noa - now].setLink(true, noa);</span>
      }    
      else {
<span class="fc" id="L1588">	now = 1;</span>
      }
    }

<span class="fc" id="L1592">  }</span>

  /**
   * This creates the required output units.
   */
  private void setupOutputs() throws Exception {
  
<span class="fc" id="L1599">    m_outputs = new NeuralEnd[m_numClasses];</span>
<span class="fc bfc" id="L1600" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="fc bfc" id="L1601" title="All 2 branches covered.">      if (m_numeric) {</span>
<span class="fc" id="L1602">	m_outputs[noa] = new NeuralEnd(m_instances.classAttribute().name());</span>
      }
      else {
<span class="fc" id="L1605">	m_outputs[noa]= new NeuralEnd(m_instances.classAttribute().value(noa));</span>
      }
      
<span class="fc" id="L1608">      m_outputs[noa].setX(.9);</span>
<span class="fc" id="L1609">      m_outputs[noa].setY((noa + 1.0) / (m_numClasses + 1));</span>
<span class="fc" id="L1610">      m_outputs[noa].setLink(false, noa);</span>
<span class="fc" id="L1611">      NeuralNode temp = new NeuralNode(String.valueOf(m_nextId), m_random,</span>
<span class="fc" id="L1612">				       m_sigmoidUnit);</span>
<span class="fc" id="L1613">      m_nextId++;</span>
<span class="fc" id="L1614">      temp.setX(.75);</span>
<span class="fc" id="L1615">      temp.setY((noa + 1.0) / (m_numClasses + 1));</span>
<span class="fc" id="L1616">      addNode(temp);</span>
<span class="fc" id="L1617">      NeuralConnection.connect(temp, m_outputs[noa]);</span>
    }
 
<span class="fc" id="L1620">  }</span>
  
  /**
   * Call this function to automatically generate the hidden units
   */
  private void setupHiddenLayer()
  {
<span class="fc" id="L1627">    StringTokenizer tok = new StringTokenizer(m_hiddenLayers, &quot;,&quot;);</span>
<span class="fc" id="L1628">    int val = 0;  //num of nodes in a layer</span>
<span class="fc" id="L1629">    int prev = 0; //used to remember the previous layer</span>
<span class="fc" id="L1630">    int num = tok.countTokens(); //number of layers</span>
    String c;
<span class="fc bfc" id="L1632" title="All 2 branches covered.">    for (int noa = 0; noa &lt; num; noa++) {</span>
      //note that I am using the Double to get the value rather than the
      //Integer class, because for some reason the Double implementation can
      //handle leading white space and the integer version can't!?!
<span class="fc" id="L1636">      c = tok.nextToken().trim();</span>
<span class="pc bpc" id="L1637" title="1 of 2 branches missed.">      if (c.equals(&quot;a&quot;)) {</span>
<span class="fc" id="L1638">	val = (m_numAttributes + m_numClasses) / 2;</span>
      }
<span class="nc bnc" id="L1640" title="All 2 branches missed.">      else if (c.equals(&quot;i&quot;)) {</span>
<span class="nc" id="L1641">	val = m_numAttributes;</span>
      }
<span class="nc bnc" id="L1643" title="All 2 branches missed.">      else if (c.equals(&quot;o&quot;)) {</span>
<span class="nc" id="L1644">	val = m_numClasses;</span>
      }
<span class="nc bnc" id="L1646" title="All 2 branches missed.">      else if (c.equals(&quot;t&quot;)) {</span>
<span class="nc" id="L1647">	val = m_numAttributes + m_numClasses;</span>
      }
      else {
<span class="nc" id="L1650">	val = Double.valueOf(c).intValue();</span>
      }
<span class="fc bfc" id="L1652" title="All 2 branches covered.">      for (int nob = 0; nob &lt; val; nob++) {</span>
<span class="fc" id="L1653">	NeuralNode temp = new NeuralNode(String.valueOf(m_nextId), m_random,</span>
<span class="fc" id="L1654">					 m_sigmoidUnit);</span>
<span class="fc" id="L1655">	m_nextId++;</span>
<span class="fc" id="L1656">	temp.setX(.5 / (num) * noa + .25);</span>
<span class="fc" id="L1657">	temp.setY((nob + 1.0) / (val + 1));</span>
<span class="fc" id="L1658">	addNode(temp);</span>
<span class="pc bpc" id="L1659" title="1 of 2 branches missed.">	if (noa &gt; 0) {</span>
	  //then do connections
<span class="nc" id="L1661">	  for (int noc = m_neuralNodes.length - nob - 1 - prev;</span>
<span class="nc bnc" id="L1662" title="All 2 branches missed.">	       noc &lt; m_neuralNodes.length - nob - 1; noc++) {</span>
<span class="nc" id="L1663">	    NeuralConnection.connect(m_neuralNodes[noc], temp);</span>
	  }
	}
      }      
<span class="fc" id="L1667">      prev = val;</span>
    }
<span class="fc" id="L1669">    tok = new StringTokenizer(m_hiddenLayers, &quot;,&quot;);</span>
<span class="fc" id="L1670">    c = tok.nextToken();</span>
<span class="pc bpc" id="L1671" title="1 of 2 branches missed.">    if (c.equals(&quot;a&quot;)) {</span>
<span class="fc" id="L1672">      val = (m_numAttributes + m_numClasses) / 2;</span>
    }
<span class="nc bnc" id="L1674" title="All 2 branches missed.">    else if (c.equals(&quot;i&quot;)) {</span>
<span class="nc" id="L1675">      val = m_numAttributes;</span>
    }
<span class="nc bnc" id="L1677" title="All 2 branches missed.">    else if (c.equals(&quot;o&quot;)) {</span>
<span class="nc" id="L1678">      val = m_numClasses;</span>
    }
<span class="nc bnc" id="L1680" title="All 2 branches missed.">    else if (c.equals(&quot;t&quot;)) {</span>
<span class="nc" id="L1681">      val = m_numAttributes + m_numClasses;</span>
    }
    else {
<span class="nc" id="L1684">      val = Double.valueOf(c).intValue();</span>
    }
    
<span class="pc bpc" id="L1687" title="1 of 2 branches missed.">    if (val == 0) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">	for (int nob = 0; nob &lt; m_numClasses; nob++) {</span>
<span class="nc" id="L1690">	  NeuralConnection.connect(m_inputs[noa], m_neuralNodes[nob]);</span>
	}
      }
    }
    else {
<span class="fc bfc" id="L1695" title="All 2 branches covered.">      for (int noa = 0; noa &lt; m_numAttributes; noa++) {</span>
<span class="fc bfc" id="L1696" title="All 2 branches covered.">	for (int nob = m_numClasses; nob &lt; m_numClasses + val; nob++) {</span>
<span class="fc" id="L1697">	  NeuralConnection.connect(m_inputs[noa], m_neuralNodes[nob]);</span>
	}
      }
<span class="fc bfc" id="L1700" title="All 2 branches covered.">      for (int noa = m_neuralNodes.length - prev; noa &lt; m_neuralNodes.length;</span>
<span class="fc" id="L1701">	   noa++) {</span>
<span class="fc bfc" id="L1702" title="All 2 branches covered.">	for (int nob = 0; nob &lt; m_numClasses; nob++) {</span>
<span class="fc" id="L1703">	  NeuralConnection.connect(m_neuralNodes[noa], m_neuralNodes[nob]);</span>
	}
      }
    }
    
<span class="fc" id="L1708">  }</span>
  
  /**
   * This will go through all the nodes and check if they are connected
   * to a pure output unit. If so they will be set to be linear units.
   * If not they will be set to be sigmoid units.
   */
  private void setEndsToLinear() {
<span class="fc bfc" id="L1716" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">      if ((m_neuralNodes[noa].getType() &amp; NeuralConnection.OUTPUT) ==</span>
<span class="fc" id="L1718">	  NeuralConnection.OUTPUT) {</span>
<span class="fc" id="L1719">	((NeuralNode)m_neuralNodes[noa]).setMethod(m_linearUnit);</span>
      }
      else {
<span class="fc" id="L1722">	((NeuralNode)m_neuralNodes[noa]).setMethod(m_sigmoidUnit);</span>
      }
    }
<span class="fc" id="L1725">  }</span>

  /**
   * Returns default capabilities of the classifier.
   *
   * @return      the capabilities of this classifier
   */
  public Capabilities getCapabilities() {
<span class="fc" id="L1733">    Capabilities result = super.getCapabilities();</span>
<span class="fc" id="L1734">    result.disableAll();</span>

    // attributes
<span class="fc" id="L1737">    result.enable(Capability.NOMINAL_ATTRIBUTES);</span>
<span class="fc" id="L1738">    result.enable(Capability.NUMERIC_ATTRIBUTES);</span>
<span class="fc" id="L1739">    result.enable(Capability.DATE_ATTRIBUTES);</span>
<span class="fc" id="L1740">    result.enable(Capability.MISSING_VALUES);</span>

    // class
<span class="fc" id="L1743">    result.enable(Capability.NOMINAL_CLASS);</span>
<span class="fc" id="L1744">    result.enable(Capability.NUMERIC_CLASS);</span>
<span class="fc" id="L1745">    result.enable(Capability.DATE_CLASS);</span>
<span class="fc" id="L1746">    result.enable(Capability.MISSING_CLASS_VALUES);</span>
    
<span class="fc" id="L1748">    return result;</span>
  }
  
  /**
   * Call this function to build and train a neural network for the training
   * data provided.
   * @param i The training data.
   * @throws Exception if can't build classification properly.
   */
  public void buildClassifier(Instances i) throws Exception {

    // can classifier handle the data?
<span class="fc" id="L1760">    getCapabilities().testWithFail(i);</span>

    // remove instances with missing class
<span class="fc" id="L1763">    i = new Instances(i);</span>
<span class="fc" id="L1764">    i.deleteWithMissingClass();</span>

<span class="fc" id="L1766">    m_ZeroR = new weka.classifiers.rules.ZeroR();</span>
<span class="fc" id="L1767">    m_ZeroR.buildClassifier(i);</span>
    // only class? -&gt; use ZeroR model
<span class="fc bfc" id="L1769" title="All 2 branches covered.">    if (i.numAttributes() == 1) {</span>
<span class="fc" id="L1770">      System.err.println(</span>
<span class="fc" id="L1771">	  &quot;Cannot build model (only class attribute present in data!), &quot;</span>
	  + &quot;using ZeroR model instead!&quot;);
<span class="fc" id="L1773">      m_useDefaultModel = true;</span>
<span class="fc" id="L1774">      return;</span>
    }
    else {
<span class="fc" id="L1777">      m_useDefaultModel = false;</span>
    }
    
<span class="fc" id="L1780">    m_epoch = 0;</span>
<span class="fc" id="L1781">    m_error = 0;</span>
<span class="fc" id="L1782">    m_instances = null;</span>
<span class="fc" id="L1783">    m_currentInstance = null;</span>
<span class="fc" id="L1784">    m_controlPanel = null;</span>
<span class="fc" id="L1785">    m_nodePanel = null;</span>
    
    
<span class="fc" id="L1788">    m_outputs = new NeuralEnd[0];</span>
<span class="fc" id="L1789">    m_inputs = new NeuralEnd[0];</span>
<span class="fc" id="L1790">    m_numAttributes = 0;</span>
<span class="fc" id="L1791">    m_numClasses = 0;</span>
<span class="fc" id="L1792">    m_neuralNodes = new NeuralConnection[0];</span>
    
<span class="fc" id="L1794">    m_selected = new FastVector(4);</span>
<span class="fc" id="L1795">    m_graphers = new FastVector(2);</span>
<span class="fc" id="L1796">    m_nextId = 0;</span>
<span class="fc" id="L1797">    m_stopIt = true;</span>
<span class="fc" id="L1798">    m_stopped = true;</span>
<span class="fc" id="L1799">    m_accepted = false;    </span>
<span class="fc" id="L1800">    m_instances = new Instances(i);</span>
<span class="fc" id="L1801">    m_random = new Random(m_randomSeed);</span>
<span class="fc" id="L1802">    m_instances.randomize(m_random);</span>

<span class="pc bpc" id="L1804" title="1 of 2 branches missed.">    if (m_useNomToBin) {</span>
<span class="fc" id="L1805">      m_nominalToBinaryFilter = new NominalToBinary();</span>
<span class="fc" id="L1806">      m_nominalToBinaryFilter.setInputFormat(m_instances);</span>
<span class="fc" id="L1807">      m_instances = Filter.useFilter(m_instances,</span>
<span class="fc" id="L1808">				     m_nominalToBinaryFilter);</span>
    }
<span class="fc" id="L1810">    m_numAttributes = m_instances.numAttributes() - 1;</span>
<span class="fc" id="L1811">    m_numClasses = m_instances.numClasses();</span>
 
    
<span class="fc" id="L1814">    setClassType(m_instances);</span>
    

   
    //this sets up the validation set.
<span class="fc" id="L1819">    Instances valSet = null;</span>
    //numinval is needed later
<span class="fc" id="L1821">    int numInVal = (int)(m_valSize / 100.0 * m_instances.numInstances());</span>
<span class="pc bpc" id="L1822" title="1 of 2 branches missed.">    if (m_valSize &gt; 0) {</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">      if (numInVal == 0) {</span>
<span class="nc" id="L1824">	numInVal = 1;</span>
      }
<span class="nc" id="L1826">      valSet = new Instances(m_instances, 0, numInVal);</span>
    }
    ///////////

<span class="fc" id="L1830">    setupInputs();</span>
      
<span class="fc" id="L1832">    setupOutputs();    </span>
<span class="pc bpc" id="L1833" title="1 of 2 branches missed.">    if (m_autoBuild) {</span>
<span class="fc" id="L1834">      setupHiddenLayer();</span>
    }
    
    /////////////////////////////
    //this sets up the gui for usage
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">    if (m_gui) {</span>
<span class="nc" id="L1840">      m_win = new JFrame();</span>
      
<span class="nc" id="L1842">      m_win.addWindowListener(new WindowAdapter() {</span>
	  public void windowClosing(WindowEvent e) {
<span class="nc" id="L1844">	    boolean k = m_stopIt;</span>
<span class="nc" id="L1845">	    m_stopIt = true;</span>
<span class="nc" id="L1846">	    int well =JOptionPane.showConfirmDialog(m_win, </span>
<span class="nc" id="L1847">						    &quot;Are You Sure...\n&quot;</span>
						    + &quot;Click Yes To Accept&quot;
						    + &quot; The Neural Network&quot; 
						    + &quot;\n Click No To Return&quot;,
<span class="nc" id="L1851">						    &quot;Accept Neural Network&quot;, </span>
<span class="nc" id="L1852">						    JOptionPane.YES_NO_OPTION);</span>
	    
<span class="nc bnc" id="L1854" title="All 2 branches missed.">	    if (well == 0) {</span>
<span class="nc" id="L1855">	      m_win.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);</span>
<span class="nc" id="L1856">	      m_accepted = true;</span>
<span class="nc" id="L1857">	      blocker(false);</span>
	    }
	    else {
<span class="nc" id="L1860">	      m_win.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);</span>
	    }
<span class="nc" id="L1862">	    m_stopIt = k;</span>
<span class="nc" id="L1863">	  }</span>
	});
      
<span class="nc" id="L1866">      m_win.getContentPane().setLayout(new BorderLayout());</span>
<span class="nc" id="L1867">      m_win.setTitle(&quot;Neural Network&quot;);</span>
<span class="nc" id="L1868">      m_nodePanel = new NodePanel();</span>
      // without the following two lines, the NodePanel.paintComponents(Graphics) 
      // method will go berserk if the network doesn't fit completely: it will
      // get called on a constant basis, using 100% of the CPU
      // see the following forum thread:
      // http://forum.java.sun.com/thread.jspa?threadID=580929&amp;messageID=2945011
<span class="nc" id="L1874">      m_nodePanel.setPreferredSize(new Dimension(640, 480));</span>
<span class="nc" id="L1875">      m_nodePanel.revalidate();</span>

<span class="nc" id="L1877">      JScrollPane sp = new JScrollPane(m_nodePanel,</span>
<span class="nc" id="L1878">				       JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, </span>
<span class="nc" id="L1879">				       JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);</span>
<span class="nc" id="L1880">      m_controlPanel = new ControlPanel();</span>
           
<span class="nc" id="L1882">      m_win.getContentPane().add(sp, BorderLayout.CENTER);</span>
<span class="nc" id="L1883">      m_win.getContentPane().add(m_controlPanel, BorderLayout.SOUTH);</span>
<span class="nc" id="L1884">      m_win.setSize(640, 480);</span>
<span class="nc" id="L1885">      m_win.setVisible(true);</span>
    }
   
    //This sets up the initial state of the gui
<span class="pc bpc" id="L1889" title="1 of 2 branches missed.">    if (m_gui) {</span>
<span class="nc" id="L1890">      blocker(true);</span>
<span class="nc" id="L1891">      m_controlPanel.m_changeEpochs.setEnabled(false);</span>
<span class="nc" id="L1892">      m_controlPanel.m_changeLearning.setEnabled(false);</span>
<span class="nc" id="L1893">      m_controlPanel.m_changeMomentum.setEnabled(false);</span>
    } 
    
    //For silly situations in which the network gets accepted before training
    //commenses
<span class="fc bfc" id="L1898" title="All 2 branches covered.">    if (m_numeric) {</span>
<span class="fc" id="L1899">      setEndsToLinear();</span>
    }
<span class="pc bpc" id="L1901" title="1 of 2 branches missed.">    if (m_accepted) {</span>
<span class="nc" id="L1902">      m_win.dispose();</span>
<span class="nc" id="L1903">      m_controlPanel = null;</span>
<span class="nc" id="L1904">      m_nodePanel = null;</span>
<span class="nc" id="L1905">      m_instances = new Instances(m_instances, 0);</span>
<span class="nc" id="L1906">      m_currentInstance = null;</span>
<span class="nc" id="L1907">      return;</span>
    }

    //connections done.
<span class="fc" id="L1911">    double right = 0;</span>
<span class="fc" id="L1912">    double driftOff = 0;</span>
<span class="fc" id="L1913">    double lastRight = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L1914">    double bestError = Double.POSITIVE_INFINITY;</span>
    double tempRate;
<span class="fc" id="L1916">    double totalWeight = 0;</span>
<span class="fc" id="L1917">    double totalValWeight = 0;</span>
<span class="fc" id="L1918">    double origRate = m_learningRate; //only used for when reset</span>
    
    //ensure that at least 1 instance is trained through.
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">    if (numInVal == m_instances.numInstances()) {</span>
<span class="nc" id="L1922">      numInVal--;</span>
    }
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">    if (numInVal &lt; 0) {</span>
<span class="nc" id="L1925">      numInVal = 0;</span>
    }
<span class="fc bfc" id="L1927" title="All 2 branches covered.">    for (int noa = numInVal; noa &lt; m_instances.numInstances(); noa++) {</span>
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">      if (!m_instances.instance(noa).classIsMissing()) {</span>
<span class="fc" id="L1929">	totalWeight += m_instances.instance(noa).weight();</span>
      }
    }
<span class="pc bpc" id="L1932" title="1 of 2 branches missed.">    if (m_valSize != 0) {</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">      for (int noa = 0; noa &lt; valSet.numInstances(); noa++) {</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">	if (!valSet.instance(noa).classIsMissing()) {</span>
<span class="nc" id="L1935">	  totalValWeight += valSet.instance(noa).weight();</span>
	}
      }
    }
<span class="fc" id="L1939">    m_stopped = false;</span>
     

<span class="fc bfc" id="L1942" title="All 2 branches covered.">    for (int noa = 1; noa &lt; m_numEpochs + 1; noa++) {</span>
<span class="fc" id="L1943">      right = 0;</span>
<span class="fc bfc" id="L1944" title="All 2 branches covered.">      for (int nob = numInVal; nob &lt; m_instances.numInstances(); nob++) {</span>
<span class="fc" id="L1945">	m_currentInstance = m_instances.instance(nob);</span>
	
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">	if (!m_currentInstance.classIsMissing()) {</span>
	   
	  //this is where the network updating (and training occurs, for the
	  //training set
<span class="fc" id="L1951">	  resetNetwork();</span>
<span class="fc" id="L1952">	  calculateOutputs();</span>
<span class="fc" id="L1953">	  tempRate = m_learningRate * m_currentInstance.weight();  </span>
<span class="pc bpc" id="L1954" title="1 of 2 branches missed.">	  if (m_decay) {</span>
<span class="nc" id="L1955">	    tempRate /= noa;</span>
	  }

<span class="fc" id="L1958">	  right += (calculateErrors() / m_instances.numClasses()) *</span>
<span class="fc" id="L1959">	    m_currentInstance.weight();</span>
<span class="fc" id="L1960">	  updateNetworkWeights(tempRate, m_momentum);</span>
	  
	}
	
      }
<span class="fc" id="L1965">      right /= totalWeight;</span>
<span class="fc bfc" id="L1966" title="All 4 branches covered.">      if (Double.isInfinite(right) || Double.isNaN(right)) {</span>
<span class="pc bpc" id="L1967" title="1 of 2 branches missed.">	if (!m_reset) {</span>
<span class="nc" id="L1968">	  m_instances = null;</span>
<span class="nc" id="L1969">	  throw new Exception(&quot;Network cannot train. Try restarting with a&quot; +</span>
			      &quot; smaller learning rate.&quot;);
	}
	else {
	  //reset the network if possible
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">	  if (m_learningRate &lt;= Utils.SMALL)</span>
<span class="nc" id="L1975">	    throw new IllegalStateException(</span>
<span class="nc" id="L1976">		&quot;Learning rate got too small (&quot; + m_learningRate </span>
<span class="nc" id="L1977">		+ &quot; &lt;= &quot; + Utils.SMALL + &quot;)!&quot;);</span>
<span class="fc" id="L1978">	  m_learningRate /= 2;</span>
<span class="fc" id="L1979">	  buildClassifier(i);</span>
<span class="fc" id="L1980">	  m_learningRate = origRate;</span>
<span class="fc" id="L1981">	  m_instances = new Instances(m_instances, 0);</span>
<span class="fc" id="L1982">	  m_currentInstance = null;</span>
<span class="fc" id="L1983">	  return;</span>
	}
      }

      ////////////////////////do validation testing if applicable
<span class="pc bpc" id="L1988" title="1 of 2 branches missed.">      if (m_valSize != 0) {</span>
<span class="nc" id="L1989">	right = 0;</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">	for (int nob = 0; nob &lt; valSet.numInstances(); nob++) {</span>
<span class="nc" id="L1991">	  m_currentInstance = valSet.instance(nob);</span>
<span class="nc bnc" id="L1992" title="All 2 branches missed.">	  if (!m_currentInstance.classIsMissing()) {</span>
	    //this is where the network updating occurs, for the validation set
<span class="nc" id="L1994">	    resetNetwork();</span>
<span class="nc" id="L1995">	    calculateOutputs();</span>
<span class="nc" id="L1996">	    right += (calculateErrors() / valSet.numClasses()) </span>
<span class="nc" id="L1997">	      * m_currentInstance.weight();</span>
	    //note 'right' could be calculated here just using
	    //the calculate output values. This would be faster.
	    //be less modular
	  }
	  
	}
	
<span class="nc bnc" id="L2005" title="All 2 branches missed.">	if (right &lt; lastRight) {</span>
	  
<span class="nc bnc" id="L2007" title="All 2 branches missed.">	  if (right &lt; bestError) {</span>
<span class="nc" id="L2008">	    bestError = right;</span>
	    // save the network weights at this point
<span class="nc bnc" id="L2010" title="All 2 branches missed.">	    for (int noc = 0; noc &lt; m_numClasses; noc++) {</span>
<span class="nc" id="L2011">	      m_outputs[noc].saveWeights();</span>
	    }
<span class="nc" id="L2013">	    driftOff = 0;</span>
	  }
	}
	else {
<span class="nc" id="L2017">	  driftOff++;</span>
	}
<span class="nc" id="L2019">	lastRight = right;</span>
<span class="nc bnc" id="L2020" title="All 4 branches missed.">	if (driftOff &gt; m_driftThreshold || noa + 1 &gt;= m_numEpochs) {</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">	  for (int noc = 0; noc &lt; m_numClasses; noc++) {</span>
<span class="nc" id="L2022">            m_outputs[noc].restoreWeights();</span>
          }
<span class="nc" id="L2024">	  m_accepted = true;</span>
	}
<span class="nc" id="L2026">	right /= totalValWeight;</span>
      }
<span class="fc" id="L2028">      m_epoch = noa;</span>
<span class="fc" id="L2029">      m_error = right;</span>
      //shows what the neuralnet is upto if a gui exists. 
<span class="fc" id="L2031">      updateDisplay();</span>
      //This junction controls what state the gui is in at the end of each
      //epoch, Such as if it is paused, if it is resumable etc...
<span class="pc bpc" id="L2034" title="1 of 2 branches missed.">      if (m_gui) {</span>
<span class="nc bnc" id="L2035" title="All 8 branches missed.">	while ((m_stopIt || (m_epoch &gt;= m_numEpochs &amp;&amp; m_valSize == 0)) &amp;&amp; </span>
<span class="nc" id="L2036">		!m_accepted) {</span>
<span class="nc" id="L2037">	  m_stopIt = true;</span>
<span class="nc" id="L2038">	  m_stopped = true;</span>
<span class="nc bnc" id="L2039" title="All 4 branches missed.">	  if (m_epoch &gt;= m_numEpochs &amp;&amp; m_valSize == 0) {</span>
	    
<span class="nc" id="L2041">	    m_controlPanel.m_startStop.setEnabled(false);</span>
	  }
	  else {
<span class="nc" id="L2044">	    m_controlPanel.m_startStop.setEnabled(true);</span>
	  }
<span class="nc" id="L2046">	  m_controlPanel.m_startStop.setText(&quot;Start&quot;);</span>
<span class="nc" id="L2047">	  m_controlPanel.m_startStop.setActionCommand(&quot;Start&quot;);</span>
<span class="nc" id="L2048">	  m_controlPanel.m_changeEpochs.setEnabled(true);</span>
<span class="nc" id="L2049">	  m_controlPanel.m_changeLearning.setEnabled(true);</span>
<span class="nc" id="L2050">	  m_controlPanel.m_changeMomentum.setEnabled(true);</span>
	  
<span class="nc" id="L2052">	  blocker(true);</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">	  if (m_numeric) {</span>
<span class="nc" id="L2054">	    setEndsToLinear();</span>
	  }
	}
<span class="nc" id="L2057">	m_controlPanel.m_changeEpochs.setEnabled(false);</span>
<span class="nc" id="L2058">	m_controlPanel.m_changeLearning.setEnabled(false);</span>
<span class="nc" id="L2059">	m_controlPanel.m_changeMomentum.setEnabled(false);</span>
	
<span class="nc" id="L2061">	m_stopped = false;</span>
	//if the network has been accepted stop the training loop
<span class="nc bnc" id="L2063" title="All 2 branches missed.">	if (m_accepted) {</span>
<span class="nc" id="L2064">	  m_win.dispose();</span>
<span class="nc" id="L2065">	  m_controlPanel = null;</span>
<span class="nc" id="L2066">	  m_nodePanel = null;</span>
<span class="nc" id="L2067">	  m_instances = new Instances(m_instances, 0);</span>
<span class="nc" id="L2068">	  m_currentInstance = null;</span>
<span class="nc" id="L2069">	  return;</span>
	}
      }
<span class="pc bpc" id="L2072" title="1 of 2 branches missed.">      if (m_accepted) {</span>
<span class="nc" id="L2073">	m_instances = new Instances(m_instances, 0);</span>
<span class="nc" id="L2074">	m_currentInstance = null;</span>
<span class="nc" id="L2075">	return;</span>
      }
    }
<span class="pc bpc" id="L2078" title="1 of 2 branches missed.">    if (m_gui) {</span>
<span class="nc" id="L2079">      m_win.dispose();</span>
<span class="nc" id="L2080">      m_controlPanel = null;</span>
<span class="nc" id="L2081">      m_nodePanel = null;</span>
    }
<span class="fc" id="L2083">    m_instances = new Instances(m_instances, 0);</span>
<span class="fc" id="L2084">    m_currentInstance = null;</span>
<span class="fc" id="L2085">  }</span>

  /**
   * Call this function to predict the class of an instance once a 
   * classification model has been built with the buildClassifier call.
   * @param i The instance to classify.
   * @return A double array filled with the probabilities of each class type.
   * @throws Exception if can't classify instance.
   */
  public double[] distributionForInstance(Instance i) throws Exception {

    // default model?
<span class="fc bfc" id="L2097" title="All 2 branches covered.">    if (m_useDefaultModel) {</span>
<span class="fc" id="L2098">      return m_ZeroR.distributionForInstance(i);</span>
    }
    
<span class="pc bpc" id="L2101" title="1 of 2 branches missed.">    if (m_useNomToBin) {</span>
<span class="fc" id="L2102">      m_nominalToBinaryFilter.input(i);</span>
<span class="fc" id="L2103">      m_currentInstance = m_nominalToBinaryFilter.output();</span>
    }
    else {
<span class="nc" id="L2106">      m_currentInstance = i;</span>
    }
    
<span class="pc bpc" id="L2109" title="1 of 2 branches missed.">    if (m_normalizeAttributes) {</span>
<span class="fc bfc" id="L2110" title="All 2 branches covered.">      for (int noa = 0; noa &lt; m_instances.numAttributes(); noa++) {</span>
<span class="fc bfc" id="L2111" title="All 2 branches covered.">	if (noa != m_instances.classIndex()) {</span>
<span class="pc bpc" id="L2112" title="1 of 2 branches missed.">	  if (m_attributeRanges[noa] != 0) {</span>
<span class="fc" id="L2113">	    m_currentInstance.setValue(noa, (m_currentInstance.value(noa) - </span>
<span class="fc" id="L2114">					     m_attributeBases[noa]) / </span>
<span class="fc" id="L2115">				       m_attributeRanges[noa]);</span>
	  }
	  else {
<span class="nc" id="L2118">	    m_currentInstance.setValue(noa, m_currentInstance.value(noa) -</span>
<span class="nc" id="L2119">				       m_attributeBases[noa]);</span>
	  }
	}
      }
    }
<span class="fc" id="L2124">    resetNetwork();</span>
    
    //since all the output values are needed.
    //They are calculated manually here and the values collected.
<span class="fc" id="L2128">    double[] theArray = new double[m_numClasses];</span>
<span class="fc bfc" id="L2129" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="fc" id="L2130">      theArray[noa] = m_outputs[noa].outputValue(true);</span>
    }
<span class="fc bfc" id="L2132" title="All 2 branches covered.">    if (m_instances.classAttribute().isNumeric()) {</span>
<span class="fc" id="L2133">      return theArray;</span>
    }
    
    //now normalize the array
<span class="fc" id="L2137">    double count = 0;</span>
<span class="fc bfc" id="L2138" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="fc" id="L2139">      count += theArray[noa];</span>
    }
<span class="pc bpc" id="L2141" title="1 of 2 branches missed.">    if (count &lt;= 0) {</span>
<span class="nc" id="L2142">      return m_ZeroR.distributionForInstance(i);</span>
    }
<span class="fc bfc" id="L2144" title="All 2 branches covered.">    for (int noa = 0; noa &lt; m_numClasses; noa++) {</span>
<span class="fc" id="L2145">      theArray[noa] /= count;</span>
    }
<span class="fc" id="L2147">    return theArray;</span>
  }
  


  /**
   * Returns an enumeration describing the available options.
   *
   * @return an enumeration of all the available options.
   */
  public Enumeration listOptions() {
    
<span class="fc" id="L2159">    Vector newVector = new Vector(14);</span>

<span class="fc" id="L2161">    newVector.addElement(new Option(</span>
<span class="fc" id="L2162">	      &quot;\tLearning Rate for the backpropagation algorithm.\n&quot;</span>
	      +&quot;\t(Value should be between 0 - 1, Default = 0.3).&quot;,
<span class="fc" id="L2164">	      &quot;L&quot;, 1, &quot;-L &lt;learning rate&gt;&quot;));</span>
<span class="fc" id="L2165">    newVector.addElement(new Option(</span>
<span class="fc" id="L2166">	      &quot;\tMomentum Rate for the backpropagation algorithm.\n&quot;</span>
	      +&quot;\t(Value should be between 0 - 1, Default = 0.2).&quot;,
<span class="fc" id="L2168">	      &quot;M&quot;, 1, &quot;-M &lt;momentum&gt;&quot;));</span>
<span class="fc" id="L2169">    newVector.addElement(new Option(</span>
<span class="fc" id="L2170">	      &quot;\tNumber of epochs to train through.\n&quot;</span>
	      +&quot;\t(Default = 500).&quot;,
<span class="fc" id="L2172">	      &quot;N&quot;, 1,&quot;-N &lt;number of epochs&gt;&quot;));</span>
<span class="fc" id="L2173">    newVector.addElement(new Option(</span>
<span class="fc" id="L2174">	      &quot;\tPercentage size of validation set to use to terminate\n&quot;</span>
	      + &quot;\ttraining (if this is non zero it can pre-empt num of epochs.\n&quot;
	      +&quot;\t(Value should be between 0 - 100, Default = 0).&quot;,
<span class="fc" id="L2177">	      &quot;V&quot;, 1, &quot;-V &lt;percentage size of validation set&gt;&quot;));</span>
<span class="fc" id="L2178">    newVector.addElement(new Option(</span>
<span class="fc" id="L2179">	      &quot;\tThe value used to seed the random number generator\n&quot;</span>
	      + &quot;\t(Value should be &gt;= 0 and and a long, Default = 0).&quot;,
<span class="fc" id="L2181">	      &quot;S&quot;, 1, &quot;-S &lt;seed&gt;&quot;));</span>
<span class="fc" id="L2182">    newVector.addElement(new Option(</span>
<span class="fc" id="L2183">	      &quot;\tThe consequetive number of errors allowed for validation\n&quot;</span>
	      + &quot;\ttesting before the netwrok terminates.\n&quot;
	      + &quot;\t(Value should be &gt; 0, Default = 20).&quot;,
<span class="fc" id="L2186">	      &quot;E&quot;, 1, &quot;-E &lt;threshold for number of consequetive errors&gt;&quot;));</span>
<span class="fc" id="L2187">    newVector.addElement(new Option(</span>
<span class="fc" id="L2188">              &quot;\tGUI will be opened.\n&quot;</span>
	      +&quot;\t(Use this to bring up a GUI).&quot;,
<span class="fc" id="L2190">	      &quot;G&quot;, 0,&quot;-G&quot;));</span>
<span class="fc" id="L2191">    newVector.addElement(new Option(</span>
<span class="fc" id="L2192">              &quot;\tAutocreation of the network connections will NOT be done.\n&quot;</span>
	      +&quot;\t(This will be ignored if -G is NOT set)&quot;,
<span class="fc" id="L2194">	      &quot;A&quot;, 0,&quot;-A&quot;));</span>
<span class="fc" id="L2195">    newVector.addElement(new Option(</span>
<span class="fc" id="L2196">              &quot;\tA NominalToBinary filter will NOT automatically be used.\n&quot;</span>
	      +&quot;\t(Set this to not use a NominalToBinary filter).&quot;,
<span class="fc" id="L2198">	      &quot;B&quot;, 0,&quot;-B&quot;));</span>
<span class="fc" id="L2199">    newVector.addElement(new Option(</span>
<span class="fc" id="L2200">	      &quot;\tThe hidden layers to be created for the network.\n&quot;</span>
	      + &quot;\t(Value should be a list of comma separated Natural \n&quot;
	      + &quot;\tnumbers or the letters 'a' = (attribs + classes) / 2, \n&quot;
	      + &quot;\t'i' = attribs, 'o' = classes, 't' = attribs .+ classes)\n&quot;
	      + &quot;\tfor wildcard values, Default = a).&quot;,
<span class="fc" id="L2205">	      &quot;H&quot;, 1, &quot;-H &lt;comma seperated numbers for nodes on each layer&gt;&quot;));</span>
<span class="fc" id="L2206">    newVector.addElement(new Option(</span>
<span class="fc" id="L2207">              &quot;\tNormalizing a numeric class will NOT be done.\n&quot;</span>
	      +&quot;\t(Set this to not normalize the class if it's numeric).&quot;,
<span class="fc" id="L2209">	      &quot;C&quot;, 0,&quot;-C&quot;));</span>
<span class="fc" id="L2210">    newVector.addElement(new Option(</span>
<span class="fc" id="L2211">              &quot;\tNormalizing the attributes will NOT be done.\n&quot;</span>
	      +&quot;\t(Set this to not normalize the attributes).&quot;,
<span class="fc" id="L2213">	      &quot;I&quot;, 0,&quot;-I&quot;));</span>
<span class="fc" id="L2214">    newVector.addElement(new Option(</span>
<span class="fc" id="L2215">              &quot;\tReseting the network will NOT be allowed.\n&quot;</span>
	      +&quot;\t(Set this to not allow the network to reset).&quot;,
<span class="fc" id="L2217">	      &quot;R&quot;, 0,&quot;-R&quot;));</span>
<span class="fc" id="L2218">    newVector.addElement(new Option(</span>
<span class="fc" id="L2219">              &quot;\tLearning rate decay will occur.\n&quot;</span>
	      +&quot;\t(Set this to cause the learning rate to decay).&quot;,
<span class="fc" id="L2221">	      &quot;D&quot;, 0,&quot;-D&quot;));</span>
    
    
<span class="fc" id="L2224">    return newVector.elements();</span>
  }

  /**
   * Parses a given list of options. &lt;p/&gt;
   *
   &lt;!-- options-start --&gt;
   * Valid options are: &lt;p/&gt;
   * 
   * &lt;pre&gt; -L &amp;lt;learning rate&amp;gt;
   *  Learning Rate for the backpropagation algorithm.
   *  (Value should be between 0 - 1, Default = 0.3).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -M &amp;lt;momentum&amp;gt;
   *  Momentum Rate for the backpropagation algorithm.
   *  (Value should be between 0 - 1, Default = 0.2).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -N &amp;lt;number of epochs&amp;gt;
   *  Number of epochs to train through.
   *  (Default = 500).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -V &amp;lt;percentage size of validation set&amp;gt;
   *  Percentage size of validation set to use to terminate
   *  training (if this is non zero it can pre-empt num of epochs.
   *  (Value should be between 0 - 100, Default = 0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -S &amp;lt;seed&amp;gt;
   *  The value used to seed the random number generator
   *  (Value should be &amp;gt;= 0 and and a long, Default = 0).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -E &amp;lt;threshold for number of consequetive errors&amp;gt;
   *  The consequetive number of errors allowed for validation
   *  testing before the netwrok terminates.
   *  (Value should be &amp;gt; 0, Default = 20).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -G
   *  GUI will be opened.
   *  (Use this to bring up a GUI).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -A
   *  Autocreation of the network connections will NOT be done.
   *  (This will be ignored if -G is NOT set)&lt;/pre&gt;
   * 
   * &lt;pre&gt; -B
   *  A NominalToBinary filter will NOT automatically be used.
   *  (Set this to not use a NominalToBinary filter).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -H &amp;lt;comma seperated numbers for nodes on each layer&amp;gt;
   *  The hidden layers to be created for the network.
   *  (Value should be a list of comma separated Natural 
   *  numbers or the letters 'a' = (attribs + classes) / 2, 
   *  'i' = attribs, 'o' = classes, 't' = attribs .+ classes)
   *  for wildcard values, Default = a).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -C
   *  Normalizing a numeric class will NOT be done.
   *  (Set this to not normalize the class if it's numeric).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -I
   *  Normalizing the attributes will NOT be done.
   *  (Set this to not normalize the attributes).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -R
   *  Reseting the network will NOT be allowed.
   *  (Set this to not allow the network to reset).&lt;/pre&gt;
   * 
   * &lt;pre&gt; -D
   *  Learning rate decay will occur.
   *  (Set this to cause the learning rate to decay).&lt;/pre&gt;
   * 
   &lt;!-- options-end --&gt;
   *
   * @param options the list of options as an array of strings
   * @throws Exception if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    //the defaults can be found here!!!!
<span class="fc" id="L2301">    String learningString = Utils.getOption('L', options);</span>
<span class="fc bfc" id="L2302" title="All 2 branches covered.">    if (learningString.length() != 0) {</span>
<span class="fc" id="L2303">      setLearningRate((new Double(learningString)).doubleValue());</span>
    } else {
<span class="fc" id="L2305">      setLearningRate(0.3);</span>
    }
<span class="fc" id="L2307">    String momentumString = Utils.getOption('M', options);</span>
<span class="fc bfc" id="L2308" title="All 2 branches covered.">    if (momentumString.length() != 0) {</span>
<span class="fc" id="L2309">      setMomentum((new Double(momentumString)).doubleValue());</span>
    } else {
<span class="fc" id="L2311">      setMomentum(0.2);</span>
    }
<span class="fc" id="L2313">    String epochsString = Utils.getOption('N', options);</span>
<span class="fc bfc" id="L2314" title="All 2 branches covered.">    if (epochsString.length() != 0) {</span>
<span class="fc" id="L2315">      setTrainingTime(Integer.parseInt(epochsString));</span>
    } else {
<span class="fc" id="L2317">      setTrainingTime(500);</span>
    }
<span class="fc" id="L2319">    String valSizeString = Utils.getOption('V', options);</span>
<span class="fc bfc" id="L2320" title="All 2 branches covered.">    if (valSizeString.length() != 0) {</span>
<span class="fc" id="L2321">      setValidationSetSize(Integer.parseInt(valSizeString));</span>
    } else {
<span class="fc" id="L2323">      setValidationSetSize(0);</span>
    }
<span class="fc" id="L2325">    String seedString = Utils.getOption('S', options);</span>
<span class="fc bfc" id="L2326" title="All 2 branches covered.">    if (seedString.length() != 0) {</span>
<span class="fc" id="L2327">      setSeed(Integer.parseInt(seedString));</span>
    } else {
<span class="fc" id="L2329">      setSeed(0);</span>
    }
<span class="fc" id="L2331">    String thresholdString = Utils.getOption('E', options);</span>
<span class="fc bfc" id="L2332" title="All 2 branches covered.">    if (thresholdString.length() != 0) {</span>
<span class="fc" id="L2333">      setValidationThreshold(Integer.parseInt(thresholdString));</span>
    } else {
<span class="fc" id="L2335">      setValidationThreshold(20);</span>
    }
<span class="fc" id="L2337">    String hiddenLayers = Utils.getOption('H', options);</span>
<span class="fc bfc" id="L2338" title="All 2 branches covered.">    if (hiddenLayers.length() != 0) {</span>
<span class="fc" id="L2339">      setHiddenLayers(hiddenLayers);</span>
    } else {
<span class="fc" id="L2341">      setHiddenLayers(&quot;a&quot;);</span>
    }
<span class="pc bpc" id="L2343" title="1 of 2 branches missed.">    if (Utils.getFlag('G', options)) {</span>
<span class="nc" id="L2344">      setGUI(true);</span>
    } else {
<span class="fc" id="L2346">      setGUI(false);</span>
    } //small note. since the gui is the only option that can change the other
    //options this should be set first to allow the other options to set 
    //properly
<span class="pc bpc" id="L2350" title="1 of 2 branches missed.">    if (Utils.getFlag('A', options)) {</span>
<span class="nc" id="L2351">      setAutoBuild(false);</span>
    } else {
<span class="fc" id="L2353">      setAutoBuild(true);</span>
    }
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">    if (Utils.getFlag('B', options)) {</span>
<span class="nc" id="L2356">      setNominalToBinaryFilter(false);</span>
    } else {
<span class="fc" id="L2358">      setNominalToBinaryFilter(true);</span>
    }
<span class="pc bpc" id="L2360" title="1 of 2 branches missed.">    if (Utils.getFlag('C', options)) {</span>
<span class="nc" id="L2361">      setNormalizeNumericClass(false);</span>
    } else {
<span class="fc" id="L2363">      setNormalizeNumericClass(true);</span>
    }
<span class="pc bpc" id="L2365" title="1 of 2 branches missed.">    if (Utils.getFlag('I', options)) {</span>
<span class="nc" id="L2366">      setNormalizeAttributes(false);</span>
    } else {
<span class="fc" id="L2368">      setNormalizeAttributes(true);</span>
    }
<span class="pc bpc" id="L2370" title="1 of 2 branches missed.">    if (Utils.getFlag('R', options)) {</span>
<span class="nc" id="L2371">      setReset(false);</span>
    } else {
<span class="fc" id="L2373">      setReset(true);</span>
    }
<span class="pc bpc" id="L2375" title="1 of 2 branches missed.">    if (Utils.getFlag('D', options)) {</span>
<span class="nc" id="L2376">      setDecay(true);</span>
    } else {
<span class="fc" id="L2378">      setDecay(false);</span>
    }
    
<span class="fc" id="L2381">    Utils.checkForRemainingOptions(options);</span>
<span class="fc" id="L2382">  }</span>
  
  /**
   * Gets the current settings of NeuralNet.
   *
   * @return an array of strings suitable for passing to setOptions()
   */
  public String [] getOptions() {

<span class="fc" id="L2391">    String [] options = new String [21];</span>
<span class="fc" id="L2392">    int current = 0;</span>
<span class="fc" id="L2393">    options[current++] = &quot;-L&quot;; options[current++] = &quot;&quot; + getLearningRate(); </span>
<span class="fc" id="L2394">    options[current++] = &quot;-M&quot;; options[current++] = &quot;&quot; + getMomentum();</span>
<span class="fc" id="L2395">    options[current++] = &quot;-N&quot;; options[current++] = &quot;&quot; + getTrainingTime(); </span>
<span class="fc" id="L2396">    options[current++] = &quot;-V&quot;; options[current++] = &quot;&quot; +getValidationSetSize();</span>
<span class="fc" id="L2397">    options[current++] = &quot;-S&quot;; options[current++] = &quot;&quot; + getSeed();</span>
<span class="fc" id="L2398">    options[current++] = &quot;-E&quot;; options[current++] =&quot;&quot;+getValidationThreshold();</span>
<span class="fc" id="L2399">    options[current++] = &quot;-H&quot;; options[current++] = getHiddenLayers();</span>
<span class="pc bpc" id="L2400" title="1 of 2 branches missed.">    if (getGUI()) {</span>
<span class="nc" id="L2401">      options[current++] = &quot;-G&quot;;</span>
    }
<span class="pc bpc" id="L2403" title="1 of 2 branches missed.">    if (!getAutoBuild()) {</span>
<span class="nc" id="L2404">      options[current++] = &quot;-A&quot;;</span>
    }
<span class="pc bpc" id="L2406" title="1 of 2 branches missed.">    if (!getNominalToBinaryFilter()) {</span>
<span class="nc" id="L2407">      options[current++] = &quot;-B&quot;;</span>
    }
<span class="pc bpc" id="L2409" title="1 of 2 branches missed.">    if (!getNormalizeNumericClass()) {</span>
<span class="nc" id="L2410">      options[current++] = &quot;-C&quot;;</span>
    }
<span class="pc bpc" id="L2412" title="1 of 2 branches missed.">    if (!getNormalizeAttributes()) {</span>
<span class="nc" id="L2413">      options[current++] = &quot;-I&quot;;</span>
    }
<span class="pc bpc" id="L2415" title="1 of 2 branches missed.">    if (!getReset()) {</span>
<span class="nc" id="L2416">      options[current++] = &quot;-R&quot;;</span>
    }
<span class="pc bpc" id="L2418" title="1 of 2 branches missed.">    if (getDecay()) {</span>
<span class="nc" id="L2419">      options[current++] = &quot;-D&quot;;</span>
    }

    
<span class="pc bfc" id="L2423" title="All 2 branches covered.">    while (current &lt; options.length) {</span>
<span class="fc" id="L2424">      options[current++] = &quot;&quot;;</span>
    }
<span class="fc" id="L2426">    return options;</span>
  }
  
  /**
   * @return string describing the model.
   */
  public String toString() {
    // only ZeroR model?
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">    if (m_useDefaultModel) {</span>
<span class="nc" id="L2435">      StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L2436">      buf.append(this.getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;) + &quot;\n&quot;);</span>
<span class="nc" id="L2437">      buf.append(this.getClass().getName().replaceAll(&quot;.*\\.&quot;, &quot;&quot;).replaceAll(&quot;.&quot;, &quot;=&quot;) + &quot;\n\n&quot;);</span>
<span class="nc" id="L2438">      buf.append(&quot;Warning: No model could be built, hence ZeroR model is used:\n\n&quot;);</span>
<span class="nc" id="L2439">      buf.append(m_ZeroR.toString());</span>
<span class="nc" id="L2440">      return buf.toString();</span>
    }
    
<span class="fc" id="L2443">    StringBuffer model = new StringBuffer(m_neuralNodes.length * 100); </span>
    //just a rough size guess
    NeuralNode con;
    double[] weights;
    NeuralConnection[] inputs;
<span class="pc bpc" id="L2448" title="1 of 2 branches missed.">    for (int noa = 0; noa &lt; m_neuralNodes.length; noa++) {</span>
<span class="nc" id="L2449">      con = (NeuralNode) m_neuralNodes[noa];  //this would need a change</span>
                                              //for items other than nodes!!!
<span class="nc" id="L2451">      weights = con.getWeights();</span>
<span class="nc" id="L2452">      inputs = con.getInputs();</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">      if (con.getMethod() instanceof SigmoidUnit) {</span>
<span class="nc" id="L2454">	model.append(&quot;Sigmoid &quot;);</span>
      }
<span class="nc bnc" id="L2456" title="All 2 branches missed.">      else if (con.getMethod() instanceof LinearUnit) {</span>
<span class="nc" id="L2457">	model.append(&quot;Linear &quot;);</span>
      }
<span class="nc" id="L2459">      model.append(&quot;Node &quot; + con.getId() + &quot;\n    Inputs    Weights\n&quot;);</span>
<span class="nc" id="L2460">      model.append(&quot;    Threshold    &quot; + weights[0] + &quot;\n&quot;);</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">      for (int nob = 1; nob &lt; con.getNumInputs() + 1; nob++) {</span>
<span class="nc bnc" id="L2462" title="All 2 branches missed.">	if ((inputs[nob - 1].getType() &amp; NeuralConnection.PURE_INPUT) </span>
<span class="nc" id="L2463">	    == NeuralConnection.PURE_INPUT) {</span>
<span class="nc" id="L2464">	  model.append(&quot;    Attrib &quot; + </span>
<span class="nc" id="L2465">		       m_instances.attribute(((NeuralEnd)inputs[nob-1]).</span>
<span class="nc" id="L2466">					     getLink()).name()</span>
<span class="nc" id="L2467">		       + &quot;    &quot; + weights[nob] + &quot;\n&quot;);</span>
	}
	else {
<span class="nc" id="L2470">	  model.append(&quot;    Node &quot; + inputs[nob-1].getId() + &quot;    &quot; +</span>
<span class="nc" id="L2471">		       weights[nob] + &quot;\n&quot;);</span>
	}
      }      
    }
    //now put in the ends
<span class="pc bpc" id="L2476" title="1 of 2 branches missed.">    for (int noa = 0; noa &lt; m_outputs.length; noa++) {</span>
<span class="nc" id="L2477">      inputs = m_outputs[noa].getInputs();</span>
<span class="nc" id="L2478">      model.append(&quot;Class &quot; + </span>
<span class="nc" id="L2479">		   m_instances.classAttribute().</span>
<span class="nc" id="L2480">		   value(m_outputs[noa].getLink()) + </span>
<span class="nc" id="L2481">		   &quot;\n    Input\n&quot;);</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">      for (int nob = 0; nob &lt; m_outputs[noa].getNumInputs(); nob++) {</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">	if ((inputs[nob].getType() &amp; NeuralConnection.PURE_INPUT)</span>
<span class="nc" id="L2484">	    == NeuralConnection.PURE_INPUT) {</span>
<span class="nc" id="L2485">	  model.append(&quot;    Attrib &quot; +</span>
<span class="nc" id="L2486">		       m_instances.attribute(((NeuralEnd)inputs[nob]).</span>
<span class="nc" id="L2487">					     getLink()).name() + &quot;\n&quot;);</span>
	}
	else {
<span class="nc" id="L2490">	  model.append(&quot;    Node &quot; + inputs[nob].getId() + &quot;\n&quot;);</span>
	}
      }
    }
<span class="fc" id="L2494">    return model.toString();</span>
  }

  /**
   * This will return a string describing the classifier.
   * @return The string.
   */
  public String globalInfo() {
<span class="nc" id="L2502">    return </span>
<span class="nc" id="L2503">        &quot;A Classifier that uses backpropagation to classify instances.\n&quot;</span>
      + &quot;This network can be built by hand, created by an algorithm or both. &quot;
      + &quot;The network can also be monitored and modified during training time. &quot;
      + &quot;The nodes in this network are all sigmoid (except for when the class &quot;
      + &quot;is numeric in which case the the output nodes become unthresholded &quot;
      + &quot;linear units).&quot;;
  }
  
  /**
   * @return a string to describe the learning rate option.
   */
  public String learningRateTipText() {
<span class="nc" id="L2515">    return &quot;The amount the&quot; + </span>
      &quot; weights are updated.&quot;;
  }
  
  /**
   * @return a string to describe the momentum option.
   */
  public String momentumTipText() {
<span class="nc" id="L2523">    return &quot;Momentum applied to the weights during updating.&quot;;</span>
  }

  /**
   * @return a string to describe the AutoBuild option.
   */
  public String autoBuildTipText() {
<span class="nc" id="L2530">    return &quot;Adds and connects up hidden layers in the network.&quot;;</span>
  }

  /**
   * @return a string to describe the random seed option.
   */
  public String seedTipText() {
<span class="nc" id="L2537">    return &quot;Seed used to initialise the random number generator.&quot; +</span>
      &quot;Random numbers are used for setting the initial weights of the&quot; +
      &quot; connections betweem nodes, and also for shuffling the training data.&quot;;
  }
  
  /**
   * @return a string to describe the validation threshold option.
   */
  public String validationThresholdTipText() {
<span class="nc" id="L2546">    return &quot;Used to terminate validation testing.&quot; +</span>
      &quot;The value here dictates how many times in a row the validation set&quot; +
      &quot; error can get worse before training is terminated.&quot;;
  }
  
  /**
   * @return a string to describe the GUI option.
   */
  public String GUITipText() {
<span class="nc" id="L2555">    return &quot;Brings up a gui interface.&quot; +</span>
      &quot; This will allow the pausing and altering of the nueral network&quot; +
      &quot; during training.\n\n&quot; +
      &quot;* To add a node left click (this node will be automatically selected,&quot; +
      &quot; ensure no other nodes were selected).\n&quot; +
      &quot;* To select a node left click on it either while no other node is&quot; +
      &quot; selected or while holding down the control key (this toggles that&quot; +
      &quot; node as being selected and not selected.\n&quot; + 
      &quot;* To connect a node, first have the start node(s) selected, then click&quot;+
      &quot; either the end node or on an empty space (this will create a new node&quot;+
      &quot; that is connected with the selected nodes). The selection status of&quot; +
      &quot; nodes will stay the same after the connection. (Note these are&quot; +
      &quot; directed connections, also a connection between two nodes will not&quot; +
      &quot; be established more than once and certain connections that are&quot; + 
      &quot; deemed to be invalid will not be made).\n&quot; +
      &quot;* To remove a connection select one of the connected node(s) in the&quot; +
      &quot; connection and then right click the other node (it does not matter&quot; +
      &quot; whether the node is the start or end the connection will be removed&quot; +
      &quot;).\n&quot; +
      &quot;* To remove a node right click it while no other nodes (including it)&quot; +
      &quot; are selected. (This will also remove all connections to it)\n.&quot; +
      &quot;* To deselect a node either left click it while holding down control,&quot; +
      &quot; or right click on empty space.\n&quot; +
      &quot;* The raw inputs are provided from the labels on the left.\n&quot; +
      &quot;* The red nodes are hidden layers.\n&quot; +
      &quot;* The orange nodes are the output nodes.\n&quot; +
      &quot;* The labels on the right show the class the output node represents.&quot; +
      &quot; Note that with a numeric class the output node will automatically be&quot; +
      &quot; made into an unthresholded linear unit.\n\n&quot; +
      &quot;Alterations to the neural network can only be done while the network&quot; +
      &quot; is not running, This also applies to the learning rate and other&quot; +
      &quot; fields on the control panel.\n\n&quot; + 
      &quot;* You can accept the network as being finished at any time.\n&quot; +
      &quot;* The network is automatically paused at the beginning.\n&quot; +
      &quot;* There is a running indication of what epoch the network is up to&quot; + 
      &quot; and what the (rough) error for that epoch was (or for&quot; +
      &quot; the validation if that is being used). Note that this error value&quot; +
      &quot; is based on a network that changes as the value is computed.&quot; +
      &quot; (also depending on whether&quot; +
      &quot; the class is normalized will effect the error reported for numeric&quot; +
      &quot; classes.\n&quot; +
      &quot;* Once the network is done it will pause again and either wait to be&quot; +
      &quot; accepted or trained more.\n\n&quot; +
      &quot;Note that if the gui is not set the network will not require any&quot; +
      &quot; interaction.\n&quot;;
  }
  
  /**
   * @return a string to describe the validation size option.
   */
  public String validationSetSizeTipText() {
<span class="nc" id="L2606">    return &quot;The percentage size of the validation set.&quot; +</span>
      &quot;(The training will continue until it is observed that&quot; +
      &quot; the error on the validation set has been consistently getting&quot; +
      &quot; worse, or if the training time is reached).\n&quot; +
      &quot;If This is set to zero no validation set will be used and instead&quot; +
      &quot; the network will train for the specified number of epochs.&quot;;
  }
  
  /**
   * @return a string to describe the learning rate option.
   */
  public String trainingTimeTipText() {
<span class="nc" id="L2618">    return &quot;The number of epochs to train through.&quot; + </span>
      &quot; If the validation set is non-zero then it can terminate the network&quot; +
      &quot; early&quot;;
  }


  /**
   * @return a string to describe the nominal to binary option.
   */
  public String nominalToBinaryFilterTipText() {
<span class="nc" id="L2628">    return &quot;This will preprocess the instances with the filter.&quot; +</span>
      &quot; This could help improve performance if there are nominal attributes&quot; +
      &quot; in the data.&quot;;
  }

  /**
   * @return a string to describe the hidden layers in the network.
   */
  public String hiddenLayersTipText() {
<span class="nc" id="L2637">    return &quot;This defines the hidden layers of the neural network.&quot; +</span>
      &quot; This is a list of positive whole numbers. 1 for each hidden layer.&quot; +
      &quot; Comma seperated. To have no hidden layers put a single 0 here.&quot; +
      &quot; This will only be used if autobuild is set. There are also wildcard&quot; +
      &quot; values 'a' = (attribs + classes) / 2, 'i' = attribs, 'o' = classes&quot; +
      &quot; , 't' = attribs + classes.&quot;;
  }
  /**
   * @return a string to describe the nominal to binary option.
   */
  public String normalizeNumericClassTipText() {
<span class="nc" id="L2648">    return &quot;This will normalize the class if it's numeric.&quot; +</span>
      &quot; This could help improve performance of the network, It normalizes&quot; +
      &quot; the class to be between -1 and 1. Note that this is only internally&quot; +
      &quot;, the output will be scaled back to the original range.&quot;;
  }
  /**
   * @return a string to describe the nominal to binary option.
   */
  public String normalizeAttributesTipText() {
<span class="nc" id="L2657">    return &quot;This will normalize the attributes.&quot; +</span>
      &quot; This could help improve performance of the network.&quot; +
      &quot; This is not reliant on the class being numeric. This will also&quot; +
      &quot; normalize nominal attributes as well (after they have been run&quot; +
      &quot; through the nominal to binary filter if that is in use) so that the&quot; +
      &quot; nominal values are between -1 and 1&quot;;
  }
  /**
   * @return a string to describe the Reset option.
   */
  public String resetTipText() {
<span class="nc" id="L2668">    return &quot;This will allow the network to reset with a lower learning rate.&quot; +</span>
      &quot; If the network diverges from the answer this will automatically&quot; +
      &quot; reset the network with a lower learning rate and begin training&quot; +
      &quot; again. This option is only available if the gui is not set. Note&quot; +
      &quot; that if the network diverges but isn't allowed to reset it will&quot; +
      &quot; fail the training process and return an error message.&quot;;
  }
  
  /**
   * @return a string to describe the Decay option.
   */
  public String decayTipText() {
<span class="nc" id="L2680">    return &quot;This will cause the learning rate to decrease.&quot; +</span>
      &quot; This will divide the starting learning rate by the epoch number, to&quot; +
      &quot; determine what the current learning rate should be. This may help&quot; +
      &quot; to stop the network from diverging from the target output, as well&quot; +
      &quot; as improve general performance. Note that the decaying learning&quot; +
      &quot; rate will not be shown in the gui, only the original learning rate&quot; +
      &quot;. If the learning rate is changed in the gui, this is treated as the&quot; +
      &quot; starting learning rate.&quot;;
  }
  
  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
<span class="nc" id="L2696">    return RevisionUtils.extract(&quot;$Revision: 9445 $&quot;);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>