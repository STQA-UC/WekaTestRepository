<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>AbstractFilterTest.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">AllTests (Nov 28, 2015 2:34:31 PM)</a> &gt; <a href="../../index.html" class="el_group">wekaproject</a> &gt; <a href="../index.html" class="el_bundle">src/src/test/java</a> &gt; <a href="index.source.html" class="el_package">weka.filters</a> &gt; <span class="el_source">AbstractFilterTest.java</span></div><h1>AbstractFilterTest.java</h1><pre class="source lang-java linenums">/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 * Copyright (C) 2002 University of Waikato 
 */

package weka.filters;

import weka.classifiers.Classifier;
import weka.classifiers.meta.FilteredClassifier;
import weka.core.CheckGOE;
import weka.core.CheckOptionHandler;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.OptionHandler;
import weka.core.SerializationHelper;
import weka.core.TestInstances;
import weka.core.Capabilities.Capability;
import weka.test.Regression;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.StringWriter;

import junit.framework.TestCase;

/**
 * Abstract Test class for Filters.
 *
 * @author &lt;a href=&quot;mailto:len@reeltwo.com&quot;&gt;Len Trigg&lt;/a&gt;
 * @authro FracPete (fracpete at waikato dot ac dot nz)
 * @version $Revision: 1.14 $
 */
<span class="fc" id="L48">public abstract class AbstractFilterTest</span>
  extends TestCase {

  // TODO: 
  // * Check that results between incremental and batch use are
  //   the same
  // * Check batch operation is OK
  // * Check memory use between subsequent runs
  // * Check memory use when multiplying data?

  /** Set to true to print out extra info during testing */
<span class="fc" id="L59">  protected static boolean VERBOSE = false;</span>

  /** The filter to be tested */
  protected Filter m_Filter;

  /** A set of instances to test with */
  protected Instances m_Instances;
  
  /** the OptionHandler tester */
  protected CheckOptionHandler m_OptionTester;
  
  /** the FilteredClassifier instance used for tests */
  protected FilteredClassifier m_FilteredClassifier;
  
  /** for testing GOE stuff */
  protected CheckGOE m_GOETester;

  /**
   * Constructs the &lt;code&gt;AbstractFilterTest&lt;/code&gt;. Called by subclasses.
   *
   * @param name the name of the test class
   */
  public AbstractFilterTest(String name) {
<span class="nc" id="L82">    super(name);</span>
<span class="nc" id="L83">  }</span>

  /**
   * Called by JUnit before each test method. This implementation creates
   * the default filter to test and loads a test set of Instances.
   *
   * @throws Exception if an error occurs reading the example instances.
   */
  protected void setUp() throws Exception {
<span class="nc" id="L92">    m_Filter             = getFilter();</span>
<span class="nc" id="L93">    m_Instances          = new Instances(new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(&quot;weka/filters/data/FilterTest.arff&quot;))));</span>
<span class="nc" id="L94">    m_OptionTester       = getOptionTester();</span>
<span class="nc" id="L95">    m_GOETester          = getGOETester();</span>
<span class="nc" id="L96">    m_FilteredClassifier = getFilteredClassifier();</span>
<span class="nc" id="L97">  }</span>

  /** Called by JUnit after each test method */
  protected void tearDown() {
<span class="nc" id="L101">    m_Filter             = null;</span>
<span class="nc" id="L102">    m_Instances          = null;</span>
<span class="nc" id="L103">    m_OptionTester       = null;</span>
<span class="nc" id="L104">    m_GOETester          = null;</span>
<span class="nc" id="L105">    m_FilteredClassifier = null;</span>
<span class="nc" id="L106">  }</span>
  
  /**
   * Configures the CheckOptionHandler uses for testing the optionhandling.
   * Sets the scheme to test.
   * 
   * @return	the fully configured CheckOptionHandler
   */
  protected CheckOptionHandler getOptionTester() {
    CheckOptionHandler		result;
    
<span class="nc" id="L117">    result = new CheckOptionHandler();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">    if (getFilter() instanceof OptionHandler)</span>
<span class="nc" id="L119">      result.setOptionHandler((OptionHandler) getFilter());</span>
    else
<span class="nc" id="L121">      result.setOptionHandler(null);</span>
<span class="nc" id="L122">    result.setUserOptions(new String[0]);</span>
<span class="nc" id="L123">    result.setSilent(true);</span>
    
<span class="nc" id="L125">    return result;</span>
  }
  
  /**
   * Configures the CheckGOE used for testing GOE stuff.
   * Sets the Filter returned from the getFilter() method.
   * 
   * @return	the fully configured CheckGOE
   * @see	#getFilter()
   */
  protected CheckGOE getGOETester() {
    CheckGOE		result;
    
<span class="nc" id="L138">    result = new CheckGOE();</span>
<span class="nc" id="L139">    result.setObject(getFilter());</span>
<span class="nc" id="L140">    result.setSilent(true);</span>
    
<span class="nc" id="L142">    return result;</span>
  }

  /**
   * returns the configured FilteredClassifier. Since the base classifier is
   * determined heuristically, derived tests might need to adjust it.
   * 
   * @return the configured FilteredClassifier
   */
  protected FilteredClassifier getFilteredClassifier() {
    FilteredClassifier	result;
    Filter		filter;
    Classifier		cls;
    
<span class="nc" id="L156">    result = new FilteredClassifier();</span>
    
    // set filter
<span class="nc" id="L159">    filter = getFilter();</span>
<span class="nc" id="L160">    result.setFilter(filter);</span>
    
    // set classifier
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (filter.getCapabilities().handles(Capability.NOMINAL_CLASS))</span>
<span class="nc" id="L164">      cls = new weka.classifiers.trees.J48();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">    else if (filter.getCapabilities().handles(Capability.BINARY_CLASS))</span>
<span class="nc" id="L166">      cls = new weka.classifiers.trees.J48();</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">    else if (filter.getCapabilities().handles(Capability.UNARY_CLASS))</span>
<span class="nc" id="L168">      cls = new weka.classifiers.trees.J48();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">    else if (filter.getCapabilities().handles(Capability.NUMERIC_CLASS))</span>
<span class="nc" id="L170">      cls = new weka.classifiers.trees.M5P();</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">    else if (filter.getCapabilities().handles(Capability.DATE_CLASS))</span>
<span class="nc" id="L172">      cls = new weka.classifiers.trees.M5P();</span>
    else
<span class="nc" id="L174">      throw new IllegalStateException(&quot;Cannot determine base classifier for FilteredClassifier!&quot;);</span>
<span class="nc" id="L175">    result.setClassifier(cls);</span>
    
<span class="nc" id="L177">    return result;</span>
  }
  
  /**
   * returns data generated for the FilteredClassifier test
   * 
   * @return		the dataset for the FilteredClassifier
   * @throws Exception	if generation of data fails
   */
  protected Instances getFilteredClassifierData() throws Exception {
    TestInstances	test;
    Instances		result;

    // NB: in order to make sure that the classifier can handle the data,
    //     we're using the classifier's capabilities to generate the data.
<span class="nc" id="L192">    test = TestInstances.forCapabilities(</span>
<span class="nc" id="L193">  	m_FilteredClassifier.getClassifier().getCapabilities());</span>
<span class="nc" id="L194">    test.setClassIndex(TestInstances.CLASS_IS_LAST);</span>

<span class="nc" id="L196">    result = test.generate();</span>
    
<span class="nc" id="L198">    return result;</span>
  }
  
  /**
   * Used to create an instance of a specific filter. The filter
   * should be configured to operate on a dataset that contains
   * attributes in this order:&lt;p&gt;
   *
   * String, Nominal, Numeric, String, Nominal, Numeric&lt;p&gt;
   *
   * Where the first three attributes do not contain any missing values,
   * but the last three attributes do. If the filter is for some reason
   * incapable of accepting a dataset of this type, override setUp() to 
   * either manipulate the default dataset to be compatible, or load another
   * test dataset. &lt;p&gt;
   *
   * The configured filter should preferrably do something
   * meaningful, since the results of filtering are used as the default
   * regression output (and it would hardly be interesting if the filtered 
   * data was the same as the input data).
   *
   * @return a suitably configured &lt;code&gt;Filter&lt;/code&gt; value
   */
  public abstract Filter getFilter();

  /**
   * Simple method to return the filtered set of test instances after
   * passing through the test filter. m_Filter contains the filter and
   * m_Instances contains the test instances.
   *
   * @return the Instances after filtering through the filter we have set
   * up to test.  
   */
  protected Instances useFilter() {

<span class="nc" id="L233">    Instances result = null;</span>
<span class="nc" id="L234">    Instances icopy = new Instances(m_Instances);</span>
    try {
<span class="nc" id="L236">      m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L237">    } catch (Exception ex) {</span>
<span class="nc" id="L238">      ex.printStackTrace();</span>
<span class="nc" id="L239">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L242">      result = Filter.useFilter(icopy, m_Filter);</span>
<span class="nc" id="L243">      assertNotNull(result);</span>
<span class="nc" id="L244">    } catch (Exception ex) {</span>
<span class="nc" id="L245">      ex.printStackTrace();</span>
<span class="nc" id="L246">      fail(&quot;Exception thrown on useFilter(): \n&quot; + ex.getMessage());</span>
    }
<span class="nc" id="L248">    return result;</span>
  }

  /**
   * tests whether the scheme declares a serialVersionUID.
   */
  public void testSerialVersionUID() {
<span class="nc bnc" id="L255" title="All 2 branches missed.">    if (SerializationHelper.needsUID(m_Filter.getClass()))</span>
<span class="nc" id="L256">      fail(&quot;Doesn't declare serialVersionUID!&quot;);</span>
<span class="nc" id="L257">  }</span>
  
  /**
   * Test buffered operation. Output instances are only collected after
   * all instances are passed through
   */
  public void testBuffered() {

<span class="nc" id="L265">    Instances icopy = new Instances(m_Instances);</span>
<span class="nc" id="L266">    Instances result = null;</span>
    try {
<span class="nc" id="L268">      m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L269">    } catch (Exception ex) {</span>
<span class="nc" id="L270">      ex.printStackTrace();</span>
<span class="nc" id="L271">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L274">      result = Filter.useFilter(icopy, m_Filter);</span>
<span class="nc" id="L275">      assertNotNull(result);</span>
<span class="nc" id="L276">    } catch (Exception ex) {</span>
<span class="nc" id="L277">      ex.printStackTrace();</span>
<span class="nc" id="L278">      fail(&quot;Exception thrown on useFilter(): \n&quot; + ex.getMessage());</span>
    }

    // Check the output is valid for printing by trying to write out to 
    // a stringbuffer
<span class="nc" id="L283">    StringWriter sw = new StringWriter(2000);</span>
<span class="nc" id="L284">    sw.write(result.toString());</span>

    // Check the input hasn't been modified
    // We just check the headers are the same and that the instance
    // count is the same.
<span class="nc" id="L289">    assertTrue(icopy.equalHeaders(m_Instances));</span>
<span class="nc" id="L290">    assertEquals(icopy.numInstances(), m_Instances.numInstances());</span>

    // Try repeating the filtering and check we get the same results
<span class="nc" id="L293">    Instances result2 = null;</span>
    try {
<span class="nc" id="L295">      m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L296">    } catch (Exception ex) {</span>
<span class="nc" id="L297">      ex.printStackTrace();</span>
<span class="nc" id="L298">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex.getMessage());</span>
    }
    try {
<span class="nc" id="L301">      result2 = Filter.useFilter(icopy, m_Filter);</span>
<span class="nc" id="L302">      assertNotNull(result2);</span>
<span class="nc" id="L303">    } catch (Exception ex) {</span>
<span class="nc" id="L304">      ex.printStackTrace();</span>
<span class="nc" id="L305">      fail(&quot;Exception thrown on useFilter(): \n&quot; + ex.getMessage());</span>
    }

    // Again check the input hasn't been modified
    // We just check the headers are the same and that the instance
    // count is the same.
<span class="nc" id="L311">    assertTrue(icopy.equalHeaders(m_Instances));</span>
<span class="nc" id="L312">    assertEquals(icopy.numInstances(), m_Instances.numInstances());</span>

    // Check the same results for both runs
<span class="nc" id="L315">    assertTrue(result.equalHeaders(result2));</span>
<span class="nc" id="L316">    assertEquals(result.numInstances(), result2.numInstances());</span>
    
<span class="nc" id="L318">  }</span>

  /**
   * Test incremental operation. Each instance is removed as soon as it
   * is made available
   */
  public void testIncremental() {

<span class="nc" id="L326">    Instances icopy = new Instances(m_Instances);</span>
<span class="nc" id="L327">    Instances result = null;</span>
<span class="nc" id="L328">    boolean headerImmediate = false;</span>
    try {
<span class="nc" id="L330">      headerImmediate = m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L331">    } catch (Exception ex) {</span>
<span class="nc" id="L332">      ex.printStackTrace();</span>
<span class="nc" id="L333">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex.getMessage());</span>
    }
<span class="nc bnc" id="L335" title="All 2 branches missed.">    if (headerImmediate) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">      if (VERBOSE) System.err.println(&quot;Filter makes header immediately available.&quot;);</span>
<span class="nc" id="L337">      result = m_Filter.getOutputFormat();</span>
    }
    // Pass all the instances to the filter
<span class="nc bnc" id="L340" title="All 2 branches missed.">    for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">      if (VERBOSE) System.err.println(&quot;Input instance to filter&quot;);</span>
<span class="nc" id="L342">      boolean collectNow = false;</span>
      try {
<span class="nc" id="L344">        collectNow = m_Filter.input(icopy.instance(i));</span>
<span class="nc" id="L345">      } catch (Exception ex) {</span>
<span class="nc" id="L346">        ex.printStackTrace();</span>
<span class="nc" id="L347">        fail(&quot;Exception thrown on input(): \n&quot; + ex.getMessage());</span>
      }
<span class="nc bnc" id="L349" title="All 2 branches missed.">      if (collectNow) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (VERBOSE) System.err.println(&quot;Filter said collect immediately&quot;);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">	if (!headerImmediate) {</span>
<span class="nc" id="L352">	  fail(&quot;Filter didn't return true from setInputFormat() earlier!&quot;);</span>
	}
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (VERBOSE) System.err.println(&quot;Getting output instance&quot;);</span>
<span class="nc" id="L355">	result.add(m_Filter.output());</span>
      }
    }
    // Say that input has finished, and print any pending output instances
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (VERBOSE) System.err.println(&quot;Setting end of batch&quot;);</span>
<span class="nc" id="L360">    boolean toCollect = false;</span>
    try {
<span class="nc" id="L362">      toCollect = m_Filter.batchFinished();</span>
<span class="nc" id="L363">    } catch (Exception ex) {</span>
<span class="nc" id="L364">      ex.printStackTrace();</span>
<span class="nc" id="L365">      fail(&quot;Exception thrown on batchFinished(): \n&quot; + ex.getMessage());</span>
    }
<span class="nc bnc" id="L367" title="All 2 branches missed.">    if (toCollect) {</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">      if (VERBOSE) System.err.println(&quot;Filter said collect output&quot;);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">      if (!headerImmediate) {</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (VERBOSE) System.err.println(&quot;Getting output format&quot;);</span>
<span class="nc" id="L371">	result = m_Filter.getOutputFormat();</span>
      }
<span class="nc bnc" id="L373" title="All 2 branches missed.">      if (VERBOSE) System.err.println(&quot;Getting output instance&quot;);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0) {</span>
<span class="nc" id="L375">	result.add(m_Filter.output());</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (VERBOSE) System.err.println(&quot;Getting output instance&quot;);</span>
      }
    }
    
<span class="nc" id="L380">    assertNotNull(result);</span>

    // Check the output iss valid for printing by trying to write out to 
    // a stringbuffer
<span class="nc" id="L384">    StringWriter sw = new StringWriter(2000);</span>
<span class="nc" id="L385">    sw.write(result.toString());</span>
<span class="nc" id="L386">  }</span>

  /**
   * Describe &lt;code&gt;testRegression&lt;/code&gt; method here.
   *
   */
  public void testRegression() {

<span class="nc" id="L394">    Regression reg = new Regression(this.getClass());</span>
<span class="nc" id="L395">    Instances result = useFilter();</span>
<span class="nc" id="L396">    reg.println(result.toString());</span>
    try {
<span class="nc" id="L398">      String diff = reg.diff();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">      if (diff == null) {</span>
<span class="nc" id="L400">        System.err.println(&quot;Warning: No reference available, creating.&quot;); </span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">      } else if (!diff.equals(&quot;&quot;)) {</span>
<span class="nc" id="L402">        fail(&quot;Regression test failed. Difference:\n&quot; + diff);</span>
      }
<span class="nc" id="L404">    } catch (java.io.IOException ex) {</span>
<span class="nc" id="L405">      fail(&quot;Problem during regression testing.\n&quot; + ex);</span>
    }

<span class="nc" id="L408">    reg = new Regression(this.getClass());</span>

    // Run the filter using deprecated calls to check it still works the same
<span class="nc" id="L411">    Instances icopy = new Instances(m_Instances);</span>
    try {
<span class="nc" id="L413">      m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L414">    } catch (Exception ex) {</span>
<span class="nc" id="L415">      ex.printStackTrace();</span>
<span class="nc" id="L416">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex.getMessage());</span>
    }
    try {
<span class="nc bnc" id="L419" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc" id="L420">        m_Filter.input(icopy.instance(i));</span>
      }
<span class="nc" id="L422">      m_Filter.batchFinished();</span>
<span class="nc" id="L423">      result = m_Filter.getOutputFormat();</span>
      weka.core.Instance processed;
<span class="nc bnc" id="L425" title="All 2 branches missed.">      while ((processed = m_Filter.output()) != null) {</span>
<span class="nc" id="L426">        result.add(processed);</span>
      }
<span class="nc" id="L428">      assertNotNull(result);</span>
<span class="nc" id="L429">    } catch (Exception ex) {</span>
<span class="nc" id="L430">      ex.printStackTrace();</span>
<span class="nc" id="L431">      fail(&quot;Exception thrown on useFilter(): \n&quot; + ex.getMessage());</span>
    }
<span class="nc" id="L433">    reg.println(result.toString());</span>
    try {
<span class="nc" id="L435">      String diff = reg.diff();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">      if (diff == null) {</span>
<span class="nc" id="L437">        System.err.println(&quot;Warning: No reference available, creating.&quot;); </span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">      } else if (!diff.equals(&quot;&quot;)) {</span>
<span class="nc" id="L439">        fail(&quot;Regression test failed when using deprecated methods. Difference:\n&quot; + diff);</span>
      }
<span class="nc" id="L441">    } catch (java.io.IOException ex) {</span>
<span class="nc" id="L442">      fail(&quot;Problem during regression testing.\n&quot; + ex);</span>
    }
<span class="nc" id="L444">  }</span>

  public void testThroughput() {

<span class="nc bnc" id="L448" title="All 2 branches missed.">    if (VERBOSE) {</span>
<span class="nc" id="L449">      Instances icopy = new Instances(m_Instances);</span>
      // Make a bigger dataset
<span class="nc" id="L451">      Instances result = null;</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">      for (int i = 0; i &lt; 20000; i++) {</span>
<span class="nc" id="L453">        icopy.add(m_Instances.instance(i%m_Instances.numInstances()));</span>
      }
      long starttime, endtime;
      double secs, rate;


      // Time incremental usage
<span class="nc" id="L460">      starttime = System.currentTimeMillis();</span>
<span class="nc" id="L461">      boolean headerImmediate = false;</span>
      try {
<span class="nc" id="L463">        headerImmediate = m_Filter.setInputFormat(icopy);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        if (headerImmediate) {</span>
<span class="nc" id="L465">          result = m_Filter.getOutputFormat();</span>
        }
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc" id="L468">          boolean collectNow = false;</span>
<span class="nc" id="L469">          collectNow = m_Filter.input(icopy.instance(i));</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">          if (collectNow) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (!headerImmediate) {</span>
<span class="nc" id="L472">              fail(&quot;Filter didn't return true from setInputFormat() earlier!&quot;);</span>
            }
<span class="nc" id="L474">            result.add(m_Filter.output());</span>
          }
        }
        // Say that input has finished, and print any pending output instances
<span class="nc" id="L478">        boolean toCollect = false;</span>
<span class="nc" id="L479">        toCollect = m_Filter.batchFinished();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (toCollect) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">          if (!headerImmediate) {</span>
<span class="nc" id="L482">            result = m_Filter.getOutputFormat();</span>
          }
<span class="nc bnc" id="L484" title="All 2 branches missed.">          while (m_Filter.numPendingOutput() &gt; 0) {</span>
<span class="nc" id="L485">            result.add(m_Filter.output());</span>
          }
        }
<span class="nc" id="L488">      } catch (Exception ex) {</span>
<span class="nc" id="L489">        ex.printStackTrace();</span>
<span class="nc" id="L490">        fail(&quot;Exception thrown during incremental filtering: \n&quot; + ex.getMessage());</span>
      }
<span class="nc" id="L492">      endtime = System.currentTimeMillis();</span>
<span class="nc" id="L493">      secs = (double)(endtime - starttime) / 1000;</span>
<span class="nc" id="L494">      rate = (double)icopy.numInstances() / secs;</span>
<span class="nc" id="L495">      System.err.println(&quot;\n&quot; + m_Filter.getClass().getName() </span>
<span class="nc" id="L496">                         + &quot; incrementally processed &quot; </span>
<span class="nc" id="L497">                         + rate + &quot; instances per sec&quot;); </span>
      
      // Time batch usage
<span class="nc" id="L500">      starttime = System.currentTimeMillis();</span>
      try {
<span class="nc" id="L502">        m_Filter.setInputFormat(icopy);</span>
<span class="nc" id="L503">        result = Filter.useFilter(icopy, m_Filter);</span>
<span class="nc" id="L504">        assertNotNull(result);</span>
<span class="nc" id="L505">      } catch (Exception ex) {</span>
<span class="nc" id="L506">        ex.printStackTrace();</span>
<span class="nc" id="L507">        fail(&quot;Exception thrown during batch filtering: \n&quot; + ex.getMessage());</span>
      }
<span class="nc" id="L509">      endtime = System.currentTimeMillis();</span>
<span class="nc" id="L510">      secs = (double)(endtime - starttime) / 1000;</span>
<span class="nc" id="L511">      rate = (double)icopy.numInstances() / secs;</span>
<span class="nc" id="L512">      System.err.println(&quot;\n&quot; + m_Filter.getClass().getName() </span>
<span class="nc" id="L513">                         + &quot; batch processed &quot; </span>
<span class="nc" id="L514">                         + rate + &quot; instances per sec&quot;); </span>


    }
<span class="nc" id="L518">  }</span>
  
  /**
   * tests the listing of the options
   */
  public void testListOptions() {
<span class="nc bnc" id="L524" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">      if (!m_OptionTester.checkListOptions())</span>
<span class="nc" id="L526">	fail(&quot;Options cannot be listed via listOptions.&quot;);</span>
    }
<span class="nc" id="L528">  }</span>
  
  /**
   * tests the setting of the options
   */
  public void testSetOptions() {
<span class="nc bnc" id="L534" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">      if (!m_OptionTester.checkSetOptions())</span>
<span class="nc" id="L536">	fail(&quot;setOptions method failed.&quot;);</span>
    }
<span class="nc" id="L538">  }</span>
  
  /**
   * tests whether the default settings are processed correctly
   */
  public void testDefaultOptions() {
<span class="nc bnc" id="L544" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">      if (!m_OptionTester.checkDefaultOptions())</span>
<span class="nc" id="L546">	fail(&quot;Default options were not processed correctly.&quot;);</span>
    }
<span class="nc" id="L548">  }</span>
  
  /**
   * tests whether there are any remaining options
   */
  public void testRemainingOptions() {
<span class="nc bnc" id="L554" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (!m_OptionTester.checkRemainingOptions())</span>
<span class="nc" id="L556">	fail(&quot;There were 'left-over' options.&quot;);</span>
    }
<span class="nc" id="L558">  }</span>
  
  /**
   * tests the whether the user-supplied options stay the same after setting.
   * getting, and re-setting again.
   * 
   * @see 	#getOptionTester()
   */
  public void testCanonicalUserOptions() {
<span class="nc bnc" id="L567" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">      if (!m_OptionTester.checkCanonicalUserOptions())</span>
<span class="nc" id="L569">	fail(&quot;setOptions method failed&quot;);</span>
    }
<span class="nc" id="L571">  }</span>
  
  /**
   * tests the resetting of the options to the default ones
   */
  public void testResettingOptions() {
<span class="nc bnc" id="L577" title="All 2 branches missed.">    if (m_OptionTester.getOptionHandler() != null) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">      if (!m_OptionTester.checkSetOptions())</span>
<span class="nc" id="L579">	fail(&quot;Resetting of options failed&quot;);</span>
    }
<span class="nc" id="L581">  }</span>
  
  /**
   * tests the filter in conjunction with the FilteredClassifier
   */
  public void testFilteredClassifier() {
    Instances		data;
    int			i;
    
    try {
      // generate data
<span class="nc" id="L592">      data = getFilteredClassifierData();</span>
      
      // build classifier
<span class="nc" id="L595">      m_FilteredClassifier.buildClassifier(data);</span>

      // test classifier
<span class="nc bnc" id="L598" title="All 2 branches missed.">      for (i = 0; i &lt; data.numInstances(); i++) {</span>
<span class="nc" id="L599">	m_FilteredClassifier.classifyInstance(data.instance(i));</span>
      }
    }
<span class="nc" id="L602">    catch (Exception e) {</span>
<span class="nc" id="L603">      fail(&quot;Problem with FilteredClassifier: &quot; + e.toString());</span>
    }
<span class="nc" id="L605">  }</span>
  
  /**
   * simulates batch filtering
   */
  public void testBatchFiltering() {
<span class="nc" id="L611">    Instances result = null;</span>
<span class="nc" id="L612">    Instances icopy = new Instances(m_Instances);</span>
    
    // setup filter
    try {
<span class="nc bnc" id="L616" title="All 2 branches missed.">      if (m_Filter.setInputFormat(icopy)) {</span>
<span class="nc" id="L617">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L618">	assertNotNull(&quot;Output format defined (setup)&quot;, result);</span>
      }
    }
<span class="nc" id="L621">    catch (Exception ex) {</span>
<span class="nc" id="L622">      ex.printStackTrace();</span>
<span class="nc" id="L623">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex);</span>
    }

    // first batch
    try {
<span class="nc bnc" id="L628" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc" id="L630">	  Instance out = m_Filter.output();</span>
<span class="nc" id="L631">	  assertNotNull(&quot;Instance not made available immediately (1. batch)&quot;, out);</span>
<span class="nc" id="L632">	  result.add(out);</span>
	}
      }
<span class="nc" id="L635">      m_Filter.batchFinished();</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L638">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L639">	assertNotNull(&quot;Output format defined (1. batch)&quot;, result);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (1. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L643" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L644">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L646">    catch (Exception ex) {</span>
<span class="nc" id="L647">      ex.printStackTrace();</span>
<span class="nc" id="L648">      fail(&quot;Exception thrown during 1. batch: \n&quot; + ex);</span>
    }

    // second batch
    try {
<span class="nc" id="L653">      result = null;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">      if (m_Filter.isOutputFormatDefined())</span>
<span class="nc" id="L655">	result = m_Filter.getOutputFormat();</span>
      
<span class="nc bnc" id="L657" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">	  if (result == null) {</span>
<span class="nc" id="L660">	    fail(&quot;Filter didn't return true from isOutputFormatDefined() (2. batch)&quot;);</span>
	  }
	  else {
<span class="nc" id="L663">	    Instance out = m_Filter.output();</span>
<span class="nc" id="L664">	    assertNotNull(&quot;Instance not made available immediately (2. batch)&quot;, out);</span>
<span class="nc" id="L665">	    result.add(out);</span>
	  }
	}
      }
<span class="nc" id="L669">      m_Filter.batchFinished();</span>
      
<span class="nc bnc" id="L671" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L672">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L673">	assertNotNull(&quot;Output format defined (2. batch)&quot;, result);</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (2. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L677" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L678">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L680">    catch (Exception ex) {</span>
<span class="nc" id="L681">      ex.printStackTrace();</span>
<span class="nc" id="L682">      fail(&quot;Exception thrown during 2. batch: \n&quot; + ex);</span>
    }
<span class="nc" id="L684">  }</span>
  
  /**
   * simulates batch filtering (with the second dataset being smaller)
   */
  public void testBatchFilteringSmaller() {
<span class="nc" id="L690">    Instances result = null;</span>
<span class="nc" id="L691">    Instances icopy = new Instances(m_Instances);</span>
    
    // setup filter
    try {
<span class="nc bnc" id="L695" title="All 2 branches missed.">      if (m_Filter.setInputFormat(icopy)) {</span>
<span class="nc" id="L696">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L697">	assertNotNull(&quot;Output format defined (setup)&quot;, result);</span>
      }
    }
<span class="nc" id="L700">    catch (Exception ex) {</span>
<span class="nc" id="L701">      ex.printStackTrace();</span>
<span class="nc" id="L702">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex);</span>
    }

    // first batch
    try {
<span class="nc bnc" id="L707" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc" id="L709">	  Instance out = m_Filter.output();</span>
<span class="nc" id="L710">	  assertNotNull(&quot;Instance not made available immediately (1. batch)&quot;, out);</span>
<span class="nc" id="L711">	  result.add(out);</span>
	}
      }
<span class="nc" id="L714">      m_Filter.batchFinished();</span>

<span class="nc bnc" id="L716" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L717">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L718">	assertNotNull(&quot;Output format defined (1. batch)&quot;, result);</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (1. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L722" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L723">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L725">    catch (Exception ex) {</span>
<span class="nc" id="L726">      ex.printStackTrace();</span>
<span class="nc" id="L727">      fail(&quot;Exception thrown during 1. batch: \n&quot; + ex);</span>
    }

    // second batch
    try {
<span class="nc" id="L732">      result = null;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">      if (m_Filter.isOutputFormatDefined())</span>
<span class="nc" id="L734">	result = m_Filter.getOutputFormat();</span>
      
      // delete some instances
<span class="nc" id="L737">      int num = (int) ((double) icopy.numInstances() * 0.3);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">      for (int i = 0; i &lt; num; i++)</span>
<span class="nc" id="L739">	icopy.delete(0);</span>
      
<span class="nc bnc" id="L741" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">	  if (result == null) {</span>
<span class="nc" id="L744">	    fail(&quot;Filter didn't return true from isOutputFormatDefined() (2. batch)&quot;);</span>
	  }
	  else {
<span class="nc" id="L747">	    Instance out = m_Filter.output();</span>
<span class="nc" id="L748">	    assertNotNull(&quot;Instance not made available immediately (2. batch)&quot;, out);</span>
<span class="nc" id="L749">	    result.add(out);</span>
	  }
	}
      }
<span class="nc" id="L753">      m_Filter.batchFinished();</span>
      
<span class="nc bnc" id="L755" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L756">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L757">	assertNotNull(&quot;Output format defined (2. batch)&quot;, result);</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (2. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L761" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L762">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L764">    catch (Exception ex) {</span>
<span class="nc" id="L765">      ex.printStackTrace();</span>
<span class="nc" id="L766">      fail(&quot;Exception thrown during 2. batch: \n&quot; + ex);</span>
    }
<span class="nc" id="L768">  }</span>
  
  /**
   * simulates batch filtering (with the second dataset being bigger)
   */
  public void testBatchFilteringLarger() {
<span class="nc" id="L774">    Instances result = null;</span>
<span class="nc" id="L775">    Instances icopy = new Instances(m_Instances);</span>
    
    // setup filter
    try {
<span class="nc bnc" id="L779" title="All 2 branches missed.">      if (m_Filter.setInputFormat(icopy)) {</span>
<span class="nc" id="L780">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L781">	assertNotNull(&quot;Output format defined (setup)&quot;, result);</span>
      }
    }
<span class="nc" id="L784">    catch (Exception ex) {</span>
<span class="nc" id="L785">      ex.printStackTrace();</span>
<span class="nc" id="L786">      fail(&quot;Exception thrown on setInputFormat(): \n&quot; + ex);</span>
    }

    // first batch
    try {
<span class="nc bnc" id="L791" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc" id="L793">	  Instance out = m_Filter.output();</span>
<span class="nc" id="L794">	  assertNotNull(&quot;Instance not made available immediately (1. batch)&quot;, out);</span>
<span class="nc" id="L795">	  result.add(out);</span>
	}
      }
<span class="nc" id="L798">      m_Filter.batchFinished();</span>

<span class="nc bnc" id="L800" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L801">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L802">	assertNotNull(&quot;Output format defined (1. batch)&quot;, result);</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (1. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L806" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L807">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L809">    catch (Exception ex) {</span>
<span class="nc" id="L810">      ex.printStackTrace();</span>
<span class="nc" id="L811">      fail(&quot;Exception thrown during 1. batch: \n&quot; + ex);</span>
    }

    // second batch
    try {
<span class="nc" id="L816">      result = null;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">      if (m_Filter.isOutputFormatDefined())</span>
<span class="nc" id="L818">	result = m_Filter.getOutputFormat();</span>
      
      // add some instances
<span class="nc" id="L821">      int num = (int) ((double) icopy.numInstances() * 0.3);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">      for (int i = 0; i &lt; num; i++)</span>
<span class="nc" id="L823">	icopy.add(icopy.instance(i));</span>
      
<span class="nc bnc" id="L825" title="All 2 branches missed.">      for (int i = 0; i &lt; icopy.numInstances(); i++) {</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">	if (m_Filter.input(icopy.instance(i))) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">	  if (result == null) {</span>
<span class="nc" id="L828">	    fail(&quot;Filter didn't return true from isOutputFormatDefined() (2. batch)&quot;);</span>
	  }
	  else {
<span class="nc" id="L831">	    Instance out = m_Filter.output();</span>
<span class="nc" id="L832">	    assertNotNull(&quot;Instance not made available immediately (2. batch)&quot;, out);</span>
<span class="nc" id="L833">	    result.add(out);</span>
	  }
	}
      }
<span class="nc" id="L837">      m_Filter.batchFinished();</span>
      
<span class="nc bnc" id="L839" title="All 2 branches missed.">      if (result == null) {</span>
<span class="nc" id="L840">	result = m_Filter.getOutputFormat();</span>
<span class="nc" id="L841">	assertNotNull(&quot;Output format defined (2. batch)&quot;, result);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">	assertTrue(&quot;Pending output instances (2. batch)&quot;, m_Filter.numPendingOutput() &gt; 0);</span>
      }

<span class="nc bnc" id="L845" title="All 2 branches missed.">      while (m_Filter.numPendingOutput() &gt; 0)</span>
<span class="nc" id="L846">	result.add(m_Filter.output());</span>
    }
<span class="nc" id="L848">    catch (Exception ex) {</span>
<span class="nc" id="L849">      ex.printStackTrace();</span>
<span class="nc" id="L850">      fail(&quot;Exception thrown during 2. batch: \n&quot; + ex);</span>
    }
<span class="nc" id="L852">  }</span>
  
  /**
   * tests for a globalInfo method
   */
  public void testGlobalInfo() {
<span class="nc bnc" id="L858" title="All 2 branches missed.">    if (!m_GOETester.checkGlobalInfo())</span>
<span class="nc" id="L859">      fail(&quot;No globalInfo method&quot;);</span>
<span class="nc" id="L860">  }</span>
  
  /**
   * tests the tool tips
   */
  public void testToolTips() {
<span class="nc bnc" id="L866" title="All 2 branches missed.">    if (!m_GOETester.checkToolTips())</span>
<span class="nc" id="L867">      fail(&quot;Tool tips inconsistent&quot;);</span>
<span class="nc" id="L868">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span>AllTests (Nov 28, 2015 2:34:31 PM)</div></body></html>